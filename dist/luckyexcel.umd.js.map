{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/base64-js/index.js","node_modules/browser-resolve/empty.js","node_modules/buffer/index.js","node_modules/core-util-is/lib/util.js","node_modules/events/events.js","node_modules/ieee754/index.js","node_modules/immediate/lib/browser.js","node_modules/inherits/inherits_browser.js","node_modules/is-buffer/index.js","node_modules/isarray/index.js","node_modules/jszip/lib/base64.js","node_modules/jszip/lib/compressedObject.js","node_modules/jszip/lib/compressions.js","node_modules/jszip/lib/crc32.js","node_modules/jszip/lib/defaults.js","node_modules/jszip/lib/external.js","node_modules/jszip/lib/flate.js","node_modules/jszip/lib/generate/ZipFileWorker.js","node_modules/jszip/lib/generate/index.js","node_modules/jszip/lib/index.js","node_modules/jszip/lib/load.js","node_modules/jszip/lib/nodejsUtils.js","node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js","node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js","node_modules/jszip/lib/object.js","node_modules/jszip/lib/readable-stream-browser.js","node_modules/jszip/lib/reader/ArrayReader.js","node_modules/jszip/lib/reader/DataReader.js","node_modules/jszip/lib/reader/NodeBufferReader.js","node_modules/jszip/lib/reader/StringReader.js","node_modules/jszip/lib/reader/Uint8ArrayReader.js","node_modules/jszip/lib/reader/readerFor.js","node_modules/jszip/lib/signature.js","node_modules/jszip/lib/stream/ConvertWorker.js","node_modules/jszip/lib/stream/Crc32Probe.js","node_modules/jszip/lib/stream/DataLengthProbe.js","node_modules/jszip/lib/stream/DataWorker.js","node_modules/jszip/lib/stream/GenericWorker.js","node_modules/jszip/lib/stream/StreamHelper.js","node_modules/jszip/lib/support.js","node_modules/jszip/lib/utf8.js","node_modules/jszip/lib/utils.js","node_modules/jszip/lib/zipEntries.js","node_modules/jszip/lib/zipEntry.js","node_modules/jszip/lib/zipObject.js","node_modules/lie/lib/browser.js","node_modules/pako/index.js","node_modules/pako/lib/deflate.js","node_modules/pako/lib/inflate.js","node_modules/pako/lib/utils/common.js","node_modules/pako/lib/utils/strings.js","node_modules/pako/lib/zlib/adler32.js","node_modules/pako/lib/zlib/constants.js","node_modules/pako/lib/zlib/crc32.js","node_modules/pako/lib/zlib/deflate.js","node_modules/pako/lib/zlib/gzheader.js","node_modules/pako/lib/zlib/inffast.js","node_modules/pako/lib/zlib/inflate.js","node_modules/pako/lib/zlib/inftrees.js","node_modules/pako/lib/zlib/messages.js","node_modules/pako/lib/zlib/trees.js","node_modules/pako/lib/zlib/zstream.js","node_modules/process-nextick-args/index.js","node_modules/process/browser.js","node_modules/readable-stream/duplex-browser.js","node_modules/readable-stream/lib/_stream_duplex.js","node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/readable-stream/lib/_stream_readable.js","node_modules/readable-stream/lib/_stream_transform.js","node_modules/readable-stream/lib/_stream_writable.js","node_modules/readable-stream/lib/internal/streams/BufferList.js","node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/readable-stream/lib/internal/streams/stream-browser.js","node_modules/readable-stream/passthrough.js","node_modules/readable-stream/readable-browser.js","node_modules/readable-stream/transform.js","node_modules/readable-stream/writable-browser.js","node_modules/safe-buffer/index.js","node_modules/set-immediate-shim/index.js","node_modules/stream-browserify/index.js","node_modules/string_decoder/lib/string_decoder.js","node_modules/timers-browserify/main.js","node_modules/util-deprecate/browser.js","src/HandleZip.ts","src/ToLuckySheet/LuckyBase.ts","src/ToLuckySheet/LuckyCell.ts","src/ToLuckySheet/LuckyFile.ts","src/ToLuckySheet/LuckyImage.ts","src/ToLuckySheet/LuckySheet.ts","src/ToLuckySheet/ReadXml.ts","src/common/constant.ts","src/common/emf.ts","src/common/method.ts","src/main.ts","src/main.umd.ts"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7vDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACl1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACphDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxLA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnEA,IAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAGA,IAAA,SAAA;AAAA;AAAA,YAAA;AAII,WAAA,SAAA,CAAY,IAAZ,EAAsB;AAClB;AACA;AACI,SAAK,UAAL,GAAkB,IAAlB,CAHc,CAIlB;AACH;;AAED,EAAA,SAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,WAAV,EAAoD,SAApD,EAA+E;AAC3E;AACA,IAAA,OAAA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","file":"luckyexcel.umd.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","'use strict';\nvar utils = require('./utils');\nvar support = require('./support');\n// private property\nvar _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n\n// public method for encoding\nexports.encode = function(input) {\n    var output = [];\n    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n    var i = 0, len = input.length, remainingBytes = len;\n\n    var isArray = utils.getTypeOf(input) !== \"string\";\n    while (i < input.length) {\n        remainingBytes = len - i;\n\n        if (!isArray) {\n            chr1 = input.charCodeAt(i++);\n            chr2 = i < len ? input.charCodeAt(i++) : 0;\n            chr3 = i < len ? input.charCodeAt(i++) : 0;\n        } else {\n            chr1 = input[i++];\n            chr2 = i < len ? input[i++] : 0;\n            chr3 = i < len ? input[i++] : 0;\n        }\n\n        enc1 = chr1 >> 2;\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;\n        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;\n\n        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));\n\n    }\n\n    return output.join(\"\");\n};\n\n// public method for decoding\nexports.decode = function(input) {\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0, resultIndex = 0;\n\n    var dataUrlPrefix = \"data:\";\n\n    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {\n        // This is a common error: people give a data url\n        // (data:image/png;base64,iVBOR...) with a {base64: true} and\n        // wonders why things don't work.\n        // We can detect that the string input looks like a data url but we\n        // *can't* be sure it is one: removing everything up to the comma would\n        // be too dangerous.\n        throw new Error(\"Invalid base64 input, it looks like a data url.\");\n    }\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n    var totalLength = input.length * 3 / 4;\n    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if (totalLength % 1 !== 0) {\n        // totalLength is not an integer, the length does not match a valid\n        // base64 content. That can happen if:\n        // - the input is not a base64 content\n        // - the input is *almost* a base64 content, with a extra chars at the\n        //   beginning or at the end\n        // - the input uses a base64 variant (base64url for example)\n        throw new Error(\"Invalid base64 input, bad content length.\");\n    }\n    var output;\n    if (support.uint8array) {\n        output = new Uint8Array(totalLength|0);\n    } else {\n        output = new Array(totalLength|0);\n    }\n\n    while (i < input.length) {\n\n        enc1 = _keyStr.indexOf(input.charAt(i++));\n        enc2 = _keyStr.indexOf(input.charAt(i++));\n        enc3 = _keyStr.indexOf(input.charAt(i++));\n        enc4 = _keyStr.indexOf(input.charAt(i++));\n\n        chr1 = (enc1 << 2) | (enc2 >> 4);\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n        chr3 = ((enc3 & 3) << 6) | enc4;\n\n        output[resultIndex++] = chr1;\n\n        if (enc3 !== 64) {\n            output[resultIndex++] = chr2;\n        }\n        if (enc4 !== 64) {\n            output[resultIndex++] = chr3;\n        }\n\n    }\n\n    return output;\n};\n","'use strict';\n\nvar external = require(\"./external\");\nvar DataWorker = require('./stream/DataWorker');\nvar DataLengthProbe = require('./stream/DataLengthProbe');\nvar Crc32Probe = require('./stream/Crc32Probe');\nvar DataLengthProbe = require('./stream/DataLengthProbe');\n\n/**\n * Represent a compressed object, with everything needed to decompress it.\n * @constructor\n * @param {number} compressedSize the size of the data compressed.\n * @param {number} uncompressedSize the size of the data after decompression.\n * @param {number} crc32 the crc32 of the decompressed file.\n * @param {object} compression the type of compression, see lib/compressions.js.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.\n */\nfunction CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {\n    this.compressedSize = compressedSize;\n    this.uncompressedSize = uncompressedSize;\n    this.crc32 = crc32;\n    this.compression = compression;\n    this.compressedContent = data;\n}\n\nCompressedObject.prototype = {\n    /**\n     * Create a worker to get the uncompressed content.\n     * @return {GenericWorker} the worker.\n     */\n    getContentWorker : function () {\n        var worker = new DataWorker(external.Promise.resolve(this.compressedContent))\n        .pipe(this.compression.uncompressWorker())\n        .pipe(new DataLengthProbe(\"data_length\"));\n\n        var that = this;\n        worker.on(\"end\", function () {\n            if(this.streamInfo['data_length'] !== that.uncompressedSize) {\n                throw new Error(\"Bug : uncompressed data size mismatch\");\n            }\n        });\n        return worker;\n    },\n    /**\n     * Create a worker to get the compressed content.\n     * @return {GenericWorker} the worker.\n     */\n    getCompressedWorker : function () {\n        return new DataWorker(external.Promise.resolve(this.compressedContent))\n        .withStreamInfo(\"compressedSize\", this.compressedSize)\n        .withStreamInfo(\"uncompressedSize\", this.uncompressedSize)\n        .withStreamInfo(\"crc32\", this.crc32)\n        .withStreamInfo(\"compression\", this.compression)\n        ;\n    }\n};\n\n/**\n * Chain the given worker with other workers to compress the content with the\n * given compression.\n * @param {GenericWorker} uncompressedWorker the worker to pipe.\n * @param {Object} compression the compression object.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {GenericWorker} the new worker compressing the content.\n */\nCompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {\n    return uncompressedWorker\n    .pipe(new Crc32Probe())\n    .pipe(new DataLengthProbe(\"uncompressedSize\"))\n    .pipe(compression.compressWorker(compressionOptions))\n    .pipe(new DataLengthProbe(\"compressedSize\"))\n    .withStreamInfo(\"compression\", compression);\n};\n\nmodule.exports = CompressedObject;\n","'use strict';\n\nvar GenericWorker = require(\"./stream/GenericWorker\");\n\nexports.STORE = {\n    magic: \"\\x00\\x00\",\n    compressWorker : function (compressionOptions) {\n        return new GenericWorker(\"STORE compression\");\n    },\n    uncompressWorker : function () {\n        return new GenericWorker(\"STORE decompression\");\n    }\n};\nexports.DEFLATE = require('./flate');\n","'use strict';\n\nvar utils = require('./utils');\n\n/**\n * The following functions come from pako, from pako/lib/zlib/crc32.js\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n    var c, table = [];\n\n    for(var n =0; n < 256; n++){\n        c = n;\n        for(var k =0; k < 8; k++){\n            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n        }\n        table[n] = c;\n    }\n\n    return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n    var t = crcTable, end = pos + len;\n\n    crc = crc ^ (-1);\n\n    for (var i = pos; i < end; i++ ) {\n        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n\n    return (crc ^ (-1)); // >>> 0;\n}\n\n// That's all for the pako functions.\n\n/**\n * Compute the crc32 of a string.\n * This is almost the same as the function crc32, but for strings. Using the\n * same function for the two use cases leads to horrible performances.\n * @param {Number} crc the starting value of the crc.\n * @param {String} str the string to use.\n * @param {Number} len the length of the string.\n * @param {Number} pos the starting position for the crc32 computation.\n * @return {Number} the computed crc32.\n */\nfunction crc32str(crc, str, len, pos) {\n    var t = crcTable, end = pos + len;\n\n    crc = crc ^ (-1);\n\n    for (var i = pos; i < end; i++ ) {\n        crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];\n    }\n\n    return (crc ^ (-1)); // >>> 0;\n}\n\nmodule.exports = function crc32wrapper(input, crc) {\n    if (typeof input === \"undefined\" || !input.length) {\n        return 0;\n    }\n\n    var isArray = utils.getTypeOf(input) !== \"string\";\n\n    if(isArray) {\n        return crc32(crc|0, input, input.length, 0);\n    } else {\n        return crc32str(crc|0, input, input.length, 0);\n    }\n};\n","'use strict';\nexports.base64 = false;\nexports.binary = false;\nexports.dir = false;\nexports.createFolders = true;\nexports.date = null;\nexports.compression = null;\nexports.compressionOptions = null;\nexports.comment = null;\nexports.unixPermissions = null;\nexports.dosPermissions = null;\n","/* global Promise */\n'use strict';\n\n// load the global object first:\n// - it should be better integrated in the system (unhandledRejection in node)\n// - the environment may have a custom Promise implementation (see zone.js)\nvar ES6Promise = null;\nif (typeof Promise !== \"undefined\") {\n    ES6Promise = Promise;\n} else {\n    ES6Promise = require(\"lie\");\n}\n\n/**\n * Let the user use/change some implementations.\n */\nmodule.exports = {\n    Promise: ES6Promise\n};\n","'use strict';\nvar USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');\n\nvar pako = require(\"pako\");\nvar utils = require(\"./utils\");\nvar GenericWorker = require(\"./stream/GenericWorker\");\n\nvar ARRAY_TYPE = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\n\nexports.magic = \"\\x08\\x00\";\n\n/**\n * Create a worker that uses pako to inflate/deflate.\n * @constructor\n * @param {String} action the name of the pako function to call : either \"Deflate\" or \"Inflate\".\n * @param {Object} options the options to use when (de)compressing.\n */\nfunction FlateWorker(action, options) {\n    GenericWorker.call(this, \"FlateWorker/\" + action);\n\n    this._pako = null;\n    this._pakoAction = action;\n    this._pakoOptions = options;\n    // the `meta` object from the last chunk received\n    // this allow this worker to pass around metadata\n    this.meta = {};\n}\n\nutils.inherits(FlateWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nFlateWorker.prototype.processChunk = function (chunk) {\n    this.meta = chunk.meta;\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);\n};\n\n/**\n * @see GenericWorker.flush\n */\nFlateWorker.prototype.flush = function () {\n    GenericWorker.prototype.flush.call(this);\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push([], true);\n};\n/**\n * @see GenericWorker.cleanUp\n */\nFlateWorker.prototype.cleanUp = function () {\n    GenericWorker.prototype.cleanUp.call(this);\n    this._pako = null;\n};\n\n/**\n * Create the _pako object.\n * TODO: lazy-loading this object isn't the best solution but it's the\n * quickest. The best solution is to lazy-load the worker list. See also the\n * issue #446.\n */\nFlateWorker.prototype._createPako = function () {\n    this._pako = new pako[this._pakoAction]({\n        raw: true,\n        level: this._pakoOptions.level || -1 // default compression\n    });\n    var self = this;\n    this._pako.onData = function(data) {\n        self.push({\n            data : data,\n            meta : self.meta\n        });\n    };\n};\n\nexports.compressWorker = function (compressionOptions) {\n    return new FlateWorker(\"Deflate\", compressionOptions);\n};\nexports.uncompressWorker = function () {\n    return new FlateWorker(\"Inflate\", {});\n};\n","'use strict';\n\nvar utils = require('../utils');\nvar GenericWorker = require('../stream/GenericWorker');\nvar utf8 = require('../utf8');\nvar crc32 = require('../crc32');\nvar signature = require('../signature');\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nvar decToHex = function(dec, bytes) {\n    var hex = \"\", i;\n    for (i = 0; i < bytes; i++) {\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can't use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n    return (result & 0xFFFF) << 16;\n};\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n\n    // the dir flag is already set for compatibility\n    return (dosPermissions || 0)  & 0x3F;\n};\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {Object} streamInfo the hash with information about the compressed file.\n * @param {Boolean} streamedContent is the content streamed ?\n * @param {Boolean} streamingEnded is the stream finished ?\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {Object} the zip parts.\n */\nvar generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n    var file = streamInfo['file'],\n    compression = streamInfo['compression'],\n    useCustomEncoding = encodeFileName !== utf8.utf8encode,\n    encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n    utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n    comment = file.comment,\n    encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n    utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n    useUTF8ForComment = utfEncodedComment.length !== comment.length,\n    dosTime,\n    dosDate,\n    extraFields = \"\",\n    unicodePathExtraField = \"\",\n    unicodeCommentExtraField = \"\",\n    dir = file.dir,\n    date = file.date;\n\n\n    var dataInfo = {\n        crc32 : 0,\n        compressedSize : 0,\n        uncompressedSize : 0\n    };\n\n    // if the content is streamed, the sizes/crc32 are only available AFTER\n    // the end of the stream.\n    if (!streamedContent || streamingEnded) {\n        dataInfo.crc32 = streamInfo['crc32'];\n        dataInfo.compressedSize = streamInfo['compressedSize'];\n        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];\n    }\n\n    var bitflag = 0;\n    if (streamedContent) {\n        // Bit 3: the sizes/crc32 are set to zero in the local header.\n        // The correct values are put in the data descriptor immediately\n        // following the compressed data.\n        bitflag |= 0x0008;\n    }\n    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n        // Bit 11: Language encoding flag (EFS).\n        bitflag |= 0x0800;\n    }\n\n\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if(platform === \"UNIX\") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else { // DOS or other, fallback to DOS\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n    dosTime = date.getUTCHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getUTCMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getUTCSeconds() / 2;\n\n    dosDate = date.getUTCFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | (date.getUTCMonth() + 1);\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getUTCDate();\n\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField =\n            // Version\n            decToHex(1, 1) +\n            // NameCRC32\n            decToHex(crc32(encodedFileName), 4) +\n            // UnicodeName\n            utfEncodedFileName;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x70\" +\n            // size\n            decToHex(unicodePathExtraField.length, 2) +\n            // content\n            unicodePathExtraField;\n    }\n\n    if(useUTF8ForComment) {\n\n        unicodeCommentExtraField =\n            // Version\n            decToHex(1, 1) +\n            // CommentCRC32\n            decToHex(crc32(encodedComment), 4) +\n            // UnicodeName\n            utfEncodedComment;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x63\" +\n            // size\n            decToHex(unicodeCommentExtraField.length, 2) +\n            // content\n            unicodeCommentExtraField;\n    }\n\n    var header = \"\";\n\n    // version needed to extract\n    header += \"\\x0A\\x00\";\n    // general purpose bit flag\n    header += decToHex(bitflag, 2);\n    // compression method\n    header += compression.magic;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(dataInfo.crc32, 4);\n    // compressed size\n    header += decToHex(dataInfo.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(dataInfo.uncompressedSize, 4);\n    // file name length\n    header += decToHex(encodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n\n\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n\n    var dirRecord = signature.CENTRAL_FILE_HEADER +\n        // version made by (00: DOS)\n        decToHex(versionMadeBy, 2) +\n        // file header (common to file and central directory)\n        header +\n        // file comment length\n        decToHex(encodedComment.length, 2) +\n        // disk number start\n        \"\\x00\\x00\" +\n        // internal file attributes TODO\n        \"\\x00\\x00\" +\n        // external file attributes\n        decToHex(extFileAttr, 4) +\n        // relative offset of local header\n        decToHex(offset, 4) +\n        // file name\n        encodedFileName +\n        // extra field\n        extraFields +\n        // file comment\n        encodedComment;\n\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord\n    };\n};\n\n/**\n * Generate the EOCD record.\n * @param {Number} entriesCount the number of entries in the zip file.\n * @param {Number} centralDirLength the length (in bytes) of the central dir.\n * @param {Number} localDirLength the length (in bytes) of the local dir.\n * @param {String} comment the zip file comment as a binary string.\n * @param {Function} encodeFileName the function to encode the comment.\n * @return {String} the EOCD record.\n */\nvar generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n    var dirEnd = \"\";\n    var encodedComment = utils.transformTo(\"string\", encodeFileName(comment));\n\n    // end of central dir signature\n    dirEnd = signature.CENTRAL_DIRECTORY_END +\n        // number of this disk\n        \"\\x00\\x00\" +\n        // number of the disk with the start of the central directory\n        \"\\x00\\x00\" +\n        // total number of entries in the central directory on this disk\n        decToHex(entriesCount, 2) +\n        // total number of entries in the central directory\n        decToHex(entriesCount, 2) +\n        // size of the central directory   4 bytes\n        decToHex(centralDirLength, 4) +\n        // offset of start of central directory with respect to the starting disk number\n        decToHex(localDirLength, 4) +\n        // .ZIP file comment length\n        decToHex(encodedComment.length, 2) +\n        // .ZIP file comment\n        encodedComment;\n\n    return dirEnd;\n};\n\n/**\n * Generate data descriptors for a file entry.\n * @param {Object} streamInfo the hash generated by a worker, containing information\n * on the file entry.\n * @return {String} the data descriptors.\n */\nvar generateDataDescriptors = function (streamInfo) {\n    var descriptor = \"\";\n    descriptor = signature.DATA_DESCRIPTOR +\n        // crc-32                          4 bytes\n        decToHex(streamInfo['crc32'], 4) +\n        // compressed size                 4 bytes\n        decToHex(streamInfo['compressedSize'], 4) +\n        // uncompressed size               4 bytes\n        decToHex(streamInfo['uncompressedSize'], 4);\n\n    return descriptor;\n};\n\n\n/**\n * A worker to concatenate other workers to create a zip file.\n * @param {Boolean} streamFiles `true` to stream the content of the files,\n * `false` to accumulate it.\n * @param {String} comment the comment to use.\n * @param {String} platform the platform to use, \"UNIX\" or \"DOS\".\n * @param {Function} encodeFileName the function to encode file names and comments.\n */\nfunction ZipFileWorker(streamFiles, comment, platform, encodeFileName) {\n    GenericWorker.call(this, \"ZipFileWorker\");\n    // The number of bytes written so far. This doesn't count accumulated chunks.\n    this.bytesWritten = 0;\n    // The comment of the zip file\n    this.zipComment = comment;\n    // The platform \"generating\" the zip file.\n    this.zipPlatform = platform;\n    // the function to encode file names and comments.\n    this.encodeFileName = encodeFileName;\n    // Should we stream the content of the files ?\n    this.streamFiles = streamFiles;\n    // If `streamFiles` is false, we will need to accumulate the content of the\n    // files to calculate sizes / crc32 (and write them *before* the content).\n    // This boolean indicates if we are accumulating chunks (it will change a lot\n    // during the lifetime of this worker).\n    this.accumulate = false;\n    // The buffer receiving chunks when accumulating content.\n    this.contentBuffer = [];\n    // The list of generated directory records.\n    this.dirRecords = [];\n    // The offset (in bytes) from the beginning of the zip file for the current source.\n    this.currentSourceOffset = 0;\n    // The total number of entries in this zip file.\n    this.entriesCount = 0;\n    // the name of the file currently being added, null when handling the end of the zip file.\n    // Used for the emitted metadata.\n    this.currentFile = null;\n\n\n\n    this._sources = [];\n}\nutils.inherits(ZipFileWorker, GenericWorker);\n\n/**\n * @see GenericWorker.push\n */\nZipFileWorker.prototype.push = function (chunk) {\n\n    var currentFilePercent = chunk.meta.percent || 0;\n    var entriesCount = this.entriesCount;\n    var remainingFiles = this._sources.length;\n\n    if(this.accumulate) {\n        this.contentBuffer.push(chunk);\n    } else {\n        this.bytesWritten += chunk.data.length;\n\n        GenericWorker.prototype.push.call(this, {\n            data : chunk.data,\n            meta : {\n                currentFile : this.currentFile,\n                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100\n            }\n        });\n    }\n};\n\n/**\n * The worker started a new source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the new source.\n */\nZipFileWorker.prototype.openedSource = function (streamInfo) {\n    this.currentSourceOffset = this.bytesWritten;\n    this.currentFile = streamInfo['file'].name;\n\n    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n\n    // don't stream folders (because they don't have any content)\n    if(streamedContent) {\n        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n        this.push({\n            data : record.fileRecord,\n            meta : {percent:0}\n        });\n    } else {\n        // we need to wait for the whole file before pushing anything\n        this.accumulate = true;\n    }\n};\n\n/**\n * The worker finished a source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the finished source.\n */\nZipFileWorker.prototype.closedSource = function (streamInfo) {\n    this.accumulate = false;\n    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n\n    this.dirRecords.push(record.dirRecord);\n    if(streamedContent) {\n        // after the streamed file, we put data descriptors\n        this.push({\n            data : generateDataDescriptors(streamInfo),\n            meta : {percent:100}\n        });\n    } else {\n        // the content wasn't streamed, we need to push everything now\n        // first the file record, then the content\n        this.push({\n            data : record.fileRecord,\n            meta : {percent:0}\n        });\n        while(this.contentBuffer.length) {\n            this.push(this.contentBuffer.shift());\n        }\n    }\n    this.currentFile = null;\n};\n\n/**\n * @see GenericWorker.flush\n */\nZipFileWorker.prototype.flush = function () {\n\n    var localDirLength = this.bytesWritten;\n    for(var i = 0; i < this.dirRecords.length; i++) {\n        this.push({\n            data : this.dirRecords[i],\n            meta : {percent:100}\n        });\n    }\n    var centralDirLength = this.bytesWritten - localDirLength;\n\n    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n\n    this.push({\n        data : dirEnd,\n        meta : {percent:100}\n    });\n};\n\n/**\n * Prepare the next source to be read.\n */\nZipFileWorker.prototype.prepareNextSource = function () {\n    this.previous = this._sources.shift();\n    this.openedSource(this.previous.streamInfo);\n    if (this.isPaused) {\n        this.previous.pause();\n    } else {\n        this.previous.resume();\n    }\n};\n\n/**\n * @see GenericWorker.registerPrevious\n */\nZipFileWorker.prototype.registerPrevious = function (previous) {\n    this._sources.push(previous);\n    var self = this;\n\n    previous.on('data', function (chunk) {\n        self.processChunk(chunk);\n    });\n    previous.on('end', function () {\n        self.closedSource(self.previous.streamInfo);\n        if(self._sources.length) {\n            self.prepareNextSource();\n        } else {\n            self.end();\n        }\n    });\n    previous.on('error', function (e) {\n        self.error(e);\n    });\n    return this;\n};\n\n/**\n * @see GenericWorker.resume\n */\nZipFileWorker.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if (!this.previous && this._sources.length) {\n        this.prepareNextSource();\n        return true;\n    }\n    if (!this.previous && !this._sources.length && !this.generatedError) {\n        this.end();\n        return true;\n    }\n};\n\n/**\n * @see GenericWorker.error\n */\nZipFileWorker.prototype.error = function (e) {\n    var sources = this._sources;\n    if(!GenericWorker.prototype.error.call(this, e)) {\n        return false;\n    }\n    for(var i = 0; i < sources.length; i++) {\n        try {\n            sources[i].error(e);\n        } catch(e) {\n            // the `error` exploded, nothing to do\n        }\n    }\n    return true;\n};\n\n/**\n * @see GenericWorker.lock\n */\nZipFileWorker.prototype.lock = function () {\n    GenericWorker.prototype.lock.call(this);\n    var sources = this._sources;\n    for(var i = 0; i < sources.length; i++) {\n        sources[i].lock();\n    }\n};\n\nmodule.exports = ZipFileWorker;\n","'use strict';\n\nvar compressions = require('../compressions');\nvar ZipFileWorker = require('./ZipFileWorker');\n\n/**\n * Find the compression to use.\n * @param {String} fileCompression the compression defined at the file level, if any.\n * @param {String} zipCompression the compression defined at the load() level.\n * @return {Object} the compression object to use.\n */\nvar getCompression = function (fileCompression, zipCompression) {\n\n    var compressionName = fileCompression || zipCompression;\n    var compression = compressions[compressionName];\n    if (!compression) {\n        throw new Error(compressionName + \" is not a valid compression method !\");\n    }\n    return compression;\n};\n\n/**\n * Create a worker to generate a zip file.\n * @param {JSZip} zip the JSZip instance at the right root level.\n * @param {Object} options to generate the zip file.\n * @param {String} comment the comment to use.\n */\nexports.generateWorker = function (zip, options, comment) {\n\n    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\n    var entriesCount = 0;\n    try {\n\n        zip.forEach(function (relativePath, file) {\n            entriesCount++;\n            var compression = getCompression(file.options.compression, options.compression);\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n            var dir = file.dir, date = file.date;\n\n            file._compressWorker(compression, compressionOptions)\n            .withStreamInfo(\"file\", {\n                name : relativePath,\n                dir : dir,\n                date : date,\n                comment : file.comment || \"\",\n                unixPermissions : file.unixPermissions,\n                dosPermissions : file.dosPermissions\n            })\n            .pipe(zipFileWorker);\n        });\n        zipFileWorker.entriesCount = entriesCount;\n    } catch (e) {\n        zipFileWorker.error(e);\n    }\n\n    return zipFileWorker;\n};\n","'use strict';\n\n/**\n * Representation a of zip file in js\n * @constructor\n */\nfunction JSZip() {\n    // if this constructor isused without`new`, itadds `new` beforeitself:\n    if(!(this instanceof JSZip)) {\n        return new JSZip();\n    }\n\n    if(arguments.length) {\n        throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");\n    }\n\n    // object containing the files :\n    // {\n    //   \"folder/\" : {...},\n    //   \"folder/data.txt\" : {...}\n    // }\n    this.files = {};\n\n    this.comment = null;\n\n    // Where we are in the hierarchy\n    this.root = \"\";\n    this.clone = function() {\n        var newObj = new JSZip();\n        for (var i in this) {\n            if (typeof this[i] !== \"function\") {\n                newObj[i] = this[i];\n            }\n        }\n        return newObj;\n    };\n}\nJSZip.prototype = require('./object');\nJSZip.prototype.loadAsync = require('./load');\nJSZip.support = require('./support');\nJSZip.defaults = require('./defaults');\n\n// TODO find a better way to handle this version,\n// a require('package.json').version doesn't work with webpack, see #327\nJSZip.version = \"3.5.0\";\n\nJSZip.loadAsync = function (content, options) {\n    return new JSZip().loadAsync(content, options);\n};\n\nJSZip.external = require(\"./external\");\nmodule.exports = JSZip;\n","'use strict';\nvar utils = require('./utils');\nvar external = require(\"./external\");\nvar utf8 = require('./utf8');\nvar utils = require('./utils');\nvar ZipEntries = require('./zipEntries');\nvar Crc32Probe = require('./stream/Crc32Probe');\nvar nodejsUtils = require(\"./nodejsUtils\");\n\n/**\n * Check the CRC32 of an entry.\n * @param {ZipEntry} zipEntry the zip entry to check.\n * @return {Promise} the result.\n */\nfunction checkEntryCRC32(zipEntry) {\n    return new external.Promise(function (resolve, reject) {\n        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());\n        worker.on(\"error\", function (e) {\n            reject(e);\n        })\n        .on(\"end\", function () {\n            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {\n                reject(new Error(\"Corrupted zip : CRC32 mismatch\"));\n            } else {\n                resolve();\n            }\n        })\n        .resume();\n    });\n}\n\nmodule.exports = function(data, options) {\n    var zip = this;\n    options = utils.extend(options || {}, {\n        base64: false,\n        checkCRC32: false,\n        optimizedBinaryString: false,\n        createFolders: false,\n        decodeFileName: utf8.utf8decode\n    });\n\n    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        return external.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\"));\n    }\n\n    return utils.prepareContent(\"the loaded zip file\", data, true, options.optimizedBinaryString, options.base64)\n    .then(function(data) {\n        var zipEntries = new ZipEntries(options);\n        zipEntries.load(data);\n        return zipEntries;\n    }).then(function checkCRC32(zipEntries) {\n        var promises = [external.Promise.resolve(zipEntries)];\n        var files = zipEntries.files;\n        if (options.checkCRC32) {\n            for (var i = 0; i < files.length; i++) {\n                promises.push(checkEntryCRC32(files[i]));\n            }\n        }\n        return external.Promise.all(promises);\n    }).then(function addFiles(results) {\n        var zipEntries = results.shift();\n        var files = zipEntries.files;\n        for (var i = 0; i < files.length; i++) {\n            var input = files[i];\n            zip.file(input.fileNameStr, input.decompressed, {\n                binary: true,\n                optimizedBinaryString: true,\n                date: input.date,\n                dir: input.dir,\n                comment : input.fileCommentStr.length ? input.fileCommentStr : null,\n                unixPermissions : input.unixPermissions,\n                dosPermissions : input.dosPermissions,\n                createFolders: options.createFolders\n            });\n        }\n        if (zipEntries.zipComment.length) {\n            zip.comment = zipEntries.zipComment;\n        }\n\n        return zip;\n    });\n};\n","'use strict';\n\nmodule.exports = {\n    /**\n     * True if this is running in Nodejs, will be undefined in a browser.\n     * In a browser, browserify won't include this file and the whole module\n     * will be resolved an empty object.\n     */\n    isNode : typeof Buffer !== \"undefined\",\n    /**\n     * Create a new nodejs Buffer from an existing content.\n     * @param {Object} data the data to pass to the constructor.\n     * @param {String} encoding the encoding to use.\n     * @return {Buffer} a new Buffer.\n     */\n    newBufferFrom: function(data, encoding) {\n        if (Buffer.from && Buffer.from !== Uint8Array.from) {\n            return Buffer.from(data, encoding);\n        } else {\n            if (typeof data === \"number\") {\n                // Safeguard for old Node.js versions. On newer versions,\n                // Buffer.from(number) / Buffer(number, encoding) already throw.\n                throw new Error(\"The \\\"data\\\" argument must not be a number\");\n            }\n            return new Buffer(data, encoding);\n        }\n    },\n    /**\n     * Create a new nodejs Buffer with the specified size.\n     * @param {Integer} size the size of the buffer.\n     * @return {Buffer} a new Buffer.\n     */\n    allocBuffer: function (size) {\n        if (Buffer.alloc) {\n            return Buffer.alloc(size);\n        } else {\n            var buf = new Buffer(size);\n            buf.fill(0);\n            return buf;\n        }\n    },\n    /**\n     * Find out if an object is a Buffer.\n     * @param {Object} b the object to test.\n     * @return {Boolean} true if the object is a Buffer, false otherwise.\n     */\n    isBuffer : function(b){\n        return Buffer.isBuffer(b);\n    },\n\n    isStream : function (obj) {\n        return obj &&\n            typeof obj.on === \"function\" &&\n            typeof obj.pause === \"function\" &&\n            typeof obj.resume === \"function\";\n    }\n};\n","\"use strict\";\n\nvar utils = require('../utils');\nvar GenericWorker = require('../stream/GenericWorker');\n\n/**\n * A worker that use a nodejs stream as source.\n * @constructor\n * @param {String} filename the name of the file entry for this stream.\n * @param {Readable} stream the nodejs stream.\n */\nfunction NodejsStreamInputAdapter(filename, stream) {\n    GenericWorker.call(this, \"Nodejs stream input adapter for \" + filename);\n    this._upstreamEnded = false;\n    this._bindStream(stream);\n}\n\nutils.inherits(NodejsStreamInputAdapter, GenericWorker);\n\n/**\n * Prepare the stream and bind the callbacks on it.\n * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.\n * @param {Stream} stream the nodejs stream to use.\n */\nNodejsStreamInputAdapter.prototype._bindStream = function (stream) {\n    var self = this;\n    this._stream = stream;\n    stream.pause();\n    stream\n    .on(\"data\", function (chunk) {\n        self.push({\n            data: chunk,\n            meta : {\n                percent : 0\n            }\n        });\n    })\n    .on(\"error\", function (e) {\n        if(self.isPaused) {\n            this.generatedError = e;\n        } else {\n            self.error(e);\n        }\n    })\n    .on(\"end\", function () {\n        if(self.isPaused) {\n            self._upstreamEnded = true;\n        } else {\n            self.end();\n        }\n    });\n};\nNodejsStreamInputAdapter.prototype.pause = function () {\n    if(!GenericWorker.prototype.pause.call(this)) {\n        return false;\n    }\n    this._stream.pause();\n    return true;\n};\nNodejsStreamInputAdapter.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if(this._upstreamEnded) {\n        this.end();\n    } else {\n        this._stream.resume();\n    }\n\n    return true;\n};\n\nmodule.exports = NodejsStreamInputAdapter;\n","'use strict';\n\nvar Readable = require('readable-stream').Readable;\n\nvar utils = require('../utils');\nutils.inherits(NodejsStreamOutputAdapter, Readable);\n\n/**\n* A nodejs stream using a worker as source.\n* @see the SourceWrapper in http://nodejs.org/api/stream.html\n* @constructor\n* @param {StreamHelper} helper the helper wrapping the worker\n* @param {Object} options the nodejs stream options\n* @param {Function} updateCb the update callback.\n*/\nfunction NodejsStreamOutputAdapter(helper, options, updateCb) {\n    Readable.call(this, options);\n    this._helper = helper;\n\n    var self = this;\n    helper.on(\"data\", function (data, meta) {\n        if (!self.push(data)) {\n            self._helper.pause();\n        }\n        if(updateCb) {\n            updateCb(meta);\n        }\n    })\n    .on(\"error\", function(e) {\n        self.emit('error', e);\n    })\n    .on(\"end\", function () {\n        self.push(null);\n    });\n}\n\n\nNodejsStreamOutputAdapter.prototype._read = function() {\n    this._helper.resume();\n};\n\nmodule.exports = NodejsStreamOutputAdapter;\n","'use strict';\nvar utf8 = require('./utf8');\nvar utils = require('./utils');\nvar GenericWorker = require('./stream/GenericWorker');\nvar StreamHelper = require('./stream/StreamHelper');\nvar defaults = require('./defaults');\nvar CompressedObject = require('./compressedObject');\nvar ZipObject = require('./zipObject');\nvar generate = require(\"./generate\");\nvar nodejsUtils = require(\"./nodejsUtils\");\nvar NodejsStreamInputAdapter = require(\"./nodejs/NodejsStreamInputAdapter\");\n\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} originalOptions the options of the file\n * @return {Object} the new file.\n */\nvar fileAdd = function(name, data, originalOptions) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data),\n        parent;\n\n\n    /*\n     * Correct options.\n     */\n\n    var o = utils.extend(originalOptions || {}, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) {\n        o.compression = o.compression.toUpperCase();\n    }\n\n    if (typeof o.unixPermissions === \"string\") {\n        o.unixPermissions = parseInt(o.unixPermissions, 8);\n    }\n\n    // UNX_IFDIR  0040000 see zipinfo.c\n    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {\n        o.dir = true;\n    }\n    // Bit 4    Directory\n    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {\n        o.dir = true;\n    }\n\n    if (o.dir) {\n        name = forceTrailingSlash(name);\n    }\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n\n    var isUnicodeString = dataType === \"string\" && o.binary === false && o.base64 === false;\n    if (!originalOptions || typeof originalOptions.binary === \"undefined\") {\n        o.binary = !isUnicodeString;\n    }\n\n\n    var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;\n\n    if (isCompressedEmpty || o.dir || !data || data.length === 0) {\n        o.base64 = false;\n        o.binary = true;\n        data = \"\";\n        o.compression = \"STORE\";\n        dataType = \"string\";\n    }\n\n    /*\n     * Convert content to fit.\n     */\n\n    var zipObjectContent = null;\n    if (data instanceof CompressedObject || data instanceof GenericWorker) {\n        zipObjectContent = data;\n    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        zipObjectContent = new NodejsStreamInputAdapter(name, data);\n    } else {\n        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);\n    }\n\n    var object = new ZipObject(name, zipObjectContent, o);\n    this.files[name] = object;\n    /*\n    TODO: we can't throw an exception because we have async promises\n    (we can have a promise of a Date() for example) but returning a\n    promise is useless because file(name, data) returns the JSZip\n    object for chaining. Should we break that to allow the user\n    to catch the error ?\n\n    return external.Promise.resolve(zipObjectContent)\n    .then(function () {\n        return object;\n    });\n    */\n};\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\nvar parentFolder = function (path) {\n    if (path.slice(-1) === '/') {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf('/');\n    return (lastSlash > 0) ? path.substring(0, lastSlash) : \"\";\n};\n\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\nvar forceTrailingSlash = function(path) {\n    // Check the name ends with a /\n    if (path.slice(-1) !== \"/\") {\n        path += \"/\"; // IE doesn't like substr(-1)\n    }\n    return path;\n};\n\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nvar folderAdd = function(name, createFolders) {\n    createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;\n\n    name = forceTrailingSlash(name);\n\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nfunction isRegExp(object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n}\n\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * @see loadAsync\n     */\n    load: function() {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n\n\n    /**\n     * Call a callback function for each entry at this folder level.\n     * @param {Function} cb the callback function:\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     */\n    forEach: function(cb) {\n        var filename, relativePath, file;\n        for (filename in this.files) {\n            if (!this.files.hasOwnProperty(filename)) {\n                continue;\n            }\n            file = this.files[filename];\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (relativePath && filename.slice(0, this.root.length) === this.root) { // the file is in the current root\n                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...\n            }\n        }\n    },\n\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */\n    filter: function(search) {\n        var result = [];\n        this.forEach(function (relativePath, entry) {\n            if (search(relativePath, entry)) { // the file matches the function\n                result.push(entry);\n            }\n\n        });\n        return result;\n    },\n\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */\n    file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            }\n            else { // text\n                var obj = this.files[this.root + name];\n                if (obj && !obj.dir) {\n                    return obj;\n                } else {\n                    return null;\n                }\n            }\n        }\n        else { // more than one argument : we have data !\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */\n    folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n\n        if (isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */\n    remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) !== \"/\") {\n                name += \"/\";\n            }\n            file = this.files[name];\n        }\n\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for (var i = 0; i < kids.length; i++) {\n                delete this.files[kids[i].name];\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Generate the complete zip file\n     * @param {Object} options the options to generate the zip file :\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n     */\n    generate: function(options) {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n\n    /**\n     * Generate the complete zip file as an internal stream.\n     * @param {Object} options the options to generate the zip file :\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {StreamHelper} the streamed zip file.\n     */\n    generateInternalStream: function(options) {\n      var worker, opts = {};\n      try {\n          opts = utils.extend(options || {}, {\n              streamFiles: false,\n              compression: \"STORE\",\n              compressionOptions : null,\n              type: \"\",\n              platform: \"DOS\",\n              comment: null,\n              mimeType: 'application/zip',\n              encodeFileName: utf8.utf8encode\n          });\n\n          opts.type = opts.type.toLowerCase();\n          opts.compression = opts.compression.toUpperCase();\n\n          // \"binarystring\" is preferred but the internals use \"string\".\n          if(opts.type === \"binarystring\") {\n            opts.type = \"string\";\n          }\n\n          if (!opts.type) {\n            throw new Error(\"No output type specified.\");\n          }\n\n          utils.checkSupport(opts.type);\n\n          // accept nodejs `process.platform`\n          if(\n              opts.platform === 'darwin' ||\n              opts.platform === 'freebsd' ||\n              opts.platform === 'linux' ||\n              opts.platform === 'sunos'\n          ) {\n              opts.platform = \"UNIX\";\n          }\n          if (opts.platform === 'win32') {\n              opts.platform = \"DOS\";\n          }\n\n          var comment = opts.comment || this.comment || \"\";\n          worker = generate.generateWorker(this, opts, comment);\n      } catch (e) {\n        worker = new GenericWorker(\"error\");\n        worker.error(e);\n      }\n      return new StreamHelper(worker, opts.type || \"string\", opts.mimeType);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */\n    generateAsync: function(options, onUpdate) {\n        return this.generateInternalStream(options).accumulate(onUpdate);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */\n    generateNodeStream: function(options, onUpdate) {\n        options = options || {};\n        if (!options.type) {\n            options.type = \"nodebuffer\";\n        }\n        return this.generateInternalStream(options).toNodejsStream(onUpdate);\n    }\n};\nmodule.exports = out;\n","/*\n * This file is used by module bundlers (browserify/webpack/etc) when\n * including a stream implementation. We use \"readable-stream\" to get a\n * consistent behavior between nodejs versions but bundlers often have a shim\n * for \"stream\". Using this shim greatly improve the compatibility and greatly\n * reduce the final size of the bundle (only one stream implementation, not\n * two).\n */\nmodule.exports = require(\"stream\");\n","'use strict';\nvar DataReader = require('./DataReader');\nvar utils = require('../utils');\n\nfunction ArrayReader(data) {\n    DataReader.call(this, data);\n\tfor(var i = 0; i < this.data.length; i++) {\n\t\tdata[i] = data[i] & 0xFF;\n\t}\n}\nutils.inherits(ArrayReader, DataReader);\n/**\n * @see DataReader.byteAt\n */\nArrayReader.prototype.byteAt = function(i) {\n    return this.data[this.zero + i];\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nArrayReader.prototype.lastIndexOfSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3);\n    for (var i = this.length - 4; i >= 0; --i) {\n        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n            return i - this.zero;\n        }\n    }\n\n    return -1;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */\nArrayReader.prototype.readAndCheckSignature = function (sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3),\n        data = this.readData(4);\n    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];\n};\n/**\n * @see DataReader.readData\n */\nArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        return [];\n    }\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = ArrayReader;\n","'use strict';\nvar utils = require('../utils');\n\nfunction DataReader(data) {\n    this.data = data; // type : see implementation\n    this.length = data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */\n    checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specified index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */\n    checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + (newIndex) + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */\n    setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */\n    skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */\n    byteAt: function(i) {\n        // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */\n    readInt: function(size) {\n        var result = 0,\n            i;\n        this.checkOffset(size);\n        for (i = this.index + size - 1; i >= this.index; i--) {\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */\n    readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */\n    readData: function(size) {\n        // see implementations\n    },\n    /**\n     * Find the last occurrence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurrence, -1 if not found.\n     */\n    lastIndexOfSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Read the signature (4 bytes) at the current position and compare it with sig.\n     * @param {string} sig the expected signature\n     * @return {boolean} true if the signature matches, false otherwise.\n     */\n    readAndCheckSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */\n    readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(Date.UTC(\n        ((dostime >> 25) & 0x7f) + 1980, // year\n        ((dostime >> 21) & 0x0f) - 1, // month\n        (dostime >> 16) & 0x1f, // day\n        (dostime >> 11) & 0x1f, // hour\n        (dostime >> 5) & 0x3f, // minute\n        (dostime & 0x1f) << 1)); // second\n    }\n};\nmodule.exports = DataReader;\n","'use strict';\nvar Uint8ArrayReader = require('./Uint8ArrayReader');\nvar utils = require('../utils');\n\nfunction NodeBufferReader(data) {\n    Uint8ArrayReader.call(this, data);\n}\nutils.inherits(NodeBufferReader, Uint8ArrayReader);\n\n/**\n * @see DataReader.readData\n */\nNodeBufferReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = NodeBufferReader;\n","'use strict';\nvar DataReader = require('./DataReader');\nvar utils = require('../utils');\n\nfunction StringReader(data) {\n    DataReader.call(this, data);\n}\nutils.inherits(StringReader, DataReader);\n/**\n * @see DataReader.byteAt\n */\nStringReader.prototype.byteAt = function(i) {\n    return this.data.charCodeAt(this.zero + i);\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nStringReader.prototype.lastIndexOfSignature = function(sig) {\n    return this.data.lastIndexOf(sig) - this.zero;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */\nStringReader.prototype.readAndCheckSignature = function (sig) {\n    var data = this.readData(4);\n    return sig === data;\n};\n/**\n * @see DataReader.readData\n */\nStringReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    // this will work because the constructor applied the \"& 0xff\" mask.\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = StringReader;\n","'use strict';\nvar ArrayReader = require('./ArrayReader');\nvar utils = require('../utils');\n\nfunction Uint8ArrayReader(data) {\n    ArrayReader.call(this, data);\n}\nutils.inherits(Uint8ArrayReader, ArrayReader);\n/**\n * @see DataReader.readData\n */\nUint8ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].\n        return new Uint8Array(0);\n    }\n    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = Uint8ArrayReader;\n","'use strict';\n\nvar utils = require('../utils');\nvar support = require('../support');\nvar ArrayReader = require('./ArrayReader');\nvar StringReader = require('./StringReader');\nvar NodeBufferReader = require('./NodeBufferReader');\nvar Uint8ArrayReader = require('./Uint8ArrayReader');\n\n/**\n * Create a reader adapted to the data.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.\n * @return {DataReader} the data reader.\n */\nmodule.exports = function (data) {\n    var type = utils.getTypeOf(data);\n    utils.checkSupport(type);\n    if (type === \"string\" && !support.uint8array) {\n        return new StringReader(data);\n    }\n    if (type === \"nodebuffer\") {\n        return new NodeBufferReader(data);\n    }\n    if (support.uint8array) {\n        return new Uint8ArrayReader(utils.transformTo(\"uint8array\", data));\n    }\n    return new ArrayReader(utils.transformTo(\"array\", data));\n};\n","'use strict';\nexports.LOCAL_FILE_HEADER = \"PK\\x03\\x04\";\nexports.CENTRAL_FILE_HEADER = \"PK\\x01\\x02\";\nexports.CENTRAL_DIRECTORY_END = \"PK\\x05\\x06\";\nexports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\x06\\x07\";\nexports.ZIP64_CENTRAL_DIRECTORY_END = \"PK\\x06\\x06\";\nexports.DATA_DESCRIPTOR = \"PK\\x07\\x08\";\n","'use strict';\n\nvar GenericWorker = require('./GenericWorker');\nvar utils = require('../utils');\n\n/**\n * A worker which convert chunks to a specified type.\n * @constructor\n * @param {String} destType the destination type.\n */\nfunction ConvertWorker(destType) {\n    GenericWorker.call(this, \"ConvertWorker to \" + destType);\n    this.destType = destType;\n}\nutils.inherits(ConvertWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nConvertWorker.prototype.processChunk = function (chunk) {\n    this.push({\n        data : utils.transformTo(this.destType, chunk.data),\n        meta : chunk.meta\n    });\n};\nmodule.exports = ConvertWorker;\n","'use strict';\n\nvar GenericWorker = require('./GenericWorker');\nvar crc32 = require('../crc32');\nvar utils = require('../utils');\n\n/**\n * A worker which calculate the crc32 of the data flowing through.\n * @constructor\n */\nfunction Crc32Probe() {\n    GenericWorker.call(this, \"Crc32Probe\");\n    this.withStreamInfo(\"crc32\", 0);\n}\nutils.inherits(Crc32Probe, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nCrc32Probe.prototype.processChunk = function (chunk) {\n    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);\n    this.push(chunk);\n};\nmodule.exports = Crc32Probe;\n","'use strict';\n\nvar utils = require('../utils');\nvar GenericWorker = require('./GenericWorker');\n\n/**\n * A worker which calculate the total length of the data flowing through.\n * @constructor\n * @param {String} propName the name used to expose the length\n */\nfunction DataLengthProbe(propName) {\n    GenericWorker.call(this, \"DataLengthProbe for \" + propName);\n    this.propName = propName;\n    this.withStreamInfo(propName, 0);\n}\nutils.inherits(DataLengthProbe, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nDataLengthProbe.prototype.processChunk = function (chunk) {\n    if(chunk) {\n        var length = this.streamInfo[this.propName] || 0;\n        this.streamInfo[this.propName] = length + chunk.data.length;\n    }\n    GenericWorker.prototype.processChunk.call(this, chunk);\n};\nmodule.exports = DataLengthProbe;\n\n","'use strict';\n\nvar utils = require('../utils');\nvar GenericWorker = require('./GenericWorker');\n\n// the size of the generated chunks\n// TODO expose this as a public variable\nvar DEFAULT_BLOCK_SIZE = 16 * 1024;\n\n/**\n * A worker that reads a content and emits chunks.\n * @constructor\n * @param {Promise} dataP the promise of the data to split\n */\nfunction DataWorker(dataP) {\n    GenericWorker.call(this, \"DataWorker\");\n    var self = this;\n    this.dataIsReady = false;\n    this.index = 0;\n    this.max = 0;\n    this.data = null;\n    this.type = \"\";\n\n    this._tickScheduled = false;\n\n    dataP.then(function (data) {\n        self.dataIsReady = true;\n        self.data = data;\n        self.max = data && data.length || 0;\n        self.type = utils.getTypeOf(data);\n        if(!self.isPaused) {\n            self._tickAndRepeat();\n        }\n    }, function (e) {\n        self.error(e);\n    });\n}\n\nutils.inherits(DataWorker, GenericWorker);\n\n/**\n * @see GenericWorker.cleanUp\n */\nDataWorker.prototype.cleanUp = function () {\n    GenericWorker.prototype.cleanUp.call(this);\n    this.data = null;\n};\n\n/**\n * @see GenericWorker.resume\n */\nDataWorker.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if (!this._tickScheduled && this.dataIsReady) {\n        this._tickScheduled = true;\n        utils.delay(this._tickAndRepeat, [], this);\n    }\n    return true;\n};\n\n/**\n * Trigger a tick a schedule an other call to this function.\n */\nDataWorker.prototype._tickAndRepeat = function() {\n    this._tickScheduled = false;\n    if(this.isPaused || this.isFinished) {\n        return;\n    }\n    this._tick();\n    if(!this.isFinished) {\n        utils.delay(this._tickAndRepeat, [], this);\n        this._tickScheduled = true;\n    }\n};\n\n/**\n * Read and push a chunk.\n */\nDataWorker.prototype._tick = function() {\n\n    if(this.isPaused || this.isFinished) {\n        return false;\n    }\n\n    var size = DEFAULT_BLOCK_SIZE;\n    var data = null, nextIndex = Math.min(this.max, this.index + size);\n    if (this.index >= this.max) {\n        // EOF\n        return this.end();\n    } else {\n        switch(this.type) {\n            case \"string\":\n                data = this.data.substring(this.index, nextIndex);\n            break;\n            case \"uint8array\":\n                data = this.data.subarray(this.index, nextIndex);\n            break;\n            case \"array\":\n            case \"nodebuffer\":\n                data = this.data.slice(this.index, nextIndex);\n            break;\n        }\n        this.index = nextIndex;\n        return this.push({\n            data : data,\n            meta : {\n                percent : this.max ? this.index / this.max * 100 : 0\n            }\n        });\n    }\n};\n\nmodule.exports = DataWorker;\n","'use strict';\n\n/**\n * A worker that does nothing but passing chunks to the next one. This is like\n * a nodejs stream but with some differences. On the good side :\n * - it works on IE 6-9 without any issue / polyfill\n * - it weights less than the full dependencies bundled with browserify\n * - it forwards errors (no need to declare an error handler EVERYWHERE)\n *\n * A chunk is an object with 2 attributes : `meta` and `data`. The former is an\n * object containing anything (`percent` for example), see each worker for more\n * details. The latter is the real data (String, Uint8Array, etc).\n *\n * @constructor\n * @param {String} name the name of the stream (mainly used for debugging purposes)\n */\nfunction GenericWorker(name) {\n    // the name of the worker\n    this.name = name || \"default\";\n    // an object containing metadata about the workers chain\n    this.streamInfo = {};\n    // an error which happened when the worker was paused\n    this.generatedError = null;\n    // an object containing metadata to be merged by this worker into the general metadata\n    this.extraStreamInfo = {};\n    // true if the stream is paused (and should not do anything), false otherwise\n    this.isPaused = true;\n    // true if the stream is finished (and should not do anything), false otherwise\n    this.isFinished = false;\n    // true if the stream is locked to prevent further structure updates (pipe), false otherwise\n    this.isLocked = false;\n    // the event listeners\n    this._listeners = {\n        'data':[],\n        'end':[],\n        'error':[]\n    };\n    // the previous worker, if any\n    this.previous = null;\n}\n\nGenericWorker.prototype = {\n    /**\n     * Push a chunk to the next workers.\n     * @param {Object} chunk the chunk to push\n     */\n    push : function (chunk) {\n        this.emit(\"data\", chunk);\n    },\n    /**\n     * End the stream.\n     * @return {Boolean} true if this call ended the worker, false otherwise.\n     */\n    end : function () {\n        if (this.isFinished) {\n            return false;\n        }\n\n        this.flush();\n        try {\n            this.emit(\"end\");\n            this.cleanUp();\n            this.isFinished = true;\n        } catch (e) {\n            this.emit(\"error\", e);\n        }\n        return true;\n    },\n    /**\n     * End the stream with an error.\n     * @param {Error} e the error which caused the premature end.\n     * @return {Boolean} true if this call ended the worker with an error, false otherwise.\n     */\n    error : function (e) {\n        if (this.isFinished) {\n            return false;\n        }\n\n        if(this.isPaused) {\n            this.generatedError = e;\n        } else {\n            this.isFinished = true;\n\n            this.emit(\"error\", e);\n\n            // in the workers chain exploded in the middle of the chain,\n            // the error event will go downward but we also need to notify\n            // workers upward that there has been an error.\n            if(this.previous) {\n                this.previous.error(e);\n            }\n\n            this.cleanUp();\n        }\n        return true;\n    },\n    /**\n     * Add a callback on an event.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Function} listener the function to call when the event is triggered\n     * @return {GenericWorker} the current object for chainability\n     */\n    on : function (name, listener) {\n        this._listeners[name].push(listener);\n        return this;\n    },\n    /**\n     * Clean any references when a worker is ending.\n     */\n    cleanUp : function () {\n        this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n        this._listeners = [];\n    },\n    /**\n     * Trigger an event. This will call registered callback with the provided arg.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Object} arg the argument to call the callback with.\n     */\n    emit : function (name, arg) {\n        if (this._listeners[name]) {\n            for(var i = 0; i < this._listeners[name].length; i++) {\n                this._listeners[name][i].call(this, arg);\n            }\n        }\n    },\n    /**\n     * Chain a worker with an other.\n     * @param {Worker} next the worker receiving events from the current one.\n     * @return {worker} the next worker for chainability\n     */\n    pipe : function (next) {\n        return next.registerPrevious(this);\n    },\n    /**\n     * Same as `pipe` in the other direction.\n     * Using an API with `pipe(next)` is very easy.\n     * Implementing the API with the point of view of the next one registering\n     * a source is easier, see the ZipFileWorker.\n     * @param {Worker} previous the previous worker, sending events to this one\n     * @return {Worker} the current worker for chainability\n     */\n    registerPrevious : function (previous) {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n\n        // sharing the streamInfo...\n        this.streamInfo = previous.streamInfo;\n        // ... and adding our own bits\n        this.mergeStreamInfo();\n        this.previous =  previous;\n        var self = this;\n        previous.on('data', function (chunk) {\n            self.processChunk(chunk);\n        });\n        previous.on('end', function () {\n            self.end();\n        });\n        previous.on('error', function (e) {\n            self.error(e);\n        });\n        return this;\n    },\n    /**\n     * Pause the stream so it doesn't send events anymore.\n     * @return {Boolean} true if this call paused the worker, false otherwise.\n     */\n    pause : function () {\n        if(this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = true;\n\n        if(this.previous) {\n            this.previous.pause();\n        }\n        return true;\n    },\n    /**\n     * Resume a paused stream.\n     * @return {Boolean} true if this call resumed the worker, false otherwise.\n     */\n    resume : function () {\n        if(!this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = false;\n\n        // if true, the worker tried to resume but failed\n        var withError = false;\n        if(this.generatedError) {\n            this.error(this.generatedError);\n            withError = true;\n        }\n        if(this.previous) {\n            this.previous.resume();\n        }\n\n        return !withError;\n    },\n    /**\n     * Flush any remaining bytes as the stream is ending.\n     */\n    flush : function () {},\n    /**\n     * Process a chunk. This is usually the method overridden.\n     * @param {Object} chunk the chunk to process.\n     */\n    processChunk : function(chunk) {\n        this.push(chunk);\n    },\n    /**\n     * Add a key/value to be added in the workers chain streamInfo once activated.\n     * @param {String} key the key to use\n     * @param {Object} value the associated value\n     * @return {Worker} the current worker for chainability\n     */\n    withStreamInfo : function (key, value) {\n        this.extraStreamInfo[key] = value;\n        this.mergeStreamInfo();\n        return this;\n    },\n    /**\n     * Merge this worker's streamInfo into the chain's streamInfo.\n     */\n    mergeStreamInfo : function () {\n        for(var key in this.extraStreamInfo) {\n            if (!this.extraStreamInfo.hasOwnProperty(key)) {\n                continue;\n            }\n            this.streamInfo[key] = this.extraStreamInfo[key];\n        }\n    },\n\n    /**\n     * Lock the stream to prevent further updates on the workers chain.\n     * After calling this method, all calls to pipe will fail.\n     */\n    lock: function () {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n        this.isLocked = true;\n        if (this.previous) {\n            this.previous.lock();\n        }\n    },\n\n    /**\n     *\n     * Pretty print the workers chain.\n     */\n    toString : function () {\n        var me = \"Worker \" + this.name;\n        if (this.previous) {\n            return this.previous + \" -> \" + me;\n        } else {\n            return me;\n        }\n    }\n};\n\nmodule.exports = GenericWorker;\n","'use strict';\n\nvar utils = require('../utils');\nvar ConvertWorker = require('./ConvertWorker');\nvar GenericWorker = require('./GenericWorker');\nvar base64 = require('../base64');\nvar support = require(\"../support\");\nvar external = require(\"../external\");\n\nvar NodejsStreamOutputAdapter = null;\nif (support.nodestream) {\n    try {\n        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');\n    } catch(e) {}\n}\n\n/**\n * Apply the final transformation of the data. If the user wants a Blob for\n * example, it's easier to work with an U8intArray and finally do the\n * ArrayBuffer/Blob conversion.\n * @param {String} type the name of the final type\n * @param {String|Uint8Array|Buffer} content the content to transform\n * @param {String} mimeType the mime type of the content, if applicable.\n * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.\n */\nfunction transformZipOutput(type, content, mimeType) {\n    switch(type) {\n        case \"blob\" :\n            return utils.newBlob(utils.transformTo(\"arraybuffer\", content), mimeType);\n        case \"base64\" :\n            return base64.encode(content);\n        default :\n            return utils.transformTo(type, content);\n    }\n}\n\n/**\n * Concatenate an array of data of the given type.\n * @param {String} type the type of the data in the given array.\n * @param {Array} dataArray the array containing the data chunks to concatenate\n * @return {String|Uint8Array|Buffer} the concatenated data\n * @throws Error if the asked type is unsupported\n */\nfunction concat (type, dataArray) {\n    var i, index = 0, res = null, totalLength = 0;\n    for(i = 0; i < dataArray.length; i++) {\n        totalLength += dataArray[i].length;\n    }\n    switch(type) {\n        case \"string\":\n            return dataArray.join(\"\");\n          case \"array\":\n            return Array.prototype.concat.apply([], dataArray);\n        case \"uint8array\":\n            res = new Uint8Array(totalLength);\n            for(i = 0; i < dataArray.length; i++) {\n                res.set(dataArray[i], index);\n                index += dataArray[i].length;\n            }\n            return res;\n        case \"nodebuffer\":\n            return Buffer.concat(dataArray);\n        default:\n            throw new Error(\"concat : unsupported type '\"  + type + \"'\");\n    }\n}\n\n/**\n * Listen a StreamHelper, accumulate its content and concatenate it into a\n * complete block.\n * @param {StreamHelper} helper the helper to use.\n * @param {Function} updateCallback a callback called on each update. Called\n * with one arg :\n * - the metadata linked to the update received.\n * @return Promise the promise for the accumulation.\n */\nfunction accumulate(helper, updateCallback) {\n    return new external.Promise(function (resolve, reject){\n        var dataArray = [];\n        var chunkType = helper._internalType,\n            resultType = helper._outputType,\n            mimeType = helper._mimeType;\n        helper\n        .on('data', function (data, meta) {\n            dataArray.push(data);\n            if(updateCallback) {\n                updateCallback(meta);\n            }\n        })\n        .on('error', function(err) {\n            dataArray = [];\n            reject(err);\n        })\n        .on('end', function (){\n            try {\n                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n                resolve(result);\n            } catch (e) {\n                reject(e);\n            }\n            dataArray = [];\n        })\n        .resume();\n    });\n}\n\n/**\n * An helper to easily use workers outside of JSZip.\n * @constructor\n * @param {Worker} worker the worker to wrap\n * @param {String} outputType the type of data expected by the use\n * @param {String} mimeType the mime type of the content, if applicable.\n */\nfunction StreamHelper(worker, outputType, mimeType) {\n    var internalType = outputType;\n    switch(outputType) {\n        case \"blob\":\n        case \"arraybuffer\":\n            internalType = \"uint8array\";\n        break;\n        case \"base64\":\n            internalType = \"string\";\n        break;\n    }\n\n    try {\n        // the type used internally\n        this._internalType = internalType;\n        // the type used to output results\n        this._outputType = outputType;\n        // the mime type\n        this._mimeType = mimeType;\n        utils.checkSupport(internalType);\n        this._worker = worker.pipe(new ConvertWorker(internalType));\n        // the last workers can be rewired without issues but we need to\n        // prevent any updates on previous workers.\n        worker.lock();\n    } catch(e) {\n        this._worker = new GenericWorker(\"error\");\n        this._worker.error(e);\n    }\n}\n\nStreamHelper.prototype = {\n    /**\n     * Listen a StreamHelper, accumulate its content and concatenate it into a\n     * complete block.\n     * @param {Function} updateCb the update callback.\n     * @return Promise the promise for the accumulation.\n     */\n    accumulate : function (updateCb) {\n        return accumulate(this, updateCb);\n    },\n    /**\n     * Add a listener on an event triggered on a stream.\n     * @param {String} evt the name of the event\n     * @param {Function} fn the listener\n     * @return {StreamHelper} the current helper.\n     */\n    on : function (evt, fn) {\n        var self = this;\n\n        if(evt === \"data\") {\n            this._worker.on(evt, function (chunk) {\n                fn.call(self, chunk.data, chunk.meta);\n            });\n        } else {\n            this._worker.on(evt, function () {\n                utils.delay(fn, arguments, self);\n            });\n        }\n        return this;\n    },\n    /**\n     * Resume the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */\n    resume : function () {\n        utils.delay(this._worker.resume, [], this._worker);\n        return this;\n    },\n    /**\n     * Pause the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */\n    pause : function () {\n        this._worker.pause();\n        return this;\n    },\n    /**\n     * Return a nodejs stream for this helper.\n     * @param {Function} updateCb the update callback.\n     * @return {NodejsStreamOutputAdapter} the nodejs stream.\n     */\n    toNodejsStream : function (updateCb) {\n        utils.checkSupport(\"nodestream\");\n        if (this._outputType !== \"nodebuffer\") {\n            // an object stream containing blob/arraybuffer/uint8array/string\n            // is strange and I don't know if it would be useful.\n            // I you find this comment and have a good usecase, please open a\n            // bug report !\n            throw new Error(this._outputType + \" is not supported by this method\");\n        }\n\n        return new NodejsStreamOutputAdapter(this, {\n            objectMode : this._outputType !== \"nodebuffer\"\n        }, updateCb);\n    }\n};\n\n\nmodule.exports = StreamHelper;\n","'use strict';\n\nexports.base64 = true;\nexports.array = true;\nexports.string = true;\nexports.arraybuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\nexports.nodebuffer = typeof Buffer !== \"undefined\";\n// contains true if JSZip can read/generate Uint8Array, false otherwise.\nexports.uint8array = typeof Uint8Array !== \"undefined\";\n\nif (typeof ArrayBuffer === \"undefined\") {\n    exports.blob = false;\n}\nelse {\n    var buffer = new ArrayBuffer(0);\n    try {\n        exports.blob = new Blob([buffer], {\n            type: \"application/zip\"\n        }).size === 0;\n    }\n    catch (e) {\n        try {\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            exports.blob = builder.getBlob('application/zip').size === 0;\n        }\n        catch (e) {\n            exports.blob = false;\n        }\n    }\n}\n\ntry {\n    exports.nodestream = !!require('readable-stream').Readable;\n} catch(e) {\n    exports.nodestream = false;\n}\n","'use strict';\n\nvar utils = require('./utils');\nvar support = require('./support');\nvar nodejsUtils = require('./nodejsUtils');\nvar GenericWorker = require('./stream/GenericWorker');\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That's all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodejsUtils.newBufferFrom(str, \"utf-8\");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n    return buf2string(buf);\n};\n\n/**\n * A worker to decode utf8 encoded binary chunks into string chunks.\n * @constructor\n */\nfunction Utf8DecodeWorker() {\n    GenericWorker.call(this, \"utf-8 decode\");\n    // the last bytes if a chunk didn't end with a complete codepoint.\n    this.leftOver = null;\n}\nutils.inherits(Utf8DecodeWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nUtf8DecodeWorker.prototype.processChunk = function (chunk) {\n\n    var data = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", chunk.data);\n\n    // 1st step, re-use what's left of the previous chunk\n    if (this.leftOver && this.leftOver.length) {\n        if(support.uint8array) {\n            var previousData = data;\n            data = new Uint8Array(previousData.length + this.leftOver.length);\n            data.set(this.leftOver, 0);\n            data.set(previousData, this.leftOver.length);\n        } else {\n            data = this.leftOver.concat(data);\n        }\n        this.leftOver = null;\n    }\n\n    var nextBoundary = utf8border(data);\n    var usableData = data;\n    if (nextBoundary !== data.length) {\n        if (support.uint8array) {\n            usableData = data.subarray(0, nextBoundary);\n            this.leftOver = data.subarray(nextBoundary, data.length);\n        } else {\n            usableData = data.slice(0, nextBoundary);\n            this.leftOver = data.slice(nextBoundary, data.length);\n        }\n    }\n\n    this.push({\n        data : exports.utf8decode(usableData),\n        meta : chunk.meta\n    });\n};\n\n/**\n * @see GenericWorker.flush\n */\nUtf8DecodeWorker.prototype.flush = function () {\n    if(this.leftOver && this.leftOver.length) {\n        this.push({\n            data : exports.utf8decode(this.leftOver),\n            meta : {}\n        });\n        this.leftOver = null;\n    }\n};\nexports.Utf8DecodeWorker = Utf8DecodeWorker;\n\n/**\n * A worker to endcode string chunks into utf8 encoded binary chunks.\n * @constructor\n */\nfunction Utf8EncodeWorker() {\n    GenericWorker.call(this, \"utf-8 encode\");\n}\nutils.inherits(Utf8EncodeWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nUtf8EncodeWorker.prototype.processChunk = function (chunk) {\n    this.push({\n        data : exports.utf8encode(chunk.data),\n        meta : chunk.meta\n    });\n};\nexports.Utf8EncodeWorker = Utf8EncodeWorker;\n","'use strict';\n\nvar support = require('./support');\nvar base64 = require('./base64');\nvar nodejsUtils = require('./nodejsUtils');\nvar setImmediate = require('set-immediate-shim');\nvar external = require(\"./external\");\n\n\n/**\n * Convert a string that pass as a \"binary string\": it should represent a byte\n * array but may have > 255 char codes. Be sure to take only the first byte\n * and returns the byte array.\n * @param {String} str the string to transform.\n * @return {Array|Uint8Array} the string in a binary format.\n */\nfunction string2binary(str) {\n    var result = null;\n    if (support.uint8array) {\n      result = new Uint8Array(str.length);\n    } else {\n      result = new Array(str.length);\n    }\n    return stringToArrayLike(str, result);\n}\n\n/**\n * Create a new blob with the given content and the given type.\n * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use\n * an Uint8Array because the stock browser of android 4 won't accept it (it\n * will be silently converted to a string, \"[object Uint8Array]\").\n *\n * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:\n * when a large amount of Array is used to create the Blob, the amount of\n * memory consumed is nearly 100 times the original data amount.\n *\n * @param {String} type the mime type of the blob.\n * @return {Blob} the created blob.\n */\nexports.newBlob = function(part, type) {\n    exports.checkSupport(\"blob\");\n\n    try {\n        // Blob constructor\n        return new Blob([part], {\n            type: type\n        });\n    }\n    catch (e) {\n\n        try {\n            // deprecated, browser only, old way\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(part);\n            return builder.getBlob(type);\n        }\n        catch (e) {\n\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n\n\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n    return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n    for (var i = 0; i < str.length; ++i) {\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n\n/**\n * An helper for the function arrayLikeToString.\n * This contains static information and functions that\n * can be optimized by the browser JIT compiler.\n */\nvar arrayToStringHelper = {\n    /**\n     * Transform an array of int into a string, chunk by chunk.\n     * See the performances notes on arrayLikeToString.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @param {String} type the type of the array.\n     * @param {Integer} chunk the chunk size.\n     * @return {String} the resulting string.\n     * @throws Error if the chunk is too big for the stack.\n     */\n    stringifyByChunk: function(array, type, chunk) {\n        var result = [], k = 0, len = array.length;\n        // shortcut\n        if (len <= chunk) {\n            return String.fromCharCode.apply(null, array);\n        }\n        while (k < len) {\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            }\n            else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        return result.join(\"\");\n    },\n    /**\n     * Call String.fromCharCode on every item in the array.\n     * This is the naive implementation, which generate A LOT of intermediate string.\n     * This should be used when everything else fail.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @return {String} the result.\n     */\n    stringifyByChar: function(array){\n        var resultStr = \"\";\n        for(var i = 0; i < array.length; i++) {\n            resultStr += String.fromCharCode(array[i]);\n        }\n        return resultStr;\n    },\n    applyCanBeUsed : {\n        /**\n         * true if the browser accepts to use String.fromCharCode on Uint8Array\n         */\n        uint8array : (function () {\n            try {\n                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        })(),\n        /**\n         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.\n         */\n        nodebuffer : (function () {\n            try {\n                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        })()\n    }\n};\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    // TODO : we now have workers that split the work. Do we still need that ?\n    var chunk = 65536,\n        type = exports.getTypeOf(array),\n        canUseApply = true;\n    if (type === \"uint8array\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;\n    } else if (type === \"nodebuffer\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;\n    }\n\n    if (canUseApply) {\n        while (chunk > 1) {\n            try {\n                return arrayToStringHelper.stringifyByChunk(array, type, chunk);\n            } catch (e) {\n                chunk = Math.floor(chunk / 2);\n            }\n        }\n    }\n\n    // no apply or chunk error : slow and painful algorithm\n    // default browser on android 4.*\n    return arrayToStringHelper.stringifyByChar(array);\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for (var i = 0; i < arrayFrom.length; i++) {\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));\n    }\n};\n\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return (new Uint8Array(input)).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(new Uint8Array(input));\n    }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this platform\");\n    }\n};\n\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function(str) {\n    var res = '',\n        code, i;\n    for (i = 0; i < (str || \"\").length; i++) {\n        code = str.charCodeAt(i);\n        res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n\n/**\n * Defer the call of a function.\n * @param {Function} callback the function to call asynchronously.\n * @param {Array} args the arguments to give to the callback.\n */\nexports.delay = function(callback, args, self) {\n    setImmediate(function () {\n        callback.apply(self || null, args || []);\n    });\n};\n\n/**\n * Extends a prototype with an other, without calling a constructor with\n * side effects. Inspired by nodejs' `utils.inherits`\n * @param {Function} ctor the constructor to augment\n * @param {Function} superCtor the parent constructor to use\n */\nexports.inherits = function (ctor, superCtor) {\n    var Obj = function() {};\n    Obj.prototype = superCtor.prototype;\n    ctor.prototype = new Obj();\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nexports.extend = function() {\n    var result = {}, i, attr;\n    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers\n        for (attr in arguments[i]) {\n            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Transform arbitrary content into a Promise.\n * @param {String} name a name for the content being processed.\n * @param {Object} inputData the content to process.\n * @param {Boolean} isBinary true if the content is not an unicode string\n * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.\n * @param {Boolean} isBase64 true if the string content is encoded with base64.\n * @return {Promise} a promise in a format usable by JSZip.\n */\nexports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n\n    // if inputData is already a promise, this flatten it.\n    var promise = external.Promise.resolve(inputData).then(function(data) {\n        \n        \n        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);\n\n        if (isBlob && typeof FileReader !== \"undefined\") {\n            return new external.Promise(function (resolve, reject) {\n                var reader = new FileReader();\n\n                reader.onload = function(e) {\n                    resolve(e.target.result);\n                };\n                reader.onerror = function(e) {\n                    reject(e.target.error);\n                };\n                reader.readAsArrayBuffer(data);\n            });\n        } else {\n            return data;\n        }\n    });\n\n    return promise.then(function(data) {\n        var dataType = exports.getTypeOf(data);\n\n        if (!dataType) {\n            return external.Promise.reject(\n                new Error(\"Can't read the data of '\" + name + \"'. Is it \" +\n                          \"in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\")\n            );\n        }\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = exports.transformTo(\"uint8array\", data);\n        } else if (dataType === \"string\") {\n            if (isBase64) {\n                data = base64.decode(data);\n            }\n            else if (isBinary) {\n                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask\n                if (isOptimizedBinaryString !== true) {\n                    // this is a string, not in a base64 format.\n                    // Be sure that this is a correct \"binary string\"\n                    data = string2binary(data);\n                }\n            }\n        }\n        return data;\n    });\n};\n","'use strict';\nvar readerFor = require('./reader/readerFor');\nvar utils = require('./utils');\nvar sig = require('./signature');\nvar ZipEntry = require('./zipEntry');\nvar utf8 = require('./utf8');\nvar support = require('./support');\n//  class ZipEntries {{{\n/**\n * All the entries in the zip file.\n * @constructor\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntries(loadOptions) {\n    this.files = [];\n    this.loadOptions = loadOptions;\n}\nZipEntries.prototype = {\n    /**\n     * Check that the reader is on the specified signature.\n     * @param {string} expectedSignature the expected signature.\n     * @throws {Error} if it is an other signature.\n     */\n    checkSignature: function(expectedSignature) {\n        if (!this.reader.readAndCheckSignature(expectedSignature)) {\n            this.reader.index -= 4;\n            var signature = this.reader.readString(4);\n            throw new Error(\"Corrupted zip or bug: unexpected signature \" + \"(\" + utils.pretty(signature) + \", expected \" + utils.pretty(expectedSignature) + \")\");\n        }\n    },\n    /**\n     * Check if the given signature is at the given index.\n     * @param {number} askedIndex the index to check.\n     * @param {string} expectedSignature the signature to expect.\n     * @return {boolean} true if the signature is here, false otherwise.\n     */\n    isSignature: function(askedIndex, expectedSignature) {\n        var currentIndex = this.reader.index;\n        this.reader.setIndex(askedIndex);\n        var signature = this.reader.readString(4);\n        var result = signature === expectedSignature;\n        this.reader.setIndex(currentIndex);\n        return result;\n    },\n    /**\n     * Read the end of the central directory.\n     */\n    readBlockEndOfCentral: function() {\n        this.diskNumber = this.reader.readInt(2);\n        this.diskWithCentralDirStart = this.reader.readInt(2);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n        this.centralDirRecords = this.reader.readInt(2);\n        this.centralDirSize = this.reader.readInt(4);\n        this.centralDirOffset = this.reader.readInt(4);\n\n        this.zipCommentLength = this.reader.readInt(2);\n        // warning : the encoding depends of the system locale\n        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.\n        // On a windows machine, this field is encoded with the localized windows code page.\n        var zipComment = this.reader.readData(this.zipCommentLength);\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        // To get consistent behavior with the generation part, we will assume that\n        // this is utf8 encoded unless specified otherwise.\n        var decodeContent = utils.transformTo(decodeParamType, zipComment);\n        this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n    },\n    /**\n     * Read the end of the Zip 64 central directory.\n     * Not merged with the method readEndOfCentral :\n     * The end of central can coexist with its Zip64 brother,\n     * I don't want to read the wrong number of bytes !\n     */\n    readBlockZip64EndOfCentral: function() {\n        this.zip64EndOfCentralSize = this.reader.readInt(8);\n        this.reader.skip(4);\n        // this.versionMadeBy = this.reader.readString(2);\n        // this.versionNeeded = this.reader.readInt(2);\n        this.diskNumber = this.reader.readInt(4);\n        this.diskWithCentralDirStart = this.reader.readInt(4);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n        this.centralDirRecords = this.reader.readInt(8);\n        this.centralDirSize = this.reader.readInt(8);\n        this.centralDirOffset = this.reader.readInt(8);\n\n        this.zip64ExtensibleData = {};\n        var extraDataSize = this.zip64EndOfCentralSize - 44,\n            index = 0,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n        while (index < extraDataSize) {\n            extraFieldId = this.reader.readInt(2);\n            extraFieldLength = this.reader.readInt(4);\n            extraFieldValue = this.reader.readData(extraFieldLength);\n            this.zip64ExtensibleData[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Read the end of the Zip 64 central directory locator.\n     */\n    readBlockZip64EndOfCentralLocator: function() {\n        this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n        this.disksCount = this.reader.readInt(4);\n        if (this.disksCount > 1) {\n            throw new Error(\"Multi-volumes zip are not supported\");\n        }\n    },\n    /**\n     * Read the local files, based on the offset read in the central part.\n     */\n    readLocalFiles: function() {\n        var i, file;\n        for (i = 0; i < this.files.length; i++) {\n            file = this.files[i];\n            this.reader.setIndex(file.localHeaderOffset);\n            this.checkSignature(sig.LOCAL_FILE_HEADER);\n            file.readLocalPart(this.reader);\n            file.handleUTF8();\n            file.processAttributes();\n        }\n    },\n    /**\n     * Read the central directory.\n     */\n    readCentralDir: function() {\n        var file;\n\n        this.reader.setIndex(this.centralDirOffset);\n        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {\n            file = new ZipEntry({\n                zip64: this.zip64\n            }, this.loadOptions);\n            file.readCentralPart(this.reader);\n            this.files.push(file);\n        }\n\n        if (this.centralDirRecords !== this.files.length) {\n            if (this.centralDirRecords !== 0 && this.files.length === 0) {\n                // We expected some records but couldn't find ANY.\n                // This is really suspicious, as if something went wrong.\n                throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n            } else {\n                // We found some records but not all.\n                // Something is wrong but we got something for the user: no error here.\n                // console.warn(\"expected\", this.centralDirRecords, \"records in central dir, got\", this.files.length);\n            }\n        }\n    },\n    /**\n     * Read the end of central directory.\n     */\n    readEndOfCentral: function() {\n        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n        if (offset < 0) {\n            // Check if the content is a truncated zip or complete garbage.\n            // A \"LOCAL_FILE_HEADER\" is not required at the beginning (auto\n            // extractible zip for example) but it can give a good hint.\n            // If an ajax request was used without responseType, we will also\n            // get unreadable data.\n            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n\n            if (isGarbage) {\n                throw new Error(\"Can't find end of central directory : is this a zip file ? \" +\n                                \"If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html\");\n            } else {\n                throw new Error(\"Corrupted zip: can't find end of central directory\");\n            }\n\n        }\n        this.reader.setIndex(offset);\n        var endOfCentralDirOffset = offset;\n        this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n        this.readBlockEndOfCentral();\n\n\n        /* extract from the zip spec :\n            4)  If one of the fields in the end of central directory\n                record is too small to hold required data, the field\n                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the\n                ZIP64 format record should be created.\n            5)  The end of central directory record and the\n                Zip64 end of central directory locator record must\n                reside on the same disk when splitting or spanning\n                an archive.\n         */\n        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n            this.zip64 = true;\n\n            /*\n            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from\n            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents\n            all numbers as 64-bit double precision IEEE 754 floating point numbers.\n            So, we have 53bits for integers and bitwise operations treat everything as 32bits.\n            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators\n            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5\n            */\n\n            // should look for a zip64 EOCD locator\n            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            if (offset < 0) {\n                throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n            }\n            this.reader.setIndex(offset);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            this.readBlockZip64EndOfCentralLocator();\n\n            // now the zip64 EOCD record\n            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n                // console.warn(\"ZIP64 end of central directory not where expected.\");\n                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n                    throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n                }\n            }\n            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n            this.readBlockZip64EndOfCentral();\n        }\n\n        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n        if (this.zip64) {\n            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator\n            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;\n        }\n\n        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n\n        if (extraBytes > 0) {\n            // console.warn(extraBytes, \"extra bytes at beginning or within zipfile\");\n            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n                // The offsets seem wrong, but we have something at the specified offset.\n                // So we keep it.\n            } else {\n                // the offset is wrong, update the \"zero\" of the reader\n                // this happens if data has been prepended (crx files for example)\n                this.reader.zero = extraBytes;\n            }\n        } else if (extraBytes < 0) {\n            throw new Error(\"Corrupted zip: missing \" + Math.abs(extraBytes) + \" bytes.\");\n        }\n    },\n    prepareReader: function(data) {\n        this.reader = readerFor(data);\n    },\n    /**\n     * Read a zip file and create ZipEntries.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.\n     */\n    load: function(data) {\n        this.prepareReader(data);\n        this.readEndOfCentral();\n        this.readCentralDir();\n        this.readLocalFiles();\n    }\n};\n// }}} end of ZipEntries\nmodule.exports = ZipEntries;\n","'use strict';\nvar readerFor = require('./reader/readerFor');\nvar utils = require('./utils');\nvar CompressedObject = require('./compressedObject');\nvar crc32fn = require('./crc32');\nvar utf8 = require('./utf8');\nvar compressions = require('./compressions');\nvar support = require('./support');\n\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nvar findCompression = function(compressionMethod) {\n    for (var method in compressions) {\n        if (!compressions.hasOwnProperty(method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntry(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n    /**\n     * say if the file is encrypted.\n     * @return {boolean} true if the file is encrypted, false otherwise.\n     */\n    isEncrypted: function() {\n        // bit 1 is set\n        return (this.bitFlag & 0x0001) === 0x0001;\n    },\n    /**\n     * say if the file has utf-8 filename/comment.\n     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n     */\n    useUTF8: function() {\n        // bit 11 is set\n        return (this.bitFlag & 0x0800) === 0x0800;\n    },\n    /**\n     * Read the local part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readLocalPart: function(reader) {\n        var compression, localExtraFieldsLength;\n\n        // we already know everything from the central dir !\n        // If the central dir data are false, we are doomed.\n        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n        // The less data we get here, the more reliable this should be.\n        // Let's skip the whole header and dash to the data !\n        reader.skip(22);\n        // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n        // Strangely, the filename here is OK.\n        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n        // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n        // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n        // the internet.\n        //\n        // I think I see the logic here : the central directory is used to display\n        // content and the local directory is used to extract the files. Mixing / and \\\n        // may be used to display \\ to windows users and use / when extracting the files.\n        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n        this.fileNameLength = reader.readInt(2);\n        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.\n        this.fileName = reader.readData(this.fileNameLength);\n        reader.skip(localExtraFieldsLength);\n\n        if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n            throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory \" + \"(compressedSize === -1 || uncompressedSize === -1)\");\n        }\n\n        compression = findCompression(this.compressionMethod);\n        if (compression === null) { // no compression found\n            throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + utils.transformTo(\"string\", this.fileName) + \")\");\n        }\n        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n    },\n\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readCentralPart: function(reader) {\n        this.versionMadeBy = reader.readInt(2);\n        reader.skip(2);\n        // this.versionNeeded = reader.readInt(2);\n        this.bitFlag = reader.readInt(2);\n        this.compressionMethod = reader.readString(2);\n        this.date = reader.readDate();\n        this.crc32 = reader.readInt(4);\n        this.compressedSize = reader.readInt(4);\n        this.uncompressedSize = reader.readInt(4);\n        var fileNameLength = reader.readInt(2);\n        this.extraFieldsLength = reader.readInt(2);\n        this.fileCommentLength = reader.readInt(2);\n        this.diskNumberStart = reader.readInt(2);\n        this.internalFileAttributes = reader.readInt(2);\n        this.externalFileAttributes = reader.readInt(4);\n        this.localHeaderOffset = reader.readInt(4);\n\n        if (this.isEncrypted()) {\n            throw new Error(\"Encrypted zip are not supported\");\n        }\n\n        // will be read in the local part, see the comments there\n        reader.skip(fileNameLength);\n        this.readExtraFields(reader);\n        this.parseZIP64ExtraField(reader);\n        this.fileComment = reader.readData(this.fileCommentLength);\n    },\n\n    /**\n     * Parse the external file attributes and get the unix/dos permissions.\n     */\n    processAttributes: function () {\n        this.unixPermissions = null;\n        this.dosPermissions = null;\n        var madeBy = this.versionMadeBy >> 8;\n\n        // Check if we have the DOS directory flag set.\n        // We look for it in the DOS and UNIX permissions\n        // but some unknown platform could set it as a compatibility flag.\n        this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n\n        if(madeBy === MADE_BY_DOS) {\n            // first 6 bits (0 to 5)\n            this.dosPermissions = this.externalFileAttributes & 0x3F;\n        }\n\n        if(madeBy === MADE_BY_UNIX) {\n            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;\n            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n        }\n\n        // fail safe : if the name ends with a / it probably means a folder\n        if (!this.dir && this.fileNameStr.slice(-1) === '/') {\n            this.dir = true;\n        }\n    },\n\n    /**\n     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n     * @param {DataReader} reader the reader to use.\n     */\n    parseZIP64ExtraField: function(reader) {\n\n        if (!this.extraFields[0x0001]) {\n            return;\n        }\n\n        // should be something, preparing the extra reader\n        var extraReader = readerFor(this.extraFields[0x0001].value);\n\n        // I really hope that these 64bits integer can fit in 32 bits integer, because js\n        // won't let us have more.\n        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n            this.uncompressedSize = extraReader.readInt(8);\n        }\n        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n            this.compressedSize = extraReader.readInt(8);\n        }\n        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n            this.localHeaderOffset = extraReader.readInt(8);\n        }\n        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n            this.diskNumberStart = extraReader.readInt(4);\n        }\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readExtraFields: function(reader) {\n        var end = reader.index + this.extraFieldsLength,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n\n        if (!this.extraFields) {\n            this.extraFields = {};\n        }\n\n        while (reader.index + 4 < end) {\n            extraFieldId = reader.readInt(2);\n            extraFieldLength = reader.readInt(2);\n            extraFieldValue = reader.readData(extraFieldLength);\n\n            this.extraFields[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n\n        reader.setIndex(end);\n    },\n    /**\n     * Apply an UTF8 transformation if needed.\n     */\n    handleUTF8: function() {\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        if (this.useUTF8()) {\n            this.fileNameStr = utf8.utf8decode(this.fileName);\n            this.fileCommentStr = utf8.utf8decode(this.fileComment);\n        } else {\n            var upath = this.findExtraFieldUnicodePath();\n            if (upath !== null) {\n                this.fileNameStr = upath;\n            } else {\n                // ASCII text or unsupported code page\n                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);\n                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n            }\n\n            var ucomment = this.findExtraFieldUnicodeComment();\n            if (ucomment !== null) {\n                this.fileCommentStr = ucomment;\n            } else {\n                // ASCII text or unsupported code page\n                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);\n                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n            }\n        }\n    },\n\n    /**\n     * Find the unicode path declared in the extra field, if any.\n     * @return {String} the unicode path, null otherwise.\n     */\n    findExtraFieldUnicodePath: function() {\n        var upathField = this.extraFields[0x7075];\n        if (upathField) {\n            var extraReader = readerFor(upathField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the filename changed, this field is out of date.\n            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return utf8.utf8decode(extraReader.readData(upathField.length - 5));\n        }\n        return null;\n    },\n\n    /**\n     * Find the unicode comment declared in the extra field, if any.\n     * @return {String} the unicode comment, null otherwise.\n     */\n    findExtraFieldUnicodeComment: function() {\n        var ucommentField = this.extraFields[0x6375];\n        if (ucommentField) {\n            var extraReader = readerFor(ucommentField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the comment changed, this field is out of date.\n            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));\n        }\n        return null;\n    }\n};\nmodule.exports = ZipEntry;\n","'use strict';\n\nvar StreamHelper = require('./stream/StreamHelper');\nvar DataWorker = require('./stream/DataWorker');\nvar utf8 = require('./utf8');\nvar CompressedObject = require('./compressedObject');\nvar GenericWorker = require('./stream/GenericWorker');\n\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nvar ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n\n    this._data = data;\n    this._dataBinary = options.binary;\n    // keep only the compression\n    this.options = {\n        compression : options.compression,\n        compressionOptions : options.compressionOptions\n    };\n};\n\nZipObject.prototype = {\n    /**\n     * Create an internal stream for the content of this object.\n     * @param {String} type the type of each chunk.\n     * @return StreamHelper the stream.\n     */\n    internalStream: function (type) {\n        var result = null, outputType = \"string\";\n        try {\n            if (!type) {\n                throw new Error(\"No output type specified.\");\n            }\n            outputType = type.toLowerCase();\n            var askUnicodeString = outputType === \"string\" || outputType === \"text\";\n            if (outputType === \"binarystring\" || outputType === \"text\") {\n                outputType = \"string\";\n            }\n            result = this._decompressWorker();\n\n            var isUnicodeString = !this._dataBinary;\n\n            if (isUnicodeString && !askUnicodeString) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            if (!isUnicodeString && askUnicodeString) {\n                result = result.pipe(new utf8.Utf8DecodeWorker());\n            }\n        } catch (e) {\n            result = new GenericWorker(\"error\");\n            result.error(e);\n        }\n\n        return new StreamHelper(result, outputType, \"\");\n    },\n\n    /**\n     * Prepare the content in the asked type.\n     * @param {String} type the type of the result.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Promise the promise of the result.\n     */\n    async: function (type, onUpdate) {\n        return this.internalStream(type).accumulate(onUpdate);\n    },\n\n    /**\n     * Prepare the content as a nodejs stream.\n     * @param {String} type the type of each chunk.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Stream the stream.\n     */\n    nodeStream: function (type, onUpdate) {\n        return this.internalStream(type || \"nodebuffer\").toNodejsStream(onUpdate);\n    },\n\n    /**\n     * Return a worker for the compressed content.\n     * @private\n     * @param {Object} compression the compression object to use.\n     * @param {Object} compressionOptions the options to use when compressing.\n     * @return Worker the worker.\n     */\n    _compressWorker: function (compression, compressionOptions) {\n        if (\n            this._data instanceof CompressedObject &&\n            this._data.compression.magic === compression.magic\n        ) {\n            return this._data.getCompressedWorker();\n        } else {\n            var result = this._decompressWorker();\n            if(!this._dataBinary) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n        }\n    },\n    /**\n     * Return a worker for the decompressed content.\n     * @private\n     * @return Worker the worker.\n     */\n    _decompressWorker : function () {\n        if (this._data instanceof CompressedObject) {\n            return this._data.getContentWorker();\n        } else if (this._data instanceof GenericWorker) {\n            return this._data;\n        } else {\n            return new DataWorker(this._data);\n        }\n    }\n};\n\nvar removedMethods = [\"asText\", \"asBinary\", \"asNodeBuffer\", \"asUint8Array\", \"asArrayBuffer\"];\nvar removedFn = function () {\n    throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n};\n\nfor(var i = 0; i < removedMethods.length; i++) {\n    ZipObject.prototype[removedMethods[i]] = removedFn;\n}\nmodule.exports = ZipObject;\n","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"finally\"] = function (callback) {\n  if (typeof callback !== 'function') {\n    return this;\n  }\n  var p = this.constructor;\n  return this.then(resolve, reject);\n\n  function resolve(value) {\n    function yes () {\n      return value;\n    }\n    return p.resolve(callback()).then(yes);\n  }\n  function reject(reason) {\n    function no () {\n      throw reason;\n    }\n    return p.resolve(callback()).then(no);\n  }\n};\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n","// Top level file is just a mixin of submodules & constants\n'use strict';\n\nvar assign    = require('./lib/utils/common').assign;\n\nvar deflate   = require('./lib/deflate');\nvar inflate   = require('./lib/inflate');\nvar constants = require('./lib/zlib/constants');\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n","'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n","'use strict';\n\n\nvar zlib_inflate = require('./zlib/inflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar c            = require('./zlib/constants');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\nvar GZheader     = require('./zlib/gzheader');\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n","'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n","// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n","'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n","'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = require('../utils/common');\nvar adler32       = require('./adler32');\nvar crc32         = require('./crc32');\nvar inflate_fast  = require('./inffast');\nvar inflate_table = require('./inftrees');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = require('../utils/common');\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n","'use strict';\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = require('./lib/_stream_duplex.js');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","module.exports = require('events').EventEmitter;\n","module.exports = require('./readable').PassThrough\n","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","module.exports = require('./readable').Transform\n","module.exports = require('./lib/_stream_writable.js');\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","'use strict';\nmodule.exports = typeof setImmediate === 'function' ? setImmediate :\n\tfunction setImmediate() {\n\t\tvar args = [].slice.apply(arguments);\n\t\targs.splice(1, 0, 0);\n\t\tsetTimeout.apply(null, args);\n\t};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","import JSZip from \"jszip\";\r\nimport {IuploadfileList} from \"./ICommon\";\r\nimport {getBinaryContent} from \"./common/method\"\r\n\r\n\r\nexport class HandleZip{\r\n    uploadFile:File; \r\n    workBook:JSZip; \r\n    \r\n    constructor(file?:File){\r\n        // Support nodejs fs to read files\r\n        // if(file instanceof File){\r\n            this.uploadFile = file;\r\n        // }\r\n    }\r\n\r\n    unzipFile(successFunc:(file:IuploadfileList)=>void, errorFunc:(err:Error)=>void):void { \r\n        // var new_zip:JSZip = new JSZip();\r\n        JSZip.loadAsync(this.uploadFile)                                   // 1) read the Blob\r\n        .then(function(zip:any) {\r\n            let fileList:IuploadfileList = <IuploadfileList>{}, lastIndex:number = Object.keys(zip.files).length, index:number=0;\r\n            zip.forEach(function (relativePath:any, zipEntry:any) {  // 2) print entries\r\n                let fileName = zipEntry.name;\r\n                let fileNameArr = fileName.split(\".\");\r\n                let suffix = fileNameArr[fileNameArr.length-1].toLowerCase();\r\n                let fileType = \"string\";\r\n                if(suffix in {\"png\":1, \"jpeg\":1, \"jpg\":1, \"gif\":1,\"bmp\":1,\"tif\":1,\"webp\":1,}){\r\n                    fileType = \"base64\";\r\n                }\r\n                else if(suffix==\"emf\"){\r\n                    fileType = \"arraybuffer\";\r\n                }\r\n                zipEntry.async(fileType).then(function (data:string) {\r\n                    if(fileType==\"base64\"){\r\n                        data = \"data:image/\"+ suffix +\";base64,\" + data;\r\n                    }\r\n                    fileList[zipEntry.name] = data;\r\n                    // console.log(lastIndex, index);\r\n                    if(lastIndex==index+1){\r\n                        successFunc(fileList);\r\n                    }\r\n                    index++;\r\n                });\r\n            });\r\n            \r\n        }, function (e:Error) {\r\n            errorFunc(e);\r\n        });\r\n    }\r\n\r\n    unzipFileByUrl(url:string,successFunc:(file:IuploadfileList)=>void, errorFunc:(err:Error)=>void):void { \r\n        var new_zip:JSZip = new JSZip();\r\n        getBinaryContent(url, function(err:any, data:any) {\r\n            if(err) {\r\n                throw err; // or handle err\r\n            }\r\n        \r\n            JSZip.loadAsync(data).then(function(zip:any) {\r\n                let fileList:IuploadfileList = <IuploadfileList>{}, lastIndex:number = Object.keys(zip.files).length, index:number=0;\r\n                zip.forEach(function (relativePath:any, zipEntry:any) {  // 2) print entries\r\n                    let fileName = zipEntry.name;\r\n                    let fileNameArr = fileName.split(\".\");\r\n                    let suffix = fileNameArr[fileNameArr.length-1].toLowerCase();\r\n                    let fileType = \"string\";\r\n                    if(suffix in {\"png\":1, \"jpeg\":1, \"jpg\":1, \"gif\":1,\"bmp\":1,\"tif\":1,\"webp\":1,}){\r\n                        fileType = \"base64\";\r\n                    }\r\n                    else if(suffix==\"emf\"){\r\n                        fileType = \"arraybuffer\";\r\n                    }\r\n                    zipEntry.async(fileType).then(function (data:any) {\r\n                        if(fileType==\"base64\"){\r\n                            data = \"data:image/\"+ suffix +\";base64,\" + data;\r\n                        }\r\n                        fileList[zipEntry.name] = data;\r\n                        // console.log(lastIndex, index);\r\n                        if(lastIndex==index+1){\r\n                            successFunc(fileList);\r\n                        }\r\n                        index++;\r\n                    });\r\n                });\r\n                \r\n            }, function (e:Error) {\r\n                errorFunc(e);\r\n            });\r\n        });\r\n        \r\n    }\r\n\r\n    newZipFile():void { \r\n        var zip = new JSZip();\r\n        this.workBook =  zip;\r\n    }\r\n\r\n    //title:\"nested/hello.txt\", content:\"Hello Worldasdfasfasdfasfasfasfasfasdfas\"\r\n    addToZipFile(title:string,content:string):void { \r\n        if(this.workBook==null){\r\n            var zip = new JSZip();\r\n            this.workBook =  zip;\r\n        }\r\n        this.workBook.file(title, content);\r\n    }\r\n}","import { ILuckyFile, ILuckyFileInfo,IluckySheet,IluckySheetCelldata,IluckySheetConfig,IluckySheetCelldataValue,IluckySheetCelldataValueMerge,ILuckySheetCellFormat,IluckySheetConfigMerges,IluckySheetConfigMerge,IMapluckySheetborderInfoCellForImp,IluckySheetborderInfoCellValue,IluckySheetborderInfoCellValueStyle,IluckySheetborderInfoCellForImp,IluckySheetRowAndColumnLen,IluckySheetRowAndColumnHidden,IluckySheetSelection,IluckysheetFrozen,IluckySheetChart,IluckySheetPivotTable,IluckysheetConditionFormat,IluckysheetCalcChain,ILuckyInlineString,IluckyImage,IluckyImageBorder,IluckyImageCrop,IluckyImageDefault,IluckyImages, IluckysheetHyperlink} from \"./ILuck\";\r\n\r\n\r\n\r\nexport class LuckyFileBase implements ILuckyFile {\r\n    info:ILuckyFileInfo\r\n    sheets:IluckySheet[]\r\n}\r\n\r\nexport class LuckySheetBase implements IluckySheet{\r\n    name:string\r\n    color:string\r\n    config:IluckySheetConfig\r\n    index:string\r\n    status:string\r\n    order:string\r\n    row:number\r\n    column:number\r\n    luckysheet_select_save:IluckySheetSelection[]\r\n    scrollLeft:number\r\n    scrollTop:number\r\n    zoomRatio:number\r\n    showGridLines:string\r\n    defaultColWidth:number\r\n    defaultRowHeight:number\r\n\r\n    celldata:IluckySheetCelldata[]\r\n    chart:IluckySheetChart[]\r\n\r\n    isPivotTable:boolean\r\n    pivotTable:IluckySheetPivotTable\r\n\r\n    luckysheet_conditionformat_save:IluckysheetConditionFormat[]\r\n    freezen:IluckysheetFrozen\r\n\r\n    calcChain:IluckysheetCalcChain[]\r\n\r\n    images:IluckyImages\r\n    \r\n    hyperlink: IluckysheetHyperlink\r\n    hide: number;\r\n    \r\n}\r\n\r\nexport class LuckyFileInfo implements ILuckyFileInfo{\r\n    name:string\r\n    creator:string\r\n    lastmodifiedby:string\r\n    createdTime:string\r\n    modifiedTime:string\r\n    company:string\r\n    appversion:string\r\n}\r\n\r\nexport class LuckySheetCelldataBase implements IluckySheetCelldata{\r\n    r:number\r\n    c:number\r\n    v:IluckySheetCelldataValue | string | null\r\n}\r\n\r\nexport class LuckySheetCelldataValue implements IluckySheetCelldataValue{\r\n    ct: LuckySheetCellFormat | undefined //celltype,Cell value format: text, time, etc. numfmts\r\n    bg: string | undefined//background,#fff000,\tfill\r\n    ff: string | undefined//fontfamily, fonts\r\n    fc: string | undefined//fontcolor fonts\r\n    bl: number | undefined//Bold, fonts\r\n    it: number | undefined//italic, fonts\r\n    fs: number | undefined//font size, fonts\r\n    cl: number | undefined//strike, 0 Regular, 1 strikes, fonts\r\n    un: number | undefined//underline, 0 Regular, 1 underlines, fonts\r\n    vt: number | undefined//Vertical alignment, 0 middle, 1 up, 2 down, alignment\r\n    ht: number | undefined//Horizontal alignment,0 center, 1 left, 2 right, alignment\r\n    mc: IluckySheetCelldataValueMerge | undefined //Merge Cells, mergeCells\r\n    tr: number | undefined //Text rotation,0: 03 Vertical text alignment\r\n    tb: number | undefined //Text wrap,0 truncation, 1 overflow, 2 word wrap, alignment\r\n    v: string | undefined //Original value, v\r\n    m: string | undefined //Display value, v\r\n    f: string | undefined //formula, f\r\n    rt:number | undefined //text rotation angle 0-180 alignment\r\n    qp:number | undefined //quotePrefix, show number as string\r\n}\r\n\r\n\r\nexport class LuckySheetCellFormat implements ILuckySheetCellFormat {\r\n    fa:string\r\n    t:string\r\n    s:LuckyInlineString[] | undefined\r\n}\r\n\r\nexport class LuckyInlineString implements ILuckyInlineString {\r\n    ff:string | undefined //font family\r\n    fc:string | undefined//font color\r\n    fs:number | undefined//font size\r\n    cl:number | undefined//strike\r\n    un:number | undefined//underline\r\n    bl:number | undefined//blod\r\n    it:number | undefined//italic\r\n    va:number | undefined//1sub and 2super and 0none\r\n    v:string | undefined\r\n}\r\n\r\nexport class LuckyConfig implements IluckySheetConfig{\r\n    merge:IluckySheetConfigMerges\r\n    borderInfo:IluckySheetborderInfoCellForImp[]\r\n    // _borderInfo: IMapluckySheetborderInfoCellForImp\r\n    rowlen:IluckySheetRowAndColumnLen\r\n    columnlen:IluckySheetRowAndColumnLen\r\n    rowhidden:IluckySheetRowAndColumnHidden\r\n    colhidden:IluckySheetRowAndColumnHidden\r\n\r\n    customHeight:IluckySheetRowAndColumnHidden\r\n    customWidth:IluckySheetRowAndColumnHidden\r\n}\r\n\r\nexport class LuckySheetborderInfoCellForImp implements IluckySheetborderInfoCellForImp{\r\n    rangeType:string\r\n    // cells:string[]\r\n    value:IluckySheetborderInfoCellValue\r\n}\r\n\r\nexport class LuckySheetborderInfoCellValue implements IluckySheetborderInfoCellValue{\r\n    row_index: number\r\n    col_index: number\r\n    l: IluckySheetborderInfoCellValueStyle\r\n    r: IluckySheetborderInfoCellValueStyle\r\n    t: IluckySheetborderInfoCellValueStyle\r\n    b: IluckySheetborderInfoCellValueStyle\r\n}\r\n\r\nexport class LuckySheetborderInfoCellValueStyle implements IluckySheetborderInfoCellValueStyle{\r\n    \"style\": number\r\n    \"color\": string\r\n}\r\n\r\nexport class LuckySheetConfigMerge implements IluckySheetConfigMerge{\r\n    r: number\r\n    c: number\r\n    rs: number\r\n    cs: number\r\n}\r\n\r\nexport class LuckysheetCalcChain implements IluckysheetCalcChain{\r\n    r:number\r\n    c:number\r\n    index:string | undefined\r\n}\r\n\r\n\r\nexport class LuckyImageBase implements IluckyImage{\r\n    border: IluckyImageBorder\r\n    crop: IluckyImageCrop\r\n    default: IluckyImageDefault\r\n\r\n    fixedLeft: number\r\n    fixedTop: number\r\n    isFixedPos: Boolean\r\n    originHeight: number\r\n    originWidth: number\r\n    src: string\r\n    type: string\r\n}","import { IluckySheetborderInfoCellForImp,IluckySheetCelldataValue,IluckySheetCelldataValueMerge,ILuckySheetCellFormat } from \"./ILuck\";\r\nimport { ReadXml, Element, IStyleCollections,getColor,getlineStringAttr } from \"./ReadXml\";\r\nimport {getXmlAttibute, getColumnWidthPixel, getRowHeightPixel,getcellrange, escapeCharacter, isChinese, isJapanese, isKoera,isContainMultiType} from \"../common/method\";\r\nimport { ST_CellType, indexedColors, OEM_CHARSET,borderTypes,fontFamilys } from \"../common/constant\"\r\nimport { IattributeList, stringToNum } from \"../ICommon\";\r\nimport { LuckySheetborderInfoCellValueStyle,LuckySheetborderInfoCellForImp,LuckySheetborderInfoCellValue,LuckySheetCelldataBase,LuckySheetCelldataValue,LuckySheetCellFormat,LuckyInlineString } from \"./LuckyBase\";\r\n\r\nexport class LuckySheetCelldata extends LuckySheetCelldataBase{\r\n    _borderObject:IluckySheetborderInfoCellForImp\r\n    _fomulaRef:string\r\n    _formulaSi:string\r\n    _formulaType:string\r\n\r\n    private sheetFile:string\r\n    private readXml:ReadXml\r\n    private cell:Element\r\n    private styles:IStyleCollections\r\n    private sharedStrings:Element[]\r\n    private mergeCells:Element[]\r\n\r\n    constructor(cell:Element, styles:IStyleCollections, sharedStrings:Element[], mergeCells:Element[], sheetFile:string, ReadXml:ReadXml){\r\n        //Private\r\n        super();\r\n        this.cell = cell;\r\n        this.sheetFile = sheetFile;\r\n        this.styles = styles;\r\n        this.sharedStrings = sharedStrings;\r\n        this.readXml = ReadXml;\r\n        this.mergeCells = mergeCells;\r\n\r\n        let attrList = cell.attributeList;\r\n        let r = attrList.r, s = attrList.s, t = attrList.t;\r\n        let range = getcellrange(r);\r\n\r\n        this.r = range.row[0];\r\n        this.c = range.column[0];\r\n        this.v = this.generateValue(s, t);\r\n\r\n    }\r\n\r\n    /**\r\n    * @param s Style index ,start 1\r\n    * @param t Cell type, Optional value is ST_CellType, it's found at constat.ts\r\n    */\r\n    private generateValue(s:string, t:string){\r\n        let v = this.cell.getInnerElements(\"v\");\r\n        let f = this.cell.getInnerElements(\"f\");\r\n\r\n        if(v==null){\r\n            v = this.cell.getInnerElements(\"t\");\r\n        }\r\n\r\n        let cellXfs = this.styles[\"cellXfs\"] as Element[];\r\n        let cellStyleXfs = this.styles[\"cellStyleXfs\"] as Element[];\r\n        let cellStyles = this.styles[\"cellStyles\"] as Element[];\r\n        let fonts = this.styles[\"fonts\"] as Element[];\r\n        let fills = this.styles[\"fills\"] as Element[];\r\n        let borders = this.styles[\"borders\"] as Element[];\r\n        let numfmts = this.styles[\"numfmts\"] as IattributeList;\r\n        let clrScheme = this.styles[\"clrScheme\"] as Element[];\r\n\r\n        let sharedStrings = this.sharedStrings;\r\n        let cellValue = new LuckySheetCelldataValue();\r\n\r\n        if(f!=null){\r\n            let formula = f[0], attrList = formula.attributeList;\r\n            let t = attrList.t, ref = attrList.ref, si = attrList.si;\r\n            let formulaValue =f[0].value;\r\n            if(t==\"shared\"){\r\n                this._fomulaRef = ref;\r\n                this._formulaType = t;\r\n                this._formulaSi = si;\r\n            }\r\n            // console.log(ref, t, si);\r\n            if(ref!=null || (formulaValue!=null && formulaValue.length>0)){\r\n                formulaValue = escapeCharacter(formulaValue);\r\n                cellValue.f = \"=\" + formulaValue;\r\n            }\r\n\r\n        }\r\n\r\n        let familyFont = null;\r\n        let quotePrefix;\r\n        if(s!=null){\r\n            let sNum = parseInt(s);\r\n            let cellXf = cellXfs[sNum];\r\n            let xfId = cellXf.attributeList.xfId;\r\n\r\n            let numFmtId,fontId,fillId,borderId;\r\n            let horizontal,vertical, wrapText, textRotation, shrinkToFit, indent,applyProtection;\r\n\r\n            if(xfId!=null){\r\n                let cellStyleXf = cellStyleXfs[parseInt(xfId)];\r\n                let attrList = cellStyleXf.attributeList;\r\n\r\n                let applyNumberFormat = attrList.applyNumberFormat;\r\n                let applyFont = attrList.applyFont;\r\n                let applyFill = attrList.applyFill;\r\n                let applyBorder = attrList.applyBorder;\r\n                let applyAlignment = attrList.applyAlignment;\r\n                // let applyProtection = attrList.applyProtection;\r\n\r\n                applyProtection = attrList.applyProtection;\r\n                quotePrefix = attrList.quotePrefix;\r\n\r\n                if(applyNumberFormat!=\"0\" && attrList.numFmtId!=null){\r\n                    // if(attrList.numFmtId!=\"0\"){\r\n                        numFmtId = attrList.numFmtId;\r\n                    // }\r\n                }\r\n                if(applyFont!=\"0\" && attrList.fontId!=null){\r\n                    fontId = attrList.fontId;\r\n                }\r\n                if(applyFill!=\"0\" && attrList.fillId!=null){\r\n                    fillId = attrList.fillId;\r\n                }\r\n                if(applyBorder!=\"0\" && attrList.borderId!=null){\r\n                    borderId = attrList.borderId;\r\n                }\r\n                if(applyAlignment!=null && applyAlignment!=\"0\"){\r\n                    let alignment = cellStyleXf.getInnerElements(\"alignment\");\r\n                    if(alignment!=null){\r\n                        let attrList = alignment[0].attributeList;\r\n                        if(attrList.horizontal!=null){\r\n                            horizontal = attrList.horizontal;\r\n                        }\r\n                        if(attrList.vertical!=null){\r\n                            vertical = attrList.vertical;\r\n                        }\r\n                        if(attrList.wrapText!=null){\r\n                            wrapText = attrList.wrapText;\r\n                        }\r\n                        if(attrList.textRotation!=null){\r\n                            textRotation = attrList.textRotation;\r\n                        }\r\n                        if(attrList.shrinkToFit!=null){\r\n                            shrinkToFit = attrList.shrinkToFit;\r\n                        }\r\n                        if(attrList.indent!=null){\r\n                            indent = attrList.indent;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            let applyNumberFormat = cellXf.attributeList.applyNumberFormat;\r\n            let applyFont = cellXf.attributeList.applyFont;\r\n            let applyFill = cellXf.attributeList.applyFill;\r\n            let applyBorder = cellXf.attributeList.applyBorder;\r\n            let applyAlignment = cellXf.attributeList.applyAlignment;\r\n\r\n            if(cellXf.attributeList.applyProtection!=null){\r\n                applyProtection = cellXf.attributeList.applyProtection;\r\n            }\r\n\r\n            if(cellXf.attributeList.quotePrefix!=null){\r\n                quotePrefix = cellXf.attributeList.quotePrefix;\r\n            }\r\n\r\n            if(applyNumberFormat!=\"0\" && cellXf.attributeList.numFmtId!=null){\r\n                numFmtId = cellXf.attributeList.numFmtId;\r\n            }\r\n            if(applyFont!=\"0\"){\r\n                fontId = cellXf.attributeList.fontId;\r\n            }\r\n            if(applyFill!=\"0\"){\r\n                fillId = cellXf.attributeList.fillId;\r\n            }\r\n            if(applyBorder!=\"0\"){\r\n                borderId =cellXf.attributeList.borderId;\r\n            }\r\n            if(applyAlignment!=\"0\"){\r\n                let alignment = cellXf.getInnerElements(\"alignment\");\r\n                if(alignment!=null && alignment.length>0){\r\n                    let attrList = alignment[0].attributeList;\r\n                    if(attrList.horizontal!=null){\r\n                        horizontal = attrList.horizontal;\r\n                    }\r\n                    if(attrList.vertical!=null){\r\n                        vertical = attrList.vertical;\r\n                    }\r\n                    if(attrList.wrapText!=null){\r\n                        wrapText = attrList.wrapText;\r\n                    }\r\n                    if(attrList.textRotation!=null){\r\n                        textRotation = attrList.textRotation;\r\n                    }\r\n                    if(attrList.shrinkToFit!=null){\r\n                        shrinkToFit = attrList.shrinkToFit;\r\n                    }\r\n                    if(attrList.indent!=null){\r\n                        indent = attrList.indent;\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n\r\n            if(numFmtId!=undefined){\r\n                let numf = numfmts[parseInt(numFmtId)];\r\n                let cellFormat = new LuckySheetCellFormat();\r\n                cellFormat.fa = escapeCharacter(numf);\r\n                // console.log(numf, numFmtId, this.v);\r\n                cellFormat.t = t || 'd';\r\n                cellValue.ct = cellFormat;\r\n            }\r\n\r\n            if(fillId!=undefined){\r\n                let fillIdNum = parseInt(fillId);\r\n                let fill  = fills[fillIdNum];\r\n                // console.log(cellValue.v);\r\n                let bg = this.getBackgroundByFill(fill, clrScheme);\r\n                if(bg!=null){\r\n                    cellValue.bg = bg;\r\n                }\r\n            }\r\n\r\n\r\n            if(fontId!=undefined){\r\n                let fontIdNum = parseInt(fontId);\r\n                let font = fonts[fontIdNum];\r\n                if(font!=null){\r\n                    let sz = font.getInnerElements(\"sz\");//font size\r\n                    let colors = font.getInnerElements(\"color\");//font color\r\n                    let family = font.getInnerElements(\"name\");//font family\r\n                    let familyOverrides = font.getInnerElements(\"family\");//font family will be overrided by name\r\n                    let charset = font.getInnerElements(\"charset\");//font charset\r\n                    let bolds = font.getInnerElements(\"b\");//font bold\r\n                    let italics = font.getInnerElements(\"i\");//font italic\r\n                    let strikes = font.getInnerElements(\"strike\");//font italic\r\n                    let underlines = font.getInnerElements(\"u\");//font italic\r\n\r\n                    if(sz!=null && sz.length>0){\r\n                        let fs = sz[0].attributeList.val;\r\n                        if(fs!=null){\r\n                            cellValue.fs = parseInt(fs);\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(colors!=null && colors.length>0){\r\n                        let color = colors[0];\r\n                        let fc = getColor(color, this.styles, \"t\");\r\n                        if(fc!=null){\r\n                            cellValue.fc = fc;\r\n                        }\r\n                    }\r\n\r\n\r\n                    if(familyOverrides!=null && familyOverrides.length>0){\r\n                        let val = familyOverrides[0].attributeList.val;\r\n                        if(val!=null){\r\n                            familyFont = fontFamilys[val];\r\n                        }\r\n                    }\r\n\r\n                    if(family!=null && family.length>0){\r\n                        let val = family[0].attributeList.val;\r\n                        if(val!=null){\r\n                            cellValue.ff = val;\r\n                        }\r\n                    }\r\n\r\n\r\n                    if(bolds!=null && bolds.length>0){\r\n                        let bold = bolds[0].attributeList.val;\r\n                        if(bold==\"0\"){\r\n                            cellValue.bl =  0;\r\n                        }\r\n                        else{\r\n                            cellValue.bl =  1;\r\n                        }\r\n                    }\r\n\r\n                    if(italics!=null && italics.length>0){\r\n                        let italic = italics[0].attributeList.val;\r\n                        if(italic==\"0\"){\r\n                            cellValue.it =  0;\r\n                        }\r\n                        else{\r\n                            cellValue.it =  1;\r\n                        }\r\n                    }\r\n\r\n                    if(strikes!=null && strikes.length>0){\r\n                        let strike = strikes[0].attributeList.val;\r\n                        if(strike==\"0\"){\r\n                            cellValue.cl =  0;\r\n                        }\r\n                        else{\r\n                            cellValue.cl =  1;\r\n                        }\r\n                    }\r\n\r\n                    if(underlines!=null&&underlines.length>0){\r\nletunderline=underlines[0].attributeList.val;\r\nif(underline==\"single\"){\r\ncellValue.un=1;\r\n}\r\nelseif(underline==\"double\"){\r\ncellValue.un=2;\r\n}\r\nelseif(underline==\"singleAccounting\"){\r\ncellValue.un=3;\r\n}\r\nelseif(underline==\"doubleAccounting\"){\r\ncellValue.un=4;\r\n}\r\nelse{\r\ncellValue.un=0;\r\n}\r\n}\r\n                }\r\n            }\r\n\r\n            // vt: number | undefined//Vertical alignment, 0 middle, 1 up, 2 down, alignment\r\n            // ht: number | undefined//Horizontal alignment,0 center, 1 left, 2 right, alignment\r\n            // tr: number | undefined //Text rotation,0: 01: 45 2: -453 Vertical text4: 90 5: -90, alignment\r\n            // tb: number | undefined //Text wrap,0 truncation, 1 overflow, 2 word wrap, alignment\r\n\r\n            if(horizontal!=undefined){//Horizontal alignment\r\n                if(horizontal==\"center\"){\r\n                    cellValue.ht = 0;\r\n                }\r\n                else if(horizontal==\"centerContinuous\"){\r\n                    cellValue.ht = 0;//luckysheet unsupport\r\n                }\r\n                else if(horizontal==\"left\"){\r\n                    cellValue.ht = 1;\r\n                }\r\n                else if(horizontal==\"right\"){\r\n                    cellValue.ht = 2;\r\n                }\r\n                else if(horizontal==\"distributed\"){\r\n                    cellValue.ht = 0;//luckysheet unsupport\r\n                }\r\n                else if(horizontal==\"fill\"){\r\n                    cellValue.ht = 1;//luckysheet unsupport\r\n                }\r\n                else if(horizontal==\"general\"){\r\n                    cellValue.ht = 1;//luckysheet unsupport\r\n                }\r\n                else if(horizontal==\"justify\"){\r\n                    cellValue.ht = 0;//luckysheet unsupport\r\n                }\r\n                else{\r\n                    cellValue.ht = 1;\r\n                }\r\n            }\r\n\r\n            if(vertical!=undefined){//Vertical alignment\r\n                if(vertical==\"bottom\"){\r\n                    cellValue.vt = 2;\r\n                }\r\n                else if(vertical==\"center\"){\r\n                    cellValue.vt = 0;\r\n                }\r\n                else if(vertical==\"distributed\"){\r\n                    cellValue.vt = 0;//luckysheet unsupport\r\n                }\r\n                else if(vertical==\"justify\"){\r\n                    cellValue.vt = 0;//luckysheet unsupport\r\n                }\r\n                else if(vertical==\"top\"){\r\n                    cellValue.vt = 1;\r\n                }\r\n                else{\r\n                    cellValue.vt = 1;\r\n                }\r\n            }\r\n            else {\r\n                //sometimes bottom style is lost after setting it in excel\r\n                //when vertical is undefined set it to 2.\r\n                cellValue.vt = 2;\r\n            }\r\n\r\n            if(wrapText!=undefined){\r\n                if(wrapText==\"1\"){\r\n                    cellValue.tb = 2;\r\n                }\r\n                else{\r\n                    cellValue.tb = 1;\r\n                }\r\n            }\r\n            else{\r\n                cellValue.tb = 1;\r\n            }\r\n\r\n            if(textRotation!=undefined){\r\n                // tr: number | undefined //Text rotation,0: 01: 45 2: -453 Vertical text4: 90 5: -90, alignment\r\n                if(textRotation==\"255\"){\r\n                    cellValue.tr = 3;\r\n                }\r\n                // else if(textRotation==\"45\"){\r\n                //     cellValue.tr = 1;\r\n                // }\r\n                // else if(textRotation==\"90\"){\r\n                //     cellValue.tr = 4;\r\n                // }\r\n                // else if(textRotation==\"135\"){\r\n                //     cellValue.tr = 2;\r\n                // }\r\n                // else if(textRotation==\"180\"){\r\n                //     cellValue.tr = 5;\r\n                // }\r\n                else{\r\n                    cellValue.tr = 0;\r\n                    cellValue.rt =  parseInt(textRotation);\r\n                }\r\n\r\n\r\n            }\r\n\r\n            if(shrinkToFit!=undefined){//luckysheet unsupport\r\n\r\n            }\r\n\r\n            if(indent!=undefined){//luckysheet unsupport\r\n\r\n            }\r\n\r\n            if(borderId!=undefined){\r\n                let borderIdNum = parseInt(borderId);\r\n                let border = borders[borderIdNum];\r\n                // this._borderId = borderIdNum;\r\n\r\n                let borderObject = new LuckySheetborderInfoCellForImp();\r\n                borderObject.rangeType = \"cell\";\r\n                // borderObject.cells = [];\r\n                let borderCellValue = new LuckySheetborderInfoCellValue();\r\n\r\n                borderCellValue.row_index = this.r;\r\n                borderCellValue.col_index = this.c;\r\n\r\n                let lefts = border.getInnerElements(\"left\");\r\n                let rights = border.getInnerElements(\"right\");\r\n                let tops = border.getInnerElements(\"top\");\r\n                let bottoms = border.getInnerElements(\"bottom\");\r\n                let diagonals = border.getInnerElements(\"diagonal\");\r\n\r\n                let starts = border.getInnerElements(\"start\");\r\n                let ends = border.getInnerElements(\"end\");\r\n\r\n                let left = this.getBorderInfo(lefts);\r\n                let right = this.getBorderInfo(rights);\r\n                let top = this.getBorderInfo(tops);\r\n                let bottom = this.getBorderInfo(bottoms);\r\n                let diagonal = this.getBorderInfo(diagonals);\r\n\r\n                let start = this.getBorderInfo(starts);\r\n                let end = this.getBorderInfo(ends);\r\n\r\n                let isAdd = false;\r\n\r\n                if(start!=null && start.color!=null){\r\n                    borderCellValue.l = start;\r\n                    isAdd = true;\r\n                }\r\n\r\n                if(end!=null && end.color!=null){\r\n                    borderCellValue.r = end;\r\n                    isAdd = true;\r\n                }\r\n\r\n                if(left!=null && left.color!=null){\r\n                    borderCellValue.l = left;\r\n                    isAdd = true;\r\n                }\r\n\r\n                if(right!=null && right.color!=null){\r\n                    borderCellValue.r = right;\r\n                    isAdd = true;\r\n                }\r\n\r\n                if(top!=null && top.color!=null){\r\n                    borderCellValue.t = top;\r\n                    isAdd = true;\r\n                }\r\n\r\n                if(bottom!=null && bottom.color!=null){\r\n                    borderCellValue.b = bottom;\r\n                    isAdd = true;\r\n                }\r\n\r\n                if(isAdd){\r\n                    borderObject.value = borderCellValue;\r\n                    // this.config._borderInfo[borderId] = borderObject;\r\n                    this._borderObject = borderObject;\r\n                }\r\n            }\r\n\r\n        }\r\n        else{\r\n            cellValue.tb = 1;\r\n        }\r\n\r\n        if(v!=null){\r\n            let value =v[0].value;\r\n\r\n            if(/&#\\d+;/.test(value)){\r\n                value = this.htmlDecode(value);\r\n            }\r\n\r\n            if(t==ST_CellType[\"SharedString\"]){\r\n                let siIndex = parseInt(v[0].value);\r\n                let sharedSI = sharedStrings[siIndex];\r\n\r\n                let rFlag = sharedSI.getInnerElements(\"r\");\r\n                if(rFlag==null){\r\n                    let tFlag = sharedSI.getInnerElements(\"t\");\r\n                    if(tFlag!=null){\r\n                        let text = \"\";\r\n                        tFlag.forEach((t)=>{\r\n                            text += t.value;\r\n                        });\r\n\r\n                        text = escapeCharacter(text);\r\n\r\n                        //isContainMultiType(text) &&\r\n                        if(familyFont==\"Roman\" && text.length>0){\r\n                            let textArray = text.split(\"\");\r\n                            let preWordType:string = null, wordText=\"\", preWholef:string=null;\r\n                            let wholef = \"Times New Roman\";\r\n                            if(cellValue.ff!=null){\r\n                                wholef = cellValue.ff;\r\n                            }\r\n\r\n                            let cellFormat = cellValue.ct;\r\n                            if(cellFormat==null){\r\n                                cellFormat = new LuckySheetCellFormat();\r\n                            }\r\n\r\n                            if(cellFormat.s==null){\r\n                                cellFormat.s = [];\r\n                            }\r\n\r\n                            for(let i=0;i<textArray.length;i++){\r\n                                let w = textArray[i];\r\n                                let type:string = null, ff=wholef;\r\n\r\n                                if(isChinese(w)){\r\n                                    type = \"c\";\r\n                                    ff=\"\";\r\n                                }\r\n                                else if(isJapanese(w)){\r\n                                    type = \"j\";\r\n                                    ff=\"Yu Gothic\";\r\n                                }\r\n                                else if(isKoera(w)){\r\n                                    type = \"k\";\r\n                                    ff=\"Malgun Gothic\";\r\n                                }\r\n                                else{\r\n                                    type = \"e\";\r\n                                }\r\n\r\n                                if((type!=preWordType && preWordType!=null) || i==textArray.length-1){\r\n                                    let InlineString = new LuckyInlineString();\r\n\r\n                                    InlineString.ff = preWholef;\r\n\r\n                                    if(cellValue.fc!=null){\r\n                                        InlineString.fc = cellValue.fc;\r\n                                    }\r\n\r\n                                    if(cellValue.fs!=null){\r\n                                        InlineString.fs = cellValue.fs;\r\n                                    }\r\n\r\n                                    if(cellValue.cl!=null){\r\n                                        InlineString.cl = cellValue.cl;\r\n                                    }\r\n\r\n                                    if(cellValue.un!=null){\r\n                                        InlineString.un = cellValue.un;\r\n                                    }\r\n\r\n                                    if(cellValue.bl!=null){\r\n                                        InlineString.bl = cellValue.bl;\r\n                                    }\r\n\r\n                                    if(cellValue.it!=null){\r\n                                        InlineString.it = cellValue.it;\r\n                                    }\r\n\r\n                                    if(i==textArray.length-1){\r\n                                        if(type==preWordType){\r\n                                            InlineString.ff = ff;\r\n                                            InlineString.v = wordText + w;\r\n                                        }\r\n                                        else{\r\n                                            InlineString.ff = preWholef;\r\n                                            InlineString.v = wordText;\r\n                                            cellFormat.s.push(InlineString);\r\n\r\n                                            let InlineStringLast = new LuckyInlineString();\r\n                                            InlineStringLast.ff = ff;\r\n                                            InlineStringLast.v = w;\r\n                                            if(cellValue.fc!=null){\r\n                                                InlineStringLast.fc = cellValue.fc;\r\n                                            }\r\n\r\n                                            if(cellValue.fs!=null){\r\n                                                InlineStringLast.fs = cellValue.fs;\r\n                                            }\r\n\r\n                                            if(cellValue.cl!=null){\r\n                                                InlineStringLast.cl = cellValue.cl;\r\n                                            }\r\n\r\n                                            if(cellValue.un!=null){\r\n                                                InlineStringLast.un = cellValue.un;\r\n                                            }\r\n\r\n                                            if(cellValue.bl!=null){\r\n                                                InlineStringLast.bl = cellValue.bl;\r\n                                            }\r\n\r\n                                            if(cellValue.it!=null){\r\n                                                InlineStringLast.it = cellValue.it;\r\n                                            }\r\n                                            cellFormat.s.push(InlineStringLast);\r\n\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    else{\r\n                                        InlineString.v = wordText;\r\n                                    }\r\n\r\n\r\n                                    cellFormat.s.push(InlineString);\r\n\r\n                                    wordText = w;\r\n                                }\r\n                                else{\r\n                                    wordText += w;\r\n                                }\r\n\r\n\r\n                                preWordType = type;\r\n                                preWholef = ff;\r\n                            }\r\n\r\n                            cellFormat.t = \"inlineStr\";\r\n                            // cellFormat.s = [InlineString];\r\n                            cellValue.ct = cellFormat;\r\n                            // console.log(cellValue);\r\n                        }\r\n                        else{\r\n\r\n\r\n                            text = this.replaceSpecialWrap(text);\r\n\r\n                            if(text.indexOf(\"\\r\\n\")>-1 || text.indexOf(\"\\n\")>-1){\r\n                                let InlineString = new LuckyInlineString();\r\n                                InlineString.v = text;\r\n                                let cellFormat = cellValue.ct;\r\n                                if(cellFormat==null){\r\n                                    cellFormat = new LuckySheetCellFormat();\r\n                                }\r\n\r\n                                if(cellValue.ff!=null){\r\n                                    InlineString.ff = cellValue.ff;\r\n                                }\r\n\r\n                                if(cellValue.fc!=null){\r\n                                    InlineString.fc = cellValue.fc;\r\n                                }\r\n\r\n                                if(cellValue.fs!=null){\r\n                                    InlineString.fs = cellValue.fs;\r\n                                }\r\n\r\n                                if(cellValue.cl!=null){\r\n                                    InlineString.cl = cellValue.cl;\r\n                                }\r\n\r\n                                if(cellValue.un!=null){\r\n                                    InlineString.un = cellValue.un;\r\n                                }\r\n\r\n                                if(cellValue.bl!=null){\r\n                                    InlineString.bl = cellValue.bl;\r\n                                }\r\n\r\n                                if(cellValue.it!=null){\r\n                                    InlineString.it = cellValue.it;\r\n                                }\r\n\r\n                                cellFormat.t = \"inlineStr\";\r\n                                cellFormat.s = [InlineString];\r\n                                cellValue.ct = cellFormat;\r\n                            }\r\n                            else{\r\n                                cellValue.v = text;\r\n                                quotePrefix = \"1\";\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n                else{\r\n                    let styles:LuckyInlineString[] = [];\r\n                    rFlag.forEach((r)=>{\r\n                        let tFlag = r.getInnerElements(\"t\");\r\n                        let rPr = r.getInnerElements(\"rPr\");\r\n\r\n                        let InlineString = new LuckyInlineString();\r\n\r\n                        if(tFlag!=null && tFlag.length>0){\r\n                            let text = tFlag[0].value;\r\n                            text = this.replaceSpecialWrap(text);\r\n                            text = escapeCharacter(text);\r\n                            InlineString.v = text;\r\n                        }\r\n\r\n                        if(rPr!=null && rPr.length>0){\r\n                            let frpr = rPr[0];\r\n                            let sz = getlineStringAttr(frpr,\"sz\"), rFont=getlineStringAttr(frpr,\"rFont\"), family=getlineStringAttr(frpr,\"family\"), charset=getlineStringAttr(frpr,\"charset\"), scheme=getlineStringAttr(frpr,\"scheme\"), b=getlineStringAttr(frpr,\"b\"), i=getlineStringAttr(frpr,\"i\"), u=getlineStringAttr(frpr,\"u\"), strike=getlineStringAttr(frpr,\"strike\"), vertAlign=getlineStringAttr(frpr,\"vertAlign\"), color;\r\n\r\n\r\n                            let cEle = frpr.getInnerElements(\"color\");\r\n                            if(cEle!=null && cEle.length>0){\r\n                                color = getColor(cEle[0],this.styles, \"t\");\r\n                            }\r\n\r\n\r\n                            let ff;\r\n                            // if(family!=null){\r\n                            //     ff = fontFamilys[family];\r\n                            // }\r\n                            if(rFont!=null){\r\n                                ff = rFont;\r\n                            }\r\n                            if(ff!=null){\r\n                                InlineString.ff = ff;\r\n                            }\r\n                            else if(cellValue.ff!=null){\r\n                                InlineString.ff = cellValue.ff;\r\n                            }\r\n\r\n                            if(color!=null){\r\n                                InlineString.fc = color;\r\n                            }\r\n                            else if(cellValue.fc!=null){\r\n                                InlineString.fc = cellValue.fc;\r\n                            }\r\n\r\n                            if(sz!=null){\r\n                                InlineString.fs = parseInt(sz);\r\n                            }\r\n                            else if(cellValue.fs!=null){\r\n                                InlineString.fs = cellValue.fs;\r\n                            }\r\n\r\n                            if(strike!=null){\r\n                                InlineString.cl = parseInt(strike);\r\n                            }\r\n                            else if(cellValue.cl!=null){\r\n                                InlineString.cl = cellValue.cl;\r\n                            }\r\n\r\n                            if(u!=null){\r\n                                InlineString.un = parseInt(u);\r\n                            }\r\n                            else if(cellValue.un!=null){\r\n                                InlineString.un = cellValue.un;\r\n                            }\r\n\r\n                            if(b!=null){\r\n                                InlineString.bl = parseInt(b);\r\n                            }\r\n                            else if(cellValue.bl!=null){\r\n                                InlineString.bl = cellValue.bl;\r\n                            }\r\n\r\n                            if(i!=null){\r\n                                InlineString.it = parseInt(i);\r\n                            }\r\n                            else if(cellValue.it!=null){\r\n                                InlineString.it = cellValue.it;\r\n                            }\r\n\r\n                            if(vertAlign!=null){\r\n                                InlineString.va = parseInt(vertAlign);\r\n                            }\r\n\r\n\r\n                            // ff:string | undefined //font family\r\n                            // fc:string | undefined//font color\r\n                            // fs:number | undefined//font size\r\n                            // cl:number | undefined//strike\r\n                            // un:number | undefined//underline\r\n                            // bl:number | undefined//blod\r\n                            // it:number | undefined//italic\r\n                            // v:string | undefined\r\n                        }\r\n                        else{\r\n                            if(InlineString.ff==null && cellValue.ff!=null){\r\n                                InlineString.ff = cellValue.ff;\r\n                            }\r\n\r\n                            if(InlineString.fc==null && cellValue.fc!=null){\r\n                                InlineString.fc = cellValue.fc;\r\n                            }\r\n\r\n                            if(InlineString.fs==null && cellValue.fs!=null){\r\n                                InlineString.fs = cellValue.fs;\r\n                            }\r\n\r\n                            if(InlineString.cl==null && cellValue.cl!=null){\r\n                                InlineString.cl = cellValue.cl;\r\n                            }\r\n\r\n                            if(InlineString.un==null && cellValue.un!=null){\r\n                                InlineString.un = cellValue.un;\r\n                            }\r\n\r\n                            if(InlineString.bl==null && cellValue.bl!=null){\r\n                                InlineString.bl = cellValue.bl;\r\n                            }\r\n\r\n                            if(InlineString.it==null && cellValue.it!=null){\r\n                                InlineString.it = cellValue.it;\r\n                            }\r\n                        }\r\n\r\n\r\n                        styles.push(InlineString);\r\n                    });\r\n\r\n                    let cellFormat = cellValue.ct;\r\n                    if(cellFormat==null){\r\n                        cellFormat = new LuckySheetCellFormat();\r\n                    }\r\n                    cellFormat.t = \"inlineStr\";\r\n                    cellFormat.s = styles;\r\n                    cellValue.ct = cellFormat;\r\n                }\r\n            }\r\n            // to be confirmed\r\n            else if(t==ST_CellType[\"InlineString\"] && v!=null){\r\n                cellValue.v = \"'\"+ value;\r\n            }\r\n            else {\r\n                value = escapeCharacter(value);\r\n                cellValue.v = value;\r\n            }\r\n        }\r\n\r\n        if(quotePrefix!=null){\r\n            cellValue.qp = parseInt(quotePrefix);\r\n        }\r\n\r\n        return cellValue;\r\n\r\n    }\r\n\r\n    private replaceSpecialWrap(text:string):string{\r\n        text = text.replace(/_x000D_/g, \"\").replace(/&#13;&#10;/g, \"\\r\\n\").replace(/&#13;/g, \"\\r\").replace(/&#10;/g, \"\\n\");\r\n        return text;\r\n    }\r\n\r\n\r\n    private getBackgroundByFill(fill:Element, clrScheme:Element[]):string|null{\r\n        let patternFills = fill.getInnerElements(\"patternFill\");\r\n        if(patternFills!=null){\r\n            let patternFill = patternFills[0];\r\n            let fgColors = patternFill.getInnerElements(\"fgColor\");\r\n            let bgColors = patternFill.getInnerElements(\"bgColor\");\r\n            let fg, bg;\r\n            if(fgColors!=null){\r\n                let fgColor = fgColors[0];\r\n                fg = getColor(fgColor, this.styles);\r\n            }\r\n\r\n            if(bgColors!=null){\r\n                let bgColor = bgColors[0];\r\n                bg = getColor(bgColor, this.styles);\r\n            }\r\n            // console.log(fgColors,bgColors,clrScheme);\r\n            if(fg!=null){\r\n                return fg;\r\n            }\r\n            else if(bg!=null){\r\n                return bg;\r\n            }\r\n        }\r\n        else{\r\n            let gradientfills = fill.getInnerElements(\"gradientFill\");\r\n            if(gradientfills!=null){\r\n                //graient color fill handler\r\n\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    private getBorderInfo(borders:Element[]):LuckySheetborderInfoCellValueStyle{\r\n        if(borders==null){\r\n            return null;\r\n        }\r\n\r\n        let border = borders[0], attrList = border.attributeList;\r\n        let clrScheme = this.styles[\"clrScheme\"] as Element[];\r\n        let style:string = attrList.style;\r\n        if(style==null || style==\"none\"){\r\n            return null;\r\n        }\r\n\r\n        let colors = border.getInnerElements(\"color\");\r\n        let colorRet = \"#000000\";\r\n        if(colors!=null){\r\n            let color = colors[0];\r\n            colorRet = getColor(color, this.styles, \"b\");\r\n            if(colorRet==null){\r\n                colorRet = \"#000000\";\r\n            }\r\n        }\r\n\r\n        let ret = new LuckySheetborderInfoCellValueStyle();\r\n        ret.style = borderTypes[style];\r\n        ret.color = colorRet;\r\n\r\n        return ret;\r\n    }\r\n\r\n    private htmlDecode (str:string):string {\r\n        return str.replace(/&#(x)?([^&]{1,5});/g,function($,$1,$2) {\r\n            return String.fromCharCode(parseInt($2 , $1 ? 16:10));\r\n        });\r\n    };\r\n\r\n}\r\n\r\n","import { ILuckyFile,IluckySheetRowAndColumnHidden,IluckySheetRowAndColumnLen} from \"./ILuck\";\r\nimport { LuckySheet} from \"./LuckySheet\";\r\nimport {IuploadfileList, IattributeList} from \"../ICommon\";\r\nimport {workBookFile, coreFile, appFile, stylesFile, sharedStringsFile,numFmtDefault,theme1File,calcChainFile,workbookRels, numFmtDefaultMap} from \"../common/constant\";\r\nimport { ReadXml,IStyleCollections,Element } from \"./ReadXml\";\r\nimport {getXmlAttibute} from \"../common/method\";\r\nimport { LuckyFileBase,LuckyFileInfo,LuckySheetBase,LuckySheetCelldataBase,LuckySheetCelldataValue,LuckySheetCellFormat } from \"./LuckyBase\";\r\nimport {ImageList} from \"./LuckyImage\";\r\n\r\nexport class LuckyFile extends LuckyFileBase {\r\n\r\n    private files:IuploadfileList\r\n    private sheetNameList:IattributeList\r\n    private readXml:ReadXml\r\n    private fileName:string\r\n    private styles:IStyleCollections\r\n    private sharedStrings:Element[]\r\n    private calcChain:Element[]\r\n    private imageList:ImageList\r\n\r\n    constructor(files:IuploadfileList, fileName:string) {\r\n        super();\r\n        this.files = files;\r\n        this.fileName = fileName;\r\n        this.readXml = new ReadXml(files);\r\n        this.getSheetNameList();\r\n\r\n        this.sharedStrings = this.readXml.getElementsByTagName(\"sst/si\", sharedStringsFile);\r\n        this.calcChain = this.readXml.getElementsByTagName(\"calcChain/c\", calcChainFile);\r\n        this.styles = {};\r\n        this.styles[\"cellXfs\"] =  this.readXml.getElementsByTagName(\"cellXfs/xf\", stylesFile);\r\n        this.styles[\"cellStyleXfs\"] =  this.readXml.getElementsByTagName(\"cellStyleXfs/xf\", stylesFile);\r\n        this.styles[\"cellStyles\"] =  this.readXml.getElementsByTagName(\"cellStyles/cellStyle\", stylesFile);\r\n        this.styles[\"fonts\"] =  this.readXml.getElementsByTagName(\"fonts/font\", stylesFile);\r\n        this.styles[\"fills\"] =  this.readXml.getElementsByTagName(\"fills/fill\", stylesFile);\r\n        this.styles[\"borders\"] =  this.readXml.getElementsByTagName(\"borders/border\", stylesFile);\r\n        this.styles[\"clrScheme\"] =  this.readXml.getElementsByTagName(\"a:clrScheme/a:dk1|a:lt1|a:dk2|a:lt2|a:accent1|a:accent2|a:accent3|a:accent4|a:accent5|a:accent6|a:hlink|a:folHlink\", theme1File);\r\n        this.styles[\"indexedColors\"] =  this.readXml.getElementsByTagName(\"colors/indexedColors/rgbColor\", stylesFile);\r\n        this.styles[\"mruColors\"] =  this.readXml.getElementsByTagName(\"colors/mruColors/color\", stylesFile);\r\n\r\n        this.imageList = new ImageList(files);\r\n\r\n        let numfmts =  this.readXml.getElementsByTagName(\"numFmt/numFmt\", stylesFile);\r\n        let numFmtDefaultC = JSON.parse(JSON.stringify(numFmtDefault));\r\n        for(let i=0;i<numfmts.length;i++){\r\n            let attrList = numfmts[i].attributeList;\r\n            let numfmtid = getXmlAttibute(attrList, \"numFmtId\", \"49\");\r\n            let formatcode = getXmlAttibute(attrList, \"formatCode\", \"@\");\r\n            // console.log(numfmtid, formatcode);\r\n            if(!(numfmtid in numFmtDefault)){\r\n                numFmtDefaultC[numfmtid] = numFmtDefaultMap[formatcode] || formatcode;\r\n            }\r\n        }\r\n\r\n        // console.log(JSON.stringify(numFmtDefaultC), numfmts);\r\n        this.styles[\"numfmts\"] =  numFmtDefaultC;\r\n    }\r\n\r\n    /**\r\n    * @return All sheet name of workbook\r\n    */\r\n    private getSheetNameList(){\r\n        let workbookRelList = this.readXml.getElementsByTagName(\"Relationships/Relationship\", workbookRels);\r\n        if(workbookRelList==null){\r\n            return;\r\n        }\r\n\r\n        let regex = new RegExp(\"worksheets/[^/]*?.xml\");\r\n        let sheetNames:IattributeList = {};\r\n        for(let i=0;i<workbookRelList.length;i++){\r\n            let rel = workbookRelList[i], attrList = rel.attributeList;\r\n            let id = attrList[\"Id\"], target = attrList[\"Target\"];\r\n            if(regex.test(target)){\r\n                if(target.indexOf('/xl') === 0){\r\n                    sheetNames[id] =   target.substr(1);\r\n                }else{\r\n                    sheetNames[id] =   \"xl/\" + target;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        this.sheetNameList = sheetNames;\r\n    }\r\n\r\n    /**\r\n    * @param sheetName WorkSheet'name\r\n    * @return sheet file name and path in zip\r\n    */\r\n   private getSheetFileBysheetId(sheetId:string){\r\n        // for(let i=0;i<this.sheetNameList.length;i++){\r\n        //     let sheetFileName = this.sheetNameList[i];\r\n        //     if(sheetFileName.indexOf(\"sheet\"+sheetId)>-1){\r\n        //         return sheetFileName;\r\n        //     }\r\n        // }\r\n        return this.sheetNameList[sheetId];\r\n    }\r\n\r\n    /**\r\n    * @return workBook information\r\n    */\r\n    getWorkBookInfo(){\r\n        let Company = this.readXml.getElementsByTagName(\"Company\", appFile);\r\n        let AppVersion = this.readXml.getElementsByTagName(\"AppVersion\", appFile);\r\n        let creator = this.readXml.getElementsByTagName(\"dc:creator\", coreFile);\r\n        let lastModifiedBy = this.readXml.getElementsByTagName(\"cp:lastModifiedBy\", coreFile);\r\n        let created = this.readXml.getElementsByTagName(\"dcterms:created\", coreFile);\r\n        let modified = this.readXml.getElementsByTagName(\"dcterms:modified\", coreFile);\r\n        this.info = new LuckyFileInfo();\r\n        this.info.name = this.fileName;\r\n        this.info.creator = creator.length>0?creator[0].value:\"\";\r\n        this.info.lastmodifiedby = lastModifiedBy.length>0?lastModifiedBy[0].value:\"\";\r\n        this.info.createdTime = created.length>0?created[0].value:\"\";\r\n        this.info.modifiedTime = modified.length>0?modified[0].value:\"\";\r\n        this.info.company = Company.length>0?Company[0].value:\"\";\r\n        this.info.appversion = AppVersion.length>0?AppVersion[0].value:\"\";\r\n    }\r\n\r\n    /**\r\n    * @return All sheet , include whole information\r\n    */\r\n    getSheetsFull(isInitialCell:boolean=true){\r\n        let sheets = this.readXml.getElementsByTagName(\"sheets/sheet\", workBookFile);\r\n        let sheetList:IattributeList = {};\r\n        for(let key in sheets){\r\n            let sheet = sheets[key];\r\n            sheetList[sheet.attributeList.name] = sheet.attributeList[\"sheetId\"];\r\n        }\r\n        this.sheets = [];\r\n        let order = 0;\r\n        for(let key in sheets){\r\n            let sheet = sheets[key];\r\n            let sheetName = sheet.attributeList.name;\r\n            let sheetId = sheet.attributeList[\"sheetId\"];\r\n            let rid = sheet.attributeList[\"r:id\"];\r\n            let sheetFile = this.getSheetFileBysheetId(rid);\r\n            let hide = sheet.attributeList.state === \"hidden\" ? 1 : 0;\r\n\r\n            let drawing = this.readXml.getElementsByTagName(\"worksheet/drawing\", sheetFile), drawingFile, drawingRelsFile;\r\n            if(drawing!=null && drawing.length>0){\r\n                let attrList = drawing[0].attributeList;\r\n                let rid = getXmlAttibute(attrList, \"r:id\", null);\r\n                if(rid!=null){\r\n                    drawingFile = this.getDrawingFile(rid, sheetFile);\r\n                    drawingRelsFile = this.getDrawingRelsFile(drawingFile);\r\n                }\r\n            }\r\n\r\n            if(sheetFile!=null){\r\n                let sheet = new LuckySheet(sheetName, sheetId, order, isInitialCell,\r\n                    {\r\n                        sheetFile:sheetFile,\r\n                        readXml:this.readXml,\r\n                        sheetList:sheetList,\r\n                        styles:this.styles,\r\n                        sharedStrings:this.sharedStrings,\r\n                        calcChain:this.calcChain,\r\n                        imageList:this.imageList,\r\n                        drawingFile:drawingFile,\r\n                        drawingRelsFile: drawingRelsFile,\r\n                        hide: hide,\r\n                    }\r\n                )\r\n                this.columnWidthSet = [];\r\n                this.rowHeightSet = [];\r\n\r\n                this.imagePositionCaculation(sheet);\r\n\r\n                this.sheets.push(sheet);\r\n                order++;\r\n            }\r\n        }\r\n    }\r\n\r\n    private columnWidthSet:number[] = [];\r\n    private rowHeightSet:number[] = [];\r\n\r\n    private extendArray(index:number, sets:number[],def:number, hidden:IluckySheetRowAndColumnHidden, lens:IluckySheetRowAndColumnLen){\r\n        if(index<sets.length){\r\n            return;\r\n        }\r\n\r\n        let startIndex = sets.length, endIndex = index;\r\n        let allGap = 0;\r\n        if(startIndex>0){\r\n            allGap = sets[startIndex-1];\r\n        }\r\n        // else{\r\n        //     sets.push(0);\r\n        // }\r\n        for(let i=startIndex;i<=endIndex;i++){\r\n            let gap = def, istring  = i.toString();\r\n            if(istring in hidden){\r\n                gap = 0;\r\n            }\r\n            else if(istring in lens){\r\n                gap = lens[istring];\r\n            }\r\n\r\n            allGap += Math.round(gap + 1);\r\n\r\n            sets.push(allGap);\r\n        }\r\n    }\r\n\r\n    private imagePositionCaculation(sheet:LuckySheet){\r\n        let images = sheet.images, defaultColWidth = sheet.defaultColWidth, defaultRowHeight = sheet.defaultRowHeight;\r\n        let colhidden = {};\r\n        if(sheet.config.colhidden){\r\n            colhidden = sheet.config.colhidden;\r\n        }\r\n\r\n        let columnlen = {};\r\n        if(sheet.config.columnlen){\r\n            columnlen = sheet.config.columnlen;\r\n        }\r\n\r\n        let rowhidden = {};\r\n        if(sheet.config.rowhidden){\r\n            rowhidden = sheet.config.rowhidden;\r\n        }\r\n\r\n        let rowlen = {};\r\n        if(sheet.config.rowlen){\r\n            rowlen = sheet.config.rowlen;\r\n        }\r\n\r\n        for(let key in images){\r\n            let imageObject:any = images[key];//Image, luckyImage\r\n            let fromCol = imageObject.fromCol;\r\n            let fromColOff = imageObject.fromColOff;\r\n            let fromRow = imageObject.fromRow;\r\n            let fromRowOff = imageObject.fromRowOff;\r\n\r\n            let toCol = imageObject.toCol;\r\n            let toColOff = imageObject.toColOff;\r\n            let toRow = imageObject.toRow;\r\n            let toRowOff = imageObject.toRowOff;\r\n\r\n            let x_n =0,y_n = 0;\r\n            let cx_n = 0, cy_n = 0;\r\n\r\n            if(fromCol>=this.columnWidthSet.length){\r\n                this.extendArray(fromCol, this.columnWidthSet, defaultColWidth, colhidden, columnlen);\r\n            }\r\n            if(fromCol==0){\r\n                x_n = 0;\r\n            }\r\n            else{\r\n                x_n = this.columnWidthSet[fromCol-1];\r\n            }\r\n            x_n = x_n + fromColOff;\r\n\r\n            if(fromRow>=this.rowHeightSet.length){\r\n                this.extendArray(fromRow, this.rowHeightSet, defaultRowHeight, rowhidden, rowlen);\r\n            }\r\n            if(fromRow==0){\r\n                y_n = 0;\r\n            }\r\n            else{\r\n                y_n = this.rowHeightSet[fromRow-1];\r\n            }\r\n            y_n = y_n + fromRowOff;\r\n\r\n\r\n            if(toCol>=this.columnWidthSet.length){\r\n                this.extendArray(toCol, this.columnWidthSet, defaultColWidth, colhidden, columnlen);\r\n            }\r\n            if(toCol==0){\r\n                cx_n = 0;\r\n            }\r\n            else{\r\n                cx_n = this.columnWidthSet[toCol-1];\r\n            }\r\n            cx_n = cx_n + toColOff- x_n;\r\n\r\n            if(toRow>=this.rowHeightSet.length){\r\n                this.extendArray(toRow, this.rowHeightSet, defaultRowHeight, rowhidden, rowlen);\r\n            }\r\n            if(toRow==0){\r\n                cy_n = 0;\r\n            }\r\n            else{\r\n                cy_n = this.rowHeightSet[toRow-1];\r\n            }\r\n\r\n            cy_n = cy_n + toRowOff - y_n;\r\n\r\n            // console.log(defaultColWidth, colhidden , columnlen);\r\n            // console.log(fromCol, this.columnWidthSet[fromCol] , fromColOff);\r\n            // console.log(toCol, this.columnWidthSet[toCol] , toColOff, JSON.stringify(this.columnWidthSet));\r\n\r\n            imageObject.originWidth = cx_n;\r\n            imageObject.originHeight = cy_n;\r\n\r\n            imageObject.crop.height = cy_n;\r\n            imageObject.crop.width = cx_n;\r\n\r\n            imageObject.default.height = cy_n;\r\n            imageObject.default.left = x_n;\r\n            imageObject.default.top = y_n;\r\n            imageObject.default.width = cx_n;\r\n        }\r\n\r\n        //console.log(this.columnWidthSet, this.rowHeightSet);\r\n    }\r\n\r\n    /**\r\n    * @return drawing file string\r\n    */\r\n   private getDrawingFile(rid:string, sheetFile:string):string{\r\n        let sheetRelsPath = \"xl/worksheets/_rels/\";\r\n        let sheetFileArr = sheetFile.split(\"/\");\r\n        let sheetRelsName = sheetFileArr[sheetFileArr.length-1];\r\n\r\n        let sheetRelsFile = sheetRelsPath + sheetRelsName + \".rels\";\r\n\r\n        let drawing = this.readXml.getElementsByTagName(\"Relationships/Relationship\", sheetRelsFile);\r\n        if(drawing.length>0){\r\n            for(let i=0;i<drawing.length;i++){\r\n                let relationship = drawing[i];\r\n                let attrList = relationship.attributeList;\r\n                let relationshipId = getXmlAttibute(attrList, \"Id\", null);\r\n                if(relationshipId==rid){\r\n                    let target = getXmlAttibute(attrList, \"Target\", null);\r\n                    if(target!=null){\r\n                        return target.replace(/\\.\\.\\//g, \"\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n    private getDrawingRelsFile(drawingFile:string):string{\r\n        let drawingRelsPath = \"xl/drawings/_rels/\";\r\n        let drawingFileArr = drawingFile.split(\"/\");\r\n        let drawingRelsName = drawingFileArr[drawingFileArr.length-1];\r\n\r\n        let drawingRelsFile = drawingRelsPath + drawingRelsName + \".rels\";\r\n\r\n        return drawingRelsFile;\r\n    }\r\n\r\n    /**\r\n    * @return All sheet base information widthout cell and config\r\n    */\r\n    getSheetsWithoutCell(){\r\n        this.getSheetsFull(false);\r\n    }\r\n\r\n    /**\r\n    * @return LuckySheet file json\r\n    */\r\n    Parse():string{\r\n        // let xml = this.readXml;\r\n        // for(let key in this.sheetNameList){\r\n        //     let sheetName=this.sheetNameList[key];\r\n        //     let sheetColumns = xml.getElementsByTagName(\"row/c/f\", sheetName);\r\n        //     console.log(sheetColumns);\r\n        // }\r\n        // return \"\";\r\n\r\n        this.getWorkBookInfo();\r\n        this.getSheetsFull();\r\n\r\n        // for(let i=0;i<this.sheets.length;i++){\r\n        //     let sheet = this.sheets[i];\r\n        //     let _borderInfo = sheet.config._borderInfo;\r\n        //     if(_borderInfo==null){\r\n        //         continue;\r\n        //     }\r\n        //     let _borderInfoKeys = Object.keys(_borderInfo);\r\n        //     _borderInfoKeys.sort();\r\n        //     for(let a=0;a<_borderInfoKeys.length;a++){\r\n        //         let key = parseInt(_borderInfoKeys[a]);\r\n        //         let b = _borderInfo[key];\r\n        //         if(b.cells.length==0){\r\n        //             continue;\r\n        //         }\r\n        //         if(sheet.config.borderInfo==null){\r\n        //             sheet.config.borderInfo = [];\r\n        //         }\r\n        //         sheet.config.borderInfo.push(b);\r\n        //     }\r\n        // }\r\n\r\n        return this.toJsonString(this);\r\n    }\r\n\r\n    private toJsonString(file:ILuckyFile):string{\r\n        let LuckyOutPutFile = new LuckyFileBase();\r\n        LuckyOutPutFile.info = file.info;\r\n        LuckyOutPutFile.sheets = [];\r\n\r\n        file.sheets.forEach((sheet)=>{\r\n            let sheetout = new LuckySheetBase();\r\n            //let attrName = [\"name\",\"color\",\"config\",\"index\",\"status\",\"order\",\"row\",\"column\",\"luckysheet_select_save\",\"scrollLeft\",\"scrollTop\",\"zoomRatio\",\"showGridLines\",\"defaultColWidth\",\"defaultRowHeight\",\"celldata\",\"chart\",\"isPivotTable\",\"pivotTable\",\"luckysheet_conditionformat_save\",\"freezen\",\"calcChain\"];\r\n\r\n            if(sheet.name!=null){\r\n                sheetout.name = sheet.name;\r\n            }\r\n\r\n            if(sheet.color!=null){\r\n                sheetout.color = sheet.color;\r\n            }\r\n\r\n            if(sheet.config!=null){\r\n                sheetout.config = sheet.config;\r\n                // if(sheetout.config._borderInfo!=null){\r\n                //     delete sheetout.config._borderInfo;\r\n                // }\r\n            }\r\n\r\n            if(sheet.index!=null){\r\n                sheetout.index = sheet.index;\r\n            }\r\n\r\n            if(sheet.status!=null){\r\n                sheetout.status = sheet.status;\r\n            }\r\n\r\n            if(sheet.order!=null){\r\n                sheetout.order = sheet.order;\r\n            }\r\n\r\n            if(sheet.row!=null){\r\n                sheetout.row = sheet.row;\r\n            }\r\n\r\n            if(sheet.column!=null){\r\n                sheetout.column = sheet.column;\r\n            }\r\n\r\n            if(sheet.luckysheet_select_save!=null){\r\n                sheetout.luckysheet_select_save = sheet.luckysheet_select_save;\r\n            }\r\n\r\n            if(sheet.scrollLeft!=null){\r\n                sheetout.scrollLeft = sheet.scrollLeft;\r\n            }\r\n\r\n            if(sheet.scrollTop!=null){\r\n                sheetout.scrollTop = sheet.scrollTop;\r\n            }\r\n\r\n            if(sheet.zoomRatio!=null){\r\n                sheetout.zoomRatio = sheet.zoomRatio;\r\n            }\r\n\r\n            if(sheet.showGridLines!=null){\r\n                sheetout.showGridLines = sheet.showGridLines;\r\n            }\r\n\r\n            if(sheet.defaultColWidth!=null){\r\n                sheetout.defaultColWidth = sheet.defaultColWidth;\r\n            }\r\n\r\n            if(sheet.defaultRowHeight!=null){\r\n                sheetout.defaultRowHeight = sheet.defaultRowHeight;\r\n            }\r\n\r\n            if(sheet.celldata!=null){\r\n                // sheetout.celldata = sheet.celldata;\r\n                sheetout.celldata = [];\r\n                sheet.celldata.forEach((cell)=>{\r\n                    let cellout = new LuckySheetCelldataBase();\r\n                    cellout.r = cell.r;\r\n                    cellout.c = cell.c;\r\n                    cellout.v = cell.v;\r\n                    sheetout.celldata.push(cellout);\r\n                });\r\n            }\r\n\r\n            if(sheet.chart!=null){\r\n                sheetout.chart = sheet.chart;\r\n            }\r\n\r\n            if(sheet.isPivotTable!=null){\r\n                sheetout.isPivotTable = sheet.isPivotTable;\r\n            }\r\n\r\n            if(sheet.pivotTable!=null){\r\n                sheetout.pivotTable = sheet.pivotTable;\r\n            }\r\n\r\n            if(sheet.luckysheet_conditionformat_save!=null){\r\n                sheetout.luckysheet_conditionformat_save = sheet.luckysheet_conditionformat_save;\r\n            }\r\n\r\n            if(sheet.freezen!=null){\r\n                sheetout.freezen = sheet.freezen;\r\n            }\r\n\r\n            if(sheet.calcChain!=null){\r\n                sheetout.calcChain = sheet.calcChain;\r\n            }\r\n\r\n            if(sheet.images!=null){\r\n                sheetout.images = sheet.images;\r\n            }\r\n          \r\n            if (sheet.hyperlink != null){\r\n                sheetout.hyperlink = sheet.hyperlink;\r\n            }\r\n          \r\n            if (sheet.hide != null) {\r\n              sheetout.hide = sheet.hide;\r\n            }\r\n            \r\n            LuckyOutPutFile.sheets.push(sheetout);\r\n        });\r\n\r\n        return JSON.stringify(LuckyOutPutFile);\r\n    }\r\n\r\n\r\n}\r\n","import { IluckyImage } from \"./ILuck\";\r\nimport {LuckySheetCelldata} from \"./LuckyCell\";\r\nimport { IuploadfileList, IattributeList } from \"../ICommon\";\r\nimport {getXmlAttibute, getColumnWidthPixel, fromulaRef,getRowHeightPixel,getcellrange} from \"../common/method\";\r\nimport {borderTypes} from \"../common/constant\";\r\nimport { ReadXml, IStyleCollections, Element,getColor } from \"./ReadXml\";\r\nimport { LuckyImageBase } from \"./LuckyBase\";\r\nimport { UDOC,FromEMF,ToContext2D  } from \"../common/emf\";\r\n\r\n\r\nexport class ImageList {\r\n    private images:IattributeList\r\n    constructor(files:IuploadfileList) {\r\n        if(files==null){\r\n            return;\r\n        }\r\n        this.images = {};\r\n        for(let fileKey in files){\r\n            // let reg = new RegExp(\"xl/media/image1.png\", \"g\");\r\n            if(fileKey.indexOf(\"xl/media/\")>-1){\r\n                let fileNameArr = fileKey.split(\".\");\r\n                let suffix = fileNameArr[fileNameArr.length-1].toLowerCase();\r\n                if(suffix in {\"png\":1, \"jpeg\":1, \"jpg\":1, \"gif\":1,\"bmp\":1,\"tif\":1,\"webp\":1,\"emf\":1}){\r\n                    if(suffix==\"emf\"){\r\n                        var pNum  = 0;  // number of the page, that you want to render\r\n                        var scale = 1;  // the scale of the document\r\n                        var wrt = new ToContext2D(pNum, scale);\r\n                        var inp, out, stt;\r\n                        FromEMF.K = [];\r\n                        inp = FromEMF.C;   out = FromEMF.K;   stt=4;\r\n                        for(var p in inp) out[inp[p]] = p.slice(stt);\r\n                        FromEMF.Parse(files[fileKey], wrt);\r\n                        this.images[fileKey] = wrt.canvas.toDataURL(\"image/png\");\r\n                    }\r\n                    else{\r\n                        this.images[fileKey] = files[fileKey];\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    getImageByName(pathName:string):Image{\r\n        if(pathName in this.images){\r\n            let base64 = this.images[pathName];\r\n            return new Image(pathName, base64);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n\r\nclass Image extends LuckyImageBase {\r\n\r\n    fromCol:number\r\n    fromColOff:number\r\n    fromRow:number\r\n    fromRowOff:number\r\n\r\n    toCol:number\r\n    toColOff:number\r\n    toRow:number\r\n    toRowOff:number\r\n\r\n    constructor(pathName:string, base64:string) {\r\n        super();\r\n        this.src = base64;\r\n    }\r\n\r\n    setDefault(){\r\n\r\n    }\r\n}","import { IluckyImageBorder,IluckyImageCrop,IluckyImageDefault,IluckyImages,IluckySheetCelldata,IluckySheetCelldataValue,IMapluckySheetborderInfoCellForImp,IluckySheetborderInfoCellValue,IluckySheetborderInfoCellValueStyle,IFormulaSI,IluckySheetRowAndColumnLen,IluckySheetRowAndColumnHidden,IluckySheetSelection,IcellOtherInfo,IformulaList,IformulaListItem, IluckysheetHyperlink, IluckysheetHyperlinkType} from \"./ILuck\";\r\nimport {LuckySheetCelldata} from \"./LuckyCell\";\r\nimport { IattributeList } from \"../ICommon\";\r\nimport {getXmlAttibute, getColumnWidthPixel, fromulaRef,getRowHeightPixel,getcellrange,generateRandomIndex,getPxByEMUs, getMultiSequenceToNum, getTransR1C1ToSequence} from \"../common/method\";\r\nimport {borderTypes, worksheetFilePath} from \"../common/constant\";\r\nimport { ReadXml, IStyleCollections, Element,getColor } from \"./ReadXml\";\r\nimport { LuckyFileBase,LuckySheetBase,LuckyConfig,LuckySheetborderInfoCellForImp,LuckySheetborderInfoCellValue,LuckysheetCalcChain,LuckySheetConfigMerge } from \"./LuckyBase\";\r\nimport {ImageList} from \"./LuckyImage\";\r\n\r\nexport class LuckySheet extends LuckySheetBase {\r\n\r\n    private readXml:ReadXml\r\n    private sheetFile:string\r\n    private isInitialCell:boolean\r\n    private styles:IStyleCollections\r\n    private sharedStrings:Element[]\r\n    private mergeCells:Element[]\r\n    private calcChainEles:Element[]\r\n    private sheetList:IattributeList\r\n\r\n    private imageList:ImageList\r\n\r\n    private formulaRefList:IFormulaSI\r\n\r\n    constructor(sheetName:string, sheetId:string, sheetOrder:number,isInitialCell:boolean=false, allFileOption:any){\r\n        //Private\r\n        super();\r\n        this.isInitialCell = isInitialCell;\r\n\r\n        this.readXml = allFileOption.readXml;\r\n        this.sheetFile = allFileOption.sheetFile;\r\n        this.styles = allFileOption.styles;\r\n        this.sharedStrings = allFileOption.sharedStrings;\r\n        this.calcChainEles = allFileOption.calcChain;\r\n        this.sheetList = allFileOption.sheetList;\r\n        this.imageList = allFileOption.imageList;\r\n        this.hide = allFileOption.hide;\r\n\r\n        //Output\r\n        this.name = sheetName;\r\n        this.index = sheetId;\r\n        this.order = sheetOrder.toString();\r\n        this.config = new LuckyConfig();\r\n        this.celldata = [];\r\n        this.mergeCells = this.readXml.getElementsByTagName(\"mergeCells/mergeCell\", this.sheetFile);\r\n        let clrScheme = this.styles[\"clrScheme\"] as Element[];\r\n        let sheetView = this.readXml.getElementsByTagName(\"sheetViews/sheetView\", this.sheetFile);\r\n        let showGridLines = \"1\", tabSelected=\"0\", zoomScale = \"100\", activeCell = \"A1\";\r\n        if(sheetView.length>0){\r\n            let attrList = sheetView[0].attributeList;\r\n            showGridLines = getXmlAttibute(attrList, \"showGridLines\", \"1\");\r\n            tabSelected = getXmlAttibute(attrList, \"tabSelected\", \"0\");\r\n            zoomScale = getXmlAttibute(attrList, \"zoomScale\", \"100\");\r\n            // let colorId = getXmlAttibute(attrList, \"colorId\", \"0\");\r\n            let selections = sheetView[0].getInnerElements(\"selection\");\r\n            if(selections!=null && selections.length>0){\r\n                activeCell = getXmlAttibute(selections[0].attributeList, \"activeCell\", \"A1\");\r\n                let range:IluckySheetSelection = getcellrange(activeCell, this.sheetList, sheetId);\r\n                this.luckysheet_select_save = [];\r\n                this.luckysheet_select_save.push(range);\r\n            }\r\n        }\r\n        this.showGridLines = showGridLines;\r\n        this.status = tabSelected;\r\n        this.zoomRatio = parseInt(zoomScale)/100;\r\n\r\n        let tabColors = this.readXml.getElementsByTagName(\"sheetPr/tabColor\", this.sheetFile);\r\n        if(tabColors!=null && tabColors.length>0){\r\n            let tabColor = tabColors[0], attrList = tabColor.attributeList;\r\n            // if(attrList.rgb!=null){\r\n                let tc = getColor(tabColor, this.styles, \"b\");\r\n                this.color = tc;\r\n            // }\r\n        }\r\n\r\n        let sheetFormatPr = this.readXml.getElementsByTagName(\"sheetFormatPr\", this.sheetFile);\r\n        let defaultColWidth, defaultRowHeight;\r\n        if(sheetFormatPr.length>0){\r\n            let attrList = sheetFormatPr[0].attributeList;\r\n            defaultColWidth = getXmlAttibute(attrList, \"defaultColWidth\", \"9.21\");\r\n            defaultRowHeight = getXmlAttibute(attrList, \"defaultRowHeight\", \"19\");\r\n        }\r\n\r\n        this.defaultColWidth = getColumnWidthPixel(parseFloat(defaultColWidth));\r\n        this.defaultRowHeight = getRowHeightPixel(parseFloat(defaultRowHeight));\r\n\r\n\r\n        this.generateConfigColumnLenAndHidden();\r\n        let cellOtherInfo:IcellOtherInfo =  this.generateConfigRowLenAndHiddenAddCell();\r\n        \r\n        if(this.calcChain==null){\r\n            this.calcChain = [];\r\n        }\r\n\r\n        let formulaListExist:IformulaList={};\r\n        for(let c=0;c<this.calcChainEles.length;c++){\r\n            let calcChainEle = this.calcChainEles[c], attrList = calcChainEle.attributeList;\r\n            if(attrList.i!=sheetId){\r\n                continue;\r\n            }\r\n\r\n            let r = attrList.r , i = attrList.i, l = attrList.l, s = attrList.s, a = attrList.a, t = attrList.t;\r\n\r\n            let range = getcellrange(r);\r\n            let chain = new LuckysheetCalcChain();\r\n            chain.r = range.row[0];\r\n            chain.c = range.column[0];\r\n            chain.index = this.index;\r\n            this.calcChain.push(chain);\r\n            formulaListExist[\"r\"+r+\"c\"+c] = null;\r\n        }\r\n        \r\n\r\n        if(this.formulaRefList!=null){\r\n            for(let key in this.formulaRefList){\r\n                let funclist = this.formulaRefList[key];\r\n                let mainFunc = funclist[\"mainRef\"], mainCellValue = mainFunc.cellValue;\r\n                let formulaTxt = mainFunc.fv;\r\n                let mainR = mainCellValue.r, mainC = mainCellValue.c;\r\n                // let refRange = getcellrange(ref);\r\n                for(let name in funclist){\r\n                    if(name == \"mainRef\"){\r\n                        continue;\r\n                    }\r\n\r\n                    let funcValue = funclist[name], cellValue = funcValue.cellValue;\r\n                    if(cellValue==null){\r\n                        continue;\r\n                    }\r\n                    let r = cellValue.r, c = cellValue.c;\r\n\r\n                    let func = formulaTxt;\r\n                    let offsetRow = r - mainR, offsetCol = c - mainC;\r\n\r\n                    \r\n                    if(offsetRow > 0){\r\n                        func = \"=\" + fromulaRef.functionCopy(func, \"down\", offsetRow);\r\n                    }\r\n                    else if(offsetRow < 0){\r\n                        func = \"=\" + fromulaRef.functionCopy(func, \"up\", Math.abs(offsetRow));\r\n                    }\r\n\r\n                    if(offsetCol > 0){\r\n                        func = \"=\" + fromulaRef.functionCopy(func, \"right\", offsetCol);\r\n                    }\r\n                    else if(offsetCol < 0){\r\n                        func = \"=\" + fromulaRef.functionCopy(func, \"left\", Math.abs(offsetCol));\r\n                    }\r\n\r\n                    // console.log(offsetRow, offsetCol, func);\r\n\r\n                    (cellValue.v as IluckySheetCelldataValue ).f = func;\r\n                    \r\n                    //\r\n                    let chain = new LuckysheetCalcChain();\r\n                    chain.r = cellValue.r;\r\n                    chain.c = cellValue.c;\r\n                    chain.index = this.index;\r\n                    this.calcChain.push(chain);\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        //There may be formulas that do not appear in calcChain\r\n        for(let key in cellOtherInfo.formulaList){\r\n            if(!(key in formulaListExist)){\r\n                let formulaListItem = cellOtherInfo.formulaList[key];\r\n                let chain = new LuckysheetCalcChain();\r\n                chain.r = formulaListItem.r;\r\n                chain.c = formulaListItem.c;\r\n                chain.index = this.index;\r\n                this.calcChain.push(chain);\r\n            }\r\n        }\r\n\r\n        // hyperlink config\r\n        this.hyperlink = this.generateConfigHyperlinks();\r\n      \r\n        // sheet hide\r\n        this.hide = this.hide;\r\n\r\n        if(this.mergeCells!=null){\r\n            for(let i=0;i<this.mergeCells.length;i++){\r\n                let merge = this.mergeCells[i], attrList = merge.attributeList;\r\n                let ref = attrList.ref;\r\n                if(ref==null){\r\n                    continue;\r\n                }\r\n                let range = getcellrange(ref, this.sheetList, sheetId);\r\n                let mergeValue = new LuckySheetConfigMerge();\r\n                mergeValue.r = range.row[0];\r\n                mergeValue.c = range.column[0];\r\n                mergeValue.rs = range.row[1]-range.row[0]+1;\r\n                mergeValue.cs = range.column[1]-range.column[0]+1;\r\n                if(this.config.merge==null){\r\n                    this.config.merge = {};\r\n                }\r\n                this.config.merge[range.row[0] + \"_\" + range.column[0]] = mergeValue;\r\n            }\r\n        }\r\n\r\n        let drawingFile = allFileOption.drawingFile, drawingRelsFile = allFileOption.drawingRelsFile;\r\n        if(drawingFile!=null && drawingRelsFile!=null){\r\n            let twoCellAnchors = this.readXml.getElementsByTagName(\"xdr:twoCellAnchor\", drawingFile);\r\n\r\n            if(twoCellAnchors!=null && twoCellAnchors.length>0){\r\n                for(let i=0;i<twoCellAnchors.length;i++){\r\n                    let twoCellAnchor = twoCellAnchors[i];\r\n                    let editAs = getXmlAttibute(twoCellAnchor.attributeList, \"editAs\", \"twoCell\");\r\n\r\n                    let xdrFroms = twoCellAnchor.getInnerElements(\"xdr:from\"), xdrTos = twoCellAnchor.getInnerElements(\"xdr:to\");\r\n\r\n                    let xdr_blipfills = twoCellAnchor.getInnerElements(\"a:blip\");\r\n                    if(xdrFroms!=null && xdr_blipfills!=null && xdrFroms.length>0 && xdr_blipfills.length>0){\r\n                        let xdrFrom = xdrFroms[0], xdrTo = xdrTos[0],xdr_blipfill = xdr_blipfills[0];\r\n                        \r\n                        let rembed = getXmlAttibute(xdr_blipfill.attributeList, \"r:embed\", null);\r\n\r\n                        let imageObject = this.getBase64ByRid(rembed, drawingRelsFile);\r\n                        if (!imageObject) {\r\n                            return;\r\n                        }\r\n\r\n\r\n                        // let aoff = xdr_xfrm.getInnerElements(\"a:off\"), aext = xdr_xfrm.getInnerElements(\"a:ext\");\r\n\r\n                        \r\n\r\n                        // if(aoff!=null && aext!=null && aoff.length>0 && aext.length>0){\r\n                        //     let aoffAttribute = aoff[0].attributeList, aextAttribute = aext[0].attributeList;\r\n                        //     let x = getXmlAttibute(aoffAttribute, \"x\", null);\r\n                        //     let y = getXmlAttibute(aoffAttribute, \"y\", null);\r\n\r\n                        //     let cx = getXmlAttibute(aextAttribute, \"cx\", null);\r\n                        //     let cy = getXmlAttibute(aextAttribute, \"cy\", null);\r\n\r\n                        //     if(x!=null && y!=null && cx!=null && cy!=null && imageObject !=null){\r\n                        // let x_n = getPxByEMUs(parseInt(x), \"c\"),y_n = getPxByEMUs(parseInt(y));\r\n                        // let cx_n = getPxByEMUs(parseInt(cx), \"c\"),cy_n = getPxByEMUs(parseInt(cy));\r\n\r\n                        let x_n =0,y_n = 0;\r\n                        let cx_n = 0, cy_n = 0;\r\n\r\n                        imageObject.fromCol = this.getXdrValue(xdrFrom.getInnerElements(\"xdr:col\"));\r\n                        imageObject.fromColOff = getPxByEMUs(this.getXdrValue(xdrFrom.getInnerElements(\"xdr:colOff\")));\r\n                        imageObject.fromRow= this.getXdrValue(xdrFrom.getInnerElements(\"xdr:row\"));\r\n                        imageObject.fromRowOff = getPxByEMUs(this.getXdrValue(xdrFrom.getInnerElements(\"xdr:rowOff\")));\r\n\r\n                        imageObject.toCol = this.getXdrValue(xdrTo.getInnerElements(\"xdr:col\"));\r\n                        imageObject.toColOff = getPxByEMUs(this.getXdrValue(xdrTo.getInnerElements(\"xdr:colOff\")));\r\n                        imageObject.toRow = this.getXdrValue(xdrTo.getInnerElements(\"xdr:row\"));\r\n                        imageObject.toRowOff = getPxByEMUs(this.getXdrValue(xdrTo.getInnerElements(\"xdr:rowOff\")));\r\n\r\n                        imageObject.originWidth = cx_n;\r\n                        imageObject.originHeight = cy_n;\r\n                        \r\n                        if(editAs==\"absolute\"){\r\n                            imageObject.type = \"3\";\r\n                        }\r\n                        else if(editAs==\"oneCell\"){\r\n                            imageObject.type = \"2\";\r\n                        }\r\n                        else{\r\n                            imageObject.type = \"1\";\r\n                        }\r\n\r\n                        imageObject.isFixedPos = false;\r\n                        imageObject.fixedLeft = 0;\r\n                        imageObject.fixedTop = 0;\r\n\r\n                        let imageBorder:IluckyImageBorder = {\r\n                            color: \"#000\",\r\n                            radius: 0,\r\n                            style: \"solid\",\r\n                            width: 0\r\n                        }\r\n                        imageObject.border = imageBorder;\r\n\r\n                        let imageCrop:IluckyImageCrop = {\r\n                            height: cy_n,\r\n                            offsetLeft: 0,\r\n                            offsetTop: 0,\r\n                            width: cx_n\r\n                        }\r\n                        imageObject.crop = imageCrop;\r\n\r\n                        let imageDefault:IluckyImageDefault = {\r\n                            height: cy_n,\r\n                            left: x_n,\r\n                            top: y_n,\r\n                            width: cx_n\r\n                        }\r\n                        imageObject.default = imageDefault;\r\n\r\n                        if(this.images==null){\r\n                            this.images = {};\r\n                        }\r\n                        this.images[generateRandomIndex(\"image\")] = imageObject;\r\n                        //     }\r\n                        // }\r\n                    }\r\n                }\r\n            }\r\n            \r\n        } \r\n    }\r\n\r\n    private getXdrValue(ele:Element[]):number{\r\n        if(ele==null || ele.length==0){\r\n            return null;\r\n        }\r\n\r\n        return parseInt(ele[0].value);\r\n    }\r\n\r\n    private getBase64ByRid(rid:string, drawingRelsFile:string){\r\n        let Relationships = this.readXml.getElementsByTagName(\"Relationships/Relationship\", drawingRelsFile);\r\n\r\n        if(Relationships!=null && Relationships.length>0){\r\n            for(let i=0;i<Relationships.length;i++){\r\n                let Relationship = Relationships[i];\r\n                let attrList = Relationship.attributeList;\r\n                let Id = getXmlAttibute(attrList, \"Id\", null);\r\n                let src = getXmlAttibute(attrList, \"Target\", null);\r\n                if(Id == rid){\r\n                    src = src.replace(/\\.\\.\\//g, \"\");\r\n                    src = \"xl/\" + src;\r\n                    let imgage = this.imageList.getImageByName(src);\r\n                    return imgage;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n    * @desc This will convert cols/col to luckysheet config of column'width\r\n    */\r\n    private generateConfigColumnLenAndHidden(){\r\n        let cols = this.readXml.getElementsByTagName(\"cols/col\", this.sheetFile);\r\n        for(let i=0;i<cols.length;i++){\r\n            let col = cols[i], attrList = col.attributeList;\r\n            let min = getXmlAttibute(attrList, \"min\", null);\r\n            let max = getXmlAttibute(attrList, \"max\", null);\r\n            let width = getXmlAttibute(attrList, \"width\", null);\r\n            let hidden = getXmlAttibute(attrList, \"hidden\", null);\r\n            let customWidth = getXmlAttibute(attrList, \"customWidth\", null);\r\n\r\n\r\n            if(min==null || max==null){\r\n                continue;\r\n            }\r\n\r\n            let minNum = parseInt(min)-1, maxNum=parseInt(max)-1, widthNum=parseFloat(width);\r\n            \r\n            for(let m=minNum;m<=maxNum;m++){\r\n                if(width!=null){\r\n                    if(this.config.columnlen==null){\r\n                        this.config.columnlen = {};\r\n                    }\r\n                    this.config.columnlen[m] = getColumnWidthPixel(widthNum);\r\n                }\r\n\r\n                if(hidden==\"1\"){\r\n                    if(this.config.colhidden==null){\r\n                        this.config.colhidden = {};\r\n                    }\r\n                    this.config.colhidden[m] = 0;\r\n\r\n                    if(this.config.columnlen){\r\n                        delete this.config.columnlen[m];\r\n                    }\r\n                    \r\n                }\r\n\r\n                if(customWidth!=null){\r\n                    if(this.config.customWidth==null){\r\n                        this.config.customWidth = {};\r\n                    }\r\n                    this.config.customWidth[m] = 1;\r\n                }\r\n            } \r\n        }\r\n    }\r\n\r\n    /**\r\n    * @desc This will convert cols/col to luckysheet config of column'width\r\n    */\r\n    private generateConfigRowLenAndHiddenAddCell():IcellOtherInfo{\r\n        let rows = this.readXml.getElementsByTagName(\"sheetData/row\", this.sheetFile);\r\n        let cellOtherInfo:IcellOtherInfo = {};\r\n        let formulaList:IformulaList = {};\r\n        cellOtherInfo.formulaList = formulaList;\r\n        for(let i=0;i<rows.length;i++){\r\n            let row = rows[i], attrList = row.attributeList;\r\n            let rowNo = getXmlAttibute(attrList, \"r\", null);\r\n            let height = getXmlAttibute(attrList, \"ht\", null);\r\n            let hidden = getXmlAttibute(attrList, \"hidden\", null);\r\n            let customHeight = getXmlAttibute(attrList, \"customHeight\", null);\r\n\r\n            if(rowNo==null){\r\n                continue;\r\n            }\r\n\r\n            let rowNoNum = parseInt(rowNo) - 1;\r\n            if(height!=null){\r\n                let heightNum = parseFloat(height);\r\n                if(this.config.rowlen==null){\r\n                    this.config.rowlen = {};\r\n                }\r\n                this.config.rowlen[rowNoNum] = getRowHeightPixel(heightNum);\r\n            }\r\n\r\n            if(hidden==\"1\"){\r\n                if(this.config.rowhidden==null){\r\n                    this.config.rowhidden = {};\r\n                }\r\n                this.config.rowhidden[rowNoNum] = 0;\r\n                \r\n                if(this.config.rowlen){\r\n                    delete this.config.rowlen[rowNoNum];\r\n                }\r\n                \r\n            }\r\n\r\n            if(customHeight!=null){\r\n                if(this.config.customHeight==null){\r\n                    this.config.customHeight = {};\r\n                }\r\n                this.config.customHeight[rowNoNum] = 1;\r\n            }\r\n\r\n\r\n            if(this.isInitialCell){\r\n                let cells = row.getInnerElements(\"c\");\r\n                for(let key in cells){\r\n                    let cell = cells[key];\r\n                    let cellValue = new LuckySheetCelldata(cell, this.styles, this.sharedStrings, this.mergeCells,this.sheetFile, this.readXml);\r\n                    if(cellValue._borderObject!=null){\r\n                        if(this.config.borderInfo==null){\r\n                            this.config.borderInfo = [];\r\n                        }\r\n                        this.config.borderInfo.push(cellValue._borderObject);\r\n                        delete cellValue._borderObject;\r\n                    }\r\n                    \r\n                    // let borderId = cellValue._borderId;\r\n                    // if(borderId!=null){\r\n                    //     let borders = this.styles[\"borders\"] as Element[];\r\n                    //     if(this.config._borderInfo==null){\r\n                    //         this.config._borderInfo = {};\r\n                    //     }\r\n                    //     if( borderId in this.config._borderInfo){\r\n                    //         this.config._borderInfo[borderId].cells.push(cellValue.r + \"_\" + cellValue.c);\r\n                    //     }\r\n                    //     else{\r\n                    //         let border = borders[borderId];\r\n                    //         let borderObject = new LuckySheetborderInfoCellForImp();\r\n                    //         borderObject.rangeType = \"cellGroup\";\r\n                    //         borderObject.cells = [];\r\n                    //         let borderCellValue = new LuckySheetborderInfoCellValue();\r\n                            \r\n                    //         let lefts = border.getInnerElements(\"left\");\r\n                    //         let rights = border.getInnerElements(\"right\");\r\n                    //         let tops = border.getInnerElements(\"top\");\r\n                    //         let bottoms = border.getInnerElements(\"bottom\");\r\n                    //         let diagonals = border.getInnerElements(\"diagonal\");\r\n\r\n                    //         let left = this.getBorderInfo(lefts);\r\n                    //         let right = this.getBorderInfo(rights);\r\n                    //         let top = this.getBorderInfo(tops);\r\n                    //         let bottom = this.getBorderInfo(bottoms);\r\n                    //         let diagonal = this.getBorderInfo(diagonals);\r\n\r\n                    //         let isAdd = false;\r\n                    //         if(left!=null && left.color!=null){\r\n                    //             borderCellValue.l = left;\r\n                    //             isAdd = true;\r\n                    //         }\r\n\r\n                    //         if(right!=null && right.color!=null){\r\n                    //             borderCellValue.r = right;\r\n                    //             isAdd = true;\r\n                    //         }\r\n\r\n                    //         if(top!=null && top.color!=null){\r\n                    //             borderCellValue.t = top;\r\n                    //             isAdd = true;\r\n                    //         }\r\n\r\n                    //         if(bottom!=null && bottom.color!=null){\r\n                    //             borderCellValue.b = bottom;\r\n                    //             isAdd = true;\r\n                    //         }\r\n\r\n                    //         if(isAdd){\r\n                    //             borderObject.value = borderCellValue;\r\n                    //             this.config._borderInfo[borderId] = borderObject;\r\n                    //         }\r\n\r\n                    //     }\r\n                    // }\r\n                    if(cellValue._formulaType==\"shared\"){\r\n                        if(this.formulaRefList==null){\r\n                            this.formulaRefList = {};\r\n                        }\r\n\r\n                        if(this.formulaRefList[cellValue._formulaSi]==null){\r\n                            this.formulaRefList[cellValue._formulaSi] = {}\r\n                        }\r\n\r\n                        let fv;\r\n                        if(cellValue.v!=null){\r\n                            fv = (cellValue.v as IluckySheetCelldataValue).f;\r\n                        }\r\n\r\n                        let refValue = {\r\n                            t:cellValue._formulaType,\r\n                            ref:cellValue._fomulaRef,\r\n                            si:cellValue._formulaSi,\r\n                            fv:fv,\r\n                            cellValue:cellValue\r\n                        }\r\n\r\n                        if(cellValue._fomulaRef!=null){\r\n                            this.formulaRefList[cellValue._formulaSi][\"mainRef\"] = refValue;\r\n                        }\r\n                        else{\r\n                            this.formulaRefList[cellValue._formulaSi][cellValue.r+\"_\"+cellValue.c] = refValue;\r\n                        }\r\n\r\n                        // console.log(refValue, this.formulaRefList);\r\n                    }\r\n\r\n                    //There may be formulas that do not appear in calcChain\r\n                    if(cellValue.v!=null && (cellValue.v as IluckySheetCelldataValue).f!=null){\r\n                        let formulaCell:IformulaListItem = {\r\n                            r:cellValue.r,\r\n                            c:cellValue.c\r\n                        }\r\n                        cellOtherInfo.formulaList[\"r\"+cellValue.r+\"c\"+cellValue.c] = formulaCell;\r\n                    }\r\n\r\n                    this.celldata.push(cellValue);\r\n                }\r\n                \r\n            }\r\n        }\r\n\r\n        return cellOtherInfo;\r\n    }\r\n  \r\n    /**\r\n     * luckysheet config of hyperlink\r\n     * \r\n     * @returns {IluckysheetHyperlink} - hyperlink config\r\n     */\r\n    private generateConfigHyperlinks(): IluckysheetHyperlink {\r\n      let rows = this.readXml.getElementsByTagName(\r\n        \"hyperlinks/hyperlink\",\r\n        this.sheetFile\r\n      );\r\n      let hyperlink: IluckysheetHyperlink = {};\r\n      for (let i = 0; i < rows.length; i++) {\r\n        let row = rows[i];\r\n        let attrList = row.attributeList;\r\n        let ref = getXmlAttibute(attrList, \"ref\", null),\r\n            refArr = getMultiSequenceToNum(ref),\r\n            _display = getXmlAttibute(attrList, \"display\", null),\r\n            _address = getXmlAttibute(attrList, \"location\", null),\r\n            _tooltip = getXmlAttibute(attrList, \"tooltip\", null);\r\n        let _type: IluckysheetHyperlinkType = _address ? \"internal\" : \"external\";\r\n  \r\n        // external hyperlink\r\n        if (!_address) {\r\n          let rid = attrList[\"r:id\"];\r\n          let sheetFile = this.sheetFile;\r\n          let relationshipList = this.readXml.getElementsByTagName(\r\n            \"Relationships/Relationship\",\r\n            `xl/worksheets/_rels/${sheetFile.replace(worksheetFilePath, \"\")}.rels`\r\n          );\r\n  \r\n          const findRid = relationshipList?.find(\r\n            (e) => e.attributeList[\"Id\"] === rid\r\n          );\r\n\r\n          if (findRid) {\r\n            _address = findRid.attributeList[\"Target\"];\r\n            _type = findRid.attributeList[\r\n              \"TargetMode\"\r\n            ]?.toLocaleLowerCase() as IluckysheetHyperlinkType;\r\n          }\r\n        }\r\n\r\n        // match R1C1\r\n        const addressReg = new RegExp(/^.*!R([\\d$])+C([\\d$])*$/g)\r\n        if (addressReg.test(_address)) {\r\n          _address = getTransR1C1ToSequence(_address);\r\n        }\r\n        \r\n        // dynamically add hyperlinks\r\n        for (const ref of refArr) {\r\n          hyperlink[ref] = {\r\n            linkAddress: _address,\r\n            linkTooltip: _tooltip || \"\",\r\n            linkType: _type,\r\n            display: _display || \"\",\r\n          };\r\n        }\r\n      }\r\n      \r\n      return hyperlink;\r\n    }\r\n\r\n    // private getBorderInfo(borders:Element[]):LuckySheetborderInfoCellValueStyle{\r\n    //     if(borders==null){\r\n    //         return null;\r\n    //     }\r\n\r\n    //     let border = borders[0], attrList = border.attributeList;\r\n    //     let clrScheme = this.styles[\"clrScheme\"] as Element[];\r\n    //     let style:string = attrList.style;\r\n    //     if(style==null || style==\"none\"){\r\n    //         return null;\r\n    //     }\r\n\r\n    //     let colors = border.getInnerElements(\"color\");\r\n    //     let colorRet = \"#000000\";\r\n    //     if(colors!=null){\r\n    //         let color = colors[0];\r\n    //         colorRet = getColor(color, clrScheme);\r\n    //     }\r\n\r\n    //     let ret = new LuckySheetborderInfoCellValueStyle();\r\n    //     ret.style = borderTypes[style];\r\n    //     ret.color = colorRet;\r\n\r\n    //     return ret;\r\n    // }\r\n}\r\n","import {IuploadfileList, IattributeList, stringToNum} from \"../ICommon\";\r\nimport {indexedColors}  from \"../common/constant\";\r\nimport {LightenDarkenColor}  from \"../common/method\";\r\n\r\n\r\nclass xmloperation {\r\n    /**\r\n    * @param tag Search xml tag name , div,title etc.\r\n    * @param file Xml string\r\n    * @return Xml element string \r\n    */\r\n    protected getElementsByOneTag(tag:string, file:string):string[]{\r\n        //<a:[^/>: ]+?>.*?</a:[^/>: ]+?>\r\n        let readTagReg;\r\n        if(tag.indexOf(\"|\")>-1){\r\n            let tags = tag.split(\"|\"), tagsRegTxt=\"\";\r\n            for(let i=0;i<tags.length;i++){\r\n                let t = tags[i];\r\n                tagsRegTxt += \"|<\"+ t +\" [^>]+?[^/]>[\\\\s\\\\S]*?</\"+ t +\">|<\"+ t +\" [^>]+?/>|<\"+ t +\">[\\\\s\\\\S]*?</\"+ t +\">|<\"+ t +\"/>\";\r\n            }\r\n            tagsRegTxt = tagsRegTxt.substr(1, tagsRegTxt.length);\r\n            readTagReg = new RegExp(tagsRegTxt, \"g\");\r\n        }\r\n        else{\r\n            readTagReg = new RegExp(\"<\"+ tag +\" [^>]+?[^/]>[\\\\s\\\\S]*?</\"+ tag +\">|<\"+ tag +\" [^>]+?/>|<\"+ tag +\">[\\\\s\\\\S]*?</\"+ tag +\">|<\"+ tag +\"/>\", \"g\");\r\n        }\r\n        \r\n        let ret = file.match(readTagReg);\r\n        if(ret==null){\r\n            return [];\r\n        }\r\n        else{\r\n            return ret;\r\n        }\r\n    }\r\n}\r\n\r\nexport class ReadXml extends xmloperation{\r\n    originFile:IuploadfileList\r\n    constructor(files:IuploadfileList){\r\n        super();\r\n        this.originFile = files;\r\n    }\r\n    /**\r\n    * @param path Search xml tag group , div,title etc.\r\n    * @param fileName One of uploadfileList, uploadfileList is file group, {key:value}\r\n    * @return Xml element calss\r\n    */\r\n    getElementsByTagName(path:string, fileName:string): Element[]{\r\n        \r\n        let file = this.getFileByName(fileName);\r\n        let pathArr = path.split(\"/\"), ret:string[] | string;\r\n        for(let key in pathArr){\r\n            let path = pathArr[key];\r\n            if(ret==undefined){\r\n                ret = this.getElementsByOneTag(path,file);\r\n            }\r\n            else{\r\n                if(ret instanceof Array){\r\n                    let items:string[]=[];\r\n                    for(let key in ret){\r\n                        let item = ret[key];\r\n                        items = items.concat(this.getElementsByOneTag(path,item));\r\n                    }\r\n                    ret = items;\r\n                }\r\n                else{\r\n                    ret = this.getElementsByOneTag(path,ret);\r\n                }\r\n            }\r\n        }\r\n\r\n        let elements:Element[] = [];\r\n\r\n        for(let i=0;i<ret.length;i++){\r\n            let ele = new Element(ret[i]);\r\n            elements.push(ele);\r\n        }\r\n\r\n        return elements;\r\n    }\r\n\r\n    /**\r\n    * @param name One of uploadfileList's name, search for file by this parameter\r\n    * @retrun Select a file from uploadfileList\r\n    */\r\n    private getFileByName(name:string):string{\r\n        for(let fileKey in this.originFile){\r\n            if(fileKey.indexOf(name)>-1){\r\n                return this.originFile[fileKey];\r\n            }\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    \r\n}\r\n\r\nexport class Element extends xmloperation {\r\n    elementString:string\r\n    attributeList:IattributeList\r\n    value:string\r\n    container:string\r\n    constructor(str:string){\r\n        super();\r\n        this.elementString = str;\r\n        this.setValue();\r\n        const readAttrReg = new RegExp('[a-zA-Z0-9_:]*?=\".*?\"', \"g\");\r\n        let attrList = this.container.match(readAttrReg);\r\n        this.attributeList = {};\r\n        if(attrList!=null){\r\n            for(let key in attrList){\r\n                let attrFull = attrList[key];\r\n                // let al= attrFull.split(\"=\");\r\n                if(attrFull.length==0){\r\n                    continue;\r\n                }\r\n                let attrKey = attrFull.substr(0, attrFull.indexOf('='));\r\n                let attrValue = attrFull.substr(attrFull.indexOf('=') + 1);\r\n                if(attrKey==null || attrValue==null ||attrKey.length==0 || attrValue.length==0){\r\n                    continue;\r\n                }\r\n                this.attributeList[attrKey] = attrValue.substr(1, attrValue.length-2);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @param name Get attribute by key in element\r\n    * @return Single attribute\r\n    */\r\n    get(name:string):string|number|boolean{\r\n        return this.attributeList[name];\r\n    }\r\n\r\n    /**\r\n    * @param tag Get elements by tag in elementString\r\n    * @return Element group\r\n    */\r\n    getInnerElements(tag:string):Element[]{\r\n        let ret = this.getElementsByOneTag(tag,this.elementString);\r\n        let elements:Element[] = [];\r\n\r\n        for(let i=0;i<ret.length;i++){\r\n            let ele = new Element(ret[i]);\r\n            elements.push(ele);\r\n        }\r\n\r\n        if(elements.length==0){\r\n            return null;\r\n        }\r\n        return elements;\r\n    }\r\n\r\n    /**\r\n    * @desc get xml dom value and container, <container>value</container>\r\n    */\r\n    private setValue(){\r\n        let str = this.elementString;\r\n        if(str.substr(str.length-2, 2)==\"/>\"){\r\n            this.value = \"\";\r\n            this.container = str;\r\n        }\r\n        else{\r\n            let firstTag = this.getFirstTag();\r\n            const firstTagReg = new RegExp(\"(<\"+ firstTag +\" [^>]+?[^/]>)([\\\\s\\\\S]*?)</\"+ firstTag +\">|(<\"+ firstTag +\">)([\\\\s\\\\S]*?)</\"+ firstTag +\">\", \"g\");\r\n            let result = firstTagReg.exec(str);\r\n            if (result != null) {\r\n                if(result[1]!=null){\r\n                    this.container = result[1];\r\n                    this.value = result[2];\r\n                }\r\n                else{\r\n                    this.container = result[3];\r\n                    this.value = result[4];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @desc get xml dom first tag, <a><b></b></a>, get a\r\n    */\r\n    private getFirstTag(){\r\n        let str = this.elementString;\r\n        let firstTag = str.substr(0, str.indexOf(' '));\r\n        if(firstTag==\"\" || firstTag.indexOf(\">\")>-1){\r\n            firstTag = str.substr(0, str.indexOf('>'));\r\n        }\r\n        firstTag = firstTag.substr(1,firstTag.length);\r\n        return firstTag;\r\n    }\r\n}\r\n\r\n\r\nexport interface IStyleCollections {\r\n    [index:string]:Element[] | IattributeList\r\n}\r\n\r\nfunction combineIndexedColor(indexedColorsInner:Element[], indexedColors:IattributeList):IattributeList{\r\n    let ret:IattributeList = {};\r\n    if(indexedColorsInner==null || indexedColorsInner.length==0){\r\n        return indexedColors;\r\n    }\r\n    for(let key in indexedColors){\r\n        let value = indexedColors[key], kn = parseInt(key);\r\n        let inner = indexedColorsInner[kn];\r\n        if(inner==null){\r\n            ret[key] = value;\r\n        }\r\n        else{\r\n            let rgb = inner.attributeList.rgb;\r\n            ret[key] = rgb;\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\n//clrScheme:Element[]\r\nexport function getColor(color:Element, styles:IStyleCollections , type:string=\"g\"){\r\n    let attrList = color.attributeList;\r\n    let clrScheme = styles[\"clrScheme\"] as Element[];\r\n    let indexedColorsInner = styles[\"indexedColors\"] as Element[];\r\n    let mruColorsInner = styles[\"mruColors\"];\r\n    let indexedColorsList = combineIndexedColor(indexedColorsInner, indexedColors);\r\n    let indexed = attrList.indexed, rgb = attrList.rgb, theme = attrList.theme, tint = attrList.tint;\r\n    let bg;\r\n    if(indexed!=null){\r\n        let indexedNum = parseInt(indexed);\r\n        bg = indexedColorsList[indexedNum];\r\n        if(bg!=null){\r\n            bg = bg.substring(bg.length-6, bg.length);\r\n            bg = \"#\"+bg;\r\n        }\r\n    }\r\n    else if(rgb!=null){\r\n        rgb = rgb.substring(rgb.length-6, rgb.length);\r\n        bg = \"#\"+rgb;\r\n    }\r\n    else if(theme!=null){\r\n        let themeNum = parseInt(theme);\r\n        if(themeNum==0){\r\n            themeNum = 1;\r\n        }\r\n        else if(themeNum==1){\r\n            themeNum = 0;\r\n        }\r\n        else if(themeNum==2){\r\n            themeNum = 3;\r\n        }\r\n        else if(themeNum==3){\r\n            themeNum = 2;\r\n        }\r\n        let clrSchemeElement = clrScheme[themeNum];\r\n        if(clrSchemeElement!=null){\r\n            let clrs = clrSchemeElement.getInnerElements(\"a:sysClr|a:srgbClr\");\r\n            if(clrs!=null){\r\n                let clr = clrs[0];\r\n                let clrAttrList = clr.attributeList;\r\n                // console.log(clr.container, );\r\n                if(clr.container.indexOf(\"sysClr\")>-1){\r\n                    // if(type==\"g\" && clrAttrList.val==\"windowText\"){\r\n                    //     bg = null;\r\n                    // }\r\n                    // else if((type==\"t\" || type==\"b\") && clrAttrList.val==\"window\"){\r\n                    //     bg = null;\r\n                    // }                    \r\n                    // else \r\n                    if(clrAttrList.lastClr!=null){\r\n                        bg = \"#\" + clrAttrList.lastClr;\r\n                    }\r\n                    else if(clrAttrList.val!=null){\r\n                        bg = \"#\" + clrAttrList.val;\r\n                    }\r\n\r\n                }\r\n                else if(clr.container.indexOf(\"srgbClr\")>-1){\r\n                    // console.log(clrAttrList.val);\r\n                    bg = \"#\" + clrAttrList.val;\r\n                }\r\n            }\r\n        }\r\n        \r\n    }\r\n    \r\n    if(tint!=null){\r\n        let tintNum = parseFloat(tint);\r\n        if(bg!=null){\r\n            bg = LightenDarkenColor(bg, tintNum);\r\n        }\r\n    }\r\n\r\n    return bg;\r\n}\r\n\r\n\r\n/** \r\n * @dom xml attribute object\r\n * @attr attribute name\r\n * @d if attribute is null, return default value \r\n * @return attribute value\r\n*/\r\nexport function getlineStringAttr(frpr:Element, attr:string):string{\r\n    let attrEle = frpr.getInnerElements(attr), value;\r\n\r\n    if(attrEle!=null && attrEle.length>0){\r\n        if(attr==\"b\" || attr==\"i\" || attr==\"strike\"){\r\n            value = \"1\";\r\n        }\r\n        else if(attr==\"u\"){\r\n            let v = attrEle[0].attributeList.val;\r\n            if(v==\"double\"){\r\n                value=\"2\";\r\n            }\r\n            elseif(v==\"singleAccounting\"){\r\n                value=\"3\";\r\n            }\r\n            elseif(v==\"doubleAccounting\"){\r\n                value=\"4\";\r\n            }\r\n            else{\r\n                value = \"1\";\r\n            }\r\n        }\r\n        else if(attr==\"vertAlign\"){\r\n            let v = attrEle[0].attributeList.val;\r\n            if(v==\"subscript\"){\r\n                value = \"1\";\r\n            }\r\n            else if(v==\"superscript\"){\r\n                value = \"2\";\r\n            }\r\n        }\r\n        else{\r\n            value = attrEle[0].attributeList.val;\r\n        }\r\n        \r\n    }\r\n\r\n    return value;\r\n}","import {stringToNum, IattributeList, numTostring} from \"../ICommon\";\r\n\r\nexport const columeHeader_word:string[] = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\r\n\r\nexport const columeHeader_word_index:stringToNum = { 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7, 'I': 8, 'J': 9, 'K': 10, 'L': 11, 'M': 12, 'N': 13, 'O': 14, 'P': 15, 'Q': 16, 'R': 17, 'S': 18, 'T': 19, 'U': 20, 'V': 21, 'W': 22, 'X': 23, 'Y': 24, 'Z': 25 };\r\n\r\nexport const coreFile = \"docProps/core.xml\";\r\nexport const appFile = \"docProps/app.xml\";\r\nexport const contentTypesFile = \"[Content_Types].xml\";\r\nexport const workBookFile = \"xl/workbook.xml\";\r\nexport const calcChainFile = \"xl/calcChain.xml\";\r\nexport const stylesFile = \"xl/styles.xml\";\r\nexport const sharedStringsFile = \"xl/sharedStrings.xml\";\r\nexport const worksheetFilePath = \"xl/worksheets/\";\r\nexport const theme1File = \"xl/theme/theme1.xml\";\r\nexport const workbookRels= \"xl/_rels/workbook.xml.rels\";\r\n\r\n\r\n\r\n\r\n//Excel Built-In cell type\r\nexport const ST_CellType:IattributeList ={\r\n    \"Boolean\":\"b\",\r\n    \"Date\":\"d\",\r\n    \"Error\":\"e\",\r\n    \"InlineString\":\"inlineStr\",\r\n    \"Number\":\"n\",\r\n    \"SharedString\":\"s\",\r\n    \"String\":\"str\",\r\n}\r\n\r\n//Excel Built-In cell style\r\nexport const BuiltInCellStyles:IattributeList = {\r\n    \"0\":\"Normal\",\r\n\r\n}\r\n\r\n\r\nexport let numFmtDefault:IattributeList = {\r\n    \"0\":'General',\r\n    \"1\": '0',\r\n    \"2\": '0.00',\r\n    \"3\": '#,##0',\r\n    \"4\": '#,##0.00',\r\n    \"9\":'0%',\r\n    \"10\": '0.00%',\r\n    \"11\": '0.00E+00',\r\n    \"12\": '# ?/?',\r\n    \"13\": '# ??/??',\r\n    \"14\": 'm/d/yy',\r\n    \"15\": 'd-mmm-yy',\r\n    \"16\": 'd-mmm',\r\n    \"17\": 'mmm-yy',\r\n    \"18\": 'h:mm AM/PM',\r\n    \"19\": 'h:mm:ss AM/PM',\r\n    \"20\": 'h:mm',\r\n    \"21\": 'h:mm:ss',\r\n    \"22\": 'm/d/yy h:mm',\r\n    \"37\": '#,##0 ;(#,##0)',\r\n    \"38\": '#,##0 ;[Red](#,##0)',\r\n    \"39\": '#,##0.00;(#,##0.00)',\r\n    \"40\": '#,##0.00;[Red](#,##0.00)',\r\n    \"45\": 'mm:ss',\r\n    \"46\": '[h]:mm:ss',\r\n    \"47\": 'mmss.0',\r\n    \"48\": '##0.0E+0',\r\n    \"49\": '@'\r\n}\r\n\r\nexport const indexedColors:IattributeList = {\r\n    \"0\":'00000000',\r\n    \"1\":'00FFFFFF',\r\n    \"2\":'00FF0000',\r\n    \"3\":'0000FF00',\r\n    \"4\":'000000FF',\r\n    \"5\":'00FFFF00',\r\n    \"6\":'00FF00FF',\r\n    \"7\":'0000FFFF',\r\n    \"8\":'00000000',\r\n    \"9\":'00FFFFFF',\r\n    \"10\":'00FF0000',\r\n    \"11\":'0000FF00',\r\n    \"12\":'000000FF',\r\n    \"13\":'00FFFF00',\r\n    \"14\":'00FF00FF',\r\n    \"15\":'0000FFFF',\r\n    \"16\":'00800000',\r\n    \"17\":'00008000',\r\n    \"18\":'00000080',\r\n    \"19\":'00808000',\r\n    \"20\":'00800080',\r\n    \"21\":'00008080',\r\n    \"22\":'00C0C0C0',\r\n    \"23\":'00808080',\r\n    \"24\":'009999FF',\r\n    \"25\":'00993366',\r\n    \"26\":'00FFFFCC',\r\n    \"27\":'00CCFFFF',\r\n    \"28\":'00660066',\r\n    \"29\":'00FF8080',\r\n    \"30\":'000066CC',\r\n    \"31\":'00CCCCFF',\r\n    \"32\":'00000080',\r\n    \"33\":'00FF00FF',\r\n    \"34\":'00FFFF00',\r\n    \"35\":'0000FFFF',\r\n    \"36\":'00800080',\r\n    \"37\":'00800000',\r\n    \"38\":'00008080',\r\n    \"39\":'000000FF',\r\n    \"40\":'0000CCFF',\r\n    \"41\":'00CCFFFF',\r\n    \"42\":'00CCFFCC',\r\n    \"43\":'00FFFF99',\r\n    \"44\":'0099CCFF',\r\n    \"45\":'00FF99CC',\r\n    \"46\":'00CC99FF',\r\n    \"47\":'00FFCC99',\r\n    \"48\":'003366FF',\r\n    \"49\":'0033CCCC',\r\n    \"50\":'0099CC00',\r\n    \"51\":'00FFCC00',\r\n    \"52\":'00FF9900',\r\n    \"53\":'00FF6600',\r\n    \"54\":'00666699',\r\n    \"55\":'00969696',\r\n    \"56\":'00003366',\r\n    \"57\":'00339966',\r\n    \"58\":'00003300',\r\n    \"59\":'00333300',\r\n    \"60\":'00993300',\r\n    \"61\":'00993366',\r\n    \"62\":'00333399',\r\n    \"63\":'00333333',\r\n    \"64\":null,//system Foreground n/a\r\n    \"65\":null,//system Background n/a\r\n}\r\n\r\nexport const OEM_CHARSET:IattributeList = {\r\n    \"0\": \"ANSI_CHARSET\",\r\n    \"1\": \"DEFAULT_CHARSET\",\r\n    \"2\": \"SYMBOL_CHARSET\",\r\n    \"77\": \"MAC_CHARSET\",\r\n    \"128\": \"SHIFTJIS_CHARSET\",\r\n    \"129\": \"HANGUL_CHARSET\",\r\n    \"130\": \"JOHAB_CHARSET\",\r\n    \"134\": \"GB2312_CHARSET\",\r\n    \"136\": \"CHINESEBIG5_CHARSET\",\r\n    \"161\": \"GREEK_CHARSET\",\r\n    \"162\": \"TURKISH_CHARSET\",\r\n    \"163\": \"VIETNAMESE_CHARSET\",\r\n    \"177\": \"HEBREW_CHARSET\",\r\n    \"178\": \"ARABIC_CHARSET\",\r\n    \"186\": \"BALTIC_CHARSET\",\r\n    \"204\": \"RUSSIAN_CHARSET\",\r\n    \"222\": \"THAI_CHARSET\",\r\n    \"238\": \"EASTEUROPE_CHARSET\",\r\n    \"255\": \"OEM_CHARSET\",\r\n}\r\n\r\n\r\nexport const borderTypes:stringToNum = {\r\n    \"none\":0,\r\n    \"thin\":1, \r\n    \"hair\":2, \r\n    \"dotted\":3, \r\n    \"dashed\":4, \r\n    \"dashDot\":5, \r\n    \"dashDotDot\":6, \r\n    \"double\":7, \r\n    \"medium\":8, \r\n    \"mediumDashed\":9, \r\n    \"mediumDashDot\":10, \r\n    \"mediumDashDotDot\":11, \r\n    \"slantDashDot\":12, \r\n    \"thick\":13\r\n}\r\n\r\n\r\nexport let numFmtDefaultMap: IattributeList = {\r\n    \"yyyy/m/d;@\": \"yyyy/MM/dd\",\r\n    \"yyyy&quot;&quot;m&quot;&quot;d&quot;&quot;;@\":\r\n      \"yyyy&quot;&quot;MM&quot;&quot;dd&quot;&quot;\",\r\n    \"[$-409]yyyy/m/d\\\\ h:mm\\\\ AM/PM;@\": \"yyyy/MM/dd hh:mm AM/PM\",\r\n};\r\n\r\nexport const fontFamilys:IattributeList = {\r\n    \"0\":\"defualt\",\r\n    \"1\":\"Roman\",\r\n    \"2\":\"Swiss\",\r\n    \"3\":\"Modern\",\r\n    \"4\":\"Script\",\r\n    \"5\":\"Decorative\"\r\n}","export let UDOC:any = {};\r\n\t\r\n\tUDOC.G = {\r\n\t\tconcat : function(p:any,r:any) {\r\n\t\t\tfor(var i=0; i<r.cmds.length; i++) p.cmds.push(r.cmds[i]);\r\n\t\t\tfor(var i=0; i<r.crds.length; i++) p.crds.push(r.crds[i]);\r\n\t\t},\r\n\t\tgetBB  : function(ps:any) {\r\n\t\t\tvar x0=1e99, y0=1e99, x1=-x0, y1=-y0;\r\n\t\t\tfor(var i=0; i<ps.length; i+=2) {  var x=ps[i],y=ps[i+1];  if(x<x0)x0=x; else if(x>x1)x1=x;  if(y<y0)y0=y;  else if(y>y1)y1=y;  }\r\n\t\t\treturn [x0,y0,x1,y1];\r\n\t\t},\r\n\t\trectToPath: function(r:any) {  return  {cmds:[\"M\",\"L\",\"L\",\"L\",\"Z\"],crds:[r[0],r[1],r[2],r[1], r[2],r[3],r[0],r[3]]};  },\r\n\t\t// a inside b\r\n\t\tinsideBox: function(a:any,b:any) {  return b[0]<=a[0] && b[1]<=a[1] && a[2]<=b[2] && a[3]<=b[3];   },\r\n\t\tisBox : function(p:any, bb:any) {\r\n\t\t\tvar sameCrd8 = function(pcrd:any, crds:any) {\r\n\t\t\t\tfor(var o=0; o<8; o+=2) {  var eq = true;  for(var j=0; j<8; j++) if(Math.abs(crds[j]-pcrd[(j+o)&7])>=2) {  eq = false;  break;  }    if(eq) return true;  }\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t\tif(p.cmds.length>10) return false;\r\n\t\t\tvar cmds=p.cmds.join(\"\"), crds=p.crds;\r\n\t\t\tvar sameRect = false;\r\n\t\t\tif((cmds==\"MLLLZ\"  && crds.length== 8) \r\n\t\t\t ||(cmds==\"MLLLLZ\" && crds.length==10) ) {\r\n\t\t\t\tif(crds.length==10) crds=crds.slice(0,8);\r\n\t\t\t\tvar x0=bb[0],y0=bb[1],x1=bb[2],y1=bb[3];\r\n\t\t\t\tif(!sameRect) sameRect = sameCrd8(crds, [x0,y0,x1,y0,x1,y1,x0,y1]);\r\n\t\t\t\tif(!sameRect) sameRect = sameCrd8(crds, [x0,y1,x1,y1,x1,y0,x0,y0]);\r\n\t\t\t}\r\n\t\t\treturn sameRect;\r\n\t\t},\r\n\t\tboxArea: function(a:any) {  var w=a[2]-a[0], h=a[3]-a[1];  return w*h;  },\r\n\t\tnewPath: function(gst:any    ) {  gst.pth = {cmds:[], crds:[]};  },\r\n\t\tmoveTo : function(gst:any,x:any,y:any) {  var p=UDOC.M.multPoint(gst.ctm,[x,y]);  //if(gst.cpos[0]==p[0] && gst.cpos[1]==p[1]) return;\r\n\t\t\t\t\t\t\t\t\t\tgst.pth.cmds.push(\"M\");  gst.pth.crds.push(p[0],p[1]);  gst.cpos = p;  },\r\n\t\tlineTo : function(gst:any,x:any,y:any) {  var p=UDOC.M.multPoint(gst.ctm,[x,y]);  if(gst.cpos[0]==p[0] && gst.cpos[1]==p[1]) return;\r\n\t\t\t\t\t\t\t\t\t\tgst.pth.cmds.push(\"L\");  gst.pth.crds.push(p[0],p[1]);  gst.cpos = p;  },\r\n\t\tcurveTo: function(gst:any,x1:any,y1:any,x2:any,y2:any,x3:any,y3:any) {   var p;  \r\n\t\t\tp=UDOC.M.multPoint(gst.ctm,[x1,y1]);  x1=p[0];  y1=p[1];\r\n\t\t\tp=UDOC.M.multPoint(gst.ctm,[x2,y2]);  x2=p[0];  y2=p[1];\r\n\t\t\tp=UDOC.M.multPoint(gst.ctm,[x3,y3]);  x3=p[0];  y3=p[1];  gst.cpos = p;\r\n\t\t\tgst.pth.cmds.push(\"C\");  \r\n\t\t\tgst.pth.crds.push(x1,y1,x2,y2,x3,y3);  \r\n\t\t},\r\n\t\tclosePath: function(gst:any  ) {  gst.pth.cmds.push(\"Z\");  },\r\n\t\tarc : function(gst:any,x:any,y:any,r:any,a0:any,a1:any, neg:any) {\r\n\t\t\t\r\n\t\t\t// circle from a0 counter-clock-wise to a1\r\n\t\t\tif(neg) while(a1>a0) a1-=2*Math.PI;\r\n\t\t\telse    while(a1<a0) a1+=2*Math.PI;\r\n\t\t\tvar th = (a1-a0)/4;\r\n\t\t\t\r\n\t\t\tvar x0 = Math.cos(th/2), y0 = -Math.sin(th/2);\r\n\t\t\tvar x1 = (4-x0)/3, y1 = y0==0 ? y0 : (1-x0)*(3-x0)/(3*y0);\r\n\t\t\tvar x2 = x1, y2 = -y1;\r\n\t\t\tvar x3 = x0, y3 = -y0;\r\n\t\t\t\r\n\t\t\tvar p0 = [x0,y0], p1 = [x1,y1], p2 = [x2,y2], p3 = [x3,y3];\r\n\t\t\t\r\n\t\t\tvar pth = {cmds:[(gst.pth.cmds.length==0)?\"M\":\"L\",\"C\",\"C\",\"C\",\"C\"], crds:[x0,y0,x1,y1,x2,y2,x3,y3]};\r\n\t\t\t\r\n\t\t\tvar rot = [1,0,0,1,0,0];  UDOC.M.rotate(rot,-th);\r\n\t\t\t\r\n\t\t\tfor(var i=0; i<3; i++) {\r\n\t\t\t\tp1 = UDOC.M.multPoint(rot,p1);  p2 = UDOC.M.multPoint(rot,p2);  p3 = UDOC.M.multPoint(rot,p3);\r\n\t\t\t\tpth.crds.push(p1[0],p1[1],p2[0],p2[1],p3[0],p3[1]);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar sc = [r,0,0,r,x,y];  \r\n\t\t\tUDOC.M.rotate(rot, -a0+th/2);  UDOC.M.concat(rot, sc);  UDOC.M.multArray(rot, pth.crds);\r\n\t\t\tUDOC.M.multArray(gst.ctm, pth.crds);\r\n\t\t\t\r\n\t\t\tUDOC.G.concat(gst.pth, pth);\r\n\t\t\tvar y:any=pth.crds.pop();  x=pth.crds.pop();\r\n\t\t\tgst.cpos = [x,y];\r\n\t\t},\r\n\t\ttoPoly : function(p:any) {\r\n\t\t\tif(p.cmds[0]!=\"M\" || p.cmds[p.cmds.length-1]!=\"Z\") return null;\r\n\t\t\tfor(var i=1; i<p.cmds.length-1; i++) if(p.cmds[i]!=\"L\") return null;\r\n\t\t\tvar out = [], cl = p.crds.length;\r\n\t\t\tif(p.crds[0]==p.crds[cl-2] && p.crds[1]==p.crds[cl-1]) cl-=2;\r\n\t\t\tfor(var i=0; i<cl; i+=2) out.push([p.crds[i],p.crds[i+1]]);\r\n\t\t\tif(UDOC.G.polyArea(p.crds)<0) out.reverse();\r\n\t\t\treturn out;\r\n\t\t},\r\n\t\tfromPoly : function(p:any) {\r\n\t\t\tvar o:any = {cmds:[],crds:[]};\r\n\t\t\tfor(var i=0; i<p.length; i++) { o.crds.push(p[i][0], p[i][1]);  o.cmds.push(i==0?\"M\":\"L\");  }\r\n\t\t\to.cmds.push(\"Z\");\r\n\t\t\treturn o;\r\n\t\t},\r\n\t\tpolyArea : function(p:any) {\r\n\t\t\tif(p.length <6) return 0;\r\n\t\t\tvar l = p.length - 2;\r\n\t\t\tvar sum = (p[0]-p[l]) * (p[l+1]+p[1]);\r\n\t\t\tfor(var i=0; i<l; i+=2)\r\n\t\t\t\tsum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);\r\n\t\t\treturn - sum * 0.5;\r\n\t\t},\r\n\t\tpolyClip : function(p0:any, p1:any) {  // p0 clipped by p1\r\n            var cp1:any, cp2:any, s:any, e:any;\r\n            var inside = function (p:any) {\r\n                return (cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0]);\r\n            };\r\n            var isc = function () {\r\n                var dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ],\r\n                    dp = [ s[0] - e[0], s[1] - e[1] ],\r\n                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\r\n                    n2 = s[0] * e[1] - s[1] * e[0], \r\n                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\r\n                return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3];\r\n            };\r\n            var out = p0;\r\n            cp1 = p1[p1.length-1];\r\n            for (let j in p1) {\r\n                var cp2 = p1[j];\r\n                var inp = out;\r\n                out = [];\r\n                s = inp[inp.length - 1]; //last on the input list\r\n                for (let i in inp) {\r\n                    var e = inp[i];\r\n                    if (inside(e)) {\r\n                        if (!inside(s)) {\r\n                            out.push(isc());\r\n                        }\r\n                        out.push(e);\r\n                    }\r\n                    else if (inside(s)) {\r\n                        out.push(isc());\r\n                    }\r\n                    s = e;\r\n                }\r\n                cp1 = cp2;\r\n            }\r\n            return out\r\n        }\r\n\t}\r\n\tUDOC.M = {\r\n\t\tgetScale : function(m:any) {  return Math.sqrt(Math.abs(m[0]*m[3]-m[1]*m[2]));  },\r\n\t\ttranslate: function(m:any,x:any,y:any) {  UDOC.M.concat(m, [1,0,0,1,x,y]);  },\r\n\t\trotate   : function(m:any,a:any  ) {  UDOC.M.concat(m, [Math.cos(a), -Math.sin(a), Math.sin(a), Math.cos(a),0,0]);  },\r\n\t\tscale    : function(m:any,x:any,y:any) {  UDOC.M.concat(m, [x,0,0,y,0,0]);  },\r\n\t\tconcat   : function(m:any,w:any  ) {  \r\n\t\t\tvar a=m[0],b=m[1],c=m[2],d=m[3],tx=m[4],ty=m[5];\r\n\t\t\tm[0] = (a *w[0])+(b *w[2]);       m[1] = (a *w[1])+(b *w[3]);\r\n\t\t\tm[2] = (c *w[0])+(d *w[2]);       m[3] = (c *w[1])+(d *w[3]);\r\n\t\t\tm[4] = (tx*w[0])+(ty*w[2])+w[4];  m[5] = (tx*w[1])+(ty*w[3])+w[5]; \r\n\t\t},\r\n\t\tinvert   : function(m:any    ) {  \r\n\t\t\tvar a=m[0],b=m[1],c=m[2],d=m[3],tx=m[4],ty=m[5], adbc=a*d-b*c;\r\n\t\t\tm[0] = d/adbc;  m[1] = -b/adbc;  m[2] =-c/adbc;  m[3] =  a/adbc;\r\n\t\t\tm[4] = (c*ty - d*tx)/adbc;  m[5] = (b*tx - a*ty)/adbc;\r\n\t\t},\r\n\t\tmultPoint: function(m:any, p:any ) {  var x=p[0],y=p[1];  return [x*m[0]+y*m[2]+m[4],   x*m[1]+y*m[3]+m[5]];  },\r\n\t\tmultArray: function(m:any, a:any ) {  for(var i=0; i<a.length; i+=2) {  var x=a[i],y=a[i+1];  a[i]=x*m[0]+y*m[2]+m[4];  a[i+1]=x*m[1]+y*m[3]+m[5];  }  }\r\n\t}\r\n\tUDOC.C = {\r\n\t\tsrgbGamma : function(x:any) {  return x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1.0 / 2.4) - 0.055;  },\r\n\t\tcmykToRgb : function(clr:any) { \r\n\t\t\tvar c=clr[0], m=clr[1], y=clr[2], k=clr[3];\r\n\t\t\t// return [1-Math.min(1,c+k), 1-Math.min(1, m+k), 1-Math.min(1,y+k)];\r\n\t\t\tvar r = 255\r\n\t\t\t+ c * (-4.387332384609988  * c + 54.48615194189176  * m +  18.82290502165302  * y + 212.25662451639585 * k +  -285.2331026137004) \r\n\t\t\t+ m * ( 1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) \r\n\t\t\t+ y * (-2.5217340131683033 * y - 21.248923337353073 * k +  17.5119270841813) \r\n\t\t\t+ k * (-21.86122147463605  * k - 189.48180835922747);\r\n\t\t\tvar g = 255\r\n\t\t\t+ c * (8.841041422036149   * c + 60.118027045597366 * m +  6.871425592049007  * y + 31.159100130055922 * k +  -79.2970844816548) \r\n\t\t\t+ m * (-15.310361306967817 * m + 17.575251261109482 * y +  131.35250912493976 * k - 190.9453302588951) \r\n\t\t\t+ y * (4.444339102852739   * y + 9.8632861493405    * k -  24.86741582555878) \r\n\t\t\t+ k * (-20.737325471181034 * k - 187.80453709719578);\r\n\t\t\tvar b = 255\r\n\t\t\t+ c * (0.8842522430003296  * c + 8.078677503112928  * m +  30.89978309703729  * y - 0.23883238689178934 * k + -14.183576799673286) \r\n\t\t\t+ m * (10.49593273432072   * m + 63.02378494754052  * y +  50.606957656360734 * k - 112.23884253719248) \r\n\t\t\t+ y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505)\r\n\t\t\t+ k * (-22.33816807309886  * k - 180.12613974708367);\r\n\r\n\t\t\treturn [Math.max(0, Math.min(1, r/255)), Math.max(0, Math.min(1, g/255)), Math.max(0, Math.min(1, b/255))];\r\n\t\t\t//var iK = 1-c[3];  \r\n\t\t\t//return [(1-c[0])*iK, (1-c[1])*iK, (1-c[2])*iK];  \r\n\t\t},\r\n\t\tlabToRgb  : function(lab:any) {\r\n\t\t\tvar k = 903.3, e = 0.008856, L = lab[0], a = lab[1], b = lab[2];\r\n\t\t\tvar fy = (L+16)/116, fy3 = fy*fy*fy;\r\n\t\t\tvar fz = fy - b/200, fz3 = fz*fz*fz;\r\n\t\t\tvar fx = a/500 + fy, fx3 = fx*fx*fx;\r\n\t\t\tvar zr = fz3>e ? fz3 : (116*fz-16)/k;\r\n\t\t\tvar yr = fy3>e ? fy3 : (116*fy-16)/k;\r\n\t\t\tvar xr = fx3>e ? fx3 : (116*fx-16)/k;\r\n\t\t\t\t\r\n\t\t\tvar X = xr*96.72, Y = yr*100, Z = zr*81.427, xyz = [X/100,Y/100,Z/100];\r\n\t\t\tvar x2s = [3.1338561, -1.6168667, -0.4906146, -0.9787684,  1.9161415,  0.0334540, 0.0719453, -0.2289914,  1.4052427];\r\n\t\t\t\r\n\t\t\tvar rgb = [ x2s[0]*xyz[0] + x2s[1]*xyz[1] + x2s[2]*xyz[2],\r\n\t\t\t\t\t\tx2s[3]*xyz[0] + x2s[4]*xyz[1] + x2s[5]*xyz[2],\r\n\t\t\t\t\t\tx2s[6]*xyz[0] + x2s[7]*xyz[1] + x2s[8]*xyz[2]  ];\r\n\t\t\tfor(var i=0; i<3; i++) rgb[i] = Math.max(0, Math.min(1, UDOC.C.srgbGamma(rgb[i])));\r\n\t\t\treturn rgb;\r\n\t\t}\r\n\t}\r\n\t\r\n\tUDOC.getState = function(crds:any):any {\r\n\t\treturn {\r\n\t\t\tfont : UDOC.getFont(),\r\n\t\t\tdd: {flat:1},  // device-dependent\r\n\t\t\tspace :\"/DeviceGray\",\r\n\t\t\t// fill\r\n\t\t\tca: 1,\r\n\t\t\tcolr  : [0,0,0],\r\n\t\t\tsspace:\"/DeviceGray\",\r\n\t\t\t// stroke\r\n\t\t\tCA: 1,\r\n\t\t\tCOLR : [0,0,0],\r\n\t\t\tbmode: \"/Normal\",\r\n\t\t\tSA:false, OPM:0, AIS:false, OP:false, op:false, SMask:\"/None\",\r\n\t\t\tlwidth : 1,\r\n\t\t\tlcap: 0,\r\n\t\t\tljoin: 0,\r\n\t\t\tmlimit: 10,\r\n\t\t\tSM : 0.1,\r\n\t\t\tdoff: 0,\r\n\t\t\tdash: [],\r\n\t\t\tctm : [1,0,0,1,0,0],\r\n\t\t\tcpos: [0,0],\r\n\t\t\tpth : {cmds:[],crds:[]}, \r\n\t\t\tcpth: crds ? UDOC.G.rectToPath(crds) : null  // clipping path\r\n\t\t};\r\n\t}\r\n\t\r\n\tUDOC.getFont = function() {\r\n\t\treturn {\r\n\t\t\tTc: 0, // character spacing\r\n\t\t\tTw: 0, // word spacing\r\n\t\t\tTh:100, // horizontal scale\r\n\t\t\tTl: 0, // leading\r\n\t\t\tTf:\"Helvetica-Bold\", \r\n\t\t\tTfs:1, // font size\r\n\t\t\tTmode:0, // rendering mode\r\n\t\t\tTrise:0, // rise\r\n\t\t\tTk: 0,  // knockout\r\n\t\t\tTal:0,  // align, 0: left, 1: right, 2: center\r\n\t\t\tTun:0,  // 0: no, 1: underline\r\n\t\t\t\r\n\t\t\tTm :[1,0,0,1,0,0],\r\n\t\t\tTlm:[1,0,0,1,0,0],\r\n\t\t\tTrm:[1,0,0,1,0,0]\r\n\t\t};\r\n\t}\r\n\r\n\r\nexport let FromEMF:any = function()\r\n{\r\n}\r\n\r\nFromEMF.Parse = function(buff:any, genv:any)\r\n{\r\n    buff = new Uint8Array(buff);  var off=0;\r\n    //console.log(buff.slice(0,32));\r\n    var prms:any = {fill:false, strk:false, bb:[0,0,1,1], wbb:[0,0,1,1], fnt:{nam:\"Arial\",hgh:25,und:false,orn:0}, tclr:[0,0,0], talg:0}, gst, tab = [], sts=[];\r\n    \r\n    var rI = FromEMF.B.readShort, rU = FromEMF.B.readUshort, rI32 = FromEMF.B.readInt, rU32 = FromEMF.B.readUint, rF32 = FromEMF.B.readFloat;\t\r\n    \r\n    var opn=0;\r\n    while(true) {\r\n        var fnc = rU32(buff, off);  off+=4;\r\n        var fnm = FromEMF.K[fnc]; \r\n        var siz = rU32(buff, off);  off+=4;\r\n        \r\n        //if(gst && isNaN(gst.ctm[0])) throw \"e\";\r\n        //console.log(fnc,fnm,siz);\r\n        \r\n        var loff = off;\r\n        \r\n        //if(opn++==253) break;\r\n        var obj:any = null, oid = 0;\r\n        //console.log(fnm, siz);\r\n        \r\n        if(false) {}\r\n        else if(fnm==\"EOF\") {  break;  }\r\n        else if(fnm==\"HEADER\") {\r\n            prms.bb = FromEMF._readBox(buff,loff);   loff+=16;  //console.log(fnm, prms.bb);\r\n            genv.StartPage(prms.bb[0],prms.bb[1],prms.bb[2],prms.bb[3]);\r\n            gst = UDOC.getState(prms.bb);\t\r\n        }\r\n        else if(fnm==\"SAVEDC\") sts.push(JSON.stringify(gst), JSON.stringify(prms));\r\n        else if(fnm==\"RESTOREDC\") {\r\n            var dif = rI32(buff, loff);  loff+=4;\r\n            while(dif<-1) {  sts.pop();  sts.pop();  }\r\n            prms = JSON.parse(sts.pop());  gst = JSON.parse(sts.pop());\r\n        }\r\n        else if(fnm==\"SELECTCLIPPATH\") {  gst.cpth = JSON.parse(JSON.stringify(gst.pth));  }\r\n        else if([\"SETMAPMODE\",\"SETPOLYFILLMODE\",\"SETBKMODE\"/*,\"SETVIEWPORTEXTEX\"*/,\"SETICMMODE\",\"SETROP2\",\"EXTSELECTCLIPRGN\"].indexOf(fnm)!=-1) {}\r\n        //else if(fnm==\"INTERSECTCLIPRECT\") {  var r=prms.crct=FromEMF._readBox(buff, loff);  /*var y0=r[1],y1=r[3]; if(y0>y1){r[1]=y1; r[3]=y0;}*/ console.log(prms.crct);  }\r\n        else if(fnm==\"SETMITERLIMIT\") gst.mlimit = rU32(buff, loff);\r\n        else if(fnm==\"SETTEXTCOLOR\") prms.tclr = [buff[loff]/255, buff[loff+1]/255, buff[loff+2]/255]; \r\n        else if(fnm==\"SETTEXTALIGN\") prms.talg = rU32(buff, loff);\r\n        else if(fnm==\"SETVIEWPORTEXTEX\" || fnm==\"SETVIEWPORTORGEX\") {\r\n            if(prms.vbb==null) prms.vbb=[];\r\n            var coff = fnm==\"SETVIEWPORTORGEX\" ? 0 : 2;\r\n            prms.vbb[coff  ] = rI32(buff, loff);  loff+=4;\r\n            prms.vbb[coff+1] = rI32(buff, loff);  loff+=4;\r\n            //console.log(prms.vbb);\r\n            if(fnm==\"SETVIEWPORTEXTEX\") FromEMF._updateCtm(prms, gst);\r\n        }\r\n        else if(fnm==\"SETWINDOWEXTEX\" || fnm==\"SETWINDOWORGEX\") {\r\n            var coff = fnm==\"SETWINDOWORGEX\" ? 0 : 2;\r\n            prms.wbb[coff  ] = rI32(buff, loff);  loff+=4;\r\n            prms.wbb[coff+1] = rI32(buff, loff);  loff+=4;\r\n            if(fnm==\"SETWINDOWEXTEX\") FromEMF._updateCtm(prms, gst);\r\n        }\r\n        //else if(fnm==\"SETMETARGN\") {}\r\n        else if(fnm==\"COMMENT\") {  var ds = rU32(buff, loff);  loff+=4;  }\r\n        \r\n        else if(fnm==\"SELECTOBJECT\") {\r\n            var ind = rU32(buff, loff);  loff+=4;\r\n            //console.log(ind.toString(16), tab, tab[ind]);\r\n            if     (ind==0x80000000) {  prms.fill=true ;  gst.colr=[1,1,1];  } // white brush\r\n            else if(ind==0x80000005) {  prms.fill=false;  } // null brush\r\n            else if(ind==0x80000007) {  prms.strk=true ;  prms.lwidth=1;  gst.COLR=[0,0,0];  } // black pen\r\n            else if(ind==0x80000008) {  prms.strk=false;  } // null  pen\r\n            else if(ind==0x8000000d) {} // system font\r\n            else if(ind==0x8000000e) {}  // device default font\r\n            else {\r\n                var co:any = tab[ind];  //console.log(ind, co);\r\n                if(co.t==\"b\") {\r\n                    prms.fill=co.stl!=1;\r\n                    if     (co.stl==0) {}\r\n                    else if(co.stl==1) {}\r\n                    else throw co.stl+\" e\";\r\n                    gst.colr=co.clr;\r\n                }\r\n                else if(co.t==\"p\") {\r\n                    prms.strk=co.stl!=5;\r\n                    gst.lwidth = co.wid;\r\n                    gst.COLR=co.clr;\r\n                }\r\n                else if(co.t==\"f\") {\r\n                    prms.fnt = co;\r\n                    gst.font.Tf = co.nam;\r\n                    gst.font.Tfs = Math.abs(co.hgh);\r\n                    gst.font.Tun = co.und;\r\n                }\r\n                else throw \"e\";\r\n            }\r\n        }\r\n        else if(fnm==\"DELETEOBJECT\") {\r\n            var ind = rU32(buff, loff);  loff+=4;\r\n            if(tab[ind]!=null) tab[ind]=null;\r\n            else throw \"e\";\r\n        }\r\n        else if(fnm==\"CREATEBRUSHINDIRECT\") {\r\n            oid = rU32(buff, loff);  loff+=4;\r\n            obj = {t:\"b\"};\r\n            obj.stl = rU32(buff, loff);  loff+=4;\r\n            obj.clr = [buff[loff]/255, buff[loff+1]/255, buff[loff+2]/255];  loff+=4;\r\n            obj.htc = rU32(buff, loff);  loff+=4;\r\n            //console.log(oid, obj);\r\n        }\r\n        else if(fnm==\"CREATEPEN\" || fnm==\"EXTCREATEPEN\") {\r\n            oid = rU32(buff, loff);  loff+=4;\r\n            obj = {t:\"p\"};\r\n            if(fnm==\"EXTCREATEPEN\") {\r\n                loff+=16;\r\n                obj.stl = rU32(buff, loff);  loff+=4;\r\n                obj.wid = rU32(buff, loff);  loff+=4;\r\n                //obj.stl = rU32(buff, loff);  \r\n                loff+=4;\r\n            } else {\r\n                obj.stl = rU32(buff, loff);  loff+=4;\r\n                obj.wid = rU32(buff, loff);  loff+=4;  loff+=4;\r\n            }\r\n            obj.clr = [buff[loff]/255, buff[loff+1]/255, buff[loff+2]/255];  loff+=4;\r\n        }\r\n        else if(fnm==\"EXTCREATEFONTINDIRECTW\") {\r\n            oid = rU32(buff, loff);  loff+=4;\r\n            obj = {t:\"f\", nam:\"\"};\r\n            obj.hgh = rI32(buff, loff);  loff += 4;\r\n            loff += 4*2;\r\n            obj.orn = rI32(buff, loff)/10;  loff+=4;\r\n            var wgh = rU32(buff, loff);  loff+=4;  //console.log(fnm, obj.orn, wgh);\r\n            //console.log(rU32(buff,loff), rU32(buff,loff+4), buff.slice(loff,loff+8));\r\n            obj.und = buff[loff+1];  obj.stk = buff[loff+2];  loff += 4*2;\r\n            while(rU(buff,loff)!=0) {  obj.nam+=String.fromCharCode(rU(buff,loff));  loff+=2;  }\r\n            if(wgh>500) obj.nam+=\"-Bold\";\r\n            //console.log(wgh, obj.nam);\r\n        }\r\n        else if(fnm==\"EXTTEXTOUTW\") {\r\n            //console.log(buff.slice(loff-8, loff-8+siz));\r\n            loff+=16;\r\n            var mod = rU32(buff, loff);  loff+=4;  //console.log(mod);\r\n            var scx = rF32(buff, loff);  loff+=4;\r\n            var scy = rF32(buff, loff);  loff+=4;\r\n            var rfx = rI32(buff, loff);  loff+=4;\r\n            var rfy = rI32(buff, loff);  loff+=4;\r\n            //console.log(mod, scx, scy,rfx,rfy);\r\n            \r\n            gst.font.Tm = [1,0,0,-1,0,0];\r\n            UDOC.M.rotate(gst.font.Tm, prms.fnt.orn*Math.PI/180);\r\n            UDOC.M.translate(gst.font.Tm, rfx, rfy);\r\n            \r\n            var alg = prms.talg;  //console.log(alg.toString(2));\r\n            if     ((alg&6)==6) gst.font.Tal = 2;\r\n            else if((alg&7)==0) gst.font.Tal = 0;\r\n            else throw alg+\" e\";\r\n            if((alg&24)==24) {}  // baseline\r\n            else if((alg&24)==0) UDOC.M.translate(gst.font.Tm, 0, gst.font.Tfs);\r\n            else throw \"e\";\r\n            \r\n            \r\n            var crs = rU32(buff, loff);  loff+=4;\r\n            var ofs = rU32(buff, loff);  loff+=4;\r\n            var ops = rU32(buff, loff);  loff+=4;  //if(ops!=0) throw \"e\";\r\n            //console.log(ofs,ops,crs);\r\n            loff+=16;\r\n            var ofD = rU32(buff, loff);  loff+=4;  //console.log(ops, ofD, loff, ofs+off-8);\r\n            ofs += off-8;  //console.log(crs, ops);\r\n            var str = \"\";\r\n            for(var i=0; i<crs; i++) {  var cc=rU(buff,ofs+i*2);  str+=String.fromCharCode(cc);  };\r\n            var oclr = gst.colr;  gst.colr = prms.tclr;\r\n            //console.log(str, gst.colr, gst.font.Tm);\r\n            //var otfs = gst.font.Tfs;  gst.font.Tfs *= 1/gst.ctm[0];\r\n            genv.PutText(gst, str, str.length*gst.font.Tfs*0.5);  gst.colr=oclr;\r\n            //gst.font.Tfs = otfs;\r\n            //console.log(rfx, rfy, scx, ops, rcX, rcY, rcW, rcH, offDx, str);\r\n        }\r\n        else if(fnm==\"BEGINPATH\") {  UDOC.G.newPath(gst);  }\r\n        else if(fnm==\"ENDPATH\"  ) {    }\r\n        else if(fnm==\"CLOSEFIGURE\") UDOC.G.closePath(gst);\r\n        else if(fnm==\"MOVETOEX\" ) {  UDOC.G.moveTo(gst, rI32(buff,loff), rI32(buff,loff+4));  }\r\n        else if(fnm==\"LINETO\"   ) {  \r\n            if(gst.pth.cmds.length==0) {  var im=gst.ctm.slice(0);  UDOC.M.invert(im);  var p = UDOC.M.multPoint(im, gst.cpos);  UDOC.G.moveTo(gst, p[0], p[1]);  }  \r\n            UDOC.G.lineTo(gst, rI32(buff,loff), rI32(buff,loff+4));  }\r\n        else if(fnm==\"POLYGON\" || fnm==\"POLYGON16\" || fnm==\"POLYLINE\" || fnm==\"POLYLINE16\" || fnm==\"POLYLINETO\" || fnm==\"POLYLINETO16\") {\r\n            loff+=16;\r\n            var ndf = fnm.startsWith(\"POLYGON\"), isTo = fnm.indexOf(\"TO\")!=-1;\r\n            var cnt = rU32(buff, loff);  loff+=4;\r\n            if(!isTo) UDOC.G.newPath(gst);\r\n            loff = FromEMF._drawPoly(buff,loff,cnt,gst, fnm.endsWith(\"16\")?2:4,  ndf, isTo);\r\n            if(!isTo) FromEMF._draw(genv,gst,prms, ndf);\r\n            //console.log(prms, gst.lwidth);\r\n            //console.log(JSON.parse(JSON.stringify(gst.pth)));\r\n        }\r\n        else if(fnm==\"POLYPOLYGON16\") {\r\n            loff+=16;\r\n            var ndf = fnm.startsWith(\"POLYPOLYGON\"), isTo = fnm.indexOf(\"TO\")!=-1;\r\n            var nop = rU32(buff, loff);  loff+=4;  loff+=4;\r\n            var pi = loff;  loff+= nop*4;\r\n            \r\n            if(!isTo) UDOC.G.newPath(gst);\r\n            for(var i=0; i<nop; i++) {\r\n                var ppp = rU(buff, pi+i*4);\r\n                loff = FromEMF._drawPoly(buff,loff,ppp,gst, fnm.endsWith(\"16\")?2:4, ndf, isTo);\r\n            }\r\n            if(!isTo) FromEMF._draw(genv,gst,prms, ndf);\r\n        }\r\n        else if(fnm==\"POLYBEZIER\" || fnm==\"POLYBEZIER16\" || fnm==\"POLYBEZIERTO\" || fnm==\"POLYBEZIERTO16\") {\r\n            loff+=16;\r\n            var is16 = fnm.endsWith(\"16\"), rC = is16?rI:rI32, nl = is16?2:4;\r\n            var cnt = rU32(buff, loff);  loff+=4;\r\n            if(fnm.indexOf(\"TO\")==-1) {\r\n                UDOC.G.moveTo(gst, rC(buff,loff), rC(buff,loff+nl));  loff+=2*nl;  cnt--;\r\n            }\r\n            while(cnt>0) {\r\n                UDOC.G.curveTo(gst, rC(buff,loff), rC(buff,loff+nl), rC(buff,loff+2*nl), rC(buff,loff+3*nl), rC(buff,loff+4*nl), rC(buff,loff+5*nl) );\r\n                loff+=6*nl;\r\n                cnt-=3;\r\n            }\r\n            //console.log(JSON.parse(JSON.stringify(gst.pth)));\r\n        }\r\n        else if(fnm==\"RECTANGLE\" || fnm==\"ELLIPSE\") {\r\n            UDOC.G.newPath(gst);\r\n            var bx = FromEMF._readBox(buff, loff);\r\n            if(fnm==\"RECTANGLE\") {\r\n                UDOC.G.moveTo(gst, bx[0],bx[1]);\r\n                UDOC.G.lineTo(gst, bx[2],bx[1]);\r\n                UDOC.G.lineTo(gst, bx[2],bx[3]);\r\n                UDOC.G.lineTo(gst, bx[0],bx[3]);\r\n            }\r\n            else {\r\n                var x = (bx[0]+bx[2])/2, y = (bx[1]+bx[3])/2;\r\n                UDOC.G.arc(gst,x,y,(bx[2]-bx[0])/2,0,2*Math.PI, false);\r\n            }\r\n            UDOC.G.closePath(gst);\r\n            FromEMF._draw(genv,gst,prms, true);\r\n            //console.log(prms, gst.lwidth);\r\n        }\r\n        else if(fnm==\"FILLPATH\"  ) genv.Fill(gst, false);\r\n        else if(fnm==\"STROKEPATH\") genv.Stroke(gst);\r\n        else if(fnm==\"STROKEANDFILLPATH\") {  genv.Fill(gst, false);  genv.Stroke(gst);  }\r\n        else if(fnm==\"SETWORLDTRANSFORM\" || fnm==\"MODIFYWORLDTRANSFORM\") {\r\n            var mat = [];\r\n            for(var i=0; i<6; i++) mat.push(rF32(buff,loff+i*4));  loff+=24;\r\n            //console.log(fnm, gst.ctm.slice(0), mat);\r\n            if(fnm==\"SETWORLDTRANSFORM\") gst.ctm=mat;\r\n            else {\r\n                var mod = rU32(buff,loff);  loff+=4;\r\n                if(mod==2) {  var om=gst.ctm;  gst.ctm=mat;  UDOC.M.concat(gst.ctm, om);  }\r\n                else throw \"e\";\r\n            }\r\n        }\r\n        else if(fnm==\"SETSTRETCHBLTMODE\") {  var sm = rU32(buff, loff);  loff+=4;  }\r\n        else if(fnm==\"STRETCHDIBITS\") {\r\n            var bx = FromEMF._readBox(buff, loff);  loff+=16;\r\n            var xD = rI32(buff, loff);  loff+=4;\r\n            var yD = rI32(buff, loff);  loff+=4;\r\n            var xS = rI32(buff, loff);  loff+=4;\r\n            var yS = rI32(buff, loff);  loff+=4;\r\n            var wS = rI32(buff, loff);  loff+=4;\r\n            var hS = rI32(buff, loff);  loff+=4;\r\n            var ofH = rU32(buff, loff)+off-8;  loff+=4;\r\n            var szH = rU32(buff, loff);  loff+=4;\r\n            var ofB = rU32(buff, loff)+off-8;  loff+=4;\r\n            var szB = rU32(buff, loff);  loff+=4;\r\n            var usg = rU32(buff, loff);  loff+=4;  if(usg!=0) throw \"e\";\r\n            var bop = rU32(buff, loff);  loff+=4;\r\n            var wD = rI32(buff, loff);  loff+=4;\r\n            var hD = rI32(buff, loff);  loff+=4;  //console.log(bop, wD, hD);\r\n            \r\n            //console.log(ofH, szH, ofB, szB, ofH+40);\r\n            //console.log(bx, xD,yD,wD,hD);\r\n            //console.log(xS,yS,wS,hS);\r\n            //console.log(ofH,szH,ofB,szB,usg,bop);\r\n            \r\n            var hl = rU32(buff, ofH);  ofH+=4;\r\n            var w  = rU32(buff, ofH);  ofH+=4;\r\n            var h  = rU32(buff, ofH);  ofH+=4;  if(w!=wS || h!=hS) throw \"e\";\r\n            var ps = rU  (buff, ofH);  ofH+=2;\r\n            var bc = rU  (buff, ofH);  ofH+=2;  if(bc!=8 && bc!=24 && bc!=32) throw bc+\" e\";\r\n            var cpr= rU32(buff, ofH);  ofH+=4;  if(cpr!=0) throw cpr+\" e\";\r\n            var sz = rU32(buff, ofH);  ofH+=4;\r\n            var xpm= rU32(buff, ofH);  ofH+=4;\r\n            var ypm= rU32(buff, ofH);  ofH+=4;\r\n            var cu = rU32(buff, ofH);  ofH+=4;\r\n            var ci = rU32(buff, ofH);  ofH+=4;  //console.log(hl, w, h, ps, bc, cpr, sz, xpm, ypm, cu, ci);\r\n            \r\n            //console.log(hl,w,h,\",\",xS,yS,wS,hS,\",\",xD,yD,wD,hD,\",\",xpm,ypm);\r\n            \r\n            var rl = Math.floor(((w * ps * bc + 31) & ~31) / 8);\r\n            var img = new Uint8Array(w*h*4);\r\n            if(bc==8) {\r\n                for(var y=0; y<h; y++) \r\n                    for(var x=0; x<w; x++) {\r\n                        var qi = (y*w+x)<<2, ind:any = buff[ofB+(h-1-y)*rl+x]<<2;\r\n                        img[qi  ] = buff[ofH+ind+2];\r\n                        img[qi+1] = buff[ofH+ind+1];\r\n                        img[qi+2] = buff[ofH+ind+0];\r\n                        img[qi+3] = 255;\r\n                    }\r\n            }\r\n            if(bc==24) {\r\n                for(var y=0; y<h; y++) \r\n                    for(var x=0; x<w; x++) {\r\n                        var qi = (y*w+x)<<2, ti=ofB+(h-1-y)*rl+x*3;\r\n                        img[qi  ] = buff[ti+2];\r\n                        img[qi+1] = buff[ti+1];\r\n                        img[qi+2] = buff[ti+0];\r\n                        img[qi+3] = 255;\r\n                    }\r\n            }\r\n            if(bc==32) {\r\n                for(var y=0; y<h; y++) \r\n                    for(var x=0; x<w; x++) {\r\n                        var qi = (y*w+x)<<2, ti=ofB+(h-1-y)*rl+x*4;\r\n                        img[qi  ] = buff[ti+2];\r\n                        img[qi+1] = buff[ti+1];\r\n                        img[qi+2] = buff[ti+0];\r\n                        img[qi+3] = buff[ti+3];\r\n                    }\r\n            }\r\n            \r\n            var ctm = gst.ctm.slice(0);\r\n            gst.ctm = [1,0,0,1,0,0];\r\n            UDOC.M.scale(gst.ctm, wD, -hD);\r\n            UDOC.M.translate(gst.ctm, xD, yD+hD);\r\n            UDOC.M.concat(gst.ctm, ctm);\r\n            genv.PutImage(gst, img, w, h);\r\n            gst.ctm = ctm;\r\n        }\r\n        else {\r\n            console.log(fnm, siz);\r\n        }\r\n        \r\n        if(obj!=null) tab[oid]=obj;\r\n        \r\n        off+=siz-8;\r\n    }\r\n    //genv.Stroke(gst);\r\n    genv.ShowPage();  genv.Done();\r\n}\r\nFromEMF._readBox = function(buff:any, off:any) {  var b=[];  for(var i=0; i<4; i++) b[i] = FromEMF.B.readInt(buff,off+i*4);  return b;  }\t\r\n\r\nFromEMF._updateCtm = function(prms:any, gst:any) {\r\n    var mat = [1,0,0,1,0,0];\r\n    var wbb = prms.wbb, bb = prms.bb, vbb=(prms.vbb && prms.vbb.length==4) ? prms.vbb:prms.bb;\r\n    \r\n    //var y0 = bb[1], y1 = bb[3];  bb[1]=Math.min(y0,y1);  bb[3]=Math.max(y0,y1);\r\n    \r\n    UDOC.M.translate(mat, -wbb[0],-wbb[1]);\r\n    UDOC.M.scale(mat, 1/wbb[2], 1/wbb[3]);\r\n    \r\n    UDOC.M.scale(mat, vbb[2], vbb[3]);\r\n    //UDOC.M.scale(mat, vbb[2]/(bb[2]-bb[0]), vbb[3]/(bb[3]-bb[1]));\r\n    \r\n    //UDOC.M.scale(mat, bb[2]-bb[0],bb[3]-bb[1]);\r\n    \r\n    gst.ctm = mat;\r\n}\r\nFromEMF._draw = function(genv:any, gst:any, prms:any, needFill:any) {\r\n    if(prms.fill && needFill     ) genv.Fill  (gst, false);\r\n    if(prms.strk && gst.lwidth!=0) genv.Stroke(gst);\r\n}\r\nFromEMF._drawPoly = function(buff:any, off:any, ppp:any, gst:any, nl:any, clos:any, justLine:any) {\r\n    var rS = nl==2 ? FromEMF.B.readShort : FromEMF.B.readInt;\r\n    for(var j=0; j<ppp; j++) {\r\n        var px = rS(buff, off);  off+=nl;  \r\n        var py = rS(buff, off);  off+=nl;\r\n        if(j==0 && !justLine) UDOC.G.moveTo(gst,px,py);  else UDOC.G.lineTo(gst,px,py);\r\n    }\r\n    if(clos) UDOC.G.closePath(gst);\r\n    return off;\r\n}\r\n\r\nFromEMF.B = {\r\n    uint8 : new Uint8Array(4),\r\n    readShort  : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  return FromEMF.B.int16 [0];  },\r\n    readUshort : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  return FromEMF.B.uint16[0];  },\r\n    readInt    : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  u8[2]=buff[p+2];  u8[3]=buff[p+3];  return FromEMF.B.int32 [0];  },\r\n    readUint   : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  u8[2]=buff[p+2];  u8[3]=buff[p+3];  return FromEMF.B.uint32[0];  },\r\n    readFloat  : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  u8[2]=buff[p+2];  u8[3]=buff[p+3];  return FromEMF.B.flot32[0];  },\r\n    readASCII  : function(buff:any,p:any,l:any):any {  var s = \"\";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    }\r\n}\r\nFromEMF.B.int16  = new Int16Array (FromEMF.B.uint8.buffer);\r\nFromEMF.B.uint16 = new Uint16Array(FromEMF.B.uint8.buffer);\r\nFromEMF.B.int32  = new Int32Array (FromEMF.B.uint8.buffer);\r\nFromEMF.B.uint32 = new Uint32Array(FromEMF.B.uint8.buffer);\r\nFromEMF.B.flot32 = new Float32Array(FromEMF.B.uint8.buffer);\r\n\r\n\r\nFromEMF.C = {\r\n    EMR_HEADER : 0x00000001,\r\n    EMR_POLYBEZIER : 0x00000002,\r\n    EMR_POLYGON : 0x00000003,\r\n    EMR_POLYLINE : 0x00000004,\r\n    EMR_POLYBEZIERTO : 0x00000005,\r\n    EMR_POLYLINETO : 0x00000006,\r\n    EMR_POLYPOLYLINE : 0x00000007,\r\n    EMR_POLYPOLYGON : 0x00000008,\r\n    EMR_SETWINDOWEXTEX : 0x00000009,\r\n    EMR_SETWINDOWORGEX : 0x0000000A,\r\n    EMR_SETVIEWPORTEXTEX : 0x0000000B,\r\n    EMR_SETVIEWPORTORGEX : 0x0000000C,\r\n    EMR_SETBRUSHORGEX : 0x0000000D,\r\n    EMR_EOF : 0x0000000E,\r\n    EMR_SETPIXELV : 0x0000000F,\r\n    EMR_SETMAPPERFLAGS : 0x00000010,\r\n    EMR_SETMAPMODE : 0x00000011,\r\n    EMR_SETBKMODE : 0x00000012,\r\n    EMR_SETPOLYFILLMODE : 0x00000013,\r\n    EMR_SETROP2 : 0x00000014,\r\n    EMR_SETSTRETCHBLTMODE : 0x00000015,\r\n    EMR_SETTEXTALIGN : 0x00000016,\r\n    EMR_SETCOLORADJUSTMENT : 0x00000017,\r\n    EMR_SETTEXTCOLOR : 0x00000018,\r\n    EMR_SETBKCOLOR : 0x00000019,\r\n    EMR_OFFSETCLIPRGN : 0x0000001A,\r\n    EMR_MOVETOEX : 0x0000001B,\r\n    EMR_SETMETARGN : 0x0000001C,\r\n    EMR_EXCLUDECLIPRECT : 0x0000001D,\r\n    EMR_INTERSECTCLIPRECT : 0x0000001E,\r\n    EMR_SCALEVIEWPORTEXTEX : 0x0000001F,\r\n    EMR_SCALEWINDOWEXTEX : 0x00000020,\r\n    EMR_SAVEDC : 0x00000021,\r\n    EMR_RESTOREDC : 0x00000022,\r\n    EMR_SETWORLDTRANSFORM : 0x00000023,\r\n    EMR_MODIFYWORLDTRANSFORM : 0x00000024,\r\n    EMR_SELECTOBJECT : 0x00000025,\r\n    EMR_CREATEPEN : 0x00000026,\r\n    EMR_CREATEBRUSHINDIRECT : 0x00000027,\r\n    EMR_DELETEOBJECT : 0x00000028,\r\n    EMR_ANGLEARC : 0x00000029,\r\n    EMR_ELLIPSE : 0x0000002A,\r\n    EMR_RECTANGLE : 0x0000002B,\r\n    EMR_ROUNDRECT : 0x0000002C,\r\n    EMR_ARC : 0x0000002D,\r\n    EMR_CHORD : 0x0000002E,\r\n    EMR_PIE : 0x0000002F,\r\n    EMR_SELECTPALETTE : 0x00000030,\r\n    EMR_CREATEPALETTE : 0x00000031,\r\n    EMR_SETPALETTEENTRIES : 0x00000032,\r\n    EMR_RESIZEPALETTE : 0x00000033,\r\n    EMR_REALIZEPALETTE : 0x00000034,\r\n    EMR_EXTFLOODFILL : 0x00000035,\r\n    EMR_LINETO : 0x00000036,\r\n    EMR_ARCTO : 0x00000037,\r\n    EMR_POLYDRAW : 0x00000038,\r\n    EMR_SETARCDIRECTION : 0x00000039,\r\n    EMR_SETMITERLIMIT : 0x0000003A,\r\n    EMR_BEGINPATH : 0x0000003B,\r\n    EMR_ENDPATH : 0x0000003C,\r\n    EMR_CLOSEFIGURE : 0x0000003D,\r\n    EMR_FILLPATH : 0x0000003E,\r\n    EMR_STROKEANDFILLPATH : 0x0000003F,\r\n    EMR_STROKEPATH : 0x00000040,\r\n    EMR_FLATTENPATH : 0x00000041,\r\n    EMR_WIDENPATH : 0x00000042,\r\n    EMR_SELECTCLIPPATH : 0x00000043,\r\n    EMR_ABORTPATH : 0x00000044,\r\n    EMR_COMMENT : 0x00000046,\r\n    EMR_FILLRGN : 0x00000047,\r\n    EMR_FRAMERGN : 0x00000048,\r\n    EMR_INVERTRGN : 0x00000049,\r\n    EMR_PAINTRGN : 0x0000004A,\r\n    EMR_EXTSELECTCLIPRGN : 0x0000004B,\r\n    EMR_BITBLT : 0x0000004C,\r\n    EMR_STRETCHBLT : 0x0000004D,\r\n    EMR_MASKBLT : 0x0000004E,\r\n    EMR_PLGBLT : 0x0000004F,\r\n    EMR_SETDIBITSTODEVICE : 0x00000050,\r\n    EMR_STRETCHDIBITS : 0x00000051,\r\n    EMR_EXTCREATEFONTINDIRECTW : 0x00000052,\r\n    EMR_EXTTEXTOUTA : 0x00000053,\r\n    EMR_EXTTEXTOUTW : 0x00000054,\r\n    EMR_POLYBEZIER16 : 0x00000055,\r\n    EMR_POLYGON16 : 0x00000056,\r\n    EMR_POLYLINE16 : 0x00000057,\r\n    EMR_POLYBEZIERTO16 : 0x00000058,\r\n    EMR_POLYLINETO16 : 0x00000059,\r\n    EMR_POLYPOLYLINE16 : 0x0000005A,\r\n    EMR_POLYPOLYGON16 : 0x0000005B,\r\n    EMR_POLYDRAW16 : 0x0000005C,\r\n    EMR_CREATEMONOBRUSH : 0x0000005D,\r\n    EMR_CREATEDIBPATTERNBRUSHPT : 0x0000005E,\r\n    EMR_EXTCREATEPEN : 0x0000005F,\r\n    EMR_POLYTEXTOUTA : 0x00000060,\r\n    EMR_POLYTEXTOUTW : 0x00000061,\r\n    EMR_SETICMMODE : 0x00000062,\r\n    EMR_CREATECOLORSPACE : 0x00000063,\r\n    EMR_SETCOLORSPACE : 0x00000064,\r\n    EMR_DELETECOLORSPACE : 0x00000065,\r\n    EMR_GLSRECORD : 0x00000066,\r\n    EMR_GLSBOUNDEDRECORD : 0x00000067,\r\n    EMR_PIXELFORMAT : 0x00000068,\r\n    EMR_DRAWESCAPE : 0x00000069,\r\n    EMR_EXTESCAPE : 0x0000006A,\r\n    EMR_SMALLTEXTOUT : 0x0000006C,\r\n    EMR_FORCEUFIMAPPING : 0x0000006D,\r\n    EMR_NAMEDESCAPE : 0x0000006E,\r\n    EMR_COLORCORRECTPALETTE : 0x0000006F,\r\n    EMR_SETICMPROFILEA : 0x00000070,\r\n    EMR_SETICMPROFILEW : 0x00000071,\r\n    EMR_ALPHABLEND : 0x00000072,\r\n    EMR_SETLAYOUT : 0x00000073,\r\n    EMR_TRANSPARENTBLT : 0x00000074,\r\n    EMR_GRADIENTFILL : 0x00000076,\r\n    EMR_SETLINKEDUFIS : 0x00000077,\r\n    EMR_SETTEXTJUSTIFICATION : 0x00000078,\r\n    EMR_COLORMATCHTOTARGETW : 0x00000079,\r\n    EMR_CREATECOLORSPACEW : 0x0000007A\r\n};\r\nFromEMF.K = [];\r\n\r\n// (function() {\r\n//     var inp, out, stt;\r\n//     inp = FromEMF.C;   out = FromEMF.K;   stt=4;\r\n//     for(var p in inp) out[inp[p]] = p.slice(stt);\r\n// }  )();\r\n\r\n\r\n\r\nexport let ToContext2D:any = function (needPage:any, scale:any)\r\n{\r\n    this.canvas = document.createElement(\"canvas\");\r\n    this.ctx = this.canvas.getContext(\"2d\");\r\n    this.bb = null;\r\n    this.currPage = 0;\r\n    this.needPage = needPage;\r\n    this.scale = scale;\r\n}\r\nToContext2D.prototype.StartPage = function(x:any,y:any,w:any,h:any) {\r\n    if(this.currPage!=this.needPage) return;\r\n    this.bb = [x,y,w,h];\r\n    var scl = this.scale, dpr = window.devicePixelRatio;\r\n    var cnv = this.canvas, ctx = this.ctx;\r\n    cnv.width = Math.round(w*scl);  cnv.height = Math.round(h*scl);\r\n    ctx.translate(0,h*scl);  ctx.scale(scl,-scl);\r\n    cnv.setAttribute(\"style\", \"border:1px solid; width:\"+(cnv.width/dpr)+\"px; height:\"+(cnv.height/dpr)+\"px\");\r\n}\r\nToContext2D.prototype.Fill = function(gst:any, evenOdd:any) {\r\n    if(this.currPage!=this.needPage) return;\r\n    var ctx = this.ctx;\r\n    ctx.beginPath();\r\n    this._setStyle(gst, ctx);\r\n    this._draw(gst.pth, ctx);\r\n    ctx.fill();\r\n}\r\nToContext2D.prototype.Stroke = function(gst:any) {\r\n    if(this.currPage!=this.needPage) return;\r\n    var ctx = this.ctx;\r\n    ctx.beginPath();\r\n    this._setStyle(gst, ctx);\r\n    this._draw(gst.pth, ctx);\r\n    ctx.stroke();\r\n}\r\nToContext2D.prototype.PutText = function(gst:any, str:any, stw:any) {\r\n    if(this.currPage!=this.needPage) return;\r\n    var scl = this._scale(gst.ctm);\r\n    var ctx = this.ctx;\r\n    this._setStyle(gst, ctx);\r\n    ctx.save();\r\n    var m = [1,0,0,-1,0,0];  this._concat(m, gst.font.Tm);  this._concat(m, gst.ctm);\r\n    //console.log(str, m, gst);  throw \"e\";\r\n    ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5]);\r\n    ctx.fillText(str,0,0);\r\n    ctx.restore();\r\n}\r\nToContext2D.prototype.PutImage = function(gst:any, buff:any, w:any, h:any, msk:any) {\r\n    if(this.currPage!=this.needPage) return;\r\n    var ctx = this.ctx;\r\n    \r\n    if(buff.length==w*h*4) {\r\n        buff = buff.slice(0);\r\n        if(msk && msk.length==w*h*4) for(var i=0; i<buff.length; i+=4) buff[i+3] = msk[i+1];\r\n        \r\n        var cnv = document.createElement(\"canvas\"), cctx = cnv.getContext(\"2d\");\r\n        cnv.width = w;  cnv.height = h;\r\n        var imgd = cctx.createImageData(w,h);\r\n        for(var i=0; i<buff.length; i++) imgd.data[i]=buff[i];\r\n        cctx.putImageData(imgd,0,0);\r\n        \r\n        ctx.save();\r\n        var m = [1,0,0,1,0,0];  this._concat(m, [1/w,0,0,-1/h,0,1]);  this._concat(m, gst.ctm);\r\n        ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5]);\r\n        ctx.drawImage(cnv,0,0);\r\n        ctx.restore();\r\n    }\r\n}\r\nToContext2D.prototype.ShowPage = function() {  this.currPage++;  }\r\nToContext2D.prototype.Done = function() {}\r\n\r\n\r\nfunction _flt(n:any)  {  return \"\"+parseFloat(n.toFixed(2));  }\r\n\r\nToContext2D.prototype._setStyle = function(gst:any, ctx:any) {\r\n    var scl = this._scale(gst.ctm);\r\n    ctx.fillStyle = this._getFill(gst.colr, gst.ca, ctx);\r\n    ctx.strokeStyle=this._getFill(gst.COLR, gst.CA, ctx);\r\n    \r\n    ctx.lineCap = [\"butt\",\"round\",\"square\"][gst.lcap];\r\n    ctx.lineJoin= [\"miter\",\"round\",\"bevel\"][gst.ljoin];\r\n    ctx.lineWidth=gst.lwidth*scl;\r\n    var dsh = gst.dash.slice(0);  for(var i=0; i<dsh.length; i++) dsh[i] = _flt(dsh[i]*scl);\r\n    ctx.setLineDash(dsh); \r\n    ctx.miterLimit = gst.mlimit*scl;\r\n    \r\n    var fn = gst.font.Tf, ln = fn.toLowerCase();\r\n    var p0 = ln.indexOf(\"bold\")!=-1 ? \"bold \" : \"\";\r\n    var p1 = (ln.indexOf(\"italic\")!=-1 || ln.indexOf(\"oblique\")!=-1) ? \"italic \" : \"\";\r\n    ctx.font = p0+p1 + gst.font.Tfs+\"px \\\"\"+fn+\"\\\"\";\r\n}\r\nToContext2D.prototype._getFill = function(colr:any, ca:any, ctx:any)\r\n{\r\n    if(colr.typ==null) return this._colr(colr,ca);\r\n    else {\r\n        var grd = colr, crd = grd.crds, mat = grd.mat, scl=this._scale(mat), gf;\r\n        if     (grd.typ==\"lin\") {\r\n            var p0 = this._multPoint(mat,crd.slice(0,2)), p1 = this._multPoint(mat,crd.slice(2));\r\n            gf=ctx.createLinearGradient(p0[0],p0[1],p1[0],p1[1]);\r\n        }\r\n        else if(grd.typ==\"rad\") {\r\n            var p0 = this._multPoint(mat,crd.slice(0,2)), p1 = this._multPoint(mat,crd.slice(3));\r\n            gf=ctx.createRadialGradient(p0[0],p0[1],crd[2]*scl,p1[0],p1[1],crd[5]*scl);\r\n        }\r\n        for(var i=0; i<grd.grad.length; i++)  gf.addColorStop(grd.grad[i][0],this._colr(grd.grad[i][1], ca));\r\n        return gf;\r\n    }\r\n}\r\nToContext2D.prototype._colr  = function(c:any,a:any) {  return \"rgba(\"+Math.round(c[0]*255)+\",\"+Math.round(c[1]*255)+\",\"+Math.round(c[2]*255)+\",\"+a+\")\";  };\r\nToContext2D.prototype._scale = function(m:any)  {  return Math.sqrt(Math.abs(m[0]*m[3]-m[1]*m[2]));  };\r\nToContext2D.prototype._concat= function(m:any,w:any  ) {  \r\n        var a=m[0],b=m[1],c=m[2],d=m[3],tx=m[4],ty=m[5];\r\n        m[0] = (a *w[0])+(b *w[2]);       m[1] = (a *w[1])+(b *w[3]);\r\n        m[2] = (c *w[0])+(d *w[2]);       m[3] = (c *w[1])+(d *w[3]);\r\n        m[4] = (tx*w[0])+(ty*w[2])+w[4];  m[5] = (tx*w[1])+(ty*w[3])+w[5]; \r\n}\r\nToContext2D.prototype._multPoint= function(m:any, p:any) {  var x=p[0],y=p[1];  return [x*m[0]+y*m[2]+m[4],   x*m[1]+y*m[3]+m[5]];  },\r\nToContext2D.prototype._draw  = function(path:any, ctx:any)\r\n{\r\n    var c = 0, crds = path.crds;\r\n    for(var j=0; j<path.cmds.length; j++) {\r\n        var cmd = path.cmds[j];\r\n        if     (cmd==\"M\") {  ctx.moveTo(crds[c], crds[c+1]);  c+=2;  }\r\n        else if(cmd==\"L\") {  ctx.lineTo(crds[c], crds[c+1]);  c+=2;  }\r\n        else if(cmd==\"C\") {  ctx.bezierCurveTo(crds[c], crds[c+1], crds[c+2], crds[c+3], crds[c+4], crds[c+5]);  c+=6;  }\r\n        else if(cmd==\"Q\") {  ctx.quadraticCurveTo(crds[c], crds[c+1], crds[c+2], crds[c+3]);  c+=4;  }\r\n        else if(cmd==\"Z\") {  ctx.closePath();  }\r\n    }\r\n}\r\n","import { columeHeader_word, columeHeader_word_index } from \"./constant\";\r\nimport { IluckySheetSelection } from \"../ToLuckySheet/ILuck\";\r\nimport { IattributeList, stringToNum} from \"../ICommon\";\r\n\r\n\r\nexport function getRangetxt(range:IluckySheetSelection, sheettxt:string) {\r\n\r\n    let row0 = range[\"row\"][0], row1 = range[\"row\"][1];\r\n    let column0 = range[\"column\"][0], column1 = range[\"column\"][1];\r\n\r\n    if (row0 == null && row1 == null) {\r\n        return sheettxt + chatatABC(column0) + \":\" + chatatABC(column1);\r\n    }\r\n    else if (column0 == null && column1 == null) {\r\n        return sheettxt + (row0 + 1) + \":\" + (row1 + 1);\r\n    }\r\n    else {\r\n        if (column0 == column1 && row0 == row1) {\r\n            return sheettxt + chatatABC(column0) + (row0 + 1);\r\n        }\r\n        else {\r\n            return sheettxt + chatatABC(column0) + (row0 + 1) + \":\" + chatatABC(column1) + (row1 + 1);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport function getcellrange (txt:string, sheets:IattributeList={}, sheetId:string=\"1\") {\r\n    let val = txt.split(\"!\");\r\n\r\n    let sheettxt = \"\",\r\n        rangetxt = \"\",\r\n        sheetIndex = -1;\r\n\r\n    if (val.length > 1) {\r\n        sheettxt = val[0];\r\n        rangetxt = val[1];\r\n        \r\n        let si = sheets[sheettxt];\r\n        if(si==null){\r\n            sheetIndex = parseInt(sheetId);\r\n        }\r\n        else{\r\n            sheetIndex = parseInt(si);\r\n        }\r\n    } \r\n    else {\r\n        sheetIndex = parseInt(sheetId);\r\n        rangetxt = val[0];\r\n    }\r\n    \r\n    if (rangetxt.indexOf(\":\") == -1) {\r\n        let row = parseInt(rangetxt.replace(/[^0-9]/g, \"\")) - 1;\r\n        let col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, \"\"));\r\n\r\n        if (!isNaN(row) && !isNaN(col)) {\r\n            return {\r\n                \"row\": [row, row],\r\n                \"column\": [col, col],\r\n                \"sheetIndex\": sheetIndex\r\n            };\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    } \r\n    else {\r\n        let rangetxtArray:string[] = rangetxt.split(\":\");\r\n        let row = [],col = [];\r\n        row[0] = parseInt(rangetxtArray[0].replace(/[^0-9]/g, \"\")) - 1;\r\n        row[1] = parseInt(rangetxtArray[1].replace(/[^0-9]/g, \"\")) - 1;\r\n        // if (isNaN(row[0])) {\r\n        //     row[0] = 0;\r\n        // }\r\n        // if (isNaN(row[1])) {\r\n        //     row[1] = sheetdata.length - 1;\r\n        // }\r\n        if (row[0] > row[1]) {\r\n            return null;\r\n        }\r\n        col[0] = ABCatNum(rangetxtArray[0].replace(/[^A-Za-z]/g, \"\"));\r\n        col[1] = ABCatNum(rangetxtArray[1].replace(/[^A-Za-z]/g, \"\"));\r\n        // if (isNaN(col[0])) {\r\n        //     col[0] = 0;\r\n        // }\r\n        // if (isNaN(col[1])) {\r\n        //     col[1] = sheetdata[0].length - 1;\r\n        // }\r\n        if (col[0] > col[1]) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            \"row\": row,\r\n            \"column\": col,\r\n            \"sheetIndex\": sheetIndex\r\n        };\r\n    }\r\n}\r\n\r\n//  \r\nfunction ABCatNum(abc:string) {\r\n    abc = abc.toUpperCase();\r\n\r\n    let abc_len = abc.length;\r\n    if (abc_len == 0) {\r\n        return NaN;\r\n    }\r\n\r\n    let abc_array = abc.split(\"\");\r\n    let wordlen = columeHeader_word.length;\r\n    let ret = 0;\r\n\r\n    for (let i = abc_len - 1; i >= 0; i--) {\r\n        if (i == abc_len - 1) {\r\n            ret += columeHeader_word_index[abc_array[i]];\r\n        }\r\n        else {\r\n            ret += Math.pow(wordlen, abc_len - i - 1) * (columeHeader_word_index[abc_array[i]] + 1);\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\n//  \r\nfunction chatatABC(index:number) {\r\n    let wordlen = columeHeader_word.length;\r\n\r\n    if (index < wordlen) {\r\n        return columeHeader_word[index];\r\n    }\r\n    else {\r\n        let last = 0, pre = 0, ret = \"\";\r\n        let i = 1, n = 0;\r\n\r\n        while (index >= (wordlen / (wordlen - 1)) * (Math.pow(wordlen, i++) - 1)) {\r\n            n = i;\r\n        }\r\n\r\n        let index_ab = index - (wordlen / (wordlen - 1)) * (Math.pow(wordlen, n - 1) - 1);//970\r\n        last = index_ab + 1;\r\n\r\n        for (let x = n; x > 0; x--) {\r\n            let last1 = last, x1 = x;//-702=268, 3\r\n\r\n            if (x == 1) {\r\n                last1 = last1 % wordlen;\r\n\r\n                if (last1 == 0) {\r\n                    last1 = 26;\r\n                }\r\n\r\n                return ret + columeHeader_word[last1 - 1];\r\n            }\r\n\r\n            last1 = Math.ceil(last1 / Math.pow(wordlen, x - 1));\r\n            //last1 = last1 % wordlen;\r\n            ret += columeHeader_word[last1 - 1];\r\n\r\n            if (x > 1) {\r\n                last = last - (last1 - 1) * wordlen;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** \r\n * @return ratio, default 0.75 1in = 2.54cm = 25.4mm = 72pt = 6pc,  pt = 1/72 In, px = 1/dpi In\r\n*/\r\nexport function getptToPxRatioByDPI():number{\r\n    return 72/96;\r\n}\r\n\r\n/** \r\n * @emus EMUs, Excel drawing unit\r\n * @return pixel\r\n*/\r\nexport function getPxByEMUs(emus:number){\r\n    if(emus==null){\r\n        return 0;\r\n    }\r\n    let inch = emus/914400;\r\n    let pt = inch*72;\r\n    let px = pt / getptToPxRatioByDPI();\r\n    return px;\r\n}\r\n\r\n/** \r\n * @dom xml attribute object\r\n * @attr attribute name\r\n * @d if attribute is null, return default value \r\n * @return attribute value\r\n*/\r\nexport function getXmlAttibute(dom:IattributeList, attr:string, d:string){\r\n    let value = dom[attr];\r\n    value = value==null?d:value;\r\n    return value;\r\n}\r\n\r\n/** \r\n * @columnWidth Excel column width\r\n * @return pixel column width\r\n*/\r\nexport function getColumnWidthPixel(columnWidth:number){\r\n    let pix = Math.round((columnWidth-0.83) * 8 + 5);\r\n    return pix;\r\n}\r\n\r\n/** \r\n * @rowHeight Excel row height\r\n * @return pixel row height\r\n*/\r\nexport function getRowHeightPixel(rowHeight:number){\r\n    let pix = Math.round(rowHeight/getptToPxRatioByDPI());\r\n    return pix;\r\n}\r\n\r\nexport function LightenDarkenColor(sixColor:string, tint:number){\r\n    let hex:string = sixColor.substring(sixColor.length-6,sixColor.length);\r\n    let rgbArray:number[] = hexToRgbArray(\"#\"+hex);\r\n    let hslArray = rgbToHsl(rgbArray[0], rgbArray[1],rgbArray[2]);\r\n    if(tint>0){\r\n        hslArray[2] = hslArray[2] * (1.0-tint) + tint;\r\n    }\r\n    else if(tint<0){\r\n        hslArray[2] = hslArray[2] * (1.0 + tint)\r\n    }\r\n    else{\r\n        return \"#\"+hex;\r\n    }\r\n\r\n    let newRgbArray = hslToRgb(hslArray[0],hslArray[1],hslArray[2]);\r\n\r\n    return rgbToHex(\"RGB(\" + newRgbArray.join(\",\") + \")\");\r\n}\r\n\r\n\r\nfunction rgbToHex(rgb:string){\r\n    //\r\n    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;\r\n    // rgb\r\n    if (/^(rgb|RGB)/.test(rgb)) {\r\n        var aColor = rgb.replace(/(?:\\(|\\)|rgb|RGB)*/g, \"\").split(\",\");\r\n        var strHex = \"#\";\r\n        for (var i=0; i<aColor.length; i++) {\r\n            var hex = Number(aColor[i]).toString(16);\r\n            if (hex.length < 2) {\r\n                hex = '0' + hex;    \r\n            }\r\n            strHex += hex;\r\n        }\r\n        if (strHex.length !== 7) {\r\n            strHex = rgb;    \r\n        }\r\n        return strHex;\r\n    } else if (reg.test(rgb)) {\r\n        var aNum = rgb.replace(/#/,\"\").split(\"\");\r\n        if (aNum.length === 6) {\r\n            return rgb;    \r\n        } else if(aNum.length === 3) {\r\n            var numHex = \"#\";\r\n            for (var i=0; i<aNum.length; i+=1) {\r\n                numHex += (aNum[i] + aNum[i]);\r\n            }\r\n            return numHex;\r\n        }\r\n    }\r\n    return rgb;\r\n}\r\n\r\nfunction hexToRgb(hex:string){\r\n    var sColor = hex.toLowerCase();\r\n    //\r\n    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;\r\n    // 16\r\n    if (sColor && reg.test(sColor)) {\r\n        if (sColor.length === 4) {\r\n            var sColorNew = \"#\";\r\n            for (var i=1; i<4; i+=1) {\r\n                sColorNew += sColor.slice(i, i+1).concat(sColor.slice(i, i+1));    \r\n            }\r\n            sColor = sColorNew;\r\n        }\r\n        //\r\n        var sColorChange = [];\r\n        for (var i=1; i<7; i+=2) {\r\n            sColorChange.push(parseInt(\"0x\"+sColor.slice(i, i+2)));    \r\n        }\r\n        return \"RGB(\" + sColorChange.join(\",\") + \")\";\r\n    }\r\n    return sColor;\r\n}\r\n\r\nfunction hexToRgbArray(hex:string){\r\n    var sColor = hex.toLowerCase();\r\n    //\r\n    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;\r\n    // 16\r\n    if (sColor && reg.test(sColor)) {\r\n        if (sColor.length === 4) {\r\n            var sColorNew = \"#\";\r\n            for (var i=1; i<4; i+=1) {\r\n                sColorNew += sColor.slice(i, i+1).concat(sColor.slice(i, i+1));    \r\n            }\r\n            sColor = sColorNew;\r\n        }\r\n        //\r\n        var sColorChange:number[] = [];\r\n        for (var i=1; i<7; i+=2) {\r\n            sColorChange.push(parseInt(\"0x\"+sColor.slice(i, i+2)));    \r\n        }\r\n        return  sColorChange;\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * HSLRGB. \r\n *  http://en.wikipedia.org/wiki/HSL_color_space.\r\n * h, s,  l  [0, 1] \r\n *  r, g,  b  [0, 255]\r\n *\r\n * @param   Number  h       \r\n * @param   Number  s       \r\n * @param   Number  l       \r\n * @return  Array           RGB\r\n */\r\nfunction hslToRgb(h:number, s:number, l:number) {\r\n    var r, g, b;\r\n\r\n    if(s == 0) {\r\n        r = g = b = l; // achromatic\r\n    } else {\r\n        var hue2rgb = function hue2rgb(p:number, q:number, t:number) {\r\n            if(t < 0) t += 1;\r\n            if(t > 1) t -= 1;\r\n            if(t < 1/6) return p + (q - p) * 6 * t;\r\n            if(t < 1/2) return q;\r\n            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\r\n            return p;\r\n        }\r\n\r\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n        var p = 2 * l - q;\r\n        r = hue2rgb(p, q, h + 1/3);\r\n        g = hue2rgb(p, q, h);\r\n        b = hue2rgb(p, q, h - 1/3);\r\n    }\r\n\r\n    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\r\n}\r\n\r\n\r\n/**\r\n * RGB  HSL.\r\n *  http://en.wikipedia.org/wiki/HSL_color_space.\r\n * r, g,  b  [0, 255] \r\n *  h, s,  l  [0, 1] \r\n *\r\n * @param   Number  r       \r\n * @param   Number  g       \r\n * @param   Number  b       \r\n * @return  Array           HSL\r\n */\r\nfunction rgbToHsl(r:number, g:number, b:number) {\r\n    r /= 255, g /= 255, b /= 255;\r\n    var max = Math.max(r, g, b), min = Math.min(r, g, b);\r\n    var h, s, l = (max + min) / 2;\r\n\r\n    if (max == min){ \r\n        h = s = 0; // achromatic\r\n    } else {\r\n        var d = max - min;\r\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n        switch(max) {\r\n            case r: h = (g - b) / d + (g < b ? 6 : 0); break;\r\n            case g: h = (b - r) / d + 2; break;\r\n            case b: h = (r - g) / d + 4; break;\r\n        }\r\n        h /= 6;\r\n    }\r\n\r\n    return [h, s, l];\r\n}\r\n \r\nexport function generateRandomIndex(prefix:string):string {\r\n    if(prefix == null){\r\n        prefix = \"Sheet\";\r\n    }\r\n\r\n    let userAgent = window.navigator.userAgent.replace(/[^a-zA-Z0-9]/g, \"\").split(\"\");\r\n\r\n    let mid = \"\";\r\n\r\n    for(let i = 0; i < 5; i++){\r\n        mid += userAgent[Math.round(Math.random() * (userAgent.length - 1))];\r\n    }\r\n\r\n    let time = new Date().getTime();\r\n\r\n    return prefix + \"_\" + mid + \"_\" + time;\r\n}\r\n\r\n\r\nexport function escapeCharacter(str:string){\r\n    if(str==null || str.length==0){\r\n        return str;\r\n    }\r\n\r\n    return str.replace(/&amp;/g, \"&\").replace(/&quot;/g, '\"').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&nbsp;/g, ' ').replace(/&apos;/g, \"'\").replace(/&iexcl;/g, \"\").replace(/&cent;/g, \"\").replace(/&pound;/g, \"\").replace(/&curren;/g, \"\").replace(/&yen;/g, \"\").replace(/&brvbar;/g, \"\").replace(/&sect;/g, \"\").replace(/&uml;/g, \"\").replace(/&copy;/g, \"\").replace(/&ordf;/g, \"\").replace(/&laquo;/g, \"\").replace(/&not;/g, \"\").replace(/&shy;/g, \"\").replace(/&reg;/g, \"\").replace(/&macr;/g, \"\").replace(/&deg;/g, \"\").replace(/&plusmn;/g, \"\").replace(/&sup2;/g, \"\").replace(/&sup3;/g, \"\").replace(/&acute;/g, \"\").replace(/&micro;/g, \"\").replace(/&para;/g, \"\").replace(/&middot;/g, \"\").replace(/&cedil;/g, \"\").replace(/&sup1;/g, \"\").replace(/&ordm;/g, \"\").replace(/&raquo;/g, \"\").replace(/&frac14;/g, \"\").replace(/&frac12;/g, \"\").replace(/&frac34;/g, \"\").replace(/&iquest;/g, \"\").replace(/&times;/g, \"\").replace(/&divide;/g, \"\").replace(/&Agrave;/g, \"\").replace(/&Aacute;/g, \"\").replace(/&Acirc;/g, \"\").replace(/&Atilde;/g, \"\").replace(/&Auml;/g, \"\").replace(/&Aring;/g, \"\").replace(/&AElig;/g, \"\").replace(/&Ccedil;/g, \"\").replace(/&Egrave;/g, \"\").replace(/&Eacute;/g, \"\").replace(/&Ecirc;/g, \"\").replace(/&Euml;/g, \"\").replace(/&Igrave;/g, \"\").replace(/&Iacute;/g, \"\").replace(/&Icirc;/g, \"\").replace(/&Iuml;/g, \"\").replace(/&ETH;/g, \"\").replace(/&Ntilde;/g, \"\").replace(/&Ograve;/g, \"\").replace(/&Oacute;/g, \"\").replace(/&Ocirc;/g, \"\").replace(/&Otilde;/g, \"\").replace(/&Ouml;/g, \"\").replace(/&Oslash;/g, \"\").replace(/&Ugrave;/g, \"\").replace(/&Uacute;/g, \"\").replace(/&Ucirc;/g, \"\").replace(/&Uuml;/g, \"\").replace(/&Yacute;/g, \"\").replace(/&THORN;/g, \"\").replace(/&szlig;/g, \"\").replace(/&agrave;/g, \"\").replace(/&aacute;/g, \"\").replace(/&acirc;/g, \"\").replace(/&atilde;/g, \"\").replace(/&auml;/g, \"\").replace(/&aring;/g, \"\").replace(/&aelig;/g, \"\").replace(/&ccedil;/g, \"\").replace(/&egrave;/g, \"\").replace(/&eacute;/g, \"\").replace(/&ecirc;/g, \"\").replace(/&euml;/g, \"\").replace(/&igrave;/g, \"\").replace(/&iacute;/g, \"\").replace(/&icirc;/g, \"\").replace(/&iuml;/g, \"\").replace(/&eth;/g, \"\").replace(/&ntilde;/g, \"\").replace(/&ograve;/g, \"\").replace(/&oacute;/g, \"\").replace(/&ocirc;/g, \"\").replace(/&otilde;/g, \"\").replace(/&ouml;/g, \"\").replace(/&oslash;/g, \"\").replace(/&ugrave;/g, \"\").replace(/&uacute;/g, \"\").replace(/&ucirc;/g, \"\").replace(/&uuml;/g, \"\").replace(/&yacute;/g, \"\").replace(/&thorn;/g, \"\").replace(/&yuml;/g, \"\");\r\n\r\n}\r\n\r\n\r\nexport class fromulaRef {\r\n\r\n    static operator = '==|!=|<>|<=|>=|=|+|-|>|<|/|*|%|&|^'\r\n    static error = {\r\n        v: \"#VALUE!\",    //\r\n        n: \"#NAME?\",     //\r\n        na: \"#N/A\",      //\r\n        r: \"#REF!\",      //\r\n        d: \"#DIV/0!\",    //0\r\n        nm: \"#NUM!\",     //\r\n        nl: \"#NULL!\",    //\r\n        sp: \"#SPILL!\"    //\r\n    }\r\n\r\n    static operatorjson:stringToNum = null\r\n\r\n    static trim(str:string) {  \r\n        if(str == null){  \r\n            str = \"\";  \r\n        }  \r\n        return str.replace(/(^\\s*)|(\\s*$)/g, \"\");  \r\n    }\r\n\r\n    static functionCopy(txt:string, mode:string, step:number) {\r\n        let _this = this;\r\n\r\n        if (_this.operatorjson == null) {\r\n            let arr = _this.operator.split(\"|\"),\r\n                op:stringToNum = {};\r\n\r\n            for (let i = 0; i < arr.length; i++) {\r\n                op[arr[i].toString()] = 1;\r\n            }\r\n\r\n            _this.operatorjson = op;\r\n        }\r\n\r\n        if (mode == null) {\r\n            mode = \"down\";\r\n        }\r\n\r\n        if (step == null) {\r\n            step = 1;\r\n        }\r\n\r\n        if (txt.substr(0, 1) == \"=\") {\r\n            txt = txt.substr(1);\r\n        }\r\n\r\n        let funcstack = txt.split(\"\");\r\n        let i = 0,\r\n            str = \"\",\r\n            function_str = \"\",\r\n            ispassby = true;\r\n        \r\n        let matchConfig = {\r\n            \"bracket\": 0,\r\n            \"comma\": 0,\r\n            \"squote\": 0,\r\n            \"dquote\": 0\r\n        };\r\n\r\n        while (i < funcstack.length) {\r\n            let s = funcstack[i];\r\n\r\n            if (s == \"(\" && matchConfig.dquote == 0) {\r\n                matchConfig.bracket += 1;\r\n\r\n                if (str.length > 0) {\r\n                    function_str += str + \"(\";\r\n                } \r\n                else {\r\n                    function_str += \"(\";\r\n                }\r\n\r\n                str = \"\";\r\n            } \r\n            else if (s == \")\" && matchConfig.dquote == 0) {\r\n                matchConfig.bracket -= 1;\r\n                function_str += _this.functionCopy(str, mode, step) + \")\";\r\n                str = \"\";\r\n            }\r\n            else if (s == '\"' && matchConfig.squote == 0) {\r\n                if (matchConfig.dquote > 0) {\r\n                    function_str += str + '\"';\r\n                    matchConfig.dquote -= 1;\r\n                    str = \"\";\r\n                } \r\n                else {\r\n                    matchConfig.dquote += 1;\r\n                    str += '\"';\r\n                }\r\n            } \r\n            else if (s == ',' && matchConfig.dquote == 0) {\r\n                function_str += _this.functionCopy(str, mode, step) + ',';\r\n                str = \"\";\r\n            } \r\n            else if (s == '&' && matchConfig.dquote == 0) {\r\n                if (str.length > 0) {\r\n                    function_str += _this.functionCopy(str, mode, step) + \"&\";\r\n                    str = \"\";\r\n                } \r\n                else {\r\n                    function_str += \"&\";\r\n                }\r\n            } \r\n            else if (s in _this.operatorjson && matchConfig.dquote == 0) {\r\n                let s_next = \"\";\r\n\r\n                if ((i + 1) < funcstack.length) {\r\n                    s_next = funcstack[i + 1];\r\n                }\r\n\r\n                let p = i - 1, \r\n                    s_pre = null;\r\n\r\n                if(p >= 0){\r\n                    do {\r\n                        s_pre = funcstack[p--];\r\n                    }\r\n                    while (p>=0 && s_pre ==\" \")\r\n                }\r\n\r\n                if ((s + s_next) in _this.operatorjson) {\r\n                    if (str.length > 0) {\r\n                        function_str += _this.functionCopy(str, mode, step) + s + s_next;\r\n                        str = \"\";\r\n                    } \r\n                    else {\r\n                        function_str += s + s_next;\r\n                    }\r\n\r\n                    i++;\r\n                }\r\n                else if(!(/[^0-9]/.test(s_next)) && s==\"-\" && (s_pre==\"(\" || s_pre == null || s_pre == \",\" || s_pre == \" \" || s_pre in _this.operatorjson ) ){\r\n                    str += s;\r\n                }\r\n                else {\r\n                    if (str.length > 0) {\r\n                        function_str += _this.functionCopy(str, mode, step) + s;\r\n                        str = \"\";\r\n                    } \r\n                    else {\r\n                        function_str += s;\r\n                    }\r\n                }\r\n            } \r\n            else {\r\n                str += s;\r\n            }\r\n\r\n            if (i == funcstack.length - 1) {\r\n                if (_this.iscelldata(_this.trim(str))) {\r\n                    if (mode == \"down\") {\r\n                        function_str += _this.downparam(_this.trim(str), step);\r\n                    } \r\n                    else if (mode == \"up\") {\r\n                        function_str += _this.upparam(_this.trim(str), step);\r\n                    } \r\n                    else if (mode == \"left\") {\r\n                        function_str += _this.leftparam(_this.trim(str), step);\r\n                    } \r\n                    else if (mode == \"right\") {\r\n                        function_str += _this.rightparam(_this.trim(str), step);\r\n                    }\r\n                } \r\n                else {\r\n                    function_str += _this.trim(str);\r\n                }\r\n            }\r\n            \r\n            i++;\r\n        }\r\n\r\n        return function_str;\r\n    }\r\n\r\n\r\n    static downparam(txt:string, step:number) {\r\n        return this.updateparam(\"d\", txt, step);\r\n    }\r\n\r\n    static upparam(txt:string, step:number) {\r\n        return this.updateparam(\"u\", txt, step);\r\n    }\r\n\r\n    static leftparam(txt:string, step:number) {\r\n        return this.updateparam(\"l\", txt, step);\r\n    }\r\n\r\n    static rightparam (txt:string, step:number) {\r\n        return this.updateparam(\"r\", txt, step);\r\n    }\r\n\r\n\r\n    static updateparam (orient:string, txt:string, step:number) {\r\n        let _this = this;\r\n        let val = txt.split(\"!\"),\r\n            rangetxt, prefix = \"\";\r\n        \r\n        if (val.length > 1) {\r\n            rangetxt = val[1];\r\n            prefix = val[0] + \"!\";\r\n        } \r\n        else {\r\n            rangetxt = val[0];\r\n        }\r\n\r\n        if (rangetxt.indexOf(\":\") == -1) {\r\n            let row = parseInt(rangetxt.replace(/[^0-9]/g, \"\"));\r\n            let col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, \"\"));\r\n            let freezonFuc = _this.isfreezonFuc(rangetxt);\r\n            let $row = freezonFuc[0] ? \"$\" : \"\",\r\n                $col = freezonFuc[1] ? \"$\" : \"\";\r\n            \r\n            if (orient == \"u\" && !freezonFuc[0]) {\r\n                row -= step;\r\n            } \r\n            else if (orient == \"r\" && !freezonFuc[1]) {\r\n                col += step;\r\n            } \r\n            else if (orient == \"l\" && !freezonFuc[1]) {\r\n                col -= step;\r\n            } \r\n            else if (!freezonFuc[0]) {\r\n                row += step;\r\n            }\r\n\r\n            if(row < 0 || col < 0){\r\n                return _this.error.r;\r\n            }\r\n            \r\n            if (!isNaN(row) && !isNaN(col)) {\r\n                return prefix + $col + chatatABC(col) + $row + (row);\r\n            } \r\n            else if (!isNaN(row)) {\r\n                return prefix + $row + (row);\r\n            } \r\n            else if (!isNaN(col)) {\r\n                return prefix + $col + chatatABC(col);\r\n            } \r\n            else {\r\n                return txt;\r\n            }\r\n        } \r\n        else {\r\n            rangetxt = rangetxt.split(\":\");\r\n            let row = [],\r\n                col = [];\r\n\r\n            row[0] = parseInt(rangetxt[0].replace(/[^0-9]/g, \"\"));\r\n            row[1] = parseInt(rangetxt[1].replace(/[^0-9]/g, \"\"));\r\n            if (row[0] > row[1]) {\r\n                return txt;\r\n            }\r\n            \r\n            col[0] = ABCatNum(rangetxt[0].replace(/[^A-Za-z]/g, \"\"));\r\n            col[1] = ABCatNum(rangetxt[1].replace(/[^A-Za-z]/g, \"\"));\r\n            if (col[0] > col[1]) {\r\n                return txt;\r\n            }\r\n\r\n            let freezonFuc0 = _this.isfreezonFuc(rangetxt[0]);\r\n            let freezonFuc1 = _this.isfreezonFuc(rangetxt[1]);\r\n            let $row0 = freezonFuc0[0] ? \"$\" : \"\",\r\n                $col0 = freezonFuc0[1] ? \"$\" : \"\";\r\n            let $row1 = freezonFuc1[0] ? \"$\" : \"\",\r\n                $col1 = freezonFuc1[1] ? \"$\" : \"\";\r\n            \r\n            if (orient == \"u\") {\r\n                if (!freezonFuc0[0]) {\r\n                    row[0] -= step;\r\n                }\r\n\r\n                if (!freezonFuc1[0]) {\r\n                    row[1] -= step;\r\n                }\r\n            } \r\n            else if (orient == \"r\") {\r\n                if (!freezonFuc0[1]) {\r\n                    col[0] += step;\r\n                }\r\n\r\n                if (!freezonFuc1[1]) {\r\n                    col[1] += step;\r\n                }\r\n            } \r\n            else if (orient == \"l\") {\r\n                if (!freezonFuc0[1]) {\r\n                    col[0] -= step;\r\n                }\r\n\r\n                if (!freezonFuc1[1]) {\r\n                    col[1] -= step;\r\n                }\r\n            } \r\n            else {\r\n                if (!freezonFuc0[0]) {\r\n                    row[0] += step;\r\n                }\r\n\r\n                if (!freezonFuc1[0]) {\r\n                    row[1] += step;\r\n                }\r\n            }\r\n\r\n            if(row[0] < 0 || col[0] < 0){\r\n                return _this.error.r;\r\n            }\r\n\r\n            if (isNaN(col[0]) && isNaN(col[1])) {\r\n                return prefix + $row0 + (row[0]) + \":\" + $row1 + (row[1]);\r\n            } \r\n            else if (isNaN(row[0]) && isNaN(row[1])) {\r\n                return prefix + $col0 + chatatABC(col[0]) + \":\" + $col1 + chatatABC(col[1]);\r\n            } \r\n            else {\r\n                return prefix + $col0 + chatatABC(col[0]) + $row0 + (row[0]) + \":\" + $col1 + chatatABC(col[1]) + $row1 + (row[1]);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    static iscelldata(txt:string) { //\r\n        let val = txt.split(\"!\"),\r\n            rangetxt;\r\n\r\n        if (val.length > 1) {\r\n            rangetxt = val[1];\r\n        } \r\n        else {\r\n            rangetxt = val[0];\r\n        }\r\n\r\n        let reg_cell = /^(([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+))$/g; //+ A1:B3\r\n        let reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+))))$/g; //+ A1:B3A:A\r\n        \r\n        if (rangetxt.indexOf(\":\") == -1) {\r\n            let row = parseInt(rangetxt.replace(/[^0-9]/g, \"\")) - 1;\r\n            let col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, \"\"));\r\n            \r\n            if (!isNaN(row) && !isNaN(col) && rangetxt.toString().match(reg_cell)) {\r\n                return true;\r\n            } \r\n            else if (!isNaN(row)) {\r\n                return false;\r\n            } \r\n            else if (!isNaN(col)) {\r\n                return false;\r\n            } \r\n            else {\r\n                return false;\r\n            }\r\n        } \r\n        else {\r\n            reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+)))|((([0-9]+)|([$][0-9]+s))))$/g;\r\n\r\n            rangetxt = rangetxt.split(\":\");\r\n\r\n            let row = [],col = [];\r\n            row[0] = parseInt(rangetxt[0].replace(/[^0-9]/g, \"\")) - 1;\r\n            row[1] = parseInt(rangetxt[1].replace(/[^0-9]/g, \"\")) - 1;\r\n            if (row[0] > row[1]) {\r\n                return false;\r\n            }\r\n\r\n            col[0] = ABCatNum(rangetxt[0].replace(/[^A-Za-z]/g, \"\"));\r\n            col[1] = ABCatNum(rangetxt[1].replace(/[^A-Za-z]/g, \"\"));\r\n            if (col[0] > col[1]) {\r\n                return false;\r\n            }\r\n\r\n            if(rangetxt[0].toString().match(reg_cellRange) && rangetxt[1].toString().match(reg_cellRange)){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    static isfreezonFuc(txt:string) {\r\n        let row = txt.replace(/[^0-9]/g, \"\");\r\n        let col = txt.replace(/[^A-Za-z]/g, \"\");\r\n        let row$ = txt.substr(txt.indexOf(row) - 1, 1);\r\n        let col$ = txt.substr(txt.indexOf(col) - 1, 1);\r\n        let ret = [false, false];\r\n\r\n        if (row$ == \"$\") {\r\n            ret[0] = true;\r\n        }\r\n        if (col$ == \"$\") {\r\n            ret[1] = true;\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nexport function isChinese(temp:string):boolean\r\n{ \r\n    var re = /[^\\u4e00-\\u9fa5]/; \r\n    var reg = /[\\u3002|\\uff1f|\\uff01|\\uff0c|\\u3001|\\uff1b|\\uff1a|\\u201c|\\u201d|\\u2018|\\u2019|\\uff08|\\uff09|\\u300a|\\u300b|\\u3008|\\u3009|\\u3010|\\u3011|\\u300e|\\u300f|\\u300c|\\u300d|\\ufe43|\\ufe44|\\u3014|\\u3015|\\u2026|\\u2014|\\uff5e|\\ufe4f|\\uffe5]/;\r\n    if(reg.test(temp)) return true; \r\n    if(re.test(temp)) return false; \r\n\treturn true; \r\n}\r\n \r\nexport function isJapanese(temp:string):boolean\r\n{ \r\n\tvar re = /[^\\u0800-\\u4e00]/; \r\n\tif(re.test(temp)) return false; \r\n\treturn true; \r\n}\r\n \r\nexport function isKoera(chr:any):boolean {\r\n\t\r\n\tif(((chr > 0x3130 && chr < 0x318F) || \r\n\t    (chr >= 0xAC00 && chr <= 0xD7A3))) \r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nexport function isContainMultiType(str:string):boolean {\r\n\t\r\n    let isUnicode = false;\r\n    if(escape(str).indexOf(\"%u\")>-1){\r\n        isUnicode = true;\r\n    }\r\n\r\n    let isNot = false;\r\n    let reg = /[0-9a-z]/gi; \r\n    if(reg.test(str)){\r\n        isNot = true;\r\n    }\r\n\r\n    let reEnSign = /[\\x00-\\xff]+/g;\r\n    if(reEnSign.test(str)){\r\n        isNot = true;\r\n    }\r\n\r\n    if(isUnicode && isNot){\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport function getBinaryContent (path:any, options:any) {\r\n    let promise, resolve:any, reject:any;\r\n    let callback:any;\r\n\r\n    if (!options) {\r\n        options = {};\r\n    }\r\n\r\n    // taken from jQuery\r\n    let createStandardXHR = function () {\r\n        try {\r\n            return new window.XMLHttpRequest();\r\n        } catch( e ) {}\r\n    }\r\n\r\n    let createActiveXHR = function () {\r\n        try {\r\n            return new window.ActiveXObject(\"Microsoft.XMLHTTP\");\r\n        } catch( e ) {}\r\n    }\r\n\r\n    // Create the request object\r\n    var createXHR = (typeof window !== \"undefined\" && window.ActiveXObject) ?\r\n        /* Microsoft failed to properly\r\n        * implement the XMLHttpRequest in IE7 (can't request local files),\r\n        * so we use the ActiveXObject when it is available\r\n        * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\r\n        * we need a fallback.\r\n        */\r\n        function() {\r\n        return createStandardXHR() || createActiveXHR();\r\n    } :\r\n        // For all other browsers, use the standard XMLHttpRequest object\r\n        createStandardXHR;\r\n\r\n    // backward compatible callback\r\n    if (typeof options === \"function\") {\r\n        callback = options;\r\n        options = {};\r\n    } else if (typeof options.callback === 'function') {\r\n        // callback inside options object\r\n        callback = options.callback;\r\n    }\r\n\r\n    resolve = function (data:any) { callback(null, data); };\r\n    reject = function (err:any) { callback(err, null); };\r\n\r\n    try {\r\n        var xhr = createXHR();\r\n\r\n        xhr.open('GET', path, true);\r\n\r\n        // recent browsers\r\n        if (\"responseType\" in xhr) {\r\n            xhr.responseType = \"arraybuffer\";\r\n        }\r\n\r\n        // older browser\r\n        if(xhr.overrideMimeType) {\r\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\r\n        }\r\n\r\n        xhr.onreadystatechange = function (event:Event) {\r\n            // use `xhr` and not `this`... thanks IE\r\n            if (xhr.readyState === 4) {\r\n                if (xhr.status === 200 || xhr.status === 0) {\r\n                    try {\r\n                        resolve(function (xhr:XMLHttpRequest) {\r\n                            // for xhr.responseText, the 0xFF mask is applied by JSZip\r\n                            return xhr.response || xhr.responseText;\r\n                        }(xhr));\r\n                    } catch(err) {\r\n                        reject(new Error(err));\r\n                    }\r\n                } else {\r\n                    reject(new Error(\"Ajax error for \" + path + \" : \" + this.status + \" \" + this.statusText));\r\n                }\r\n            }\r\n        };\r\n\r\n        if(options.progress) {\r\n            xhr.onprogress = function(e:any) {\r\n                options.progress({\r\n                    path: path,\r\n                    originalEvent: e,\r\n                    percent: e.loaded / e.total * 100,\r\n                    loaded: e.loaded,\r\n                    total: e.total\r\n                });\r\n            };\r\n        }\r\n\r\n        xhr.send();\r\n\r\n    } catch (e) {\r\n        reject(new Error(e), null);\r\n    }\r\n\r\n    // returns a promise or undefined depending on whether a callback was\r\n    // provided\r\n    return promise;\r\n}\r\n\r\n/**\r\n * multi sequence conversion\r\n * example:\r\n *  1E14 -> 13_4\r\n *  2E14 J14 O14 T14 Y14 AD14 AI14 AN14 AS14 AX14 ->\r\n *     ['13_4', '13_9','13_14', '13_19', '13_24', '13_3', '13_8',  '13_13', '13_18', '13_23']\r\n *  3E46:E47 -> ['45_4',  '46_4']\r\n *\r\n * @param {string} sqref - before sequence\r\n * @returns {string[]}\r\n */\r\nexport function getMultiSequenceToNum(sqref: string): string[] {\r\n  if (!sqref || sqref?.length <= 0) return [];\r\n  sqref = sqref.toUpperCase();\r\n  let sqrefRawArr = sqref.split(\" \");\r\n  let sqrefArr = sqrefRawArr.filter((e) => e && e.trim());\r\n  let sqrefLastArr = getSqrefRawArrFormat(sqrefArr);\r\n\r\n  let resArr: string[] = [];\r\n  for (let i = 0; i < sqrefLastArr.length; i++) {\r\n    let _res = getSingleSequenceToNum(sqrefLastArr[i]);\r\n    if (_res) resArr.push(_res);\r\n  }\r\n  return resArr;\r\n}\r\n\r\n/**\r\n * unified processing of conversion formats\r\n * example:\r\n *  1['E38', 'A1:C2'] -> ['E38', 'A1', 'A2', 'B1', 'B2', 'C1', 'C2']\r\n *\r\n * @param {string[]} arr - formats arr\r\n * @returns {string[]} - after arr\r\n */\r\nexport function getSqrefRawArrFormat(arr: string[]): string[] {\r\n  arr?.map((el) => {\r\n    if (el.includes(\":\")) {\r\n      let tempArr: string[] = el.split(\":\");\r\n      if (tempArr?.length === 2) {\r\n        let regEn = new RegExp(/[A-Z]+|[0-9]+/g);\r\n        let startArr = tempArr[0]?.match(regEn);\r\n        let lastArr = tempArr[1]?.match(regEn);\r\n        let columnMax = Math.max(\r\n          ...[ABCatNum(startArr[0]), ABCatNum(lastArr[0])]\r\n        );\r\n        let columnMin = Math.min(\r\n          ...[ABCatNum(startArr[0]), ABCatNum(lastArr[0])]\r\n        );\r\n        let rowMax = Math.max(...[parseInt(startArr[1]), parseInt(lastArr[1])]);\r\n        let rowMin = Math.min(...[parseInt(startArr[1]), parseInt(lastArr[1])]);\r\n        let formatArr: string[] = [];\r\n        \r\n        for (let i = columnMin; i <= columnMax; i++) {\r\n          for (let j = rowMin; j <= rowMax; j++) {\r\n            formatArr.push(`${chatatABC(i)}${j}`);\r\n          }\r\n        }\r\n        arr = arr.concat(formatArr);\r\n        arr.splice(arr.indexOf(el), 1);\r\n      }\r\n    }\r\n  });\r\n  return arr;\r\n}\r\n\r\n/**\r\n * single sequence to number\r\n * example:\r\n *  1A1 -> 0_0\r\n *  2ES14 -> 13_4\r\n *\r\n * @param {string} sqref - before sequence\r\n * @returns {string} - after sequence\r\n */\r\nexport function getSingleSequenceToNum(sqref: string): string {\r\n  let sqrefArray = sqref.match(/[A-Z]+|[0-9]+/g);\r\n  let sqrefLen = sqrefArray.length;\r\n  let regEn = new RegExp(\"^[A-Z]+$\");\r\n  let ret = \"\";\r\n  for (let i = sqrefLen - 1; i >= 0; i--) {\r\n    let cur = sqrefArray[i];\r\n    if (regEn.test(cur)) {\r\n      ret += ABCatNum(cur) + \"_\";\r\n    } else {\r\n      ret += parseInt(cur) - 1 + \"_\";\r\n    }\r\n  }\r\n  return ret.substring(0, ret.length - 1);\r\n}\r\n\r\n/**\r\n * R1C1 to Sequence\r\n * example: sheet2!R1C1 => sheet!A1\r\n *\r\n * @param {string} value - R1C1 value\r\n * @returns\r\n */\r\n export function getTransR1C1ToSequence(value: string): string {\r\n  if (!value && value?.length <= 0) return \"\";\r\n  let valueArr = value.toLocaleUpperCase()?.split(\"!\");\r\n  let repStr = valueArr[1] || \"\";\r\n  let indexR = repStr.indexOf(\"R\");\r\n  let indexC = repStr.indexOf(\"C\");\r\n  let row = Number(repStr.slice(indexR + 1, indexC));\r\n  let column = chatatABC(Number(repStr.slice(indexC + 1, repStr?.length)) - 1);\r\n  return `${valueArr[0]}!${column}${row}`;\r\n}","import { LuckyFile } from \"./ToLuckySheet/LuckyFile\";\r\n// import {SecurityDoor,Car} from './content';\r\n\r\nimport {HandleZip} from './HandleZip';\r\n\r\nimport {IuploadfileList} from \"./ICommon\";\r\nimport { fstat } from \"fs\";\r\n\r\n// //demo\r\n// function demoHandler(){\r\n//     let upload = document.getElementById(\"Luckyexcel-demo-file\");\r\n//     let selectADemo = document.getElementById(\"Luckyexcel-select-demo\");\r\n//     let downlodDemo = document.getElementById(\"Luckyexcel-downlod-file\");\r\n//     let mask = document.getElementById(\"lucky-mask-demo\");\r\n//     if(upload){\r\n        \r\n//         window.onload = () => {\r\n            \r\n//             upload.addEventListener(\"change\", function(evt){\r\n//                 var files:FileList = (evt.target as any).files;\r\n//                 if(files==null || files.length==0){\r\n//                     alert(\"No files wait for import\");\r\n//                     return;\r\n//                 }\r\n\r\n//                 let name = files[0].name;\r\n//                 let suffixArr = name.split(\".\"), suffix = suffixArr[suffixArr.length-1];\r\n//                 if(suffix!=\"xlsx\"){\r\n//                     alert(\"Currently only supports the import of xlsx files\");\r\n//                     return;\r\n//                 }\r\n//                 LuckyExcel.transformExcelToLucky(files[0], function(exportJson:any, luckysheetfile:string){\r\n                    \r\n//                     if(exportJson.sheets==null || exportJson.sheets.length==0){\r\n//                         alert(\"Failed to read the content of the excel file, currently does not support xls files!\");\r\n//                         return;\r\n//                     }\r\n//                     console.log(exportJson, luckysheetfile);\r\n//                     window.luckysheet.destroy();\r\n                    \r\n//                     window.luckysheet.create({\r\n//                         container: 'luckysheet', //luckysheet is the container id\r\n//                         showinfobar:false,\r\n//                         data:exportJson.sheets,\r\n//                         title:exportJson.info.name,\r\n//                         userInfo:exportJson.info.name.creator\r\n//                     });\r\n//                 });\r\n//             });\r\n\r\n//             selectADemo.addEventListener(\"change\", function(evt){\r\n//                 var obj:any = selectADemo;\r\n//                 var index = obj.selectedIndex;\r\n//                 var value = obj.options[index].value;\r\n//                 var name = obj.options[index].innerHTML;\r\n//                 if(value==\"\"){\r\n//                     return;\r\n//                 }\r\n//                 mask.style.display = \"flex\";\r\n//                 LuckyExcel.transformExcelToLuckyByUrl(value, name, function(exportJson:any, luckysheetfile:string){\r\n                    \r\n//                     if(exportJson.sheets==null || exportJson.sheets.length==0){\r\n//                         alert(\"Failed to read the content of the excel file, currently does not support xls files!\");\r\n//                         return;\r\n//                     }\r\n//                     console.log(exportJson, luckysheetfile);\r\n//                     mask.style.display = \"none\";\r\n//                     window.luckysheet.destroy();\r\n                    \r\n//                     window.luckysheet.create({\r\n//                         container: 'luckysheet', //luckysheet is the container id\r\n//                         showinfobar:false,\r\n//                         data:exportJson.sheets,\r\n//                         title:exportJson.info.name,\r\n//                         userInfo:exportJson.info.name.creator\r\n//                     });\r\n//                 });\r\n//             });\r\n\r\n//             downlodDemo.addEventListener(\"click\", function(evt){\r\n//                 var obj:any = selectADemo;\r\n//                 var index = obj.selectedIndex;\r\n//                 var value = obj.options[index].value;\r\n\r\n//                 if(value.length==0){\r\n//                     alert(\"Please select a demo file\");\r\n//                     return;\r\n//                 }\r\n\r\n//                 var elemIF:any = document.getElementById(\"Lucky-download-frame\");\r\n//                 if(elemIF==null){\r\n//                     elemIF = document.createElement(\"iframe\");\r\n//                     elemIF.style.display = \"none\";\r\n//                     elemIF.id = \"Lucky-download-frame\";\r\n//                     document.body.appendChild(elemIF);\r\n//                 }\r\n//                 elemIF.src = value;\r\n\r\n//                 // elemIF.parentNode.removeChild(elemIF);\r\n//             });\r\n//         }\r\n//     }\r\n// }\r\n// demoHandler();\r\n\r\n// api\r\nexport class LuckyExcel{\r\n    static transformExcelToLucky(excelFile: File,\r\n        callback?: (files: IuploadfileList, fs?: string) => void,\r\n        errorHandler?: (err: Error) => void) {\r\n        let handleZip:HandleZip = new HandleZip(excelFile);\r\n        \r\n        handleZip.unzipFile(function (files: IuploadfileList) {\r\n            let luckyFile = new LuckyFile(files, excelFile.name);\r\n            let luckysheetfile = luckyFile.Parse();\r\n            let exportJson = JSON.parse(luckysheetfile);\r\n            if (callback != undefined) {\r\n                callback(exportJson, luckysheetfile);\r\n            }\r\n        },\r\n        function(err:Error){\r\n            if (errorHandler) {\r\n                errorHandler(err);\r\n              } else {\r\n                console.error(err);\r\n              }\r\n        });\r\n    }\r\n\r\n    static transformExcelToLuckyByUrl(\r\n        url: string,\r\n        name: string,\r\n        callBack?: (files: IuploadfileList, fs?: string) => void,\r\n        errorHandler?: (err: Error) => void) {\r\n        let handleZip:HandleZip = new HandleZip();\r\n        handleZip.unzipFileByUrl(url, function(files:IuploadfileList){\r\n            let luckyFile = new LuckyFile(files, name);\r\n            let luckysheetfile = luckyFile.Parse();\r\n            let exportJson = JSON.parse(luckysheetfile);\r\n            if(callBack != undefined){\r\n                callBack(exportJson, luckysheetfile);\r\n            }\r\n        },\r\n        function(err:Error){\r\n            if (errorHandler) {\r\n                errorHandler(err);\r\n              } else {\r\n                console.error(err);\r\n              }\r\n        });\r\n    }\r\n\r\n    static transformLuckyToExcel(\r\n        LuckyFile: any,\r\n        callBack?: (files: string) => void ,\r\n        errorHandler?: (err: Error) => void){ }\r\n}","import {LuckyExcel} from \"./main\"\r\n// export Node module\r\nexport = LuckyExcel;"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbW1lZGlhdGUvbGliL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jb21wcmVzc2VkT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jb21wcmVzc2lvbnMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2NyYzMyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvZXh0ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2ZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9nZW5lcmF0ZS9aaXBGaWxlV29ya2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9nZW5lcmF0ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2xvYWQuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqc1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9ub2RlanMvTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9ub2RlanMvTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkYWJsZS1zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL0FycmF5UmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvRGF0YVJlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL05vZGVCdWZmZXJSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9TdHJpbmdSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9VaW50OEFycmF5UmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvcmVhZGVyRm9yLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zaWduYXR1cmUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9Db252ZXJ0V29ya2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vQ3JjMzJQcm9iZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0RhdGFMZW5ndGhQcm9iZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0RhdGFXb3JrZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9HZW5lcmljV29ya2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vU3RyZWFtSGVscGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdXBwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi91dGY4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwRW50cmllcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwRW50cnkuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcE9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9saWUvbGliL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NldC1pbW1lZGlhdGUtc2hpbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwic3JjL0hhbmRsZVppcC50cyIsInNyYy9Ub0x1Y2t5U2hlZXQvTHVja3lCYXNlLnRzIiwic3JjL1RvTHVja3lTaGVldC9MdWNreUNlbGwudHMiLCJzcmMvVG9MdWNreVNoZWV0L0x1Y2t5RmlsZS50cyIsInNyYy9Ub0x1Y2t5U2hlZXQvTHVja3lJbWFnZS50cyIsInNyYy9Ub0x1Y2t5U2hlZXQvTHVja3lTaGVldC50cyIsInNyYy9Ub0x1Y2t5U2hlZXQvUmVhZFhtbC50cyIsInNyYy9jb21tb24vY29uc3RhbnQudHMiLCJzcmMvY29tbW9uL2VtZi50cyIsInNyYy9jb21tb24vbWV0aG9kLnRzIiwic3JjL21haW4udHMiLCJzcmMvbWFpbi51bWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0c0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkVBLElBQUEsT0FBQSxHQUFBLGVBQUEsQ0FBQSxPQUFBLENBQUEsT0FBQSxDQUFBLENBQUE7O0FBRUEsSUFBQSxRQUFBLEdBQUEsT0FBQSxDQUFBLGlCQUFBLENBQUE7O0FBR0EsSUFBQSxTQUFBO0FBQUE7QUFBQSxZQUFBO0FBSUksV0FBQSxTQUFBLENBQVksSUFBWixFQUFzQjtBQUNsQjtBQUNBO0FBQ0ksU0FBSyxVQUFMLEdBQWtCLElBQWxCLENBSGMsQ0FJbEI7QUFDSDs7QUFFRCxFQUFBLFNBQUEsQ0FB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O0FBQ3JCLFFBQUEsUUFBUSxDQUFDLFVBQUQsRUFBYSxjQUFiLENBQVI7QUFDSDtBQUNKLEtBUEQsRUFRQSxVQUFTLEdBQVQsRUFBa0I7QUFDZCxVQUFJLFlBQUosRUFBa0I7QUFDZCxRQUFBLFlBQVksQ0FBQyxHQUFELENBQVo7QUFDRCxPQUZILE1BRVM7QUFDTCxRQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsR0FBZDtBQUNEO0FBQ04sS0FkRDtBQWVILEdBckJNOztBQXVCQSxFQUFBLFVBQUEsQ0FBQSxxQkFBQSxHQUFQLFVBQ0ksU0FESixFQUVJLFFBRkosRUFHSSxZQUhKLEVBR3VDLENBQUksQ0FIcEM7O0FBSVgsU0FBQSxVQUFBO0FBQUMsQ0FsREQsRUFBQTs7QUFBYSxPQUFBLENBQUEsVUFBQSxHQUFBLFVBQUE7Ozs7O0FDMUdiLElBQUEsTUFBQSxHQUFBLE9BQUEsQ0FBQSxRQUFBLENBQUE7O0FBRUEsTUFBQSxDQUFBLE9BQUEsR0FBUyxNQUFBLENBQUEsVUFBVCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTXV0YXRpb24gPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxudmFyIHNjaGVkdWxlRHJhaW47XG5cbntcbiAgaWYgKE11dGF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uKG5leHRUaWNrKTtcbiAgICB2YXIgZWxlbWVudCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQuZGF0YSA9IChjYWxsZWQgPSArK2NhbGxlZCAlIDIpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIWdsb2JhbC5zZXRJbW1lZGlhdGUgJiYgdHlwZW9mIGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBnbG9iYWwuTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IG5leHRUaWNrO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoJ2RvY3VtZW50JyBpbiBnbG9iYWwgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgdmFyIHNjcmlwdEVsID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0VGljaygpO1xuXG4gICAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHNjcmlwdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgICBzY3JpcHRFbCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGljaywgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgZHJhaW5pbmc7XG52YXIgcXVldWUgPSBbXTtcbi8vbmFtZWQgbmV4dFRpY2sgZm9yIGxlc3MgY29uZnVzaW5nIHN0YWNrIHRyYWNlc1xuZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGksIG9sZFF1ZXVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAobGVuKSB7XG4gICAgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBvbGRRdWV1ZVtpXSgpO1xuICAgIH1cbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cbiAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbW1lZGlhdGU7XG5mdW5jdGlvbiBpbW1lZGlhdGUodGFzaykge1xuICBpZiAocXVldWUucHVzaCh0YXNrKSA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBzY2hlZHVsZURyYWluKCk7XG4gIH1cbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuLy8gcHJpdmF0ZSBwcm9wZXJ0eVxudmFyIF9rZXlTdHIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG5cblxuLy8gcHVibGljIG1ldGhvZCBmb3IgZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjMsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCBsZW4gPSBpbnB1dC5sZW5ndGgsIHJlbWFpbmluZ0J5dGVzID0gbGVuO1xuXG4gICAgdmFyIGlzQXJyYXkgPSB1dGlscy5nZXRUeXBlT2YoaW5wdXQpICE9PSBcInN0cmluZ1wiO1xuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJlbWFpbmluZ0J5dGVzID0gbGVuIC0gaTtcblxuICAgICAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICAgICAgICAgIGNocjIgPSBpIDwgbGVuID8gaW5wdXRbaSsrXSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG4gICAgICAgIGVuYzMgPSByZW1haW5pbmdCeXRlcyA+IDEgPyAoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpIDogNjQ7XG4gICAgICAgIGVuYzQgPSByZW1haW5pbmdCeXRlcyA+IDIgPyAoY2hyMyAmIDYzKSA6IDY0O1xuXG4gICAgICAgIG91dHB1dC5wdXNoKF9rZXlTdHIuY2hhckF0KGVuYzEpICsgX2tleVN0ci5jaGFyQXQoZW5jMikgKyBfa2V5U3RyLmNoYXJBdChlbmMzKSArIF9rZXlTdHIuY2hhckF0KGVuYzQpKTtcblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn07XG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGRlY29kaW5nXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGF0YVVybFByZWZpeCA9IFwiZGF0YTpcIjtcblxuICAgIGlmIChpbnB1dC5zdWJzdHIoMCwgZGF0YVVybFByZWZpeC5sZW5ndGgpID09PSBkYXRhVXJsUHJlZml4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBjb21tb24gZXJyb3I6IHBlb3BsZSBnaXZlIGEgZGF0YSB1cmxcbiAgICAgICAgLy8gKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUi4uLikgd2l0aCBhIHtiYXNlNjQ6IHRydWV9IGFuZFxuICAgICAgICAvLyB3b25kZXJzIHdoeSB0aGluZ3MgZG9uJ3Qgd29yay5cbiAgICAgICAgLy8gV2UgY2FuIGRldGVjdCB0aGF0IHRoZSBzdHJpbmcgaW5wdXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsIGJ1dCB3ZVxuICAgICAgICAvLyAqY2FuJ3QqIGJlIHN1cmUgaXQgaXMgb25lOiByZW1vdmluZyBldmVyeXRoaW5nIHVwIHRvIHRoZSBjb21tYSB3b3VsZFxuICAgICAgICAvLyBiZSB0b28gZGFuZ2Vyb3VzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgaXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsLlwiKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCBcIlwiKTtcblxuICAgIHZhciB0b3RhbExlbmd0aCA9IGlucHV0Lmxlbmd0aCAqIDMgLyA0O1xuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAxKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAyKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmICh0b3RhbExlbmd0aCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gdG90YWxMZW5ndGggaXMgbm90IGFuIGludGVnZXIsIHRoZSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggYSB2YWxpZFxuICAgICAgICAvLyBiYXNlNjQgY29udGVudC4gVGhhdCBjYW4gaGFwcGVuIGlmOlxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyBub3QgYSBiYXNlNjQgY29udGVudFxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyAqYWxtb3N0KiBhIGJhc2U2NCBjb250ZW50LCB3aXRoIGEgZXh0cmEgY2hhcnMgYXQgdGhlXG4gICAgICAgIC8vICAgYmVnaW5uaW5nIG9yIGF0IHRoZSBlbmRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgdXNlcyBhIGJhc2U2NCB2YXJpYW50IChiYXNlNjR1cmwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBiYWQgY29udGVudCBsZW5ndGguXCIpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0O1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGh8MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG5cbiAgICAgICAgZW5jMSA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzIgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMzID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jNCA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIxO1xuXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjM7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciBEYXRhV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YVdvcmtlcicpO1xudmFyIERhdGFMZW5ndGhQcm9iZSA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZScpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9DcmMzMlByb2JlJyk7XG52YXIgRGF0YUxlbmd0aFByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50IGEgY29tcHJlc3NlZCBvYmplY3QsIHdpdGggZXZlcnl0aGluZyBuZWVkZWQgdG8gZGVjb21wcmVzcyBpdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbXByZXNzZWRTaXplIHRoZSBzaXplIG9mIHRoZSBkYXRhIGNvbXByZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdW5jb21wcmVzc2VkU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSBhZnRlciBkZWNvbXByZXNzaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGNyYzMyIHRoZSBjcmMzMiBvZiB0aGUgZGVjb21wcmVzc2VkIGZpbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcHJlc3Npb24gdGhlIHR5cGUgb2YgY29tcHJlc3Npb24sIHNlZSBsaWIvY29tcHJlc3Npb25zLmpzLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gQ29tcHJlc3NlZE9iamVjdChjb21wcmVzc2VkU2l6ZSwgdW5jb21wcmVzc2VkU2l6ZSwgY3JjMzIsIGNvbXByZXNzaW9uLCBkYXRhKSB7XG4gICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGNvbXByZXNzZWRTaXplO1xuICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHVuY29tcHJlc3NlZFNpemU7XG4gICAgdGhpcy5jcmMzMiA9IGNyYzMyO1xuICAgIHRoaXMuY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbjtcbiAgICB0aGlzLmNvbXByZXNzZWRDb250ZW50ID0gZGF0YTtcbn1cblxuQ29tcHJlc3NlZE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgdW5jb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50V29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IERhdGFXb3JrZXIoZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tcHJlc3NlZENvbnRlbnQpKVxuICAgICAgICAucGlwZSh0aGlzLmNvbXByZXNzaW9uLnVuY29tcHJlc3NXb3JrZXIoKSlcbiAgICAgICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcImRhdGFfbGVuZ3RoXCIpKTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHdvcmtlci5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZih0aGlzLnN0cmVhbUluZm9bJ2RhdGFfbGVuZ3RoJ10gIT09IHRoYXQudW5jb21wcmVzc2VkU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IHVuY29tcHJlc3NlZCBkYXRhIHNpemUgbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29tcHJlc3NlZFdvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3NlZFNpemVcIiwgdGhpcy5jb21wcmVzc2VkU2l6ZSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwidW5jb21wcmVzc2VkU2l6ZVwiLCB0aGlzLnVuY29tcHJlc3NlZFNpemUpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNyYzMyXCIsIHRoaXMuY3JjMzIpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzaW9uXCIsIHRoaXMuY29tcHJlc3Npb24pXG4gICAgICAgIDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoYWluIHRoZSBnaXZlbiB3b3JrZXIgd2l0aCBvdGhlciB3b3JrZXJzIHRvIGNvbXByZXNzIHRoZSBjb250ZW50IHdpdGggdGhlXG4gKiBnaXZlbiBjb21wcmVzc2lvbi5cbiAqIEBwYXJhbSB7R2VuZXJpY1dvcmtlcn0gdW5jb21wcmVzc2VkV29ya2VyIHRoZSB3b3JrZXIgdG8gcGlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSBuZXcgd29ya2VyIGNvbXByZXNzaW5nIHRoZSBjb250ZW50LlxuICovXG5Db21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20gPSBmdW5jdGlvbiAodW5jb21wcmVzc2VkV29ya2VyLCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIHVuY29tcHJlc3NlZFdvcmtlclxuICAgIC5waXBlKG5ldyBDcmMzMlByb2JlKCkpXG4gICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcInVuY29tcHJlc3NlZFNpemVcIikpXG4gICAgLnBpcGUoY29tcHJlc3Npb24uY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb25PcHRpb25zKSlcbiAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwiY29tcHJlc3NlZFNpemVcIikpXG4gICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3Npb25cIiwgY29tcHJlc3Npb24pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wcmVzc2VkT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG5leHBvcnRzLlNUT1JFID0ge1xuICAgIG1hZ2ljOiBcIlxceDAwXFx4MDBcIixcbiAgICBjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uIChjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljV29ya2VyKFwiU1RPUkUgY29tcHJlc3Npb25cIik7XG4gICAgfSxcbiAgICB1bmNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNXb3JrZXIoXCJTVE9SRSBkZWNvbXByZXNzaW9uXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkRFRkxBVEUgPSByZXF1aXJlKCcuL2ZsYXRlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjb21lIGZyb20gcGFrbywgZnJvbSBwYWtvL2xpYi96bGliL2NyYzMyLmpzXG4gKiByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIHNlZSBwYWtvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9cbiAqL1xuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICAgIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gICAgZm9yKHZhciBuID0wOyBuIDwgMjU2OyBuKyspe1xuICAgICAgICBjID0gbjtcbiAgICAgICAgZm9yKHZhciBrID0wOyBrIDwgODsgaysrKXtcbiAgICAgICAgICAgIGMgPSAoKGMmMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlW25dID0gYztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGNyYzMyIG9mIGEgc3RyaW5nLlxuICogVGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgdGhlIGZ1bmN0aW9uIGNyYzMyLCBidXQgZm9yIHN0cmluZ3MuIFVzaW5nIHRoZVxuICogc2FtZSBmdW5jdGlvbiBmb3IgdGhlIHR3byB1c2UgY2FzZXMgbGVhZHMgdG8gaG9ycmlibGUgcGVyZm9ybWFuY2VzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNyYyB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGNyYy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciB0aGUgY3JjMzIgY29tcHV0YXRpb24uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb21wdXRlZCBjcmMzMi5cbiAqL1xuZnVuY3Rpb24gY3JjMzJzdHIoY3JjLCBzdHIsIGxlbiwgcG9zKSB7XG4gICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuO1xuXG4gICAgY3JjID0gY3JjIF4gKC0xKTtcblxuICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBzdHIuY2hhckNvZGVBdChpKSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmMzMndyYXBwZXIoaW5wdXQsIGNyYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIgfHwgIWlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheSA9IHV0aWxzLmdldFR5cGVPZihpbnB1dCkgIT09IFwic3RyaW5nXCI7XG5cbiAgICBpZihpc0FycmF5KSB7XG4gICAgICAgIHJldHVybiBjcmMzMihjcmN8MCwgaW5wdXQsIGlucHV0Lmxlbmd0aCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyc3RyKGNyY3wwLCBpbnB1dCwgaW5wdXQubGVuZ3RoLCAwKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuZXhwb3J0cy5iYXNlNjQgPSBmYWxzZTtcbmV4cG9ydHMuYmluYXJ5ID0gZmFsc2U7XG5leHBvcnRzLmRpciA9IGZhbHNlO1xuZXhwb3J0cy5jcmVhdGVGb2xkZXJzID0gdHJ1ZTtcbmV4cG9ydHMuZGF0ZSA9IG51bGw7XG5leHBvcnRzLmNvbXByZXNzaW9uID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb25PcHRpb25zID0gbnVsbDtcbmV4cG9ydHMuY29tbWVudCA9IG51bGw7XG5leHBvcnRzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG5leHBvcnRzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiIsIi8qIGdsb2JhbCBQcm9taXNlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIGxvYWQgdGhlIGdsb2JhbCBvYmplY3QgZmlyc3Q6XG4vLyAtIGl0IHNob3VsZCBiZSBiZXR0ZXIgaW50ZWdyYXRlZCBpbiB0aGUgc3lzdGVtICh1bmhhbmRsZWRSZWplY3Rpb24gaW4gbm9kZSlcbi8vIC0gdGhlIGVudmlyb25tZW50IG1heSBoYXZlIGEgY3VzdG9tIFByb21pc2UgaW1wbGVtZW50YXRpb24gKHNlZSB6b25lLmpzKVxudmFyIEVTNlByb21pc2UgPSBudWxsO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgRVM2UHJvbWlzZSA9IFByb21pc2U7XG59IGVsc2Uge1xuICAgIEVTNlByb21pc2UgPSByZXF1aXJlKFwibGllXCIpO1xufVxuXG4vKipcbiAqIExldCB0aGUgdXNlciB1c2UvY2hhbmdlIHNvbWUgaW1wbGVtZW50YXRpb25zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQcm9taXNlOiBFUzZQcm9taXNlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFVTRV9UWVBFREFSUkFZID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxudmFyIHBha28gPSByZXF1aXJlKFwicGFrb1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxudmFyIEFSUkFZX1RZUEUgPSBVU0VfVFlQRURBUlJBWSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuXG5leHBvcnRzLm1hZ2ljID0gXCJcXHgwOFxceDAwXCI7XG5cbi8qKlxuICogQ3JlYXRlIGEgd29ya2VyIHRoYXQgdXNlcyBwYWtvIHRvIGluZmxhdGUvZGVmbGF0ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiB0aGUgbmFtZSBvZiB0aGUgcGFrbyBmdW5jdGlvbiB0byBjYWxsIDogZWl0aGVyIFwiRGVmbGF0ZVwiIG9yIFwiSW5mbGF0ZVwiLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gKGRlKWNvbXByZXNzaW5nLlxuICovXG5mdW5jdGlvbiBGbGF0ZVdvcmtlcihhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJGbGF0ZVdvcmtlci9cIiArIGFjdGlvbik7XG5cbiAgICB0aGlzLl9wYWtvID0gbnVsbDtcbiAgICB0aGlzLl9wYWtvQWN0aW9uID0gYWN0aW9uO1xuICAgIHRoaXMuX3Bha29PcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB0aGUgYG1ldGFgIG9iamVjdCBmcm9tIHRoZSBsYXN0IGNodW5rIHJlY2VpdmVkXG4gICAgLy8gdGhpcyBhbGxvdyB0aGlzIHdvcmtlciB0byBwYXNzIGFyb3VuZCBtZXRhZGF0YVxuICAgIHRoaXMubWV0YSA9IHt9O1xufVxuXG51dGlscy5pbmhlcml0cyhGbGF0ZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5tZXRhID0gY2h1bmsubWV0YTtcbiAgICBpZiAodGhpcy5fcGFrbyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQYWtvKCk7XG4gICAgfVxuICAgIHRoaXMuX3Bha28ucHVzaCh1dGlscy50cmFuc2Zvcm1UbyhBUlJBWV9UWVBFLCBjaHVuay5kYXRhKSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuX3Bha28gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUGFrbygpO1xuICAgIH1cbiAgICB0aGlzLl9wYWtvLnB1c2goW10sIHRydWUpO1xufTtcbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuY2xlYW5VcC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3Bha28gPSBudWxsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIF9wYWtvIG9iamVjdC5cbiAqIFRPRE86IGxhenktbG9hZGluZyB0aGlzIG9iamVjdCBpc24ndCB0aGUgYmVzdCBzb2x1dGlvbiBidXQgaXQncyB0aGVcbiAqIHF1aWNrZXN0LiBUaGUgYmVzdCBzb2x1dGlvbiBpcyB0byBsYXp5LWxvYWQgdGhlIHdvcmtlciBsaXN0LiBTZWUgYWxzbyB0aGVcbiAqIGlzc3VlICM0NDYuXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5fY3JlYXRlUGFrbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYWtvID0gbmV3IHBha29bdGhpcy5fcGFrb0FjdGlvbl0oe1xuICAgICAgICByYXc6IHRydWUsXG4gICAgICAgIGxldmVsOiB0aGlzLl9wYWtvT3B0aW9ucy5sZXZlbCB8fCAtMSAvLyBkZWZhdWx0IGNvbXByZXNzaW9uXG4gICAgfSk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3Bha28ub25EYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzZWxmLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDogc2VsZi5tZXRhXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5leHBvcnRzLmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJEZWZsYXRlXCIsIGNvbXByZXNzaW9uT3B0aW9ucyk7XG59O1xuZXhwb3J0cy51bmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJJbmZsYXRlXCIsIHt9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4uL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4uL3V0ZjgnKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoJy4uL2NyYzMyJyk7XG52YXIgc2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBhIHN0cmluZyBpbiBoZXhhZGVjaW1hbC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjIHRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHJlc3VsdC5cbiAqL1xudmFyIGRlY1RvSGV4ID0gZnVuY3Rpb24oZGVjLCBieXRlcykge1xuICAgIHZhciBoZXggPSBcIlwiLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICAgIGhleCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlYyAmIDB4ZmYpO1xuICAgICAgICBkZWMgPSBkZWMgPj4+IDg7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBVTklYIHBhcnQgb2YgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1bml4UGVybWlzc2lvbnMgdGhlIHVuaXggcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBhZGFwdGVkIGZyb20gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE0NzA1L3RoZS16aXAtZm9ybWF0cy1leHRlcm5hbC1maWxlLWF0dHJpYnV0ZSA6XG4gKlxuICogVFRUVHNzdHJ3eHJ3eHJ3eDAwMDAwMDAwMDBBRFZTSFJcbiAqIF5eXl5fX19fX19fX19fX19fX19fX19fX19fX19fX19fIGZpbGUgdHlwZSwgc2VlIHppcGluZm8uYyAoVU5YXyopXG4gKiAgICAgXl5eX19fX19fX19fX19fX19fX19fX19fX19fXyBzZXR1aWQsIHNldGdpZCwgc3RpY2t5XG4gKiAgICAgICAgXl5eXl5eXl5eX19fX19fX19fX19fX19fXyBwZXJtaXNzaW9uc1xuICogICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5fX19fX18gbm90IHVzZWQgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl4gRE9TIGF0dHJpYnV0ZSBiaXRzIDogQXJjaGl2ZSwgRGlyZWN0b3J5LCBWb2x1bWUgbGFiZWwsIFN5c3RlbSBmaWxlLCBIaWRkZW4sIFJlYWQgb25seVxuICovXG52YXIgZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0ciA9IGZ1bmN0aW9uICh1bml4UGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gdW5peFBlcm1pc3Npb25zO1xuICAgIGlmICghdW5peFBlcm1pc3Npb25zKSB7XG4gICAgICAgIC8vIEkgY2FuJ3QgdXNlIG9jdGFsIHZhbHVlcyBpbiBzdHJpY3QgbW9kZSwgaGVuY2UgdGhlIGhleGEuXG4gICAgICAgIC8vICAwNDA3NzUgPT4gMHg0MWZkXG4gICAgICAgIC8vIDAxMDA2NjQgPT4gMHg4MWI0XG4gICAgICAgIHJlc3VsdCA9IGlzRGlyID8gMHg0MWZkIDogMHg4MWI0O1xuICAgIH1cbiAgICByZXR1cm4gKHJlc3VsdCAmIDB4RkZGRikgPDwgMTY7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBET1MgcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IGRvc1Blcm1pc3Npb25zIHRoZSBkb3MgcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBCaXQgMCAgICAgUmVhZC1Pbmx5XG4gKiBCaXQgMSAgICAgSGlkZGVuXG4gKiBCaXQgMiAgICAgU3lzdGVtXG4gKiBCaXQgMyAgICAgVm9sdW1lIExhYmVsXG4gKiBCaXQgNCAgICAgRGlyZWN0b3J5XG4gKiBCaXQgNSAgICAgQXJjaGl2ZVxuICovXG52YXIgZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKGRvc1Blcm1pc3Npb25zLCBpc0Rpcikge1xuXG4gICAgLy8gdGhlIGRpciBmbGFnIGlzIGFscmVhZHkgc2V0IGZvciBjb21wYXRpYmlsaXR5XG4gICAgcmV0dXJuIChkb3NQZXJtaXNzaW9ucyB8fCAwKSAgJiAweDNGO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgdmFyaW91cyBwYXJ0cyB1c2VkIGluIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIGZpbmFsIHppcCBmaWxlLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIGhhc2ggd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1lZENvbnRlbnQgaXMgdGhlIGNvbnRlbnQgc3RyZWFtZWQgP1xuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1pbmdFbmRlZCBpcyB0aGUgc3RyZWFtIGZpbmlzaGVkID9cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIGN1cnJlbnQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSBsZXQncyBwcmV0ZW5kIHdlIGFyZSB0aGlzIHBsYXRmb3JtIChjaGFuZ2UgcGxhdGZvcm0gZGVwZW5kZW50cyBmaWVsZHMpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIHRoZSBmaWxlIG5hbWUgLyBjb21tZW50LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgemlwIHBhcnRzLlxuICovXG52YXIgZ2VuZXJhdGVaaXBQYXJ0cyA9IGZ1bmN0aW9uKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgc3RyZWFtaW5nRW5kZWQsIG9mZnNldCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGZpbGUgPSBzdHJlYW1JbmZvWydmaWxlJ10sXG4gICAgY29tcHJlc3Npb24gPSBzdHJlYW1JbmZvWydjb21wcmVzc2lvbiddLFxuICAgIHVzZUN1c3RvbUVuY29kaW5nID0gZW5jb2RlRmlsZU5hbWUgIT09IHV0ZjgudXRmOGVuY29kZSxcbiAgICBlbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShmaWxlLm5hbWUpKSxcbiAgICB1dGZFbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoZmlsZS5uYW1lKSksXG4gICAgY29tbWVudCA9IGZpbGUuY29tbWVudCxcbiAgICBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKSxcbiAgICB1dGZFbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHV0ZjgudXRmOGVuY29kZShjb21tZW50KSksXG4gICAgdXNlVVRGOEZvckZpbGVOYW1lID0gdXRmRW5jb2RlZEZpbGVOYW1lLmxlbmd0aCAhPT0gZmlsZS5uYW1lLmxlbmd0aCxcbiAgICB1c2VVVEY4Rm9yQ29tbWVudCA9IHV0ZkVuY29kZWRDb21tZW50Lmxlbmd0aCAhPT0gY29tbWVudC5sZW5ndGgsXG4gICAgZG9zVGltZSxcbiAgICBkb3NEYXRlLFxuICAgIGV4dHJhRmllbGRzID0gXCJcIixcbiAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPSBcIlwiLFxuICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgZGlyID0gZmlsZS5kaXIsXG4gICAgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuXG4gICAgdmFyIGRhdGFJbmZvID0ge1xuICAgICAgICBjcmMzMiA6IDAsXG4gICAgICAgIGNvbXByZXNzZWRTaXplIDogMCxcbiAgICAgICAgdW5jb21wcmVzc2VkU2l6ZSA6IDBcbiAgICB9O1xuXG4gICAgLy8gaWYgdGhlIGNvbnRlbnQgaXMgc3RyZWFtZWQsIHRoZSBzaXplcy9jcmMzMiBhcmUgb25seSBhdmFpbGFibGUgQUZURVJcbiAgICAvLyB0aGUgZW5kIG9mIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFzdHJlYW1lZENvbnRlbnQgfHwgc3RyZWFtaW5nRW5kZWQpIHtcbiAgICAgICAgZGF0YUluZm8uY3JjMzIgPSBzdHJlYW1JbmZvWydjcmMzMiddO1xuICAgICAgICBkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSA9IHN0cmVhbUluZm9bJ2NvbXByZXNzZWRTaXplJ107XG4gICAgICAgIGRhdGFJbmZvLnVuY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvWyd1bmNvbXByZXNzZWRTaXplJ107XG4gICAgfVxuXG4gICAgdmFyIGJpdGZsYWcgPSAwO1xuICAgIGlmIChzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gQml0IDM6IHRoZSBzaXplcy9jcmMzMiBhcmUgc2V0IHRvIHplcm8gaW4gdGhlIGxvY2FsIGhlYWRlci5cbiAgICAgICAgLy8gVGhlIGNvcnJlY3QgdmFsdWVzIGFyZSBwdXQgaW4gdGhlIGRhdGEgZGVzY3JpcHRvciBpbW1lZGlhdGVseVxuICAgICAgICAvLyBmb2xsb3dpbmcgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDAwMDg7XG4gICAgfVxuICAgIGlmICghdXNlQ3VzdG9tRW5jb2RpbmcgJiYgKHVzZVVURjhGb3JGaWxlTmFtZSB8fCB1c2VVVEY4Rm9yQ29tbWVudCkpIHtcbiAgICAgICAgLy8gQml0IDExOiBMYW5ndWFnZSBlbmNvZGluZyBmbGFnIChFRlMpLlxuICAgICAgICBiaXRmbGFnIHw9IDB4MDgwMDtcbiAgICB9XG5cblxuICAgIHZhciBleHRGaWxlQXR0ciA9IDA7XG4gICAgdmFyIHZlcnNpb25NYWRlQnkgPSAwO1xuICAgIGlmIChkaXIpIHtcbiAgICAgICAgLy8gZG9zIG9yIHVuaXgsIHdlIHNldCB0aGUgZG9zIGRpciBmbGFnXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IDB4MDAwMTA7XG4gICAgfVxuICAgIGlmKHBsYXRmb3JtID09PSBcIlVOSVhcIikge1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMzFFOyAvLyBVTklYLCB2ZXJzaW9uIDMuMFxuICAgICAgICBleHRGaWxlQXR0ciB8PSBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyKGZpbGUudW5peFBlcm1pc3Npb25zLCBkaXIpO1xuICAgIH0gZWxzZSB7IC8vIERPUyBvciBvdGhlciwgZmFsbGJhY2sgdG8gRE9TXG4gICAgICAgIHZlcnNpb25NYWRlQnkgPSAweDAwMTQ7IC8vIERPUywgdmVyc2lvbiAyLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyKGZpbGUuZG9zUGVybWlzc2lvbnMsIGRpcik7XG4gICAgfVxuXG4gICAgLy8gZGF0ZVxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC81Mi8xMy5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY1LzE2Lmh0bWxcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNjYvMTYuaHRtbFxuXG4gICAgZG9zVGltZSA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSA8PCA2O1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIHwgZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDU2Vjb25kcygpIC8gMjtcblxuICAgIGRvc0RhdGUgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTgwO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDQ7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSk7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgPDwgNTtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSB8IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuXG4gICAgaWYgKHVzZVVURjhGb3JGaWxlTmFtZSkge1xuICAgICAgICAvLyBzZXQgdGhlIHVuaWNvZGUgcGF0aCBleHRyYSBmaWVsZC4gdW56aXAgbmVlZHMgYXQgbGVhc3Qgb25lIGV4dHJhXG4gICAgICAgIC8vIGZpZWxkIHRvIGNvcnJlY3RseSBoYW5kbGUgdW5pY29kZSBwYXRoLCBzbyB1c2luZyB0aGUgcGF0aCBpcyBhcyBnb29kXG4gICAgICAgIC8vIGFzIGFueSBvdGhlciBpbmZvcm1hdGlvbi4gVGhpcyBjb3VsZCBpbXByb3ZlIHRoZSBzaXR1YXRpb24gd2l0aFxuICAgICAgICAvLyBvdGhlciBhcmNoaXZlIG1hbmFnZXJzIHRvby5cbiAgICAgICAgLy8gVGhpcyBmaWVsZCBpcyB1c3VhbGx5IHVzZWQgd2l0aG91dCB0aGUgdXRmOCBmbGFnLCB3aXRoIGEgbm9uXG4gICAgICAgIC8vIHVuaWNvZGUgcGF0aCBpbiB0aGUgaGVhZGVyICh3aW5yYXIsIHdpbnppcCkuIFRoaXMgaGVscHMgKGEgYml0KVxuICAgICAgICAvLyB3aXRoIHRoZSBtZXNzeSBXaW5kb3dzJyBkZWZhdWx0IGNvbXByZXNzZWQgZm9sZGVycyBmZWF0dXJlIGJ1dFxuICAgICAgICAvLyBicmVha3Mgb24gcDd6aXAgd2hpY2ggZG9lc24ndCBzZWVrIHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuXG4gICAgICAgIC8vIFNvIGZvciBub3csIFVURi04IGV2ZXJ5d2hlcmUgIVxuICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gTmFtZUNSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkRmlsZU5hbWUpLCA0KSArXG4gICAgICAgICAgICAvLyBVbmljb2RlTmFtZVxuICAgICAgICAgICAgdXRmRW5jb2RlZEZpbGVOYW1lO1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg3MFwiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVQYXRoRXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICBpZih1c2VVVEY4Rm9yQ29tbWVudCkge1xuXG4gICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9XG4gICAgICAgICAgICAvLyBWZXJzaW9uXG4gICAgICAgICAgICBkZWNUb0hleCgxLCAxKSArXG4gICAgICAgICAgICAvLyBDb21tZW50Q1JDMzJcbiAgICAgICAgICAgIGRlY1RvSGV4KGNyYzMyKGVuY29kZWRDb21tZW50KSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRDb21tZW50O1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg2M1wiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICB2YXIgaGVhZGVyID0gXCJcIjtcblxuICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICBoZWFkZXIgKz0gXCJcXHgwQVxceDAwXCI7XG4gICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGJpdGZsYWcsIDIpO1xuICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgIGhlYWRlciArPSBjb21wcmVzc2lvbi5tYWdpYztcbiAgICAvLyBsYXN0IG1vZCBmaWxlIHRpbWVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZG9zVGltZSwgMik7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSBkYXRlXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc0RhdGUsIDIpO1xuICAgIC8vIGNyYy0zMlxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jcmMzMiwgNCk7XG4gICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRhdGFJbmZvLmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby51bmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyBmaWxlIG5hbWUgbGVuZ3RoXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGVuY29kZWRGaWxlTmFtZS5sZW5ndGgsIDIpO1xuICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChleHRyYUZpZWxkcy5sZW5ndGgsIDIpO1xuXG5cbiAgICB2YXIgZmlsZVJlY29yZCA9IHNpZ25hdHVyZS5MT0NBTF9GSUxFX0hFQURFUiArIGhlYWRlciArIGVuY29kZWRGaWxlTmFtZSArIGV4dHJhRmllbGRzO1xuXG4gICAgdmFyIGRpclJlY29yZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0ZJTEVfSEVBREVSICtcbiAgICAgICAgLy8gdmVyc2lvbiBtYWRlIGJ5ICgwMDogRE9TKVxuICAgICAgICBkZWNUb0hleCh2ZXJzaW9uTWFkZUJ5LCAyKSArXG4gICAgICAgIC8vIGZpbGUgaGVhZGVyIChjb21tb24gdG8gZmlsZSBhbmQgY2VudHJhbCBkaXJlY3RvcnkpXG4gICAgICAgIGhlYWRlciArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgZGVjVG9IZXgoZW5jb2RlZENvbW1lbnQubGVuZ3RoLCAyKSArXG4gICAgICAgIC8vIGRpc2sgbnVtYmVyIHN0YXJ0XG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gaW50ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIFRPRE9cbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgZGVjVG9IZXgoZXh0RmlsZUF0dHIsIDQpICtcbiAgICAgICAgLy8gcmVsYXRpdmUgb2Zmc2V0IG9mIGxvY2FsIGhlYWRlclxuICAgICAgICBkZWNUb0hleChvZmZzZXQsIDQpICtcbiAgICAgICAgLy8gZmlsZSBuYW1lXG4gICAgICAgIGVuY29kZWRGaWxlTmFtZSArXG4gICAgICAgIC8vIGV4dHJhIGZpZWxkXG4gICAgICAgIGV4dHJhRmllbGRzICtcbiAgICAgICAgLy8gZmlsZSBjb21tZW50XG4gICAgICAgIGVuY29kZWRDb21tZW50O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZVJlY29yZDogZmlsZVJlY29yZCxcbiAgICAgICAgZGlyUmVjb3JkOiBkaXJSZWNvcmRcbiAgICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgRU9DRCByZWNvcmQuXG4gKiBAcGFyYW0ge051bWJlcn0gZW50cmllc0NvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gY2VudHJhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGNlbnRyYWwgZGlyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvY2FsRGlyTGVuZ3RoIHRoZSBsZW5ndGggKGluIGJ5dGVzKSBvZiB0aGUgbG9jYWwgZGlyLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIHppcCBmaWxlIGNvbW1lbnQgYXMgYSBiaW5hcnkgc3RyaW5nLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgY29tbWVudC5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIEVPQ0QgcmVjb3JkLlxuICovXG52YXIgZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kID0gZnVuY3Rpb24gKGVudHJpZXNDb3VudCwgY2VudHJhbERpckxlbmd0aCwgbG9jYWxEaXJMZW5ndGgsIGNvbW1lbnQsIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGRpckVuZCA9IFwiXCI7XG4gICAgdmFyIGVuY29kZWRDb21tZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoY29tbWVudCkpO1xuXG4gICAgLy8gZW5kIG9mIGNlbnRyYWwgZGlyIHNpZ25hdHVyZVxuICAgIGRpckVuZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0RJUkVDVE9SWV9FTkQgK1xuICAgICAgICAvLyBudW1iZXIgb2YgdGhpcyBkaXNrXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoZSBkaXNrIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBvbiB0aGlzIGRpc2tcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBkZWNUb0hleChlbnRyaWVzQ291bnQsIDIpICtcbiAgICAgICAgLy8gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KGNlbnRyYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0byB0aGUgc3RhcnRpbmcgZGlzayBudW1iZXJcbiAgICAgICAgZGVjVG9IZXgobG9jYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyAuWklQIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiBkaXJFbmQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGRhdGEgZGVzY3JpcHRvcnMgZm9yIGEgZmlsZSBlbnRyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBoYXNoIGdlbmVyYXRlZCBieSBhIHdvcmtlciwgY29udGFpbmluZyBpbmZvcm1hdGlvblxuICogb24gdGhlIGZpbGUgZW50cnkuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBkYXRhIGRlc2NyaXB0b3JzLlxuICovXG52YXIgZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMgPSBmdW5jdGlvbiAoc3RyZWFtSW5mbykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gXCJcIjtcbiAgICBkZXNjcmlwdG9yID0gc2lnbmF0dXJlLkRBVEFfREVTQ1JJUFRPUiArXG4gICAgICAgIC8vIGNyYy0zMiAgICAgICAgICAgICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvWydjcmMzMiddLCA0KSArXG4gICAgICAgIC8vIGNvbXByZXNzZWQgc2l6ZSAgICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvWydjb21wcmVzc2VkU2l6ZSddLCA0KSArXG4gICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvWyd1bmNvbXByZXNzZWRTaXplJ10sIDQpO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG5cbi8qKlxuICogQSB3b3JrZXIgdG8gY29uY2F0ZW5hdGUgb3RoZXIgd29ya2VycyB0byBjcmVhdGUgYSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtRmlsZXMgYHRydWVgIHRvIHN0cmVhbSB0aGUgY29udGVudCBvZiB0aGUgZmlsZXMsXG4gKiBgZmFsc2VgIHRvIGFjY3VtdWxhdGUgaXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudCB0aGUgY29tbWVudCB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhdGZvcm0gdGhlIHBsYXRmb3JtIHRvIHVzZSwgXCJVTklYXCIgb3IgXCJET1NcIi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZUZpbGVOYW1lIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgZmlsZSBuYW1lcyBhbmQgY29tbWVudHMuXG4gKi9cbmZ1bmN0aW9uIFppcEZpbGVXb3JrZXIoc3RyZWFtRmlsZXMsIGNvbW1lbnQsIHBsYXRmb3JtLCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIlppcEZpbGVXb3JrZXJcIik7XG4gICAgLy8gVGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIHNvIGZhci4gVGhpcyBkb2Vzbid0IGNvdW50IGFjY3VtdWxhdGVkIGNodW5rcy5cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG4gICAgLy8gVGhlIGNvbW1lbnQgb2YgdGhlIHppcCBmaWxlXG4gICAgdGhpcy56aXBDb21tZW50ID0gY29tbWVudDtcbiAgICAvLyBUaGUgcGxhdGZvcm0gXCJnZW5lcmF0aW5nXCIgdGhlIHppcCBmaWxlLlxuICAgIHRoaXMuemlwUGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAvLyB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIGZpbGUgbmFtZXMgYW5kIGNvbW1lbnRzLlxuICAgIHRoaXMuZW5jb2RlRmlsZU5hbWUgPSBlbmNvZGVGaWxlTmFtZTtcbiAgICAvLyBTaG91bGQgd2Ugc3RyZWFtIHRoZSBjb250ZW50IG9mIHRoZSBmaWxlcyA/XG4gICAgdGhpcy5zdHJlYW1GaWxlcyA9IHN0cmVhbUZpbGVzO1xuICAgIC8vIElmIGBzdHJlYW1GaWxlc2AgaXMgZmFsc2UsIHdlIHdpbGwgbmVlZCB0byBhY2N1bXVsYXRlIHRoZSBjb250ZW50IG9mIHRoZVxuICAgIC8vIGZpbGVzIHRvIGNhbGN1bGF0ZSBzaXplcyAvIGNyYzMyIChhbmQgd3JpdGUgdGhlbSAqYmVmb3JlKiB0aGUgY29udGVudCkuXG4gICAgLy8gVGhpcyBib29sZWFuIGluZGljYXRlcyBpZiB3ZSBhcmUgYWNjdW11bGF0aW5nIGNodW5rcyAoaXQgd2lsbCBjaGFuZ2UgYSBsb3RcbiAgICAvLyBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIHRoaXMgd29ya2VyKS5cbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICAvLyBUaGUgYnVmZmVyIHJlY2VpdmluZyBjaHVua3Mgd2hlbiBhY2N1bXVsYXRpbmcgY29udGVudC5cbiAgICB0aGlzLmNvbnRlbnRCdWZmZXIgPSBbXTtcbiAgICAvLyBUaGUgbGlzdCBvZiBnZW5lcmF0ZWQgZGlyZWN0b3J5IHJlY29yZHMuXG4gICAgdGhpcy5kaXJSZWNvcmRzID0gW107XG4gICAgLy8gVGhlIG9mZnNldCAoaW4gYnl0ZXMpIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgemlwIGZpbGUgZm9yIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSAwO1xuICAgIC8vIFRoZSB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHppcCBmaWxlLlxuICAgIHRoaXMuZW50cmllc0NvdW50ID0gMDtcbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBjdXJyZW50bHkgYmVpbmcgYWRkZWQsIG51bGwgd2hlbiBoYW5kbGluZyB0aGUgZW5kIG9mIHRoZSB6aXAgZmlsZS5cbiAgICAvLyBVc2VkIGZvciB0aGUgZW1pdHRlZCBtZXRhZGF0YS5cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcblxuXG5cbiAgICB0aGlzLl9zb3VyY2VzID0gW107XG59XG51dGlscy5pbmhlcml0cyhaaXBGaWxlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgY3VycmVudEZpbGVQZXJjZW50ID0gY2h1bmsubWV0YS5wZXJjZW50IHx8IDA7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IHRoaXMuZW50cmllc0NvdW50O1xuICAgIHZhciByZW1haW5pbmdGaWxlcyA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoO1xuXG4gICAgaWYodGhpcy5hY2N1bXVsYXRlKSB7XG4gICAgICAgIHRoaXMuY29udGVudEJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ5dGVzV3JpdHRlbiArPSBjaHVuay5kYXRhLmxlbmd0aDtcblxuICAgICAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywge1xuICAgICAgICAgICAgZGF0YSA6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlIDogdGhpcy5jdXJyZW50RmlsZSxcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogZW50cmllc0NvdW50ID8gKGN1cnJlbnRGaWxlUGVyY2VudCArIDEwMCAqIChlbnRyaWVzQ291bnQgLSByZW1haW5pbmdGaWxlcyAtIDEpKSAvIGVudHJpZXNDb3VudCA6IDEwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSB3b3JrZXIgc3RhcnRlZCBhIG5ldyBzb3VyY2UgKGFuIG90aGVyIHdvcmtlcikuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgc3RyZWFtSW5mbyBvYmplY3QgZnJvbSB0aGUgbmV3IHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUub3BlbmVkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSB0aGlzLmJ5dGVzV3JpdHRlbjtcbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gc3RyZWFtSW5mb1snZmlsZSddLm5hbWU7XG5cbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcblxuICAgIC8vIGRvbid0IHN0cmVhbSBmb2xkZXJzIChiZWNhdXNlIHRoZXkgZG9uJ3QgaGF2ZSBhbnkgY29udGVudClcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCBmYWxzZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSB3aG9sZSBmaWxlIGJlZm9yZSBwdXNoaW5nIGFueXRoaW5nXG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIGZpbmlzaGVkIGEgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIGZpbmlzaGVkIHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuY2xvc2VkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcbiAgICB2YXIgcmVjb3JkID0gZ2VuZXJhdGVaaXBQYXJ0cyhzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHRydWUsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG5cbiAgICB0aGlzLmRpclJlY29yZHMucHVzaChyZWNvcmQuZGlyUmVjb3JkKTtcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gYWZ0ZXIgdGhlIHN0cmVhbWVkIGZpbGUsIHdlIHB1dCBkYXRhIGRlc2NyaXB0b3JzXG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMoc3RyZWFtSW5mbyksXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgY29udGVudCB3YXNuJ3Qgc3RyZWFtZWQsIHdlIG5lZWQgdG8gcHVzaCBldmVyeXRoaW5nIG5vd1xuICAgICAgICAvLyBmaXJzdCB0aGUgZmlsZSByZWNvcmQsIHRoZW4gdGhlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUodGhpcy5jb250ZW50QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY29udGVudEJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGxvY2FsRGlyTGVuZ3RoID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IHRoaXMuZGlyUmVjb3Jkc1tpXSxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgY2VudHJhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuIC0gbG9jYWxEaXJMZW5ndGg7XG5cbiAgICB2YXIgZGlyRW5kID0gZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kKHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGgsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCB0aGlzLnppcENvbW1lbnQsIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGRpckVuZCxcbiAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgbmV4dCBzb3VyY2UgdG8gYmUgcmVhZC5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHJlcGFyZU5leHRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHRoaXMuX3NvdXJjZXMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW5lZFNvdXJjZSh0aGlzLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlZ2lzdGVyUHJldmlvdXNcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVnaXN0ZXJQcmV2aW91cyA9IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgIHRoaXMuX3NvdXJjZXMucHVzaChwcmV2aW91cyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcHJldmlvdXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY2xvc2VkU291cmNlKHNlbGYucHJldmlvdXMuc3RyZWFtSW5mbyk7XG4gICAgICAgIGlmKHNlbGYuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLnByZXBhcmVOZXh0U291cmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcHJldmlvdXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucHJldmlvdXMgJiYgdGhpcy5fc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmICF0aGlzLl9zb3VyY2VzLmxlbmd0aCAmJiAhdGhpcy5nZW5lcmF0ZWRFcnJvcikge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5lcnJvclxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvdXJjZXNbaV0uZXJyb3IoZSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gdGhlIGBlcnJvcmAgZXhwbG9kZWQsIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmxvY2tcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUubG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5sb2NrLmNhbGwodGhpcyk7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbaV0ubG9jaygpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWmlwRmlsZVdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoJy4uL2NvbXByZXNzaW9ucycpO1xudmFyIFppcEZpbGVXb3JrZXIgPSByZXF1aXJlKCcuL1ppcEZpbGVXb3JrZXInKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBjb21wcmVzc2lvbiB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZUNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBkZWZpbmVkIGF0IHRoZSBmaWxlIGxldmVsLCBpZiBhbnkuXG4gKiBAcGFyYW0ge1N0cmluZ30gemlwQ29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIGRlZmluZWQgYXQgdGhlIGxvYWQoKSBsZXZlbC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gKi9cbnZhciBnZXRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uIChmaWxlQ29tcHJlc3Npb24sIHppcENvbXByZXNzaW9uKSB7XG5cbiAgICB2YXIgY29tcHJlc3Npb25OYW1lID0gZmlsZUNvbXByZXNzaW9uIHx8IHppcENvbXByZXNzaW9uO1xuICAgIHZhciBjb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uc1tjb21wcmVzc2lvbk5hbWVdO1xuICAgIGlmICghY29tcHJlc3Npb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbXByZXNzaW9uTmFtZSArIFwiIGlzIG5vdCBhIHZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZCAhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcHJlc3Npb247XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHdvcmtlciB0byBnZW5lcmF0ZSBhIHppcCBmaWxlLlxuICogQHBhcmFtIHtKU1ppcH0gemlwIHRoZSBKU1ppcCBpbnN0YW5jZSBhdCB0aGUgcmlnaHQgcm9vdCBsZXZlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSBjb21tZW50IHRvIHVzZS5cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZVdvcmtlciA9IGZ1bmN0aW9uICh6aXAsIG9wdGlvbnMsIGNvbW1lbnQpIHtcblxuICAgIHZhciB6aXBGaWxlV29ya2VyID0gbmV3IFppcEZpbGVXb3JrZXIob3B0aW9ucy5zdHJlYW1GaWxlcywgY29tbWVudCwgb3B0aW9ucy5wbGF0Zm9ybSwgb3B0aW9ucy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IDA7XG4gICAgdHJ5IHtcblxuICAgICAgICB6aXAuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICBlbnRyaWVzQ291bnQrKztcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uKGZpbGUub3B0aW9ucy5jb21wcmVzc2lvbiwgb3B0aW9ucy5jb21wcmVzc2lvbik7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb25PcHRpb25zID0gZmlsZS5vcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBkaXIgPSBmaWxlLmRpciwgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuICAgICAgICAgICAgZmlsZS5fY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucylcbiAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImZpbGVcIiwge1xuICAgICAgICAgICAgICAgIG5hbWUgOiByZWxhdGl2ZVBhdGgsXG4gICAgICAgICAgICAgICAgZGlyIDogZGlyLFxuICAgICAgICAgICAgICAgIGRhdGUgOiBkYXRlLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQgOiBmaWxlLmNvbW1lbnQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBmaWxlLnVuaXhQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBkb3NQZXJtaXNzaW9ucyA6IGZpbGUuZG9zUGVybWlzc2lvbnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucGlwZSh6aXBGaWxlV29ya2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHppcEZpbGVXb3JrZXIuZW50cmllc0NvdW50ID0gZW50cmllc0NvdW50O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgemlwRmlsZVdvcmtlci5lcnJvcihlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gemlwRmlsZVdvcmtlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gYSBvZiB6aXAgZmlsZSBpbiBqc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEpTWmlwKCkge1xuICAgIC8vIGlmIHRoaXMgY29uc3RydWN0b3IgaXPCoHVzZWQgd2l0aG91dMKgYG5ld2AsIGl0wqBhZGRzIGBuZXdgIGJlZm9yZcKgaXRzZWxmOlxuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIEpTWmlwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEpTWmlwKCk7XG4gICAgfVxuXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXJzIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH1cblxuICAgIC8vIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlcyA6XG4gICAgLy8ge1xuICAgIC8vICAgXCJmb2xkZXIvXCIgOiB7Li4ufSxcbiAgICAvLyAgIFwiZm9sZGVyL2RhdGEudHh0XCIgOiB7Li4ufVxuICAgIC8vIH1cbiAgICB0aGlzLmZpbGVzID0ge307XG5cbiAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuXG4gICAgLy8gV2hlcmUgd2UgYXJlIGluIHRoZSBoaWVyYXJjaHlcbiAgICB0aGlzLnJvb3QgPSBcIlwiO1xuICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5ld09iaiA9IG5ldyBKU1ppcCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tpXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gdGhpc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH07XG59XG5KU1ppcC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL29iamVjdCcpO1xuSlNaaXAucHJvdG90eXBlLmxvYWRBc3luYyA9IHJlcXVpcmUoJy4vbG9hZCcpO1xuSlNaaXAuc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuSlNaaXAuZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8vIFRPRE8gZmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMgdmVyc2lvbixcbi8vIGEgcmVxdWlyZSgncGFja2FnZS5qc29uJykudmVyc2lvbiBkb2Vzbid0IHdvcmsgd2l0aCB3ZWJwYWNrLCBzZWUgIzMyN1xuSlNaaXAudmVyc2lvbiA9IFwiMy41LjBcIjtcblxuSlNaaXAubG9hZEFzeW5jID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEpTWmlwKCkubG9hZEFzeW5jKGNvbnRlbnQsIG9wdGlvbnMpO1xufTtcblxuSlNaaXAuZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbm1vZHVsZS5leHBvcnRzID0gSlNaaXA7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgWmlwRW50cmllcyA9IHJlcXVpcmUoJy4vemlwRW50cmllcycpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9DcmMzMlByb2JlJyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcblxuLyoqXG4gKiBDaGVjayB0aGUgQ1JDMzIgb2YgYW4gZW50cnkuXG4gKiBAcGFyYW0ge1ppcEVudHJ5fSB6aXBFbnRyeSB0aGUgemlwIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybiB7UHJvbWlzZX0gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tFbnRyeUNSQzMyKHppcEVudHJ5KSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IHppcEVudHJ5LmRlY29tcHJlc3NlZC5nZXRDb250ZW50V29ya2VyKCkucGlwZShuZXcgQ3JjMzJQcm9iZSgpKTtcbiAgICAgICAgd29ya2VyLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3b3JrZXIuc3RyZWFtSW5mby5jcmMzMiAhPT0gemlwRW50cnkuZGVjb21wcmVzc2VkLmNyYzMyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBDUkMzMiBtaXNtYXRjaFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgemlwID0gdGhpcztcbiAgICBvcHRpb25zID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgYmFzZTY0OiBmYWxzZSxcbiAgICAgICAgY2hlY2tDUkMzMjogZmFsc2UsXG4gICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogZmFsc2UsXG4gICAgICAgIGNyZWF0ZUZvbGRlcnM6IGZhbHNlLFxuICAgICAgICBkZWNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZGVjb2RlXG4gICAgfSk7XG5cbiAgICBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJKU1ppcCBjYW4ndCBhY2NlcHQgYSBzdHJlYW0gd2hlbiBsb2FkaW5nIGEgemlwIGZpbGUuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMucHJlcGFyZUNvbnRlbnQoXCJ0aGUgbG9hZGVkIHppcCBmaWxlXCIsIGRhdGEsIHRydWUsIG9wdGlvbnMub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvcHRpb25zLmJhc2U2NClcbiAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciB6aXBFbnRyaWVzID0gbmV3IFppcEVudHJpZXMob3B0aW9ucyk7XG4gICAgICAgIHppcEVudHJpZXMubG9hZChkYXRhKTtcbiAgICAgICAgcmV0dXJuIHppcEVudHJpZXM7XG4gICAgfSkudGhlbihmdW5jdGlvbiBjaGVja0NSQzMyKHppcEVudHJpZXMpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW2V4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBFbnRyaWVzKV07XG4gICAgICAgIHZhciBmaWxlcyA9IHppcEVudHJpZXMuZmlsZXM7XG4gICAgICAgIGlmIChvcHRpb25zLmNoZWNrQ1JDMzIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNoZWNrRW50cnlDUkMzMihmaWxlc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiBhZGRGaWxlcyhyZXN1bHRzKSB7XG4gICAgICAgIHZhciB6aXBFbnRyaWVzID0gcmVzdWx0cy5zaGlmdCgpO1xuICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBmaWxlc1tpXTtcbiAgICAgICAgICAgIHppcC5maWxlKGlucHV0LmZpbGVOYW1lU3RyLCBpbnB1dC5kZWNvbXByZXNzZWQsIHtcbiAgICAgICAgICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICAgICAgICAgICAgb3B0aW1pemVkQmluYXJ5U3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGU6IGlucHV0LmRhdGUsXG4gICAgICAgICAgICAgICAgZGlyOiBpbnB1dC5kaXIsXG4gICAgICAgICAgICAgICAgY29tbWVudCA6IGlucHV0LmZpbGVDb21tZW50U3RyLmxlbmd0aCA/IGlucHV0LmZpbGVDb21tZW50U3RyIDogbnVsbCxcbiAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBpbnB1dC51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgZG9zUGVybWlzc2lvbnMgOiBpbnB1dC5kb3NQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBvcHRpb25zLmNyZWF0ZUZvbGRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6aXBFbnRyaWVzLnppcENvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICB6aXAuY29tbWVudCA9IHppcEVudHJpZXMuemlwQ29tbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB6aXA7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoaXMgaXMgcnVubmluZyBpbiBOb2RlanMsIHdpbGwgYmUgdW5kZWZpbmVkIGluIGEgYnJvd3Nlci5cbiAgICAgKiBJbiBhIGJyb3dzZXIsIGJyb3dzZXJpZnkgd29uJ3QgaW5jbHVkZSB0aGlzIGZpbGUgYW5kIHRoZSB3aG9sZSBtb2R1bGVcbiAgICAgKiB3aWxsIGJlIHJlc29sdmVkIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgKi9cbiAgICBpc05vZGUgOiB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiLFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBub2RlanMgQnVmZmVyIGZyb20gYW4gZXhpc3RpbmcgY29udGVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSB0aGUgZGF0YSB0byBwYXNzIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IGEgbmV3IEJ1ZmZlci5cbiAgICAgKi9cbiAgICBuZXdCdWZmZXJGcm9tOiBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuICAgICAgICBpZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIC8vIFNhZmVndWFyZCBmb3Igb2xkIE5vZGUuanMgdmVyc2lvbnMuIE9uIG5ld2VyIHZlcnNpb25zLFxuICAgICAgICAgICAgICAgIC8vIEJ1ZmZlci5mcm9tKG51bWJlcikgLyBCdWZmZXIobnVtYmVyLCBlbmNvZGluZykgYWxyZWFkeSB0aHJvdy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgXFxcImRhdGFcXFwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZWpzIEJ1ZmZlciB3aXRoIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHNpemUgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlci5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IGEgbmV3IEJ1ZmZlci5cbiAgICAgKi9cbiAgICBhbGxvY0J1ZmZlcjogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5hbGxvYykge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICAgICAgYnVmLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGaW5kIG91dCBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGIgdGhlIG9iamVjdCB0byB0ZXN0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIEJ1ZmZlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzQnVmZmVyIDogZnVuY3Rpb24oYil7XG4gICAgICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYik7XG4gICAgfSxcblxuICAgIGlzU3RyZWFtIDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLm9uID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoucGF1c2UgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5yZXN1bWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4uL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCB1c2UgYSBub2RlanMgc3RyZWFtIGFzIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGVudHJ5IGZvciB0aGlzIHN0cmVhbS5cbiAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSB0aGUgbm9kZWpzIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKGZpbGVuYW1lLCBzdHJlYW0pIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJOb2RlanMgc3RyZWFtIGlucHV0IGFkYXB0ZXIgZm9yIFwiICsgZmlsZW5hbWUpO1xuICAgIHRoaXMuX3Vwc3RyZWFtRW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9iaW5kU3RyZWFtKHN0cmVhbSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgc3RyZWFtIGFuZCBiaW5kIHRoZSBjYWxsYmFja3Mgb24gaXQuXG4gKiBEbyB0aGlzIEFTQVAgb24gbm9kZSAwLjEwICEgQSBsYXp5IGJpbmRpbmcgZG9lc24ndCBhbHdheXMgd29yay5cbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0gdG8gdXNlLlxuICovXG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLl9iaW5kU3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgc3RyZWFtXG4gICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wdXNoKHtcbiAgICAgICAgICAgIGRhdGE6IGNodW5rLFxuICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgIC5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2VsZi5fdXBzdHJlYW1FbmRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucGF1c2UuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbS5wYXVzZSgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodGhpcy5fdXBzdHJlYW1FbmRlZCkge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5SZWFkYWJsZTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIsIFJlYWRhYmxlKTtcblxuLyoqXG4qIEEgbm9kZWpzIHN0cmVhbSB1c2luZyBhIHdvcmtlciBhcyBzb3VyY2UuXG4qIEBzZWUgdGhlIFNvdXJjZVdyYXBwZXIgaW4gaHR0cDovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgd3JhcHBpbmcgdGhlIHdvcmtlclxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgbm9kZWpzIHN0cmVhbSBvcHRpb25zXG4qIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4qL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcihoZWxwZXIsIG9wdGlvbnMsIHVwZGF0ZUNiKSB7XG4gICAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9oZWxwZXIgPSBoZWxwZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaGVscGVyLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSwgbWV0YSkge1xuICAgICAgICBpZiAoIXNlbGYucHVzaChkYXRhKSkge1xuICAgICAgICAgICAgc2VsZi5faGVscGVyLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodXBkYXRlQ2IpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNiKG1ldGEpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9KVxuICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICB9KTtcbn1cblxuXG5Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2hlbHBlci5yZXN1bWUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcbnZhciBTdHJlYW1IZWxwZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9TdHJlYW1IZWxwZXInKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21wcmVzc2VkT2JqZWN0Jyk7XG52YXIgWmlwT2JqZWN0ID0gcmVxdWlyZSgnLi96aXBPYmplY3QnKTtcbnZhciBnZW5lcmF0ZSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlXCIpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG52YXIgTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyID0gcmVxdWlyZShcIi4vbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlclwiKTtcblxuXG4vKipcbiAqIEFkZCBhIGZpbGUgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgZGF0YSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsT3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZpbGUuXG4gKi9cbnZhciBmaWxlQWRkID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3JpZ2luYWxPcHRpb25zKSB7XG4gICAgLy8gYmUgc3VyZSBzdWIgZm9sZGVycyBleGlzdFxuICAgIHZhciBkYXRhVHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKSxcbiAgICAgICAgcGFyZW50O1xuXG5cbiAgICAvKlxuICAgICAqIENvcnJlY3Qgb3B0aW9ucy5cbiAgICAgKi9cblxuICAgIHZhciBvID0gdXRpbHMuZXh0ZW5kKG9yaWdpbmFsT3B0aW9ucyB8fCB7fSwgZGVmYXVsdHMpO1xuICAgIG8uZGF0ZSA9IG8uZGF0ZSB8fCBuZXcgRGF0ZSgpO1xuICAgIGlmIChvLmNvbXByZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgIG8uY29tcHJlc3Npb24gPSBvLmNvbXByZXNzaW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvLnVuaXhQZXJtaXNzaW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvLnVuaXhQZXJtaXNzaW9ucyA9IHBhcnNlSW50KG8udW5peFBlcm1pc3Npb25zLCA4KTtcbiAgICB9XG5cbiAgICAvLyBVTlhfSUZESVIgIDAwNDAwMDAgc2VlIHppcGluZm8uY1xuICAgIGlmIChvLnVuaXhQZXJtaXNzaW9ucyAmJiAoby51bml4UGVybWlzc2lvbnMgJiAweDQwMDApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQml0IDQgICAgRGlyZWN0b3J5XG4gICAgaWYgKG8uZG9zUGVybWlzc2lvbnMgJiYgKG8uZG9zUGVybWlzc2lvbnMgJiAweDAwMTApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoby5kaXIpIHtcbiAgICAgICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcbiAgICB9XG4gICAgaWYgKG8uY3JlYXRlRm9sZGVycyAmJiAocGFyZW50ID0gcGFyZW50Rm9sZGVyKG5hbWUpKSkge1xuICAgICAgICBmb2xkZXJBZGQuY2FsbCh0aGlzLCBwYXJlbnQsIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBpc1VuaWNvZGVTdHJpbmcgPSBkYXRhVHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBvLmJpbmFyeSA9PT0gZmFsc2UgJiYgby5iYXNlNjQgPT09IGZhbHNlO1xuICAgIGlmICghb3JpZ2luYWxPcHRpb25zIHx8IHR5cGVvZiBvcmlnaW5hbE9wdGlvbnMuYmluYXJ5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG8uYmluYXJ5ID0gIWlzVW5pY29kZVN0cmluZztcbiAgICB9XG5cblxuICAgIHZhciBpc0NvbXByZXNzZWRFbXB0eSA9IChkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCkgJiYgZGF0YS51bmNvbXByZXNzZWRTaXplID09PSAwO1xuXG4gICAgaWYgKGlzQ29tcHJlc3NlZEVtcHR5IHx8IG8uZGlyIHx8ICFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG8uYmFzZTY0ID0gZmFsc2U7XG4gICAgICAgIG8uYmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgZGF0YSA9IFwiXCI7XG4gICAgICAgIG8uY29tcHJlc3Npb24gPSBcIlNUT1JFXCI7XG4gICAgICAgIGRhdGFUeXBlID0gXCJzdHJpbmdcIjtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvbnZlcnQgY29udGVudCB0byBmaXQuXG4gICAgICovXG5cbiAgICB2YXIgemlwT2JqZWN0Q29udGVudCA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0IHx8IGRhdGEgaW5zdGFuY2VvZiBHZW5lcmljV29ya2VyKSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSBuZXcgTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKG5hbWUsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSB1dGlscy5wcmVwYXJlQ29udGVudChuYW1lLCBkYXRhLCBvLmJpbmFyeSwgby5vcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIG8uYmFzZTY0KTtcbiAgICB9XG5cbiAgICB2YXIgb2JqZWN0ID0gbmV3IFppcE9iamVjdChuYW1lLCB6aXBPYmplY3RDb250ZW50LCBvKTtcbiAgICB0aGlzLmZpbGVzW25hbWVdID0gb2JqZWN0O1xuICAgIC8qXG4gICAgVE9ETzogd2UgY2FuJ3QgdGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugd2UgaGF2ZSBhc3luYyBwcm9taXNlc1xuICAgICh3ZSBjYW4gaGF2ZSBhIHByb21pc2Ugb2YgYSBEYXRlKCkgZm9yIGV4YW1wbGUpIGJ1dCByZXR1cm5pbmcgYVxuICAgIHByb21pc2UgaXMgdXNlbGVzcyBiZWNhdXNlIGZpbGUobmFtZSwgZGF0YSkgcmV0dXJucyB0aGUgSlNaaXBcbiAgICBvYmplY3QgZm9yIGNoYWluaW5nLiBTaG91bGQgd2UgYnJlYWsgdGhhdCB0byBhbGxvdyB0aGUgdXNlclxuICAgIHRvIGNhdGNoIHRoZSBlcnJvciA/XG5cbiAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHppcE9iamVjdENvbnRlbnQpXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuICAgICovXG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIHBhcmVudCBmb2xkZXIgb2YgdGhlIHBhdGguXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gdXNlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBwYXJlbnQgZm9sZGVyLCBvciBcIlwiXG4gKi9cbnZhciBwYXJlbnRGb2xkZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChwYXRoLnNsaWNlKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICB2YXIgbGFzdFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIHJldHVybiAobGFzdFNsYXNoID4gMCkgPyBwYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpIDogXCJcIjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGF0aCB3aXRoIGEgc2xhc2ggYXQgdGhlIGVuZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHBhdGggd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICovXG52YXIgZm9yY2VUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIC8vIENoZWNrIHRoZSBuYW1lIGVuZHMgd2l0aCBhIC9cbiAgICBpZiAocGF0aC5zbGljZSgtMSkgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGggKz0gXCIvXCI7IC8vIElFIGRvZXNuJ3QgbGlrZSBzdWJzdHIoLTEpXG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuLyoqXG4gKiBBZGQgYSAoc3ViKSBmb2xkZXIgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBmb2xkZXIncyBuYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBbY3JlYXRlRm9sZGVyc10gSWYgdHJ1ZSwgYXV0b21hdGljYWxseSBjcmVhdGUgc3ViXG4gKiAgZm9sZGVycy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBuZXcgZm9sZGVyLlxuICovXG52YXIgZm9sZGVyQWRkID0gZnVuY3Rpb24obmFtZSwgY3JlYXRlRm9sZGVycykge1xuICAgIGNyZWF0ZUZvbGRlcnMgPSAodHlwZW9mIGNyZWF0ZUZvbGRlcnMgIT09ICd1bmRlZmluZWQnKSA/IGNyZWF0ZUZvbGRlcnMgOiBkZWZhdWx0cy5jcmVhdGVGb2xkZXJzO1xuXG4gICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcblxuICAgIC8vIERvZXMgdGhpcyBmb2xkZXIgYWxyZWFkeSBleGlzdD9cbiAgICBpZiAoIXRoaXMuZmlsZXNbbmFtZV0pIHtcbiAgICAgICAgZmlsZUFkZC5jYWxsKHRoaXMsIG5hbWUsIG51bGwsIHtcbiAgICAgICAgICAgIGRpcjogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IGNyZWF0ZUZvbGRlcnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbGVzW25hbWVdO1xufTtcblxuLyoqXG4qIENyb3NzLXdpbmRvdywgY3Jvc3MtTm9kZS1jb250ZXh0IHJlZ3VsYXIgZXhwcmVzc2lvbiBkZXRlY3Rpb25cbiogQHBhcmFtICB7T2JqZWN0fSAgb2JqZWN0IEFueXRoaW5nXG4qIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sXG4qIGZhbHNlIG90aGVyd2lzZVxuKi9cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbn1cblxuLy8gcmV0dXJuIHRoZSBhY3R1YWwgcHJvdG90eXBlIG9mIEpTWmlwXG52YXIgb3V0ID0ge1xuICAgIC8qKlxuICAgICAqIEBzZWUgbG9hZEFzeW5jXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBlbnRyeSBhdCB0aGlzIGZvbGRlciBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiB0aGUgY2FsbGJhY2sgZnVuY3Rpb246XG4gICAgICogZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkgey4uLn1cbiAgICAgKiBJdCB0YWtlcyAyIGFyZ3VtZW50cyA6IHRoZSByZWxhdGl2ZSBwYXRoIGFuZCB0aGUgZmlsZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoOiBmdW5jdGlvbihjYikge1xuICAgICAgICB2YXIgZmlsZW5hbWUsIHJlbGF0aXZlUGF0aCwgZmlsZTtcbiAgICAgICAgZm9yIChmaWxlbmFtZSBpbiB0aGlzLmZpbGVzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tmaWxlbmFtZV07XG4gICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBmaWxlbmFtZS5zbGljZSh0aGlzLnJvb3QubGVuZ3RoLCBmaWxlbmFtZS5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGF0aCAmJiBmaWxlbmFtZS5zbGljZSgwLCB0aGlzLnJvb3QubGVuZ3RoKSA9PT0gdGhpcy5yb290KSB7IC8vIHRoZSBmaWxlIGlzIGluIHRoZSBjdXJyZW50IHJvb3RcbiAgICAgICAgICAgICAgICBjYihyZWxhdGl2ZVBhdGgsIGZpbGUpOyAvLyBUT0RPIHJldmVyc2UgdGhlIHBhcmFtZXRlcnMgPyBuZWVkIHRvIGJlIGNsZWFuIEFORCBjb25zaXN0ZW50IHdpdGggdGhlIGZpbHRlciBzZWFyY2ggZm4uLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgbmVzdGVkIGZpbGVzL2ZvbGRlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlYXJjaCB0aGUgcHJlZGljYXRlIHRvIHVzZSA6XG4gICAgICogZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkgey4uLn1cbiAgICAgKiBJdCB0YWtlcyAyIGFyZ3VtZW50cyA6IHRoZSByZWxhdGl2ZSBwYXRoIGFuZCB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgbWF0Y2hpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgZmlsdGVyOiBmdW5jdGlvbihzZWFyY2gpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChzZWFyY2gocmVsYXRpdmVQYXRoLCBlbnRyeSkpIHsgLy8gdGhlIGZpbGUgbWF0Y2hlcyB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGZpbGUgdG8gdGhlIHppcCBmaWxlLCBvciBzZWFyY2ggYSBmaWxlLlxuICAgICAqIEBwYXJhbSAgIHtzdHJpbmd8UmVnRXhwfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGFkZCAoaWYgZGF0YSBpcyBkZWZpbmVkKSxcbiAgICAgKiB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBmaW5kIChpZiBubyBkYXRhKSBvciBhIHJlZ2V4IHRvIG1hdGNoIGZpbGVzLlxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgIFRoZSBmaWxlIGRhdGEsIGVpdGhlciByYXcgb3IgYmFzZTY0IGVuY29kZWRcbiAgICAgKiBAcGFyYW0gICB7T2JqZWN0fSBvICAgICBGaWxlIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuICB7SlNaaXB8T2JqZWN0fEFycmF5fSB0aGlzIEpTWmlwIG9iamVjdCAod2hlbiBhZGRpbmcgYSBmaWxlKSxcbiAgICAgKiBhIGZpbGUgKHdoZW4gc2VhcmNoaW5nIGJ5IHN0cmluZykgb3IgYW4gYXJyYXkgb2YgZmlsZXMgKHdoZW4gc2VhcmNoaW5nIGJ5IHJlZ2V4KS5cbiAgICAgKi9cbiAgICBmaWxlOiBmdW5jdGlvbihuYW1lLCBkYXRhLCBvKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoaXNSZWdFeHAobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhwID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZmlsZS5kaXIgJiYgcmVnZXhwLnRlc3QocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyB0ZXh0XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZmlsZXNbdGhpcy5yb290ICsgbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAmJiAhb2JqLmRpcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gbW9yZSB0aGFuIG9uZSBhcmd1bWVudCA6IHdlIGhhdmUgZGF0YSAhXG4gICAgICAgICAgICBuYW1lID0gdGhpcy5yb290ICsgbmFtZTtcbiAgICAgICAgICAgIGZpbGVBZGQuY2FsbCh0aGlzLCBuYW1lLCBkYXRhLCBvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZGlyZWN0b3J5IHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoLlxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd8UmVnRXhwfSBhcmcgVGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeSB0byBhZGQsIG9yIGEgcmVnZXggdG8gc2VhcmNoIGZvbGRlcnMuXG4gICAgICogQHJldHVybiAge0pTWmlwfSBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IGRpcmVjdG9yeSBhcyB0aGUgcm9vdCwgb3IgYW4gYXJyYXkgY29udGFpbmluZyBtYXRjaGluZyBmb2xkZXJzLlxuICAgICAqL1xuICAgIGZvbGRlcjogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIGlmICghYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1JlZ0V4cChhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUuZGlyICYmIGFyZy50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsc2UsIG5hbWUgaXMgYSBuZXcgZm9sZGVyXG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5yb290ICsgYXJnO1xuICAgICAgICB2YXIgbmV3Rm9sZGVyID0gZm9sZGVyQWRkLmNhbGwodGhpcywgbmFtZSk7XG5cbiAgICAgICAgLy8gQWxsb3cgY2hhaW5pbmcgYnkgcmV0dXJuaW5nIGEgbmV3IG9iamVjdCB3aXRoIHRoaXMgZm9sZGVyIGFzIHRoZSByb290XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJldC5yb290ID0gbmV3Rm9sZGVyLm5hbWU7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGZpbGUsIG9yIGEgZGlyZWN0b3J5IGFuZCBhbGwgc3ViLWZpbGVzLCBmcm9tIHRoZSB6aXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBkZWxldGVcbiAgICAgKiBAcmV0dXJuIHtKU1ppcH0gdGhpcyBKU1ppcCBvYmplY3RcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBhbnkgZm9sZGVyc1xuICAgICAgICAgICAgaWYgKG5hbWUuc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gXCIvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlICYmICFmaWxlLmRpcikge1xuICAgICAgICAgICAgLy8gZmlsZVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtYXliZSBhIGZvbGRlciwgZGVsZXRlIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICB2YXIga2lkcyA9IHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLm5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGgpID09PSBuYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc1traWRzW2ldLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZSA6XG4gICAgICogLSBjb21wcmVzc2lvbiwgXCJTVE9SRVwiIGJ5IGRlZmF1bHQuXG4gICAgICogLSB0eXBlLCBcImJhc2U2NFwiIGJ5IGRlZmF1bHQuIFZhbHVlcyBhcmUgOiBzdHJpbmcsIGJhc2U2NCwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIGJsb2IuXG4gICAgICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8QnVmZmVyfEJsb2J9IHRoZSB6aXAgZmlsZVxuICAgICAqL1xuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXMgYW4gaW50ZXJuYWwgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZSA6XG4gICAgICogLSBjb21wcmVzc2lvbiwgXCJTVE9SRVwiIGJ5IGRlZmF1bHQuXG4gICAgICogLSB0eXBlLCBcImJhc2U2NFwiIGJ5IGRlZmF1bHQuIFZhbHVlcyBhcmUgOiBzdHJpbmcsIGJhc2U2NCwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIGJsb2IuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgc3RyZWFtZWQgemlwIGZpbGUuXG4gICAgICovXG4gICAgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHdvcmtlciwgb3B0cyA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBvcHRzID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgICAgICAgc3RyZWFtRmlsZXM6IGZhbHNlLFxuICAgICAgICAgICAgICBjb21wcmVzc2lvbjogXCJTVE9SRVwiLFxuICAgICAgICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBudWxsLFxuICAgICAgICAgICAgICB0eXBlOiBcIlwiLFxuICAgICAgICAgICAgICBwbGF0Zm9ybTogXCJET1NcIixcbiAgICAgICAgICAgICAgY29tbWVudDogbnVsbCxcbiAgICAgICAgICAgICAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAgICAgICAgICAgICBlbmNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZW5jb2RlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBvcHRzLnR5cGUgPSBvcHRzLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBvcHRzLmNvbXByZXNzaW9uID0gb3B0cy5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgLy8gXCJiaW5hcnlzdHJpbmdcIiBpcyBwcmVmZXJyZWQgYnV0IHRoZSBpbnRlcm5hbHMgdXNlIFwic3RyaW5nXCIuXG4gICAgICAgICAgaWYob3B0cy50eXBlID09PSBcImJpbmFyeXN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRzLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghb3B0cy50eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChvcHRzLnR5cGUpO1xuXG4gICAgICAgICAgLy8gYWNjZXB0IG5vZGVqcyBgcHJvY2Vzcy5wbGF0Zm9ybWBcbiAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnIHx8XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdsaW51eCcgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ3N1bm9zJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID0gXCJVTklYXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPSBcIkRPU1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb21tZW50ID0gb3B0cy5jb21tZW50IHx8IHRoaXMuY29tbWVudCB8fCBcIlwiO1xuICAgICAgICAgIHdvcmtlciA9IGdlbmVyYXRlLmdlbmVyYXRlV29ya2VyKHRoaXMsIG9wdHMsIGNvbW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB3b3JrZXIuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcih3b3JrZXIsIG9wdHMudHlwZSB8fCBcInN0cmluZ1wiLCBvcHRzLm1pbWVUeXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAc2VlIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUFzeW5jOiBmdW5jdGlvbihvcHRpb25zLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLmFjY3VtdWxhdGUob25VcGRhdGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBzZWUgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbVxuICAgICAqL1xuICAgIGdlbmVyYXRlTm9kZVN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucywgb25VcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPSBcIm5vZGVidWZmZXJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBvdXQ7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHVzZWQgYnkgbW9kdWxlIGJ1bmRsZXJzIChicm93c2VyaWZ5L3dlYnBhY2svZXRjKSB3aGVuXG4gKiBpbmNsdWRpbmcgYSBzdHJlYW0gaW1wbGVtZW50YXRpb24uIFdlIHVzZSBcInJlYWRhYmxlLXN0cmVhbVwiIHRvIGdldCBhXG4gKiBjb25zaXN0ZW50IGJlaGF2aW9yIGJldHdlZW4gbm9kZWpzIHZlcnNpb25zIGJ1dCBidW5kbGVycyBvZnRlbiBoYXZlIGEgc2hpbVxuICogZm9yIFwic3RyZWFtXCIuIFVzaW5nIHRoaXMgc2hpbSBncmVhdGx5IGltcHJvdmUgdGhlIGNvbXBhdGliaWxpdHkgYW5kIGdyZWF0bHlcbiAqIHJlZHVjZSB0aGUgZmluYWwgc2l6ZSBvZiB0aGUgYnVuZGxlIChvbmx5IG9uZSBzdHJlYW0gaW1wbGVtZW50YXRpb24sIG5vdFxuICogdHdvKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBEYXRhUmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRkYXRhW2ldID0gZGF0YVtpXSAmIDB4RkY7XG5cdH1cbn1cbnV0aWxzLmluaGVyaXRzKEFycmF5UmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy56ZXJvICsgaV07XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHNpZzAgPSBzaWcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgc2lnMSA9IHNpZy5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBzaWcyID0gc2lnLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIHNpZzMgPSBzaWcuY2hhckNvZGVBdCgzKTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSA0OyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09PSBzaWcwICYmIHRoaXMuZGF0YVtpICsgMV0gPT09IHNpZzEgJiYgdGhpcy5kYXRhW2kgKyAyXSA9PT0gc2lnMiAmJiB0aGlzLmRhdGFbaSArIDNdID09PSBzaWczKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAtIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWRBbmRDaGVja1NpZ25hdHVyZSA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpLFxuICAgICAgICBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnMCA9PT0gZGF0YVswXSAmJiBzaWcxID09PSBkYXRhWzFdICYmIHNpZzIgPT09IGRhdGFbMl0gJiYgc2lnMyA9PT0gZGF0YVszXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheVJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIERhdGFSZWFkZXIoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7IC8vIHR5cGUgOiBzZWUgaW1wbGVtZW50YXRpb25cbiAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMuemVybyA9IDA7XG59XG5EYXRhUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBvZmZzZXQgd2lsbCBub3QgZ28gdG9vIGZhci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2Zmc2V0IHRoZSBhZGRpdGlvbmFsIG9mZnNldCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIGNoZWNrT2Zmc2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5jaGVja0luZGV4KHRoaXMuaW5kZXggKyBvZmZzZXQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHdpbGwgbm90IGJlIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0luZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMuXG4gICAgICovXG4gICAgY2hlY2tJbmRleDogZnVuY3Rpb24obmV3SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy56ZXJvICsgbmV3SW5kZXggfHwgbmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmQgb2YgZGF0YSByZWFjaGVkIChkYXRhIGxlbmd0aCA9IFwiICsgdGhpcy5sZW5ndGggKyBcIiwgYXNrZWQgaW5kZXggPSBcIiArIChuZXdJbmRleCkgKyBcIikuIENvcnJ1cHRlZCB6aXAgP1wiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SW5kZXggVGhlIG5ldyBpbmRleC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG5ldyBpbmRleCBpcyBvdXQgb2YgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2V0SW5kZXg6IGZ1bmN0aW9uKG5ld0luZGV4KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleChuZXdJbmRleCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXdJbmRleDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNraXAgdGhlIG5leHQgbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBuZXcgaW5kZXggaXMgb3V0IG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHNraXA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0aGlzLmluZGV4ICsgbik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaSB0aGUgaW5kZXggdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gYSBieXRlLlxuICAgICAqL1xuICAgIGJ5dGVBdDogZnVuY3Rpb24oaSkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgbnVtYmVyIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyLlxuICAgICAqL1xuICAgIHJlYWRJbnQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmluZGV4ICsgc2l6ZSAtIDE7IGkgPj0gdGhpcy5pbmRleDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDgpICsgdGhpcy5ieXRlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHN0cmluZyB3aXRoIGEgZ2l2ZW4gYnl0ZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjb3JyZXNwb25kaW5nIHN0cmluZy5cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLnJlYWREYXRhKHNpemUpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSB3aXRob3V0IGNvbnZlcnNpb24sIDxzaXplPiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcmF3IGRhdGEsIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxuICAgICAqL1xuICAgIHJlYWREYXRhOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBhIHppcCBzaWduYXR1cmUgKDQgYnl0ZXMpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWcgdGhlIHNpZ25hdHVyZSB0byBmaW5kLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBsYXN0IG9jY3VycmVuY2UsIC0xIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBsYXN0SW5kZXhPZlNpZ25hdHVyZTogZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIHNpZ25hdHVyZSAoNCBieXRlcykgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIGNvbXBhcmUgaXQgd2l0aCBzaWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIG1hdGNoZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZWFkQW5kQ2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgZGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtEYXRlfSB0aGUgZGF0ZS5cbiAgICAgKi9cbiAgICByZWFkRGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb3N0aW1lID0gdGhpcy5yZWFkSW50KDQpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoXG4gICAgICAgICgoZG9zdGltZSA+PiAyNSkgJiAweDdmKSArIDE5ODAsIC8vIHllYXJcbiAgICAgICAgKChkb3N0aW1lID4+IDIxKSAmIDB4MGYpIC0gMSwgLy8gbW9udGhcbiAgICAgICAgKGRvc3RpbWUgPj4gMTYpICYgMHgxZiwgLy8gZGF5XG4gICAgICAgIChkb3N0aW1lID4+IDExKSAmIDB4MWYsIC8vIGhvdXJcbiAgICAgICAgKGRvc3RpbWUgPj4gNSkgJiAweDNmLCAvLyBtaW51dGVcbiAgICAgICAgKGRvc3RpbWUgJiAweDFmKSA8PCAxKSk7IC8vIHNlY29uZFxuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gTm9kZUJ1ZmZlclJlYWRlcihkYXRhKSB7XG4gICAgVWludDhBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoTm9kZUJ1ZmZlclJlYWRlciwgVWludDhBcnJheVJlYWRlcik7XG5cbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cbk5vZGVCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBOb2RlQnVmZmVyUmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFN0cmluZ1JlYWRlcihkYXRhKSB7XG4gICAgRGF0YVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoU3RyaW5nUmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLmJ5dGVBdCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy56ZXJvICsgaSk7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHJldHVybiB0aGlzLmRhdGEubGFzdEluZGV4T2Yoc2lnKSAtIHRoaXMuemVybztcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkQW5kQ2hlY2tTaWduYXR1cmUgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlYWREYXRhKDQpO1xuICAgIHJldHVybiBzaWcgPT09IGRhdGE7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIC8vIHRoaXMgd2lsbCB3b3JrIGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIGFwcGxpZWQgdGhlIFwiJiAweGZmXCIgbWFzay5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ1JlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vQXJyYXlSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFVpbnQ4QXJyYXlSZWFkZXIoZGF0YSkge1xuICAgIEFycmF5UmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG59XG51dGlscy5pbmhlcml0cyhVaW50OEFycmF5UmVhZGVyLCBBcnJheVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5VaW50OEFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIGlmKHNpemUgPT09IDApIHtcbiAgICAgICAgLy8gaW4gSUUxMCwgd2hlbiB1c2luZyBzdWJhcnJheShpZHgsIGlkeCksIHdlIGdldCB0aGUgYXJyYXkgWzB4MDBdIGluc3RlYWQgb2YgW10uXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5UmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuLi9zdXBwb3J0Jyk7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL0FycmF5UmVhZGVyJyk7XG52YXIgU3RyaW5nUmVhZGVyID0gcmVxdWlyZSgnLi9TdHJpbmdSZWFkZXInKTtcbnZhciBOb2RlQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi9Ob2RlQnVmZmVyUmVhZGVyJyk7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlYWRlciBhZGFwdGVkIHRvIHRoZSBkYXRhLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgdG8gcmVhZC5cbiAqIEByZXR1cm4ge0RhdGFSZWFkZXJ9IHRoZSBkYXRhIHJlYWRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB0eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgIHV0aWxzLmNoZWNrU3VwcG9ydCh0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAhc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlQnVmZmVyUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5UmVhZGVyKHV0aWxzLnRyYW5zZm9ybVRvKFwiYXJyYXlcIiwgZGF0YSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmV4cG9ydHMuTE9DQUxfRklMRV9IRUFERVIgPSBcIlBLXFx4MDNcXHgwNFwiO1xuZXhwb3J0cy5DRU5UUkFMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAxXFx4MDJcIjtcbmV4cG9ydHMuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EID0gXCJQS1xceDA1XFx4MDZcIjtcbmV4cG9ydHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiA9IFwiUEtcXHgwNlxceDA3XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNlxceDA2XCI7XG5leHBvcnRzLkRBVEFfREVTQ1JJUFRPUiA9IFwiUEtcXHgwN1xceDA4XCI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9HZW5lcmljV29ya2VyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNvbnZlcnQgY2h1bmtzIHRvIGEgc3BlY2lmaWVkIHR5cGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0VHlwZSB0aGUgZGVzdGluYXRpb24gdHlwZS5cbiAqL1xuZnVuY3Rpb24gQ29udmVydFdvcmtlcihkZXN0VHlwZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkNvbnZlcnRXb3JrZXIgdG8gXCIgKyBkZXN0VHlwZSk7XG4gICAgdGhpcy5kZXN0VHlwZSA9IGRlc3RUeXBlO1xufVxudXRpbHMuaW5oZXJpdHMoQ29udmVydFdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5Db252ZXJ0V29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogdXRpbHMudHJhbnNmb3JtVG8odGhpcy5kZXN0VHlwZSwgY2h1bmsuZGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb252ZXJ0V29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIGNyYzMyID0gcmVxdWlyZSgnLi4vY3JjMzInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSBjcmMzMiBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ3JjMzJQcm9iZSgpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDcmMzMlByb2JlXCIpO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKENyYzMyUHJvYmUsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ3JjMzJQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5zdHJlYW1JbmZvLmNyYzMyID0gY3JjMzIoY2h1bmsuZGF0YSwgdGhpcy5zdHJlYW1JbmZvLmNyYzMyIHx8IDApO1xuICAgIHRoaXMucHVzaChjaHVuayk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDcmMzMlByb2JlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjYWxjdWxhdGUgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSB0aGUgbmFtZSB1c2VkIHRvIGV4cG9zZSB0aGUgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIERhdGFMZW5ndGhQcm9iZShwcm9wTmFtZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkRhdGFMZW5ndGhQcm9iZSBmb3IgXCIgKyBwcm9wTmFtZSk7XG4gICAgdGhpcy5wcm9wTmFtZSA9IHByb3BOYW1lO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8ocHJvcE5hbWUsIDApO1xufVxudXRpbHMuaW5oZXJpdHMoRGF0YUxlbmd0aFByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkRhdGFMZW5ndGhQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYoY2h1bmspIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuc3RyZWFtSW5mb1t0aGlzLnByb3BOYW1lXSB8fCAwO1xuICAgICAgICB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gPSBsZW5ndGggKyBjaHVuay5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rLmNhbGwodGhpcywgY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YUxlbmd0aFByb2JlO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xuXG4vLyB0aGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGNodW5rc1xuLy8gVE9ETyBleHBvc2UgdGhpcyBhcyBhIHB1YmxpYyB2YXJpYWJsZVxudmFyIERFRkFVTFRfQkxPQ0tfU0laRSA9IDE2ICogMTAyNDtcblxuLyoqXG4gKiBBIHdvcmtlciB0aGF0IHJlYWRzIGEgY29udGVudCBhbmQgZW1pdHMgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Byb21pc2V9IGRhdGFQIHRoZSBwcm9taXNlIG9mIHRoZSBkYXRhIHRvIHNwbGl0XG4gKi9cbmZ1bmN0aW9uIERhdGFXb3JrZXIoZGF0YVApIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhV29ya2VyXCIpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRhdGFJc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5tYXggPSAwO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcblxuICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIGRhdGFQLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi5kYXRhSXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYubWF4ID0gZGF0YSAmJiBkYXRhLmxlbmd0aCB8fCAwO1xuICAgICAgICBzZWxmLnR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSk7XG4gICAgICAgIGlmKCFzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBzZWxmLl90aWNrQW5kUmVwZWF0KCk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgIH0pO1xufVxuXG51dGlscy5pbmhlcml0cyhEYXRhV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuY2xlYW5VcFxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucmVzdW1lXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdGlja1NjaGVkdWxlZCAmJiB0aGlzLmRhdGFJc1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGEgdGljayBhIHNjaGVkdWxlIGFuIG90aGVyIGNhbGwgdG8gdGhpcyBmdW5jdGlvbi5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2tBbmRSZXBlYXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl90aWNrKCk7XG4gICAgaWYoIXRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVhZCBhbmQgcHVzaCBhIGNodW5rLlxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaXplID0gREVGQVVMVF9CTE9DS19TSVpFO1xuICAgIHZhciBkYXRhID0gbnVsbCwgbmV4dEluZGV4ID0gTWF0aC5taW4odGhpcy5tYXgsIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLm1heCkge1xuICAgICAgICAvLyBFT0ZcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIG5leHRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub2RlYnVmZmVyXCI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZGF0YSxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IHRoaXMubWF4ID8gdGhpcy5pbmRleCAvIHRoaXMubWF4ICogMTAwIDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHBhc3NpbmcgY2h1bmtzIHRvIHRoZSBuZXh0IG9uZS4gVGhpcyBpcyBsaWtlXG4gKiBhIG5vZGVqcyBzdHJlYW0gYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlcy4gT24gdGhlIGdvb2Qgc2lkZSA6XG4gKiAtIGl0IHdvcmtzIG9uIElFIDYtOSB3aXRob3V0IGFueSBpc3N1ZSAvIHBvbHlmaWxsXG4gKiAtIGl0IHdlaWdodHMgbGVzcyB0aGFuIHRoZSBmdWxsIGRlcGVuZGVuY2llcyBidW5kbGVkIHdpdGggYnJvd3NlcmlmeVxuICogLSBpdCBmb3J3YXJkcyBlcnJvcnMgKG5vIG5lZWQgdG8gZGVjbGFyZSBhbiBlcnJvciBoYW5kbGVyIEVWRVJZV0hFUkUpXG4gKlxuICogQSBjaHVuayBpcyBhbiBvYmplY3Qgd2l0aCAyIGF0dHJpYnV0ZXMgOiBgbWV0YWAgYW5kIGBkYXRhYC4gVGhlIGZvcm1lciBpcyBhblxuICogb2JqZWN0IGNvbnRhaW5pbmcgYW55dGhpbmcgKGBwZXJjZW50YCBmb3IgZXhhbXBsZSksIHNlZSBlYWNoIHdvcmtlciBmb3IgbW9yZVxuICogZGV0YWlscy4gVGhlIGxhdHRlciBpcyB0aGUgcmVhbCBkYXRhIChTdHJpbmcsIFVpbnQ4QXJyYXksIGV0YykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgc3RyZWFtIChtYWlubHkgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzKVxuICovXG5mdW5jdGlvbiBHZW5lcmljV29ya2VyKG5hbWUpIHtcbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgd29ya2VyXG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCBcImRlZmF1bHRcIjtcbiAgICAvLyBhbiBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBhYm91dCB0aGUgd29ya2VycyBjaGFpblxuICAgIHRoaXMuc3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIGFuIGVycm9yIHdoaWNoIGhhcHBlbmVkIHdoZW4gdGhlIHdvcmtlciB3YXMgcGF1c2VkXG4gICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IG51bGw7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgdG8gYmUgbWVyZ2VkIGJ5IHRoaXMgd29ya2VyIGludG8gdGhlIGdlbmVyYWwgbWV0YWRhdGFcbiAgICB0aGlzLmV4dHJhU3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBwYXVzZWQgKGFuZCBzaG91bGQgbm90IGRvIGFueXRoaW5nKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgLy8gdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBsb2NrZWQgdG8gcHJldmVudCBmdXJ0aGVyIHN0cnVjdHVyZSB1cGRhdGVzIChwaXBlKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuICAgIC8vIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7XG4gICAgICAgICdkYXRhJzpbXSxcbiAgICAgICAgJ2VuZCc6W10sXG4gICAgICAgICdlcnJvcic6W11cbiAgICB9O1xuICAgIC8vIHRoZSBwcmV2aW91cyB3b3JrZXIsIGlmIGFueVxuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xufVxuXG5HZW5lcmljV29ya2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBQdXNoIGEgY2h1bmsgdG8gdGhlIG5leHQgd29ya2Vycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2h1bmsgdGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKi9cbiAgICBwdXNoIDogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5kIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgZW5kZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVuZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtIHdpdGggYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZSB0aGUgZXJyb3Igd2hpY2ggY2F1c2VkIHRoZSBwcmVtYXR1cmUgZW5kLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIgd2l0aCBhbiBlcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVycm9yIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcblxuICAgICAgICAgICAgLy8gaW4gdGhlIHdvcmtlcnMgY2hhaW4gZXhwbG9kZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2hhaW4sXG4gICAgICAgICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgd2lsbCBnbyBkb3dud2FyZCBidXQgd2UgYWxzbyBuZWVkIHRvIG5vdGlmeVxuICAgICAgICAgICAgLy8gd29ya2VycyB1cHdhcmQgdGhhdCB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIG9uIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIG9uIDogZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDbGVhbiBhbnkgcmVmZXJlbmNlcyB3aGVuIGEgd29ya2VyIGlzIGVuZGluZy5cbiAgICAgKi9cbiAgICBjbGVhblVwIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSB0aGlzLmdlbmVyYXRlZEVycm9yID0gdGhpcy5leHRyYVN0cmVhbUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYW4gZXZlbnQuIFRoaXMgd2lsbCBjYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCB0aGUgcHJvdmlkZWQgYXJnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIHRoZSBhcmd1bWVudCB0byBjYWxsIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgICAqL1xuICAgIGVtaXQgOiBmdW5jdGlvbiAobmFtZSwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV1baV0uY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGFpbiBhIHdvcmtlciB3aXRoIGFuIG90aGVyLlxuICAgICAqIEBwYXJhbSB7V29ya2VyfSBuZXh0IHRoZSB3b3JrZXIgcmVjZWl2aW5nIGV2ZW50cyBmcm9tIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgKiBAcmV0dXJuIHt3b3JrZXJ9IHRoZSBuZXh0IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcGlwZSA6IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXh0LnJlZ2lzdGVyUHJldmlvdXModGhpcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBwaXBlYCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAgICAqIFVzaW5nIGFuIEFQSSB3aXRoIGBwaXBlKG5leHQpYCBpcyB2ZXJ5IGVhc3kuXG4gICAgICogSW1wbGVtZW50aW5nIHRoZSBBUEkgd2l0aCB0aGUgcG9pbnQgb2YgdmlldyBvZiB0aGUgbmV4dCBvbmUgcmVnaXN0ZXJpbmdcbiAgICAgKiBhIHNvdXJjZSBpcyBlYXNpZXIsIHNlZSB0aGUgWmlwRmlsZVdvcmtlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gcHJldmlvdXMgdGhlIHByZXZpb3VzIHdvcmtlciwgc2VuZGluZyBldmVudHMgdG8gdGhpcyBvbmVcbiAgICAgKiBAcmV0dXJuIHtXb3JrZXJ9IHRoZSBjdXJyZW50IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcmVnaXN0ZXJQcmV2aW91cyA6IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaGFyaW5nIHRoZSBzdHJlYW1JbmZvLi4uXG4gICAgICAgIHRoaXMuc3RyZWFtSW5mbyA9IHByZXZpb3VzLnN0cmVhbUluZm87XG4gICAgICAgIC8vIC4uLiBhbmQgYWRkaW5nIG91ciBvd24gYml0c1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gIHByZXZpb3VzO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByZXZpb3VzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBzZWxmLnByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZpb3VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgc3RyZWFtIHNvIGl0IGRvZXNuJ3Qgc2VuZCBldmVudHMgYW55bW9yZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBwYXVzZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZih0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSBhIHBhdXNlZCBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcmVzdW1lZCB0aGUgd29ya2VyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighdGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgdHJ1ZSwgdGhlIHdvcmtlciB0cmllZCB0byByZXN1bWUgYnV0IGZhaWxlZFxuICAgICAgICB2YXIgd2l0aEVycm9yID0gZmFsc2U7XG4gICAgICAgIGlmKHRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IodGhpcy5nZW5lcmF0ZWRFcnJvcik7XG4gICAgICAgICAgICB3aXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucmVzdW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXdpdGhFcnJvcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZsdXNoIGFueSByZW1haW5pbmcgYnl0ZXMgYXMgdGhlIHN0cmVhbSBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgZmx1c2ggOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgY2h1bmsuIFRoaXMgaXMgdXN1YWxseSB0aGUgbWV0aG9kIG92ZXJyaWRkZW4uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwcm9jZXNzLlxuICAgICAqL1xuICAgIHByb2Nlc3NDaHVuayA6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIHRoaXMucHVzaChjaHVuayk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBrZXkvdmFsdWUgdG8gYmUgYWRkZWQgaW4gdGhlIHdvcmtlcnMgY2hhaW4gc3RyZWFtSW5mbyBvbmNlIGFjdGl2YXRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBrZXkgdG8gdXNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRoZSBhc3NvY2lhdGVkIHZhbHVlXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHdpdGhTdHJlYW1JbmZvIDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5leHRyYVN0cmVhbUluZm9ba2V5XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE1lcmdlIHRoaXMgd29ya2VyJ3Mgc3RyZWFtSW5mbyBpbnRvIHRoZSBjaGFpbidzIHN0cmVhbUluZm8uXG4gICAgICovXG4gICAgbWVyZ2VTdHJlYW1JbmZvIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiB0aGlzLmV4dHJhU3RyZWFtSW5mbykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4dHJhU3RyZWFtSW5mby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUluZm9ba2V5XSA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9jayB0aGUgc3RyZWFtIHRvIHByZXZlbnQgZnVydGhlciB1cGRhdGVzIG9uIHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsIGFsbCBjYWxscyB0byBwaXBlIHdpbGwgZmFpbC5cbiAgICAgKi9cbiAgICBsb2NrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RyZWFtICdcIiArIHRoaXMgKyBcIicgaGFzIGFscmVhZHkgYmVlbiB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMubG9jaygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJldHR5IHByaW50IHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqL1xuICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWUgPSBcIldvcmtlciBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzICsgXCIgLT4gXCIgKyBtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VuZXJpY1dvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBDb252ZXJ0V29ya2VyID0gcmVxdWlyZSgnLi9Db252ZXJ0V29ya2VyJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4uL2Jhc2U2NCcpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi4vc3VwcG9ydFwiKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9leHRlcm5hbFwiKTtcblxudmFyIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSBudWxsO1xuaWYgKHN1cHBvcnQubm9kZXN0cmVhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSByZXF1aXJlKCcuLi9ub2RlanMvTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcicpO1xuICAgIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBBcHBseSB0aGUgZmluYWwgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGRhdGEuIElmIHRoZSB1c2VyIHdhbnRzIGEgQmxvYiBmb3JcbiAqIGV4YW1wbGUsIGl0J3MgZWFzaWVyIHRvIHdvcmsgd2l0aCBhbiBVOGludEFycmF5IGFuZCBmaW5hbGx5IGRvIHRoZVxuICogQXJyYXlCdWZmZXIvQmxvYiBjb252ZXJzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG5hbWUgb2YgdGhlIGZpbmFsIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSBjb250ZW50IHRoZSBjb250ZW50IHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxBcnJheUJ1ZmZlcnxCdWZmZXJ8QmxvYn0gdGhlIGNvbnRlbnQgaW4gdGhlIHJpZ2h0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtWmlwT3V0cHV0KHR5cGUsIGNvbnRlbnQsIG1pbWVUeXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIiA6XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMubmV3QmxvYih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5YnVmZmVyXCIsIGNvbnRlbnQpLCBtaW1lVHlwZSk7XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIiA6XG4gICAgICAgICAgICByZXR1cm4gYmFzZTY0LmVuY29kZShjb250ZW50KTtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8odHlwZSwgY29udGVudCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGFycmF5IG9mIGRhdGEgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgZGF0YSBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhQXJyYXkgdGhlIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRhdGEgY2h1bmtzIHRvIGNvbmNhdGVuYXRlXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxCdWZmZXJ9IHRoZSBjb25jYXRlbmF0ZWQgZGF0YVxuICogQHRocm93cyBFcnJvciBpZiB0aGUgYXNrZWQgdHlwZSBpcyB1bnN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBjb25jYXQgKHR5cGUsIGRhdGFBcnJheSkge1xuICAgIHZhciBpLCBpbmRleCA9IDAsIHJlcyA9IG51bGwsIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gZGF0YUFycmF5W2ldLmxlbmd0aDtcbiAgICB9XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFBcnJheS5qb2luKFwiXCIpO1xuICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGRhdGFBcnJheSk7XG4gICAgICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgICAgICByZXMgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0KGRhdGFBcnJheVtpXSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IGRhdGFBcnJheVtpXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoZGF0YUFycmF5KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmNhdCA6IHVuc3VwcG9ydGVkIHR5cGUgJ1wiICArIHR5cGUgKyBcIidcIik7XG4gICAgfVxufVxuXG4vKipcbiAqIExpc3RlbiBhIFN0cmVhbUhlbHBlciwgYWNjdW11bGF0ZSBpdHMgY29udGVudCBhbmQgY29uY2F0ZW5hdGUgaXQgaW50byBhXG4gKiBjb21wbGV0ZSBibG9jay5cbiAqIEBwYXJhbSB7U3RyZWFtSGVscGVyfSBoZWxwZXIgdGhlIGhlbHBlciB0byB1c2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYWxsYmFjayBhIGNhbGxiYWNrIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZS4gQ2FsbGVkXG4gKiB3aXRoIG9uZSBhcmcgOlxuICogLSB0aGUgbWV0YWRhdGEgbGlua2VkIHRvIHRoZSB1cGRhdGUgcmVjZWl2ZWQuXG4gKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2UgZm9yIHRoZSBhY2N1bXVsYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGUoaGVscGVyLCB1cGRhdGVDYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB2YXIgY2h1bmtUeXBlID0gaGVscGVyLl9pbnRlcm5hbFR5cGUsXG4gICAgICAgICAgICByZXN1bHRUeXBlID0gaGVscGVyLl9vdXRwdXRUeXBlLFxuICAgICAgICAgICAgbWltZVR5cGUgPSBoZWxwZXIuX21pbWVUeXBlO1xuICAgICAgICBoZWxwZXJcbiAgICAgICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEsIG1ldGEpIHtcbiAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodXBkYXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDYWxsYmFjayhtZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybVppcE91dHB1dChyZXN1bHRUeXBlLCBjb25jYXQoY2h1bmtUeXBlLCBkYXRhQXJyYXkpLCBtaW1lVHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB9KVxuICAgICAgICAucmVzdW1lKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQW4gaGVscGVyIHRvIGVhc2lseSB1c2Ugd29ya2VycyBvdXRzaWRlIG9mIEpTWmlwLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dvcmtlcn0gd29ya2VyIHRoZSB3b3JrZXIgdG8gd3JhcFxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIHR5cGUgb2YgZGF0YSBleHBlY3RlZCBieSB0aGUgdXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgY29udGVudCwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gU3RyZWFtSGVscGVyKHdvcmtlciwgb3V0cHV0VHlwZSwgbWltZVR5cGUpIHtcbiAgICB2YXIgaW50ZXJuYWxUeXBlID0gb3V0cHV0VHlwZTtcbiAgICBzd2l0Y2gob3V0cHV0VHlwZSkge1xuICAgICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgICAgIGludGVybmFsVHlwZSA9IFwidWludDhhcnJheVwiO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gdGhlIHR5cGUgdXNlZCBpbnRlcm5hbGx5XG4gICAgICAgIHRoaXMuX2ludGVybmFsVHlwZSA9IGludGVybmFsVHlwZTtcbiAgICAgICAgLy8gdGhlIHR5cGUgdXNlZCB0byBvdXRwdXQgcmVzdWx0c1xuICAgICAgICB0aGlzLl9vdXRwdXRUeXBlID0gb3V0cHV0VHlwZTtcbiAgICAgICAgLy8gdGhlIG1pbWUgdHlwZVxuICAgICAgICB0aGlzLl9taW1lVHlwZSA9IG1pbWVUeXBlO1xuICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQoaW50ZXJuYWxUeXBlKTtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gd29ya2VyLnBpcGUobmV3IENvbnZlcnRXb3JrZXIoaW50ZXJuYWxUeXBlKSk7XG4gICAgICAgIC8vIHRoZSBsYXN0IHdvcmtlcnMgY2FuIGJlIHJld2lyZWQgd2l0aG91dCBpc3N1ZXMgYnV0IHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcHJldmVudCBhbnkgdXBkYXRlcyBvbiBwcmV2aW91cyB3b3JrZXJzLlxuICAgICAgICB3b3JrZXIubG9jaygpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICB0aGlzLl93b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB0aGlzLl93b3JrZXIuZXJyb3IoZSk7XG4gICAgfVxufVxuXG5TdHJlYW1IZWxwZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIExpc3RlbiBhIFN0cmVhbUhlbHBlciwgYWNjdW11bGF0ZSBpdHMgY29udGVudCBhbmQgY29uY2F0ZW5hdGUgaXQgaW50byBhXG4gICAgICogY29tcGxldGUgYmxvY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2IgdGhlIHVwZGF0ZSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2UgZm9yIHRoZSBhY2N1bXVsYXRpb24uXG4gICAgICovXG4gICAgYWNjdW11bGF0ZSA6IGZ1bmN0aW9uICh1cGRhdGVDYikge1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0ZSh0aGlzLCB1cGRhdGVDYik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBvbiBhbiBldmVudCB0cmlnZ2VyZWQgb24gYSBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2dCB0aGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGUgbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBjdXJyZW50IGhlbHBlci5cbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uIChldnQsIGZuKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZihldnQgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oZXZ0LCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKHNlbGYsIGNodW5rLmRhdGEsIGNodW5rLm1ldGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oZXZ0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdXRpbHMuZGVsYXkoZm4sIGFyZ3VtZW50cywgc2VsZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSB0aGUgZmxvdyBvZiBjaHVua3MuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl93b3JrZXIucmVzdW1lLCBbXSwgdGhpcy5fd29ya2VyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgZmxvdyBvZiBjaHVua3MuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgcGF1c2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5wYXVzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5vZGVqcyBzdHJlYW0gZm9yIHRoaXMgaGVscGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7Tm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcn0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gICAgICovXG4gICAgdG9Ob2RlanNTdHJlYW0gOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KFwibm9kZXN0cmVhbVwiKTtcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgc3RyZWFtIGNvbnRhaW5pbmcgYmxvYi9hcnJheWJ1ZmZlci91aW50OGFycmF5L3N0cmluZ1xuICAgICAgICAgICAgLy8gaXMgc3RyYW5nZSBhbmQgSSBkb24ndCBrbm93IGlmIGl0IHdvdWxkIGJlIHVzZWZ1bC5cbiAgICAgICAgICAgIC8vIEkgeW91IGZpbmQgdGhpcyBjb21tZW50IGFuZCBoYXZlIGEgZ29vZCB1c2VjYXNlLCBwbGVhc2Ugb3BlbiBhXG4gICAgICAgICAgICAvLyBidWcgcmVwb3J0ICFcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9vdXRwdXRUeXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcih0aGlzLCB7XG4gICAgICAgICAgICBvYmplY3RNb2RlIDogdGhpcy5fb3V0cHV0VHlwZSAhPT0gXCJub2RlYnVmZmVyXCJcbiAgICAgICAgfSwgdXBkYXRlQ2IpO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1IZWxwZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuYmFzZTY0ID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXkgPSB0cnVlO1xuZXhwb3J0cy5zdHJpbmcgPSB0cnVlO1xuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydHMubm9kZWJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCI7XG4vLyBjb250YWlucyB0cnVlIGlmIEpTWmlwIGNhbiByZWFkL2dlbmVyYXRlIFVpbnQ4QXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbmV4cG9ydHMudWludDhhcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5pZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZXhwb3J0cy5ibG9iID0gZmFsc2U7XG59XG5lbHNlIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIHRyeSB7XG4gICAgICAgIGV4cG9ydHMuYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdLCB7XG4gICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL3ppcFwiXG4gICAgICAgIH0pLnNpemUgPT09IDA7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgQnVpbGRlciA9IHNlbGYuQmxvYkJ1aWxkZXIgfHwgc2VsZi5XZWJLaXRCbG9iQnVpbGRlciB8fCBzZWxmLk1vekJsb2JCdWlsZGVyIHx8IHNlbGYuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKGJ1ZmZlcik7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBidWlsZGVyLmdldEJsb2IoJ2FwcGxpY2F0aW9uL3ppcCcpLnNpemUgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG50cnkge1xuICAgIGV4cG9ydHMubm9kZXN0cmVhbSA9ICEhcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGU7XG59IGNhdGNoKGUpIHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSBmYWxzZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoJy4vbm9kZWpzVXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3V0aWxzL3N0cmluZ3NcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgX3V0ZjhsZW5baV0gPSAoaSA+PSAyNTIgPyA2IDogaSA+PSAyNDggPyA1IDogaSA+PSAyNDAgPyA0IDogaSA+PSAyMjQgPyAzIDogaSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdPV91dGY4bGVuWzI1NF09MTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG52YXIgc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAgIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gICAgfVxuXG4gICAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBuZXcgQXJyYXkoYnVmX2xlbik7XG4gICAgfVxuXG4gICAgLy8gY29udmVydFxuICAgIGZvciAoaT0wLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MrMSA8IHN0cl9sZW4pKSB7XG4gICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKzEpO1xuICAgICAgICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICAgICAgICAgIG1fcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xufTtcblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gZnVuY3Rpb24oYnVmLCBtYXgpIHtcbiAgICB2YXIgcG9zO1xuXG4gICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gICAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gICAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gICAgcG9zID0gbWF4LTE7XG4gICAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgICAvLyBGdWNrdXAgLSB2ZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gICAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gICAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIHZ1ZmZlciBpcyB0b28gc21hbGwsXG4gICAgLy8gcmV0dXJuIG1heCB0b28uXG4gICAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xudmFyIGJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIHN0ciwgaSwgb3V0LCBjLCBjX2xlbjtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcblxuICAgIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICAgIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4qMik7XG5cbiAgICBmb3IgKG91dD0wLCBpPTA7IGk8bGVuOykge1xuICAgICAgICBjID0gYnVmW2krK107XG4gICAgICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAgICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuLTE7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAgICAgLy8gam9pbiB0aGUgcmVzdFxuICAgICAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgICAgICAgY19sZW4tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICAgICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2hyaW5rQnVmKHV0ZjE2YnVmLCBvdXQpXG4gICAgaWYgKHV0ZjE2YnVmLmxlbmd0aCAhPT0gb3V0KSB7XG4gICAgICAgIGlmKHV0ZjE2YnVmLnN1YmFycmF5KSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZiA9IHV0ZjE2YnVmLnN1YmFycmF5KDAsIG91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGYxNmJ1Zi5sZW5ndGggPSBvdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGYxNmJ1Zik7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5RnJvbUNoYXJDb2RlKHV0ZjE2YnVmKTtcbn07XG5cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgamF2YXNjcmlwdCBzdHJpbmcgaW50byBhbiBhcnJheSAodHlwZWQgaWYgcG9zc2libGUpIG9mIGJ5dGVzLFxuICogVVRGLTggZW5jb2RlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgVVRGLTggZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGVuY29kZSA9IGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShzdHIsIFwidXRmLThcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZzJidWYoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBieXRlcyBhcnJheSAob3IgYSByZXByZXNlbnRhdGlvbikgcmVwcmVzZW50aW5nIGFuIFVURi04IGVuY29kZWRcbiAqIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSBidWYgdGhlIGRhdGEgZGUgZGVjb2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0cy51dGY4ZGVjb2RlID0gZnVuY3Rpb24gdXRmOGRlY29kZShidWYpIHtcbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcIm5vZGVidWZmZXJcIiwgYnVmKS50b1N0cmluZyhcInV0Zi04XCIpO1xuICAgIH1cblxuICAgIGJ1ZiA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBidWYpO1xuXG4gICAgcmV0dXJuIGJ1ZjJzdHJpbmcoYnVmKTtcbn07XG5cbi8qKlxuICogQSB3b3JrZXIgdG8gZGVjb2RlIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzIGludG8gc3RyaW5nIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGY4RGVjb2RlV29ya2VyKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcInV0Zi04IGRlY29kZVwiKTtcbiAgICAvLyB0aGUgbGFzdCBieXRlcyBpZiBhIGNodW5rIGRpZG4ndCBlbmQgd2l0aCBhIGNvbXBsZXRlIGNvZGVwb2ludC5cbiAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbn1cbnV0aWxzLmluaGVyaXRzKFV0ZjhEZWNvZGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuVXRmOERlY29kZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgZGF0YSA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBjaHVuay5kYXRhKTtcblxuICAgIC8vIDFzdCBzdGVwLCByZS11c2Ugd2hhdCdzIGxlZnQgb2YgdGhlIHByZXZpb3VzIGNodW5rXG4gICAgaWYgKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgaWYoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNEYXRhID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShwcmV2aW91c0RhdGEubGVuZ3RoICsgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpO1xuICAgICAgICAgICAgZGF0YS5zZXQodGhpcy5sZWZ0T3ZlciwgMCk7XG4gICAgICAgICAgICBkYXRhLnNldChwcmV2aW91c0RhdGEsIHRoaXMubGVmdE92ZXIubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxlZnRPdmVyLmNvbmNhdChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEJvdW5kYXJ5ID0gdXRmOGJvcmRlcihkYXRhKTtcbiAgICB2YXIgdXNhYmxlRGF0YSA9IGRhdGE7XG4gICAgaWYgKG5leHRCb3VuZGFyeSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc3ViYXJyYXkoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnN1YmFycmF5KG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc2xpY2UoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnNsaWNlKG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGRlY29kZSh1c2FibGVEYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblV0ZjhEZWNvZGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhkZWNvZGUodGhpcy5sZWZ0T3ZlciksXG4gICAgICAgICAgICBtZXRhIDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xuICAgIH1cbn07XG5leHBvcnRzLlV0ZjhEZWNvZGVXb3JrZXIgPSBVdGY4RGVjb2RlV29ya2VyO1xuXG4vKipcbiAqIEEgd29ya2VyIHRvIGVuZGNvZGUgc3RyaW5nIGNodW5rcyBpbnRvIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFV0ZjhFbmNvZGVXb3JrZXIoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwidXRmLTggZW5jb2RlXCIpO1xufVxudXRpbHMuaW5oZXJpdHMoVXRmOEVuY29kZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5VdGY4RW5jb2RlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZW5jb2RlKGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbmV4cG9ydHMuVXRmOEVuY29kZVdvcmtlciA9IFV0ZjhFbmNvZGVXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoJy4vbm9kZWpzVXRpbHMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdzZXQtaW1tZWRpYXRlLXNoaW0nKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpO1xuXG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0aGF0IHBhc3MgYXMgYSBcImJpbmFyeSBzdHJpbmdcIjogaXQgc2hvdWxkIHJlcHJlc2VudCBhIGJ5dGVcbiAqIGFycmF5IGJ1dCBtYXkgaGF2ZSA+IDI1NSBjaGFyIGNvZGVzLiBCZSBzdXJlIHRvIHRha2Ugb25seSB0aGUgZmlyc3QgYnl0ZVxuICogYW5kIHJldHVybnMgdGhlIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7QXJyYXl8VWludDhBcnJheX0gdGhlIHN0cmluZyBpbiBhIGJpbmFyeSBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZzJiaW5hcnkoc3RyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShzdHIubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKHN0ciwgcmVzdWx0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYmxvYiB3aXRoIHRoZSBnaXZlbiBjb250ZW50IGFuZCB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfSBwYXJ0IHRoZSBjb250ZW50IHRvIHB1dCBpbiB0aGUgYmxvYi4gRE8gTk9UIHVzZVxuICogYW4gVWludDhBcnJheSBiZWNhdXNlIHRoZSBzdG9jayBicm93c2VyIG9mIGFuZHJvaWQgNCB3b24ndCBhY2NlcHQgaXQgKGl0XG4gKiB3aWxsIGJlIHNpbGVudGx5IGNvbnZlcnRlZCB0byBhIHN0cmluZywgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIpLlxuICpcbiAqIFVzZSBvbmx5IE9ORSBwYXJ0IHRvIGJ1aWxkIHRoZSBibG9iIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgaW4gSUUxMSAvIEVkZ2U6XG4gKiB3aGVuIGEgbGFyZ2UgYW1vdW50IG9mIEFycmF5IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBCbG9iLCB0aGUgYW1vdW50IG9mXG4gKiBtZW1vcnkgY29uc3VtZWQgaXMgbmVhcmx5IDEwMCB0aW1lcyB0aGUgb3JpZ2luYWwgZGF0YSBhbW91bnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgYmxvYi5cbiAqIEByZXR1cm4ge0Jsb2J9IHRoZSBjcmVhdGVkIGJsb2IuXG4gKi9cbmV4cG9ydHMubmV3QmxvYiA9IGZ1bmN0aW9uKHBhcnQsIHR5cGUpIHtcbiAgICBleHBvcnRzLmNoZWNrU3VwcG9ydChcImJsb2JcIik7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBCbG9iIGNvbnN0cnVjdG9yXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbcGFydF0sIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQsIGJyb3dzZXIgb25seSwgb2xkIHdheVxuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChwYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmdldEJsb2IodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLy8gd2VsbCwgZnVjayA/IVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIDogY2FuJ3QgY29uc3RydWN0IHRoZSBCbG9iLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2FtZSBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogRmlsbCBpbiBhbiBhcnJheSB3aXRoIGEgc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byBmaWxsIGluICh3aWxsIGJlIG11dGF0ZWQpLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyYXlbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkY7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBbiBoZWxwZXIgZm9yIHRoZSBmdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZy5cbiAqIFRoaXMgY29udGFpbnMgc3RhdGljIGluZm9ybWF0aW9uIGFuZCBmdW5jdGlvbnMgdGhhdFxuICogY2FuIGJlIG9wdGltaXplZCBieSB0aGUgYnJvd3NlciBKSVQgY29tcGlsZXIuXG4gKi9cbnZhciBhcnJheVRvU3RyaW5nSGVscGVyID0ge1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBpbnQgaW50byBhIHN0cmluZywgY2h1bmsgYnkgY2h1bmsuXG4gICAgICogU2VlIHRoZSBwZXJmb3JtYW5jZXMgbm90ZXMgb24gYXJyYXlMaWtlVG9TdHJpbmcuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIHRyYW5zZm9ybS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBjaHVuayB0aGUgY2h1bmsgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGNodW5rIGlzIHRvbyBiaWcgZm9yIHRoZSBzdGFjay5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlCeUNodW5rOiBmdW5jdGlvbihhcnJheSwgdHlwZSwgY2h1bmspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBrID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAvLyBzaG9ydGN1dFxuICAgICAgICBpZiAobGVuIDw9IGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFycmF5XCIgfHwgdHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5LnNsaWNlKGssIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkuc3ViYXJyYXkoaywgTWF0aC5taW4oayArIGNodW5rLCBsZW4pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayArPSBjaHVuaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDYWxsIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gZXZlcnkgaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICogVGhpcyBpcyB0aGUgbmFpdmUgaW1wbGVtZW50YXRpb24sIHdoaWNoIGdlbmVyYXRlIEEgTE9UIG9mIGludGVybWVkaWF0ZSBzdHJpbmcuXG4gICAgICogVGhpcyBzaG91bGQgYmUgdXNlZCB3aGVuIGV2ZXJ5dGhpbmcgZWxzZSBmYWlsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIHN0cmluZ2lmeUJ5Q2hhcjogZnVuY3Rpb24oYXJyYXkpe1xuICAgICAgICB2YXIgcmVzdWx0U3RyID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFN0cjtcbiAgICB9LFxuICAgIGFwcGx5Q2FuQmVVc2VkIDoge1xuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBpZiB0aGUgYnJvd3NlciBhY2NlcHRzIHRvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIFVpbnQ4QXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHVpbnQ4YXJyYXkgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC51aW50OGFycmF5ICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGlmIHRoZSBicm93c2VyIGFjY2VwdHMgdG8gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gbm9kZWpzIEJ1ZmZlci5cbiAgICAgICAgICovXG4gICAgICAgIG5vZGVidWZmZXIgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC5ub2RlYnVmZmVyICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICB9XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheS1saWtlIG9iamVjdCB0byBhIHN0cmluZy5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvU3RyaW5nKGFycmF5KSB7XG4gICAgLy8gUGVyZm9ybWFuY2VzIG5vdGVzIDpcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpIGlzIHRoZSBmYXN0ZXN0LCBzZWVcbiAgICAvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vY29udmVydGluZy1hLXVpbnQ4YXJyYXktdG8tYS1zdHJpbmcvMlxuICAgIC8vIGJ1dCB0aGUgc3RhY2sgaXMgbGltaXRlZCAoYW5kIHdlIGNhbiBnZXQgaHVnZSBhcnJheXMgISkuXG4gICAgLy9cbiAgICAvLyByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7IGdlbmVyYXRlIHRvbyBtYW55IHN0cmluZ3MgIVxuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGlzIGluc3BpcmVkIGJ5IGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5YnVmZmVyLXRvLXN0cmluZy1hcHBseS1wZXJmb3JtYW5jZS8yXG4gICAgLy8gVE9ETyA6IHdlIG5vdyBoYXZlIHdvcmtlcnMgdGhhdCBzcGxpdCB0aGUgd29yay4gRG8gd2Ugc3RpbGwgbmVlZCB0aGF0ID9cbiAgICB2YXIgY2h1bmsgPSA2NTUzNixcbiAgICAgICAgdHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGFycmF5KSxcbiAgICAgICAgY2FuVXNlQXBwbHkgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSBcInVpbnQ4YXJyYXlcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQudWludDhhcnJheTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIGNhblVzZUFwcGx5ID0gYXJyYXlUb1N0cmluZ0hlbHBlci5hcHBseUNhbkJlVXNlZC5ub2RlYnVmZmVyO1xuICAgIH1cblxuICAgIGlmIChjYW5Vc2VBcHBseSkge1xuICAgICAgICB3aGlsZSAoY2h1bmsgPiAxKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVRvU3RyaW5nSGVscGVyLnN0cmluZ2lmeUJ5Q2h1bmsoYXJyYXksIHR5cGUsIGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IE1hdGguZmxvb3IoY2h1bmsgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vIGFwcGx5IG9yIGNodW5rIGVycm9yIDogc2xvdyBhbmQgcGFpbmZ1bCBhbGdvcml0aG1cbiAgICAvLyBkZWZhdWx0IGJyb3dzZXIgb24gYW5kcm9pZCA0LipcbiAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNoYXIoYXJyYXkpO1xufVxuXG5leHBvcnRzLmFwcGx5RnJvbUNoYXJDb2RlID0gYXJyYXlMaWtlVG9TdHJpbmc7XG5cblxuLyoqXG4gKiBDb3B5IHRoZSBkYXRhIGZyb20gYW4gYXJyYXktbGlrZSB0byBhbiBvdGhlciBhcnJheS1saWtlLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlGcm9tIHRoZSBvcmlnaW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheVRvIHRoZSBkZXN0aW5hdGlvbiBhcnJheSB3aGljaCB3aWxsIGJlIG11dGF0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIHVwZGF0ZWQgZGVzdGluYXRpb24gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvQXJyYXlMaWtlKGFycmF5RnJvbSwgYXJyYXlUbykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5VG9baV0gPSBhcnJheUZyb21baV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheVRvO1xufVxuXG4vLyBhIG1hdHJpeCBjb250YWluaW5nIGZ1bmN0aW9ucyB0byB0cmFuc2Zvcm0gZXZlcnl0aGluZyBpbnRvIGV2ZXJ5dGhpbmcuXG52YXIgdHJhbnNmb3JtID0ge307XG5cbi8vIHN0cmluZyB0byA/XG50cmFuc2Zvcm1bXCJzdHJpbmdcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcInN0cmluZ1wiXVtcInVpbnQ4YXJyYXlcIl0oaW5wdXQpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoaW5wdXQubGVuZ3RoKSk7XG4gICAgfVxufTtcblxuLy8gYXJyYXkgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBpZGVudGl0eSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAobmV3IFVpbnQ4QXJyYXkoaW5wdXQpKS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gYXJyYXlidWZmZXIgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvU3RyaW5nKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfSxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShuZXcgVWludDhBcnJheShpbnB1dCksIG5ldyBBcnJheShpbnB1dC5ieXRlTGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGlkZW50aXR5LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfVxufTtcblxuLy8gdWludDhhcnJheSB0byA/XG50cmFuc2Zvcm1bXCJ1aW50OGFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKGlucHV0KTtcbiAgICB9XG59O1xuXG4vLyBub2RlYnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl1bXCJ1aW50OGFycmF5XCJdKGlucHV0KS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBpZGVudGl0eVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gaW5wdXQgaW50byBhbnkgdHlwZS5cbiAqIFRoZSBzdXBwb3J0ZWQgb3V0cHV0IHR5cGUgYXJlIDogc3RyaW5nLCBhcnJheSwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIG5vZGVidWZmZXIuXG4gKiBJZiBubyBvdXRwdXQgdHlwZSBpcyBzcGVjaWZpZWQsIHRoZSB1bm1vZGlmaWVkIGlucHV0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3V0cHV0VHlwZSB0aGUgb3V0cHV0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gaW5wdXQgdGhlIGlucHV0IHRvIGNvbnZlcnQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgb3V0cHV0IHR5cGUuXG4gKi9cbmV4cG9ydHMudHJhbnNmb3JtVG8gPSBmdW5jdGlvbihvdXRwdXRUeXBlLCBpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkLCBudWxsLCBldGNcbiAgICAgICAgLy8gYW4gZW1wdHkgc3RyaW5nIHdvbid0IGhhcm0uXG4gICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKCFvdXRwdXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgZXhwb3J0cy5jaGVja1N1cHBvcnQob3V0cHV0VHlwZSk7XG4gICAgdmFyIGlucHV0VHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGlucHV0KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtW2lucHV0VHlwZV1bb3V0cHV0VHlwZV0oaW5wdXQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKiBUaGUgdHlwZSB3aWxsIGJlIGluIGEgZm9ybWF0IHZhbGlkIGZvciBKU1ppcC51dGlscy50cmFuc2Zvcm1UbyA6IHN0cmluZywgYXJyYXksIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IHRoZSBpbnB1dCB0byBpZGVudGlmeS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIChsb3dlcmNhc2UpIHR5cGUgb2YgdGhlIGlucHV0LlxuICovXG5leHBvcnRzLmdldFR5cGVPZiA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyICYmIG5vZGVqc1V0aWxzLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gXCJub2RlYnVmZmVyXCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkgJiYgaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBcInVpbnQ4YXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQuYXJyYXlidWZmZXIgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gXCJhcnJheWJ1ZmZlclwiO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSB0byBjaGVjay5cbiAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCB0eXBlLlxuICovXG5leHBvcnRzLmNoZWNrU3VwcG9ydCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2YXIgc3VwcG9ydGVkID0gc3VwcG9ydFt0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHBsYXRmb3JtXCIpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuTUFYX1ZBTFVFXzE2QklUUyA9IDY1NTM1O1xuZXhwb3J0cy5NQVhfVkFMVUVfMzJCSVRTID0gLTE7IC8vIHdlbGwsIFwiXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlwiIGlzIHBhcnNlZCBhcyAtMVxuXG4vKipcbiAqIFByZXR0aWZ5IGEgc3RyaW5nIHJlYWQgYXMgYmluYXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHByZXR0aWZ5LlxuICogQHJldHVybiB7c3RyaW5nfSBhIHByZXR0eSBzdHJpbmcuXG4gKi9cbmV4cG9ydHMucHJldHR5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIHJlcyA9ICcnLFxuICAgICAgICBjb2RlLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCAoc3RyIHx8IFwiXCIpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgcmVzICs9ICdcXFxceCcgKyAoY29kZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIGNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIERlZmVyIHRoZSBjYWxsIG9mIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gY2FsbCBhc3luY2hyb25vdXNseS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgdGhlIGFyZ3VtZW50cyB0byBnaXZlIHRvIHRoZSBjYWxsYmFjay5cbiAqL1xuZXhwb3J0cy5kZWxheSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBhcmdzLCBzZWxmKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiB8fCBudWxsLCBhcmdzIHx8IFtdKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRXh0ZW5kcyBhIHByb3RvdHlwZSB3aXRoIGFuIG90aGVyLCB3aXRob3V0IGNhbGxpbmcgYSBjb25zdHJ1Y3RvciB3aXRoXG4gKiBzaWRlIGVmZmVjdHMuIEluc3BpcmVkIGJ5IG5vZGVqcycgYHV0aWxzLmluaGVyaXRzYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3RvciB0aGUgY29uc3RydWN0b3IgdG8gYXVnbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDdG9yIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgdG8gdXNlXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbiAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgdmFyIE9iaiA9IGZ1bmN0aW9uKCkge307XG4gICAgT2JqLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgT2JqKCk7XG59O1xuXG4vKipcbiAqIE1lcmdlIHRoZSBvYmplY3RzIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIGludG8gYSBuZXcgb25lLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBBbGwgb2JqZWN0cyB0byBtZXJnZS5cbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHdpdGggdGhlIGRhdGEgb2YgdGhlIG90aGVycy5cbiAqL1xuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIGksIGF0dHI7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyAvLyBhcmd1bWVudHMgaXMgbm90IGVudW1lcmFibGUgaW4gc29tZSBicm93c2Vyc1xuICAgICAgICBmb3IgKGF0dHIgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldLmhhc093blByb3BlcnR5KGF0dHIpICYmIHR5cGVvZiByZXN1bHRbYXR0cl0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbYXR0cl0gPSBhcmd1bWVudHNbaV1bYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFyYml0cmFyeSBjb250ZW50IGludG8gYSBQcm9taXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgYSBuYW1lIGZvciB0aGUgY29udGVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhIHRoZSBjb250ZW50IHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IHRydWUgaWYgdGhlIGNvbnRlbnQgaXMgbm90IGFuIHVuaWNvZGUgc3RyaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nIHRydWUgaWYgdGhlIHN0cmluZyBjb250ZW50IG9ubHkgaGFzIG9uZSBieXRlIHBlciBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmFzZTY0IHRydWUgaWYgdGhlIHN0cmluZyBjb250ZW50IGlzIGVuY29kZWQgd2l0aCBiYXNlNjQuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgaW4gYSBmb3JtYXQgdXNhYmxlIGJ5IEpTWmlwLlxuICovXG5leHBvcnRzLnByZXBhcmVDb250ZW50ID0gZnVuY3Rpb24obmFtZSwgaW5wdXREYXRhLCBpc0JpbmFyeSwgaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIGlzQmFzZTY0KSB7XG5cbiAgICAvLyBpZiBpbnB1dERhdGEgaXMgYWxyZWFkeSBhIHByb21pc2UsIHRoaXMgZmxhdHRlbiBpdC5cbiAgICB2YXIgcHJvbWlzZSA9IGV4dGVybmFsLlByb21pc2UucmVzb2x2ZShpbnB1dERhdGEpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHZhciBpc0Jsb2IgPSBzdXBwb3J0LmJsb2IgJiYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iIHx8IFsnW29iamVjdCBGaWxlXScsICdbb2JqZWN0IEJsb2JdJ10uaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpICE9PSAtMSk7XG5cbiAgICAgICAgaWYgKGlzQmxvYiAmJiB0eXBlb2YgRmlsZVJlYWRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZS50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBkYXRhVHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGRhdGEpO1xuXG4gICAgICAgIGlmICghZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJDYW4ndCByZWFkIHRoZSBkYXRhIG9mICdcIiArIG5hbWUgKyBcIicuIElzIGl0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbiBhIHN1cHBvcnRlZCBKYXZhU2NyaXB0IHR5cGUgKFN0cmluZywgQmxvYiwgQXJyYXlCdWZmZXIsIGV0YykgP1wiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgOiBpdCdzIHdheSBlYXNpZXIgdG8gd29yayB3aXRoIFVpbnQ4QXJyYXkgdGhhbiB3aXRoIEFycmF5QnVmZmVyXG4gICAgICAgIGlmIChkYXRhVHlwZSA9PT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICBkYXRhID0gZXhwb3J0cy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0Jhc2U2NCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBiYXNlNjQuZGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWRCaW5hcnlTdHJpbmcgPT09IHRydWUgbWVhbnMgdGhhdCB0aGUgZmlsZSBoYXMgYWxyZWFkeSBiZWVuIGZpbHRlcmVkIHdpdGggYSAweEZGIG1hc2tcbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHN0cmluZywgbm90IGluIGEgYmFzZTY0IGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmUgc3VyZSB0aGF0IHRoaXMgaXMgYSBjb3JyZWN0IFwiYmluYXJ5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzdHJpbmcyYmluYXJ5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVhZGVyRm9yID0gcmVxdWlyZSgnLi9yZWFkZXIvcmVhZGVyRm9yJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgc2lnID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcbnZhciBaaXBFbnRyeSA9IHJlcXVpcmUoJy4vemlwRW50cnknKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuLy8gIGNsYXNzIFppcEVudHJpZXMge3t7XG4vKipcbiAqIEFsbCB0aGUgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJpZXMobG9hZE9wdGlvbnMpIHtcbiAgICB0aGlzLmZpbGVzID0gW107XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cmllcy5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgcmVhZGVyIGlzIG9uIHRoZSBzcGVjaWZpZWQgc2lnbmF0dXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFNpZ25hdHVyZSB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBpcyBhbiBvdGhlciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgY2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlKGV4cGVjdGVkU2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIuaW5kZXggLT0gNDtcbiAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCBvciBidWc6IHVuZXhwZWN0ZWQgc2lnbmF0dXJlIFwiICsgXCIoXCIgKyB1dGlscy5wcmV0dHkoc2lnbmF0dXJlKSArIFwiLCBleHBlY3RlZCBcIiArIHV0aWxzLnByZXR0eShleHBlY3RlZFNpZ25hdHVyZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBzaWduYXR1cmUgaXMgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhc2tlZEluZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIHNpZ25hdHVyZSB0byBleHBlY3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIGhlcmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1NpZ25hdHVyZTogZnVuY3Rpb24oYXNrZWRJbmRleCwgZXhwZWN0ZWRTaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMucmVhZGVyLmluZGV4O1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChhc2tlZEluZGV4KTtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoNCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBzaWduYXR1cmUgPT09IGV4cGVjdGVkU2lnbmF0dXJlO1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChjdXJyZW50SW5kZXgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQmxvY2tFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpck9mZnNldCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgdGhpcy56aXBDb21tZW50TGVuZ3RoID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgLy8gd2FybmluZyA6IHRoZSBlbmNvZGluZyBkZXBlbmRzIG9mIHRoZSBzeXN0ZW0gbG9jYWxlXG4gICAgICAgIC8vIE9uIGEgbGludXggbWFjaGluZSB3aXRoIExBTkc9ZW5fVVMudXRmOCwgdGhpcyBmaWVsZCBpcyB1dGY4IGVuY29kZWQuXG4gICAgICAgIC8vIE9uIGEgd2luZG93cyBtYWNoaW5lLCB0aGlzIGZpZWxkIGlzIGVuY29kZWQgd2l0aCB0aGUgbG9jYWxpemVkIHdpbmRvd3MgY29kZSBwYWdlLlxuICAgICAgICB2YXIgemlwQ29tbWVudCA9IHRoaXMucmVhZGVyLnJlYWREYXRhKHRoaXMuemlwQ29tbWVudExlbmd0aCk7XG4gICAgICAgIHZhciBkZWNvZGVQYXJhbVR5cGUgPSBzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcbiAgICAgICAgLy8gVG8gZ2V0IGNvbnNpc3RlbnQgYmVoYXZpb3Igd2l0aCB0aGUgZ2VuZXJhdGlvbiBwYXJ0LCB3ZSB3aWxsIGFzc3VtZSB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgdXRmOCBlbmNvZGVkIHVubGVzcyBzcGVjaWZpZWQgb3RoZXJ3aXNlLlxuICAgICAgICB2YXIgZGVjb2RlQ29udGVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgemlwQ29tbWVudCk7XG4gICAgICAgIHRoaXMuemlwQ29tbWVudCA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZGVjb2RlQ29udGVudCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKiBOb3QgbWVyZ2VkIHdpdGggdGhlIG1ldGhvZCByZWFkRW5kT2ZDZW50cmFsIDpcbiAgICAgKiBUaGUgZW5kIG9mIGNlbnRyYWwgY2FuIGNvZXhpc3Qgd2l0aCBpdHMgWmlwNjQgYnJvdGhlcixcbiAgICAgKiBJIGRvbid0IHdhbnQgdG8gcmVhZCB0aGUgd3JvbmcgbnVtYmVyIG9mIGJ5dGVzICFcbiAgICAgKi9cbiAgICByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2tpcCg0KTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTWFkZUJ5ID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTmVlZGVkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuXG4gICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YSA9IHt9O1xuICAgICAgICB2YXIgZXh0cmFEYXRhU2l6ZSA9IHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplIC0gNDQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBleHRyYURhdGFTaXplKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSB0aGlzLnJlYWRlci5yZWFkRGF0YShleHRyYUZpZWxkTGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YVtleHRyYUZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRyYUZpZWxkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgWmlwIDY0IGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3IuXG4gICAgICovXG4gICAgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNrV2l0aFppcDY0Q2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5kaXNrc0NvdW50ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgaWYgKHRoaXMuZGlza3NDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpLXZvbHVtZXMgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBmaWxlcywgYmFzZWQgb24gdGhlIG9mZnNldCByZWFkIGluIHRoZSBjZW50cmFsIHBhcnQuXG4gICAgICovXG4gICAgcmVhZExvY2FsRmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZmlsZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmZpbGVzW2ldO1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoZmlsZS5sb2NhbEhlYWRlck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG4gICAgICAgICAgICBmaWxlLnJlYWRMb2NhbFBhcnQodGhpcy5yZWFkZXIpO1xuICAgICAgICAgICAgZmlsZS5oYW5kbGVVVEY4KCk7XG4gICAgICAgICAgICBmaWxlLnByb2Nlc3NBdHRyaWJ1dGVzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRDZW50cmFsRGlyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpbGU7XG5cbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5jZW50cmFsRGlyT2Zmc2V0KTtcbiAgICAgICAgd2hpbGUgKHRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgIGZpbGUgPSBuZXcgWmlwRW50cnkoe1xuICAgICAgICAgICAgICAgIHppcDY0OiB0aGlzLnppcDY0XG4gICAgICAgICAgICB9LCB0aGlzLmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgIGZpbGUucmVhZENlbnRyYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSB0aGlzLmZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2VudHJhbERpclJlY29yZHMgIT09IDAgJiYgdGhpcy5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBleHBlY3RlZCBzb21lIHJlY29yZHMgYnV0IGNvdWxkbid0IGZpbmQgQU5ZLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVhbGx5IHN1c3BpY2lvdXMsIGFzIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiBleHBlY3RlZCBcIiArIHRoaXMuY2VudHJhbERpclJlY29yZHMgKyBcIiByZWNvcmRzIGluIGNlbnRyYWwgZGlyLCBnb3QgXCIgKyB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIHNvbWUgcmVjb3JkcyBidXQgbm90IGFsbC5cbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmcgYnV0IHdlIGdvdCBzb21ldGhpbmcgZm9yIHRoZSB1c2VyOiBubyBlcnJvciBoZXJlLlxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcImV4cGVjdGVkXCIsIHRoaXMuY2VudHJhbERpclJlY29yZHMsIFwicmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290XCIsIHRoaXMuZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudCBpcyBhIHRydW5jYXRlZCB6aXAgb3IgY29tcGxldGUgZ2FyYmFnZS5cbiAgICAgICAgICAgIC8vIEEgXCJMT0NBTF9GSUxFX0hFQURFUlwiIGlzIG5vdCByZXF1aXJlZCBhdCB0aGUgYmVnaW5uaW5nIChhdXRvXG4gICAgICAgICAgICAvLyBleHRyYWN0aWJsZSB6aXAgZm9yIGV4YW1wbGUpIGJ1dCBpdCBjYW4gZ2l2ZSBhIGdvb2QgaGludC5cbiAgICAgICAgICAgIC8vIElmIGFuIGFqYXggcmVxdWVzdCB3YXMgdXNlZCB3aXRob3V0IHJlc3BvbnNlVHlwZSwgd2Ugd2lsbCBhbHNvXG4gICAgICAgICAgICAvLyBnZXQgdW5yZWFkYWJsZSBkYXRhLlxuICAgICAgICAgICAgdmFyIGlzR2FyYmFnZSA9ICF0aGlzLmlzU2lnbmF0dXJlKDAsIHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG5cbiAgICAgICAgICAgIGlmIChpc0dhcmJhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSA6IGlzIHRoaXMgYSB6aXAgZmlsZSA/IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJZiBpdCBpcywgc2VlIGh0dHBzOi8vc3R1ay5naXRodWIuaW8vanN6aXAvZG9jdW1lbnRhdGlvbi9ob3d0by9yZWFkX3ppcC5odG1sXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KG9mZnNldCk7XG4gICAgICAgIHZhciBlbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIHRoaXMucmVhZEJsb2NrRW5kT2ZDZW50cmFsKCk7XG5cblxuICAgICAgICAvKiBleHRyYWN0IGZyb20gdGhlIHppcCBzcGVjIDpcbiAgICAgICAgICAgIDQpICBJZiBvbmUgb2YgdGhlIGZpZWxkcyBpbiB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgcmVjb3JkIGlzIHRvbyBzbWFsbCB0byBob2xkIHJlcXVpcmVkIGRhdGEsIHRoZSBmaWVsZFxuICAgICAgICAgICAgICAgIHNob3VsZCBiZSBzZXQgdG8gLTEgKDB4RkZGRiBvciAweEZGRkZGRkZGKSBhbmQgdGhlXG4gICAgICAgICAgICAgICAgWklQNjQgZm9ybWF0IHJlY29yZCBzaG91bGQgYmUgY3JlYXRlZC5cbiAgICAgICAgICAgIDUpICBUaGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgWmlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3IgcmVjb3JkIG11c3RcbiAgICAgICAgICAgICAgICByZXNpZGUgb24gdGhlIHNhbWUgZGlzayB3aGVuIHNwbGl0dGluZyBvciBzcGFubmluZ1xuICAgICAgICAgICAgICAgIGFuIGFyY2hpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5kaXNrTnVtYmVyID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTIHx8IHRoaXMuY2VudHJhbERpck9mZnNldCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy56aXA2NCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBXYXJuaW5nIDogdGhlIHppcDY0IGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWQsIGJ1dCBPTkxZIGlmIHRoZSA2NGJpdHMgaW50ZWdlciByZWFkIGZyb21cbiAgICAgICAgICAgIHRoZSB6aXAgZmlsZSBjYW4gZml0IGludG8gYSAzMmJpdHMgaW50ZWdlci4gVGhpcyBjYW5ub3QgYmUgc29sdmVkIDogSmF2YVNjcmlwdCByZXByZXNlbnRzXG4gICAgICAgICAgICBhbGwgbnVtYmVycyBhcyA2NC1iaXQgZG91YmxlIHByZWNpc2lvbiBJRUVFIDc1NCBmbG9hdGluZyBwb2ludCBudW1iZXJzLlxuICAgICAgICAgICAgU28sIHdlIGhhdmUgNTNiaXRzIGZvciBpbnRlZ2VycyBhbmQgYml0d2lzZSBvcGVyYXRpb25zIHRyZWF0IGV2ZXJ5dGhpbmcgYXMgMzJiaXRzLlxuICAgICAgICAgICAgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3JzXG4gICAgICAgICAgICBhbmQgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VDTUEtMjYyLnBkZiBzZWN0aW9uIDguNVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy8gc2hvdWxkIGxvb2sgZm9yIGEgemlwNjQgRU9DRCBsb2NhdG9yXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUik7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IGNhbid0IGZpbmQgdGhlIFpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgob2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3IoKTtcblxuICAgICAgICAgICAgLy8gbm93IHRoZSB6aXA2NCBFT0NEIHJlY29yZFxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2lnbmF0dXJlKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciwgc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgbm90IHdoZXJlIGV4cGVjdGVkLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgKyB0aGlzLmNlbnRyYWxEaXJTaXplO1xuICAgICAgICBpZiAodGhpcy56aXA2NCkge1xuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMjA7IC8vIGVuZCBvZiBjZW50cmFsIGRpciA2NCBsb2NhdG9yXG4gICAgICAgICAgICBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCArPSAxMiAvKiBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGxlYWRpbmcgMTIgYnl0ZXMgKi8gKyB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHRyYUJ5dGVzID0gZW5kT2ZDZW50cmFsRGlyT2Zmc2V0IC0gZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oZXh0cmFCeXRlcywgXCJleHRyYSBieXRlcyBhdCBiZWdpbm5pbmcgb3Igd2l0aGluIHppcGZpbGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NpZ25hdHVyZShlbmRPZkNlbnRyYWxEaXJPZmZzZXQsIHNpZy5DRU5UUkFMX0ZJTEVfSEVBREVSKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvZmZzZXRzIHNlZW0gd3JvbmcsIGJ1dCB3ZSBoYXZlIHNvbWV0aGluZyBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldC5cbiAgICAgICAgICAgICAgICAvLyBTb+KApiB3ZSBrZWVwIGl0LlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2Zmc2V0IGlzIHdyb25nLCB1cGRhdGUgdGhlIFwiemVyb1wiIG9mIHRoZSByZWFkZXJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaWYgZGF0YSBoYXMgYmVlbiBwcmVwZW5kZWQgKGNyeCBmaWxlcyBmb3IgZXhhbXBsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci56ZXJvID0gZXh0cmFCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogbWlzc2luZyBcIiArIE1hdGguYWJzKGV4dHJhQnl0ZXMpICsgXCIgYnl0ZXMuXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmVwYXJlUmVhZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyRm9yKGRhdGEpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCBhIHppcCBmaWxlIGFuZCBjcmVhdGUgWmlwRW50cmllcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgYmluYXJ5IHN0cmluZyByZXByZXNlbnRpbmcgYSB6aXAgZmlsZS5cbiAgICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZVJlYWRlcihkYXRhKTtcbiAgICAgICAgdGhpcy5yZWFkRW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIHRoaXMucmVhZENlbnRyYWxEaXIoKTtcbiAgICAgICAgdGhpcy5yZWFkTG9jYWxGaWxlcygpO1xuICAgIH1cbn07XG4vLyB9fX0gZW5kIG9mIFppcEVudHJpZXNcbm1vZHVsZS5leHBvcnRzID0gWmlwRW50cmllcztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWFkZXJGb3IgPSByZXF1aXJlKCcuL3JlYWRlci9yZWFkZXJGb3InKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21wcmVzc2VkT2JqZWN0Jyk7XG52YXIgY3JjMzJmbiA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgY29tcHJlc3Npb25zID0gcmVxdWlyZSgnLi9jb21wcmVzc2lvbnMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG5cbnZhciBNQURFX0JZX0RPUyA9IDB4MDA7XG52YXIgTUFERV9CWV9VTklYID0gMHgwMztcblxuLyoqXG4gKiBGaW5kIGEgY29tcHJlc3Npb24gcmVnaXN0ZXJlZCBpbiBKU1ppcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wcmVzc2lvbk1ldGhvZCB0aGUgbWV0aG9kIG1hZ2ljIHRvIGZpbmQuXG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gdGhlIEpTWmlwIGNvbXByZXNzaW9uIG9iamVjdCwgbnVsbCBpZiBub25lIGZvdW5kLlxuICovXG52YXIgZmluZENvbXByZXNzaW9uID0gZnVuY3Rpb24oY29tcHJlc3Npb25NZXRob2QpIHtcbiAgICBmb3IgKHZhciBtZXRob2QgaW4gY29tcHJlc3Npb25zKSB7XG4gICAgICAgIGlmICghY29tcHJlc3Npb25zLmhhc093blByb3BlcnR5KG1ldGhvZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc2lvbnNbbWV0aG9kXS5tYWdpYyA9PT0gY29tcHJlc3Npb25NZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2lvbnNbbWV0aG9kXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIGNsYXNzIFppcEVudHJ5IHt7e1xuLyoqXG4gKiBBbiBlbnRyeSBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2YgdGhlIGN1cnJlbnQgZmlsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJ5KG9wdGlvbnMsIGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvYWRPcHRpb25zID0gbG9hZE9wdGlvbnM7XG59XG5aaXBFbnRyeS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzRW5jcnlwdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDEgaXMgc2V0XG4gICAgICAgIHJldHVybiAodGhpcy5iaXRGbGFnICYgMHgwMDAxKSA9PT0gMHgwMDAxO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGhhcyB1dGYtOCBmaWxlbmFtZS9jb21tZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGZpbGVuYW1lL2NvbW1lbnQgaXMgaW4gdXRmLTgsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB1c2VVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDExIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDgwMCkgPT09IDB4MDgwMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGxvY2FsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRMb2NhbFBhcnQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB2YXIgY29tcHJlc3Npb24sIGxvY2FsRXh0cmFGaWVsZHNMZW5ndGg7XG5cbiAgICAgICAgLy8gd2UgYWxyZWFkeSBrbm93IGV2ZXJ5dGhpbmcgZnJvbSB0aGUgY2VudHJhbCBkaXIgIVxuICAgICAgICAvLyBJZiB0aGUgY2VudHJhbCBkaXIgZGF0YSBhcmUgZmFsc2UsIHdlIGFyZSBkb29tZWQuXG4gICAgICAgIC8vIE9uIHRoZSBicmlnaHQgc2lkZSwgdGhlIGxvY2FsIHBhcnQgaXMgc2NhcnkgIDogemlwNjQsIGRhdGEgZGVzY3JpcHRvcnMsIGJvdGgsIGV0Yy5cbiAgICAgICAgLy8gVGhlIGxlc3MgZGF0YSB3ZSBnZXQgaGVyZSwgdGhlIG1vcmUgcmVsaWFibGUgdGhpcyBzaG91bGQgYmUuXG4gICAgICAgIC8vIExldCdzIHNraXAgdGhlIHdob2xlIGhlYWRlciBhbmQgZGFzaCB0byB0aGUgZGF0YSAhXG4gICAgICAgIHJlYWRlci5za2lwKDIyKTtcbiAgICAgICAgLy8gaW4gc29tZSB6aXAgY3JlYXRlZCBvbiB3aW5kb3dzLCB0aGUgZmlsZW5hbWUgc3RvcmVkIGluIHRoZSBjZW50cmFsIGRpciBjb250YWlucyBcXCBpbnN0ZWFkIG9mIC8uXG4gICAgICAgIC8vIFN0cmFuZ2VseSwgdGhlIGZpbGVuYW1lIGhlcmUgaXMgT0suXG4gICAgICAgIC8vIEkgd291bGQgbG92ZSB0byB0cmVhdCB0aGVzZSB6aXAgZmlsZXMgYXMgY29ycnVwdGVkIChzZWUgaHR0cDovL3d3dy5pbmZvLXppcC5vcmcvRkFRLmh0bWwjYmFja3NsYXNoZXNcbiAgICAgICAgLy8gb3IgQVBQTk9URSM0LjQuMTcuMSwgXCJBbGwgc2xhc2hlcyBNVVNUIGJlIGZvcndhcmQgc2xhc2hlcyAnLydcIikgYnV0IHRoZXJlIGFyZSBhIGxvdCBvZiBiYWQgemlwIGdlbmVyYXRvcnMuLi5cbiAgICAgICAgLy8gU2VhcmNoIFwidW56aXAgbWlzbWF0Y2hpbmcgXCJsb2NhbFwiIGZpbGVuYW1lIGNvbnRpbnVpbmcgd2l0aCBcImNlbnRyYWxcIiBmaWxlbmFtZSB2ZXJzaW9uXCIgb25cbiAgICAgICAgLy8gdGhlIGludGVybmV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJIHRoaW5rIEkgc2VlIHRoZSBsb2dpYyBoZXJlIDogdGhlIGNlbnRyYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZGlzcGxheVxuICAgICAgICAvLyBjb250ZW50IGFuZCB0aGUgbG9jYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZXh0cmFjdCB0aGUgZmlsZXMuIE1peGluZyAvIGFuZCBcXFxuICAgICAgICAvLyBtYXkgYmUgdXNlZCB0byBkaXNwbGF5IFxcIHRvIHdpbmRvd3MgdXNlcnMgYW5kIHVzZSAvIHdoZW4gZXh0cmFjdGluZyB0aGUgZmlsZXMuXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoaXMgbGVhZCBhbHNvIHRvIHNvbWUgaXNzdWVzIDogaHR0cDovL3NlY2xpc3RzLm9yZy9mdWxsZGlzY2xvc3VyZS8yMDA5L1NlcC8zOTRcbiAgICAgICAgdGhpcy5maWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7IC8vIGNhbid0IGJlIHN1cmUgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBjZW50cmFsIGRpclxuICAgICAgICAvLyB0aGUgZmlsZU5hbWUgaXMgc3RvcmVkIGFzIGJpbmFyeSBkYXRhLCB0aGUgaGFuZGxlVVRGOCBtZXRob2Qgd2lsbCB0YWtlIGNhcmUgb2YgdGhlIGVuY29kaW5nLlxuICAgICAgICB0aGlzLmZpbGVOYW1lID0gcmVhZGVyLnJlYWREYXRhKHRoaXMuZmlsZU5hbWVMZW5ndGgpO1xuICAgICAgICByZWFkZXIuc2tpcChsb2NhbEV4dHJhRmllbGRzTGVuZ3RoKTtcblxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gLTEgfHwgdGhpcy51bmNvbXByZXNzZWRTaXplID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIG9yIGNvcnJ1cHRlZCB6aXAgOiBkaWRuJ3QgZ2V0IGVub3VnaCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBcIiArIFwiKGNvbXByZXNzZWRTaXplID09PSAtMSB8fCB1bmNvbXByZXNzZWRTaXplID09PSAtMSlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wcmVzc2lvbiA9IGZpbmRDb21wcmVzc2lvbih0aGlzLmNvbXByZXNzaW9uTWV0aG9kKTtcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uID09PSBudWxsKSB7IC8vIG5vIGNvbXByZXNzaW9uIGZvdW5kXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogY29tcHJlc3Npb24gXCIgKyB1dGlscy5wcmV0dHkodGhpcy5jb21wcmVzc2lvbk1ldGhvZCkgKyBcIiB1bmtub3duIChpbm5lciBmaWxlIDogXCIgKyB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLmZpbGVOYW1lKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY29tcHJlc3NlZCA9IG5ldyBDb21wcmVzc2VkT2JqZWN0KHRoaXMuY29tcHJlc3NlZFNpemUsIHRoaXMudW5jb21wcmVzc2VkU2l6ZSwgdGhpcy5jcmMzMiwgY29tcHJlc3Npb24sIHJlYWRlci5yZWFkRGF0YSh0aGlzLmNvbXByZXNzZWRTaXplKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZENlbnRyYWxQYXJ0OiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uTWFkZUJ5ID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHJlYWRlci5za2lwKDIpO1xuICAgICAgICAvLyB0aGlzLnZlcnNpb25OZWVkZWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5iaXRGbGFnID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPSByZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgdGhpcy5kYXRlID0gcmVhZGVyLnJlYWREYXRlKCk7XG4gICAgICAgIHRoaXMuY3JjMzIgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdmFyIGZpbGVOYW1lTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZXh0cmFGaWVsZHNMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5maWxlQ29tbWVudExlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXJTdGFydCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmludGVybmFsRmlsZUF0dHJpYnV0ZXMgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPSByZWFkZXIucmVhZEludCg0KTtcblxuICAgICAgICBpZiAodGhpcy5pc0VuY3J5cHRlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0ZWQgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2lsbCBiZSByZWFkIGluIHRoZSBsb2NhbCBwYXJ0LCBzZWUgdGhlIGNvbW1lbnRzIHRoZXJlXG4gICAgICAgIHJlYWRlci5za2lwKGZpbGVOYW1lTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5yZWFkRXh0cmFGaWVsZHMocmVhZGVyKTtcbiAgICAgICAgdGhpcy5wYXJzZVpJUDY0RXh0cmFGaWVsZChyZWFkZXIpO1xuICAgICAgICB0aGlzLmZpbGVDb21tZW50ID0gcmVhZGVyLnJlYWREYXRhKHRoaXMuZmlsZUNvbW1lbnRMZW5ndGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIGFuZCBnZXQgdGhlIHVuaXgvZG9zIHBlcm1pc3Npb25zLlxuICAgICAqL1xuICAgIHByb2Nlc3NBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG51bGw7XG4gICAgICAgIHZhciBtYWRlQnkgPSB0aGlzLnZlcnNpb25NYWRlQnkgPj4gODtcblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRoZSBET1MgZGlyZWN0b3J5IGZsYWcgc2V0LlxuICAgICAgICAvLyBXZSBsb29rIGZvciBpdCBpbiB0aGUgRE9TIGFuZCBVTklYIHBlcm1pc3Npb25zXG4gICAgICAgIC8vIGJ1dCBzb21lIHVua25vd24gcGxhdGZvcm0gY291bGQgc2V0IGl0IGFzIGEgY29tcGF0aWJpbGl0eSBmbGFnLlxuICAgICAgICB0aGlzLmRpciA9IHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyAmIDB4MDAxMCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgICBpZihtYWRlQnkgPT09IE1BREVfQllfRE9TKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCA2IGJpdHMgKDAgdG8gNSlcbiAgICAgICAgICAgIHRoaXMuZG9zUGVybWlzc2lvbnMgPSB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgJiAweDNGO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobWFkZUJ5ID09PSBNQURFX0JZX1VOSVgpIHtcbiAgICAgICAgICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gKHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA+PiAxNikgJiAweEZGRkY7XG4gICAgICAgICAgICAvLyB0aGUgb2N0YWwgcGVybWlzc2lvbnMgYXJlIGluICh0aGlzLnVuaXhQZXJtaXNzaW9ucyAmIDB4MDFGRikudG9TdHJpbmcoOCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmYWlsIHNhZmUgOiBpZiB0aGUgbmFtZSBlbmRzIHdpdGggYSAvIGl0IHByb2JhYmx5IG1lYW5zIGEgZm9sZGVyXG4gICAgICAgIGlmICghdGhpcy5kaXIgJiYgdGhpcy5maWxlTmFtZVN0ci5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICAgICAgdGhpcy5kaXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBaSVA2NCBleHRyYSBmaWVsZCBhbmQgbWVyZ2UgdGhlIGluZm8gaW4gdGhlIGN1cnJlbnQgWmlwRW50cnkuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcGFyc2VaSVA2NEV4dHJhRmllbGQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuXG4gICAgICAgIGlmICghdGhpcy5leHRyYUZpZWxkc1sweDAwMDFdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaG91bGQgYmUgc29tZXRoaW5nLCBwcmVwYXJpbmcgdGhlIGV4dHJhIHJlYWRlclxuICAgICAgICB2YXIgZXh0cmFSZWFkZXIgPSByZWFkZXJGb3IodGhpcy5leHRyYUZpZWxkc1sweDAwMDFdLnZhbHVlKTtcblxuICAgICAgICAvLyBJIHJlYWxseSBob3BlIHRoYXQgdGhlc2UgNjRiaXRzIGludGVnZXIgY2FuIGZpdCBpbiAzMiBiaXRzIGludGVnZXIsIGJlY2F1c2UganNcbiAgICAgICAgLy8gd29uJ3QgbGV0IHVzIGhhdmUgbW9yZS5cbiAgICAgICAgaWYgKHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2tOdW1iZXJTdGFydCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5kaXNrTnVtYmVyU3RhcnQgPSBleHRyYVJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRFeHRyYUZpZWxkczogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHZhciBlbmQgPSByZWFkZXIuaW5kZXggKyB0aGlzLmV4dHJhRmllbGRzTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZXh0cmFGaWVsZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmFGaWVsZHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChyZWFkZXIuaW5kZXggKyA0IDwgZW5kKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZSA9IHJlYWRlci5yZWFkRGF0YShleHRyYUZpZWxkTGVuZ3RoKTtcblxuICAgICAgICAgICAgdGhpcy5leHRyYUZpZWxkc1tleHRyYUZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRyYUZpZWxkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZWFkZXIuc2V0SW5kZXgoZW5kKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFwcGx5IGFuIFVURjggdHJhbnNmb3JtYXRpb24gaWYgbmVlZGVkLlxuICAgICAqL1xuICAgIGhhbmRsZVVURjg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVjb2RlUGFyYW1UeXBlID0gc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG4gICAgICAgIGlmICh0aGlzLnVzZVVURjgoKSkge1xuICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHV0ZjgudXRmOGRlY29kZSh0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdXBhdGggPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGgoKTtcbiAgICAgICAgICAgIGlmICh1cGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1cGF0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWVCeXRlQXJyYXkgPSAgdXRpbHMudHJhbnNmb3JtVG8oZGVjb2RlUGFyYW1UeXBlLCB0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShmaWxlTmFtZUJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1Y29tbWVudCA9IHRoaXMuZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudCgpO1xuICAgICAgICAgICAgaWYgKHVjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHVjb21tZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBU0NJSSB0ZXh0IG9yIHVuc3VwcG9ydGVkIGNvZGUgcGFnZVxuICAgICAgICAgICAgICAgIHZhciBjb21tZW50Qnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoY29tbWVudEJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgdW5pY29kZSBwYXRoIGRlY2xhcmVkIGluIHRoZSBleHRyYSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaWNvZGUgcGF0aCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cGF0aEZpZWxkID0gdGhpcy5leHRyYUZpZWxkc1sweDcwNzVdO1xuICAgICAgICBpZiAodXBhdGhGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHVwYXRoRmllbGQudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyB3cm9uZyB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZXh0cmFSZWFkZXIucmVhZEludCgxKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgY3JjIG9mIHRoZSBmaWxlbmFtZSBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlTmFtZSkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1cGF0aEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgdW5pY29kZSBjb21tZW50IGRlY2xhcmVkIGluIHRoZSBleHRyYSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaWNvZGUgY29tbWVudCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1Y29tbWVudEZpZWxkID0gdGhpcy5leHRyYUZpZWxkc1sweDYzNzVdO1xuICAgICAgICBpZiAodWNvbW1lbnRGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHVjb21tZW50RmllbGQudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyB3cm9uZyB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZXh0cmFSZWFkZXIucmVhZEludCgxKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgY3JjIG9mIHRoZSBjb21tZW50IGNoYW5nZWQsIHRoaXMgZmllbGQgaXMgb3V0IG9mIGRhdGUuXG4gICAgICAgICAgICBpZiAoY3JjMzJmbih0aGlzLmZpbGVDb21tZW50KSAhPT0gZXh0cmFSZWFkZXIucmVhZEludCg0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXRmOC51dGY4ZGVjb2RlKGV4dHJhUmVhZGVyLnJlYWREYXRhKHVjb21tZW50RmllbGQubGVuZ3RoIC0gNSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZSgnLi9zdHJlYW0vU3RyZWFtSGVscGVyJyk7XG52YXIgRGF0YVdvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFXb3JrZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSBzaW1wbGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIGZpbGUgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIG9mIHRoZSBmaWxlXG4gKi9cbnZhciBaaXBPYmplY3QgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRpciA9IG9wdGlvbnMuZGlyO1xuICAgIHRoaXMuZGF0ZSA9IG9wdGlvbnMuZGF0ZTtcbiAgICB0aGlzLmNvbW1lbnQgPSBvcHRpb25zLmNvbW1lbnQ7XG4gICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBvcHRpb25zLnVuaXhQZXJtaXNzaW9ucztcbiAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gb3B0aW9ucy5kb3NQZXJtaXNzaW9ucztcblxuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIHRoaXMuX2RhdGFCaW5hcnkgPSBvcHRpb25zLmJpbmFyeTtcbiAgICAvLyBrZWVwIG9ubHkgdGhlIGNvbXByZXNzaW9uXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBjb21wcmVzc2lvbiA6IG9wdGlvbnMuY29tcHJlc3Npb24sXG4gICAgICAgIGNvbXByZXNzaW9uT3B0aW9ucyA6IG9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zXG4gICAgfTtcbn07XG5cblppcE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGludGVybmFsIHN0cmVhbSBmb3IgdGhlIGNvbnRlbnQgb2YgdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcmV0dXJuIFN0cmVhbUhlbHBlciB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIGludGVybmFsU3RyZWFtOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbCwgb3V0cHV0VHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0VHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBhc2tVbmljb2RlU3RyaW5nID0gb3V0cHV0VHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIjtcbiAgICAgICAgICAgIGlmIChvdXRwdXRUeXBlID09PSBcImJpbmFyeXN0cmluZ1wiIHx8IG91dHB1dFR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG5cbiAgICAgICAgICAgIHZhciBpc1VuaWNvZGVTdHJpbmcgPSAhdGhpcy5fZGF0YUJpbmFyeTtcblxuICAgICAgICAgICAgaWYgKGlzVW5pY29kZVN0cmluZyAmJiAhYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzVW5pY29kZVN0cmluZyAmJiBhc2tVbmljb2RlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOERlY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSGVscGVyKHJlc3VsdCwgb3V0cHV0VHlwZSwgXCJcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgaW4gdGhlIGFza2VkIHR5cGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIG9mIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmM6IGZ1bmN0aW9uICh0eXBlLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0cmVhbSh0eXBlKS5hY2N1bXVsYXRlKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgY29udGVudCBhcyBhIG5vZGVqcyBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBTdHJlYW0gdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBub2RlU3RyZWFtOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSB8fCBcIm5vZGVidWZmZXJcIikudG9Ob2RlanNTdHJlYW0ob25VcGRhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB3b3JrZXIgZm9yIHRoZSBjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9jb21wcmVzc1dvcmtlcjogZnVuY3Rpb24gKGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QgJiZcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29tcHJlc3Npb24ubWFnaWMgPT09IGNvbXByZXNzaW9uLm1hZ2ljXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0Q29tcHJlc3NlZFdvcmtlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2RlY29tcHJlc3NXb3JrZXIoKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLl9kYXRhQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOEVuY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDb21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20ocmVzdWx0LCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgZGVjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9kZWNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbnRlbnRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFXb3JrZXIodGhpcy5fZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgcmVtb3ZlZE1ldGhvZHMgPSBbXCJhc1RleHRcIiwgXCJhc0JpbmFyeVwiLCBcImFzTm9kZUJ1ZmZlclwiLCBcImFzVWludDhBcnJheVwiLCBcImFzQXJyYXlCdWZmZXJcIl07XG52YXIgcmVtb3ZlZEZuID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xufTtcblxuZm9yKHZhciBpID0gMDsgaSA8IHJlbW92ZWRNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgWmlwT2JqZWN0LnByb3RvdHlwZVtyZW1vdmVkTWV0aG9kc1tpXV0gPSByZW1vdmVkRm47XG59XG5tb2R1bGUuZXhwb3J0cyA9IFppcE9iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpbW1lZGlhdGUgPSByZXF1aXJlKCdpbW1lZGlhdGUnKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIElOVEVSTkFMKCkge31cblxudmFyIGhhbmRsZXJzID0ge307XG5cbnZhciBSRUpFQ1RFRCA9IFsnUkVKRUNURUQnXTtcbnZhciBGVUxGSUxMRUQgPSBbJ0ZVTEZJTExFRCddO1xudmFyIFBFTkRJTkcgPSBbJ1BFTkRJTkcnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB0aGlzLnN0YXRlID0gUEVORElORztcbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICB0aGlzLm91dGNvbWUgPSB2b2lkIDA7XG4gIGlmIChyZXNvbHZlciAhPT0gSU5URVJOQUwpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUodGhpcywgcmVzb2x2ZXIpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHAgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdGhpcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgIGZ1bmN0aW9uIHllcyAoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbih5ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICBmdW5jdGlvbiBubyAoKSB7XG4gICAgICB0aHJvdyByZWFzb247XG4gICAgfVxuICAgIHJldHVybiBwLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihubyk7XG4gIH1cbn07XG5Qcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbn07XG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgIT09ICdmdW5jdGlvbicgJiYgdGhpcy5zdGF0ZSA9PT0gRlVMRklMTEVEIHx8XG4gICAgdHlwZW9mIG9uUmVqZWN0ZWQgIT09ICdmdW5jdGlvbicgJiYgdGhpcy5zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKElOVEVSTkFMKTtcbiAgaWYgKHRoaXMuc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICB2YXIgcmVzb2x2ZXIgPSB0aGlzLnN0YXRlID09PSBGVUxGSUxMRUQgPyBvbkZ1bGZpbGxlZCA6IG9uUmVqZWN0ZWQ7XG4gICAgdW53cmFwKHByb21pc2UsIHJlc29sdmVyLCB0aGlzLm91dGNvbWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucXVldWUucHVzaChuZXcgUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5mdW5jdGlvbiBRdWV1ZUl0ZW0ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMub25GdWxmaWxsZWQgPSBvbkZ1bGZpbGxlZDtcbiAgICB0aGlzLmNhbGxGdWxmaWxsZWQgPSB0aGlzLm90aGVyQ2FsbEZ1bGZpbGxlZDtcbiAgfVxuICBpZiAodHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSBvblJlamVjdGVkO1xuICAgIHRoaXMuY2FsbFJlamVjdGVkID0gdGhpcy5vdGhlckNhbGxSZWplY3RlZDtcbiAgfVxufVxuUXVldWVJdGVtLnByb3RvdHlwZS5jYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGhhbmRsZXJzLnJlc29sdmUodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdW53cmFwKHRoaXMucHJvbWlzZSwgdGhpcy5vbkZ1bGZpbGxlZCwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbFJlamVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGhhbmRsZXJzLnJlamVjdCh0aGlzLnByb21pc2UsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLm90aGVyQ2FsbFJlamVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25SZWplY3RlZCwgdmFsdWUpO1xufTtcblxuZnVuY3Rpb24gdW53cmFwKHByb21pc2UsIGZ1bmMsIHZhbHVlKSB7XG4gIGltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldHVyblZhbHVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IGZ1bmModmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZSk7XG4gICAgfVxuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gcHJvbWlzZSkge1xuICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgcmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmhhbmRsZXJzLnJlc29sdmUgPSBmdW5jdGlvbiAoc2VsZiwgdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKGdldFRoZW4sIHZhbHVlKTtcbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHNlbGYsIHJlc3VsdC52YWx1ZSk7XG4gIH1cbiAgdmFyIHRoZW5hYmxlID0gcmVzdWx0LnZhbHVlO1xuXG4gIGlmICh0aGVuYWJsZSkge1xuICAgIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICBzZWxmLm91dGNvbWUgPSB2YWx1ZTtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBzZWxmLnF1ZXVlW2ldLmNhbGxGdWxmaWxsZWQodmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5oYW5kbGVycy5yZWplY3QgPSBmdW5jdGlvbiAoc2VsZiwgZXJyb3IpIHtcbiAgc2VsZi5zdGF0ZSA9IFJFSkVDVEVEO1xuICBzZWxmLm91dGNvbWUgPSBlcnJvcjtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGxlbiA9IHNlbGYucXVldWUubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgc2VsZi5xdWV1ZVtpXS5jYWxsUmVqZWN0ZWQoZXJyb3IpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufTtcblxuZnVuY3Rpb24gZ2V0VGhlbihvYmopIHtcbiAgLy8gTWFrZSBzdXJlIHdlIG9ubHkgYWNjZXNzIHRoZSBhY2Nlc3NvciBvbmNlIGFzIHJlcXVpcmVkIGJ5IHRoZSBzcGVjXG4gIHZhciB0aGVuID0gb2JqICYmIG9iai50aGVuO1xuICBpZiAob2JqICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSAmJiB0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmdW5jdGlvbiBhcHB5VGhlbigpIHtcbiAgICAgIHRoZW4uYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5UmVzb2x2ZVRoZW5hYmxlKHNlbGYsIHRoZW5hYmxlKSB7XG4gIC8vIEVpdGhlciBmdWxmaWxsLCByZWplY3Qgb3IgcmVqZWN0IHdpdGggZXJyb3JcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbkVycm9yKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlamVjdChzZWxmLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblN1Y2Nlc3ModmFsdWUpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgaGFuZGxlcnMucmVzb2x2ZShzZWxmLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlUb1Vud3JhcCgpIHtcbiAgICB0aGVuYWJsZShvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRyeVRvVW53cmFwKTtcbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICBvbkVycm9yKHJlc3VsdC52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2goZnVuYywgdmFsdWUpIHtcbiAgdmFyIG91dCA9IHt9O1xuICB0cnkge1xuICAgIG91dC52YWx1ZSA9IGZ1bmModmFsdWUpO1xuICAgIG91dC5zdGF0dXMgPSAnc3VjY2Vzcyc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBvdXQuc3RhdHVzID0gJ2Vycm9yJztcbiAgICBvdXQudmFsdWUgPSBlO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cblByb21pc2UucmVzb2x2ZSA9IHJlc29sdmU7XG5mdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIHRoaXMpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXJzLnJlc29sdmUobmV3IHRoaXMoSU5URVJOQUwpLCB2YWx1ZSk7XG59XG5cblByb21pc2UucmVqZWN0ID0gcmVqZWN0O1xuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcbiAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCByZWFzb24pO1xufVxuXG5Qcm9taXNlLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcmFibGUpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ211c3QgYmUgYW4gYXJyYXknKSk7XG4gIH1cblxuICB2YXIgbGVuID0gaXRlcmFibGUubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7XG4gIH1cblxuICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG4gIHZhciByZXNvbHZlZCA9IDA7XG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBhbGxSZXNvbHZlcihpdGVyYWJsZVtpXSwgaSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIGFsbFJlc29sdmVyKHZhbHVlLCBpKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmVGcm9tQWxsLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZyb21BbGwob3V0VmFsdWUpIHtcbiAgICAgIHZhbHVlc1tpXSA9IG91dFZhbHVlO1xuICAgICAgaWYgKCsrcmVzb2x2ZWQgPT09IGxlbiAmJiAhY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuUHJvbWlzZS5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHJlc29sdmVyKGl0ZXJhYmxlW2ldKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZTtcbiAgZnVuY3Rpb24gcmVzb2x2ZXIodmFsdWUpIHtcbiAgICBzZWxmLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgPSByZXF1aXJlKCcuL2xpYi91dGlscy9jb21tb24nKS5hc3NpZ247XG5cbnZhciBkZWZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG52YXIgaW5mbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbnZhciBwYWtvID0ge307XG5cbmFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBha287XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcblxudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuXG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbRGVmbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGFycmF5IGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpO1xuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChaX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9pbmZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBjICAgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbnZhciBHWmhlYWRlciAgICAgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMCxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcblxuICAvLyBTZXR1cCBkaWN0aW9uYXJ5XG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH1cbiAgICBpZiAob3B0LnJhdykgeyAvL0luIHJhdyBtb2RlIHdlIG5lZWQgdG8gc2V0IHRoZSBkaWN0aW9uYXJ5IGVhcmx5XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YVxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGRlY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcbiAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7XG5cbiAgLy8gRmxhZyB0byBwcm9wZXJseSBwcm9jZXNzIFpfQlVGX0VSUk9SIG9uIHRlc3RpbmcgaW5mbGF0ZSBjYWxsXG4gIC8vIHdoZW4gd2UgY2hlY2sgdGhhdCBhbGwgb3V0cHV0IGRhdGEgd2FzIGZsdXNoZWQuXG4gIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIE9ubHkgYmluYXJ5IHN0cmluZ3MgY2FuIGJlIGRlY29tcHJlc3NlZCBvbiBwcmFjdGljZVxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdGlvbmFyeSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7XG4gICAgICBzdGF0dXMgPSBjLlpfT0s7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWxcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHsgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsgfVxuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnNcbiAgICAvLyBhcmUgZmx1c2hlZC4gVGhlIG9ubHkgd2F5IHRvIGRvIGl0IHdoZW4gYXZhaWxfb3V0ID0gMCAtIHJ1biBvbmUgbW9yZVxuICAgIC8vIGluZmxhdGUgcGFzcy4gQnV0IGlmIG91dHB1dCBkYXRhIG5vdCBleGlzdHMsIGluZmxhdGUgcmV0dXJuIFpfQlVGX0VSUk9SLlxuICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LlxuICAgIC8vXG4gICAgLy8gTk9URS4gRGVmbGF0ZSBkb2VzIG5vdCByZXR1cm4gZXJyb3IgaW4gdGhpcyBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkcyBzdWNoXG4gICAgLy8gbG9naWMuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IGMuWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBHbHVlICYgY29udmVydCBoZXJlLCB1bnRpbCB3ZSB0ZWFjaCBwYWtvIHRvIHNlbmRcbiAgICAgIC8vIHV0ZjggYWxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YVxuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGlucHV0ID0gcGFrby5kZWZsYXRlKFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgeyB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5leHBvcnRzLnVuZ3ppcCAgPSBpbmZsYXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5mdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIE9uIENocm9tZSwgdGhlIGFyZ3VtZW50cyBpbiBhIGZ1bmN0aW9uIGNhbGwgdGhhdCBhcmUgYWxsb3dlZCBpcyBgNjU1MzRgLlxuICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaXMgc21hbGxlciB0aGFuIHRoYXQsIHdlIGNhbiB1c2UgdGhpcyBvcHRpbWl6YXRpb24sXG4gIC8vIG90aGVyd2lzZSB3ZSB3aWxsIHRha2UgYSBzbG93ZXIgcGF0aC5cbiAgaWYgKGxlbiA8IDY1NTM0KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE5BTUU6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRTpcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEVETzpcbiAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFlfOlxuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZOlxuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgICAgdXRpbHMuYXJyYXlTZXQob3V0cHV0LCBpbnB1dCwgbmV4dCwgY29weSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNUOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTUFUQ0g6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMSVQ6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIH1cbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzdGF0ZTtcbiAgdmFyIGRpY3RpZDtcbiAgdmFyIHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbnZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbnZhciBTVE9SRURfQkxPQ0sgPSAwO1xudmFyIFNUQVRJQ19UUkVFUyA9IDE7XG52YXIgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbnZhciBNSU5fTUFUQ0ggICAgPSAzO1xudmFyIE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG52YXIgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbnZhciBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG52YXIgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF07XG5cbnZhciBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN107XG5cbnZhciBibF9vcmRlciA9XG4gIFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbnZhciBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbnZhciBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxudmFyIHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG52YXIgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG52YXIgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG52YXIgc3RhdGljX2xfZGVzYztcbnZhciBzdGF0aWNfZF9kZXNjO1xudmFyIHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmZ1bmN0aW9uIGRfY29kZShkaXN0KSB7XG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5mdW5jdGlvbiBwdXRfc2hvcnQocywgdykge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5mdW5jdGlvbiBiaV9mbHVzaChzKSB7XG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICB2YXIgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgdmFyIG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICB2YXIgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIHZhciBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudClcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7XG4gIHZhciBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgdmFyIGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7XG4gIHZhciBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBiaV93aW5kdXAocylcbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuICogMjtcbiAgdmFyIF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5mdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIHZhciB2ID0gcy5oZWFwW2tdO1xuICB2YXIgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gdmFyIFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIHZhciBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIHZhciBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICB2YXIgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgdmFyIG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB2YXIgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5mdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2Rlcylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIHZhciByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufVxuXG5cbnZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBfdHJfaW5pdChzKVxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF90cl9hbGlnbihzKSB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59XG5cbmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAhcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgPyBzZXRJbW1lZGlhdGUgOlxuXHRmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHMpO1xuXHRcdGFyZ3Muc3BsaWNlKDEsIDAsIDApO1xuXHRcdHNldFRpbWVvdXQuYXBwbHkobnVsbCwgYXJncyk7XG5cdH07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsImltcG9ydCBKU1ppcCBmcm9tIFwianN6aXBcIjtcclxuaW1wb3J0IHtJdXBsb2FkZmlsZUxpc3R9IGZyb20gXCIuL0lDb21tb25cIjtcclxuaW1wb3J0IHtnZXRCaW5hcnlDb250ZW50fSBmcm9tIFwiLi9jb21tb24vbWV0aG9kXCJcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgSGFuZGxlWmlwe1xyXG4gICAgdXBsb2FkRmlsZTpGaWxlOyBcclxuICAgIHdvcmtCb29rOkpTWmlwOyBcclxuICAgIFxyXG4gICAgY29uc3RydWN0b3IoZmlsZT86RmlsZSl7XHJcbiAgICAgICAgLy8gU3VwcG9ydCBub2RlanMgZnMgdG8gcmVhZCBmaWxlc1xyXG4gICAgICAgIC8vIGlmKGZpbGUgaW5zdGFuY2VvZiBGaWxlKXtcclxuICAgICAgICAgICAgdGhpcy51cGxvYWRGaWxlID0gZmlsZTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgdW56aXBGaWxlKHN1Y2Nlc3NGdW5jOihmaWxlOkl1cGxvYWRmaWxlTGlzdCk9PnZvaWQsIGVycm9yRnVuYzooZXJyOkVycm9yKT0+dm9pZCk6dm9pZCB7IFxyXG4gICAgICAgIC8vIHZhciBuZXdfemlwOkpTWmlwID0gbmV3IEpTWmlwKCk7XHJcbiAgICAgICAgSlNaaXAubG9hZEFzeW5jKHRoaXMudXBsb2FkRmlsZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEpIHJlYWQgdGhlIEJsb2JcclxuICAgICAgICAudGhlbihmdW5jdGlvbih6aXA6YW55KSB7XHJcbiAgICAgICAgICAgIGxldCBmaWxlTGlzdDpJdXBsb2FkZmlsZUxpc3QgPSA8SXVwbG9hZGZpbGVMaXN0Pnt9LCBsYXN0SW5kZXg6bnVtYmVyID0gT2JqZWN0LmtleXMoemlwLmZpbGVzKS5sZW5ndGgsIGluZGV4Om51bWJlcj0wO1xyXG4gICAgICAgICAgICB6aXAuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoOmFueSwgemlwRW50cnk6YW55KSB7ICAvLyAyKSBwcmludCBlbnRyaWVzXHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsZU5hbWUgPSB6aXBFbnRyeS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lQXJyID0gZmlsZU5hbWUuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IGZpbGVOYW1lQXJyW2ZpbGVOYW1lQXJyLmxlbmd0aC0xXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVUeXBlID0gXCJzdHJpbmdcIjtcclxuICAgICAgICAgICAgICAgIGlmKHN1ZmZpeCBpbiB7XCJwbmdcIjoxLCBcImpwZWdcIjoxLCBcImpwZ1wiOjEsIFwiZ2lmXCI6MSxcImJtcFwiOjEsXCJ0aWZcIjoxLFwid2VicFwiOjEsfSl7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZVR5cGUgPSBcImJhc2U2NFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzdWZmaXg9PVwiZW1mXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgemlwRW50cnkuYXN5bmMoZmlsZVR5cGUpLnRoZW4oZnVuY3Rpb24gKGRhdGE6c3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZmlsZVR5cGU9PVwiYmFzZTY0XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gXCJkYXRhOmltYWdlL1wiKyBzdWZmaXggK1wiO2Jhc2U2NCxcIiArIGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVMaXN0W3ppcEVudHJ5Lm5hbWVdID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhsYXN0SW5kZXgsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBpZihsYXN0SW5kZXg9PWluZGV4KzEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzRnVuYyhmaWxlTGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlOkVycm9yKSB7XHJcbiAgICAgICAgICAgIGVycm9yRnVuYyhlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB1bnppcEZpbGVCeVVybCh1cmw6c3RyaW5nLHN1Y2Nlc3NGdW5jOihmaWxlOkl1cGxvYWRmaWxlTGlzdCk9PnZvaWQsIGVycm9yRnVuYzooZXJyOkVycm9yKT0+dm9pZCk6dm9pZCB7IFxyXG4gICAgICAgIHZhciBuZXdfemlwOkpTWmlwID0gbmV3IEpTWmlwKCk7XHJcbiAgICAgICAgZ2V0QmluYXJ5Q29udGVudCh1cmwsIGZ1bmN0aW9uKGVycjphbnksIGRhdGE6YW55KSB7XHJcbiAgICAgICAgICAgIGlmKGVycikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyOyAvLyBvciBoYW5kbGUgZXJyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAgICAgSlNaaXAubG9hZEFzeW5jKGRhdGEpLnRoZW4oZnVuY3Rpb24oemlwOmFueSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVMaXN0Okl1cGxvYWRmaWxlTGlzdCA9IDxJdXBsb2FkZmlsZUxpc3Q+e30sIGxhc3RJbmRleDpudW1iZXIgPSBPYmplY3Qua2V5cyh6aXAuZmlsZXMpLmxlbmd0aCwgaW5kZXg6bnVtYmVyPTA7XHJcbiAgICAgICAgICAgICAgICB6aXAuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoOmFueSwgemlwRW50cnk6YW55KSB7ICAvLyAyKSBwcmludCBlbnRyaWVzXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lID0gemlwRW50cnkubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZU5hbWVBcnIgPSBmaWxlTmFtZS5zcGxpdChcIi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IGZpbGVOYW1lQXJyW2ZpbGVOYW1lQXJyLmxlbmd0aC0xXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlVHlwZSA9IFwic3RyaW5nXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3VmZml4IGluIHtcInBuZ1wiOjEsIFwianBlZ1wiOjEsIFwianBnXCI6MSwgXCJnaWZcIjoxLFwiYm1wXCI6MSxcInRpZlwiOjEsXCJ3ZWJwXCI6MSx9KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVR5cGUgPSBcImJhc2U2NFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN1ZmZpeD09XCJlbWZcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB6aXBFbnRyeS5hc3luYyhmaWxlVHlwZSkudGhlbihmdW5jdGlvbiAoZGF0YTphbnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmlsZVR5cGU9PVwiYmFzZTY0XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFwiZGF0YTppbWFnZS9cIisgc3VmZml4ICtcIjtiYXNlNjQsXCIgKyBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVMaXN0W3ppcEVudHJ5Lm5hbWVdID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobGFzdEluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxhc3RJbmRleD09aW5kZXgrMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzRnVuYyhmaWxlTGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlOkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvckZ1bmMoZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIG5ld1ppcEZpbGUoKTp2b2lkIHsgXHJcbiAgICAgICAgdmFyIHppcCA9IG5ldyBKU1ppcCgpO1xyXG4gICAgICAgIHRoaXMud29ya0Jvb2sgPSAgemlwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vdGl0bGU6XCJuZXN0ZWQvaGVsbG8udHh0XCIsIGNvbnRlbnQ6XCJIZWxsbyBXb3JsZGFzZGZhc2Zhc2RmYXNmYXNmYXNmYXNmYXNkZmFzXCJcclxuICAgIGFkZFRvWmlwRmlsZSh0aXRsZTpzdHJpbmcsY29udGVudDpzdHJpbmcpOnZvaWQgeyBcclxuICAgICAgICBpZih0aGlzLndvcmtCb29rPT1udWxsKXtcclxuICAgICAgICAgICAgdmFyIHppcCA9IG5ldyBKU1ppcCgpO1xyXG4gICAgICAgICAgICB0aGlzLndvcmtCb29rID0gIHppcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53b3JrQm9vay5maWxlKHRpdGxlLCBjb250ZW50KTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IElMdWNreUZpbGUsIElMdWNreUZpbGVJbmZvLElsdWNreVNoZWV0LElsdWNreVNoZWV0Q2VsbGRhdGEsSWx1Y2t5U2hlZXRDb25maWcsSWx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlLElsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZU1lcmdlLElMdWNreVNoZWV0Q2VsbEZvcm1hdCxJbHVja3lTaGVldENvbmZpZ01lcmdlcyxJbHVja3lTaGVldENvbmZpZ01lcmdlLElNYXBsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxGb3JJbXAsSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlLElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxlLElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxGb3JJbXAsSWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5MZW4sSWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5IaWRkZW4sSWx1Y2t5U2hlZXRTZWxlY3Rpb24sSWx1Y2t5c2hlZXRGcm96ZW4sSWx1Y2t5U2hlZXRDaGFydCxJbHVja3lTaGVldFBpdm90VGFibGUsSWx1Y2t5c2hlZXRDb25kaXRpb25Gb3JtYXQsSWx1Y2t5c2hlZXRDYWxjQ2hhaW4sSUx1Y2t5SW5saW5lU3RyaW5nLElsdWNreUltYWdlLElsdWNreUltYWdlQm9yZGVyLElsdWNreUltYWdlQ3JvcCxJbHVja3lJbWFnZURlZmF1bHQsSWx1Y2t5SW1hZ2VzLCBJbHVja3lzaGVldEh5cGVybGlua30gZnJvbSBcIi4vSUx1Y2tcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5RmlsZUJhc2UgaW1wbGVtZW50cyBJTHVja3lGaWxlIHtcclxuICAgIGluZm86SUx1Y2t5RmlsZUluZm9cclxuICAgIHNoZWV0czpJbHVja3lTaGVldFtdXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreVNoZWV0QmFzZSBpbXBsZW1lbnRzIElsdWNreVNoZWV0e1xyXG4gICAgbmFtZTpzdHJpbmdcclxuICAgIGNvbG9yOnN0cmluZ1xyXG4gICAgY29uZmlnOklsdWNreVNoZWV0Q29uZmlnXHJcbiAgICBpbmRleDpzdHJpbmdcclxuICAgIHN0YXR1czpzdHJpbmdcclxuICAgIG9yZGVyOnN0cmluZ1xyXG4gICAgcm93Om51bWJlclxyXG4gICAgY29sdW1uOm51bWJlclxyXG4gICAgbHVja3lzaGVldF9zZWxlY3Rfc2F2ZTpJbHVja3lTaGVldFNlbGVjdGlvbltdXHJcbiAgICBzY3JvbGxMZWZ0Om51bWJlclxyXG4gICAgc2Nyb2xsVG9wOm51bWJlclxyXG4gICAgem9vbVJhdGlvOm51bWJlclxyXG4gICAgc2hvd0dyaWRMaW5lczpzdHJpbmdcclxuICAgIGRlZmF1bHRDb2xXaWR0aDpudW1iZXJcclxuICAgIGRlZmF1bHRSb3dIZWlnaHQ6bnVtYmVyXHJcblxyXG4gICAgY2VsbGRhdGE6SWx1Y2t5U2hlZXRDZWxsZGF0YVtdXHJcbiAgICBjaGFydDpJbHVja3lTaGVldENoYXJ0W11cclxuXHJcbiAgICBpc1Bpdm90VGFibGU6Ym9vbGVhblxyXG4gICAgcGl2b3RUYWJsZTpJbHVja3lTaGVldFBpdm90VGFibGVcclxuXHJcbiAgICBsdWNreXNoZWV0X2NvbmRpdGlvbmZvcm1hdF9zYXZlOklsdWNreXNoZWV0Q29uZGl0aW9uRm9ybWF0W11cclxuICAgIGZyZWV6ZW46SWx1Y2t5c2hlZXRGcm96ZW5cclxuXHJcbiAgICBjYWxjQ2hhaW46SWx1Y2t5c2hlZXRDYWxjQ2hhaW5bXVxyXG5cclxuICAgIGltYWdlczpJbHVja3lJbWFnZXNcclxuICAgIFxyXG4gICAgaHlwZXJsaW5rOiBJbHVja3lzaGVldEh5cGVybGlua1xyXG4gICAgaGlkZTogbnVtYmVyO1xyXG4gICAgXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreUZpbGVJbmZvIGltcGxlbWVudHMgSUx1Y2t5RmlsZUluZm97XHJcbiAgICBuYW1lOnN0cmluZ1xyXG4gICAgY3JlYXRvcjpzdHJpbmdcclxuICAgIGxhc3Rtb2RpZmllZGJ5OnN0cmluZ1xyXG4gICAgY3JlYXRlZFRpbWU6c3RyaW5nXHJcbiAgICBtb2RpZmllZFRpbWU6c3RyaW5nXHJcbiAgICBjb21wYW55OnN0cmluZ1xyXG4gICAgYXBwdmVyc2lvbjpzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXRDZWxsZGF0YUJhc2UgaW1wbGVtZW50cyBJbHVja3lTaGVldENlbGxkYXRhe1xyXG4gICAgcjpudW1iZXJcclxuICAgIGM6bnVtYmVyXHJcbiAgICB2OklsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSB8IHN0cmluZyB8IG51bGxcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlIGltcGxlbWVudHMgSWx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVle1xyXG4gICAgY3Q6IEx1Y2t5U2hlZXRDZWxsRm9ybWF0IHwgdW5kZWZpbmVkIC8vY2VsbHR5cGUsQ2VsbCB2YWx1ZSBmb3JtYXQ6IHRleHQsIHRpbWUsIGV0Yy4gbnVtZm10c1xyXG4gICAgYmc6IHN0cmluZyB8IHVuZGVmaW5lZC8vYmFja2dyb3VuZCwjZmZmMDAwLFx0ZmlsbFxyXG4gICAgZmY6IHN0cmluZyB8IHVuZGVmaW5lZC8vZm9udGZhbWlseSwgZm9udHNcclxuICAgIGZjOiBzdHJpbmcgfCB1bmRlZmluZWQvL2ZvbnRjb2xvciBmb250c1xyXG4gICAgYmw6IG51bWJlciB8IHVuZGVmaW5lZC8vQm9sZCwgZm9udHNcclxuICAgIGl0OiBudW1iZXIgfCB1bmRlZmluZWQvL2l0YWxpYywgZm9udHNcclxuICAgIGZzOiBudW1iZXIgfCB1bmRlZmluZWQvL2ZvbnQgc2l6ZSwgZm9udHNcclxuICAgIGNsOiBudW1iZXIgfCB1bmRlZmluZWQvL3N0cmlrZSwgMCBSZWd1bGFyLCAxIHN0cmlrZXMsIGZvbnRzXHJcbiAgICB1bjogbnVtYmVyIHwgdW5kZWZpbmVkLy91bmRlcmxpbmUsIDAgUmVndWxhciwgMSB1bmRlcmxpbmVzLCBmb250c1xyXG4gICAgdnQ6IG51bWJlciB8IHVuZGVmaW5lZC8vVmVydGljYWwgYWxpZ25tZW50LCAwIG1pZGRsZSwgMSB1cCwgMiBkb3duLCBhbGlnbm1lbnRcclxuICAgIGh0OiBudW1iZXIgfCB1bmRlZmluZWQvL0hvcml6b250YWwgYWxpZ25tZW50LDAgY2VudGVyLCAxIGxlZnQsIDIgcmlnaHQsIGFsaWdubWVudFxyXG4gICAgbWM6IElsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZU1lcmdlIHwgdW5kZWZpbmVkIC8vTWVyZ2UgQ2VsbHMsIG1lcmdlQ2VsbHNcclxuICAgIHRyOiBudW1iZXIgfCB1bmRlZmluZWQgLy9UZXh0IHJvdGF0aW9uLDA6IDDjgIEzIFZlcnRpY2FsIHRleHQgYWxpZ25tZW50XHJcbiAgICB0YjogbnVtYmVyIHwgdW5kZWZpbmVkIC8vVGV4dCB3cmFwLDAgdHJ1bmNhdGlvbiwgMSBvdmVyZmxvdywgMiB3b3JkIHdyYXAsIGFsaWdubWVudFxyXG4gICAgdjogc3RyaW5nIHwgdW5kZWZpbmVkIC8vT3JpZ2luYWwgdmFsdWUsIHZcclxuICAgIG06IHN0cmluZyB8IHVuZGVmaW5lZCAvL0Rpc3BsYXkgdmFsdWUsIHZcclxuICAgIGY6IHN0cmluZyB8IHVuZGVmaW5lZCAvL2Zvcm11bGEsIGZcclxuICAgIHJ0Om51bWJlciB8IHVuZGVmaW5lZCAvL3RleHQgcm90YXRpb24gYW5nbGUgMC0xODAgYWxpZ25tZW50XHJcbiAgICBxcDpudW1iZXIgfCB1bmRlZmluZWQgLy9xdW90ZVByZWZpeCwgc2hvdyBudW1iZXIgYXMgc3RyaW5nXHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldENlbGxGb3JtYXQgaW1wbGVtZW50cyBJTHVja3lTaGVldENlbGxGb3JtYXQge1xyXG4gICAgZmE6c3RyaW5nXHJcbiAgICB0OnN0cmluZ1xyXG4gICAgczpMdWNreUlubGluZVN0cmluZ1tdIHwgdW5kZWZpbmVkXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreUlubGluZVN0cmluZyBpbXBsZW1lbnRzIElMdWNreUlubGluZVN0cmluZyB7XHJcbiAgICBmZjpzdHJpbmcgfCB1bmRlZmluZWQgLy9mb250IGZhbWlseVxyXG4gICAgZmM6c3RyaW5nIHwgdW5kZWZpbmVkLy9mb250IGNvbG9yXHJcbiAgICBmczpudW1iZXIgfCB1bmRlZmluZWQvL2ZvbnQgc2l6ZVxyXG4gICAgY2w6bnVtYmVyIHwgdW5kZWZpbmVkLy9zdHJpa2VcclxuICAgIHVuOm51bWJlciB8IHVuZGVmaW5lZC8vdW5kZXJsaW5lXHJcbiAgICBibDpudW1iZXIgfCB1bmRlZmluZWQvL2Jsb2RcclxuICAgIGl0Om51bWJlciB8IHVuZGVmaW5lZC8vaXRhbGljXHJcbiAgICB2YTpudW1iZXIgfCB1bmRlZmluZWQvLzFzdWIgYW5kIDJzdXBlciBhbmQgMG5vbmVcclxuICAgIHY6c3RyaW5nIHwgdW5kZWZpbmVkXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreUNvbmZpZyBpbXBsZW1lbnRzIElsdWNreVNoZWV0Q29uZmlne1xyXG4gICAgbWVyZ2U6SWx1Y2t5U2hlZXRDb25maWdNZXJnZXNcclxuICAgIGJvcmRlckluZm86SWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcFtdXHJcbiAgICAvLyBfYm9yZGVySW5mbzogSU1hcGx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcFxyXG4gICAgcm93bGVuOklsdWNreVNoZWV0Um93QW5kQ29sdW1uTGVuXHJcbiAgICBjb2x1bW5sZW46SWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5MZW5cclxuICAgIHJvd2hpZGRlbjpJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlblxyXG4gICAgY29saGlkZGVuOklsdWNreVNoZWV0Um93QW5kQ29sdW1uSGlkZGVuXHJcblxyXG4gICAgY3VzdG9tSGVpZ2h0OklsdWNreVNoZWV0Um93QW5kQ29sdW1uSGlkZGVuXHJcbiAgICBjdXN0b21XaWR0aDpJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlblxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wIGltcGxlbWVudHMgSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcHtcclxuICAgIHJhbmdlVHlwZTpzdHJpbmdcclxuICAgIC8vIGNlbGxzOnN0cmluZ1tdXHJcbiAgICB2YWx1ZTpJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlIGltcGxlbWVudHMgSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVle1xyXG4gICAgcm93X2luZGV4OiBudW1iZXJcclxuICAgIGNvbF9pbmRleDogbnVtYmVyXHJcbiAgICBsOiBJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZVxyXG4gICAgcjogSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGVcclxuICAgIHQ6IElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxlXHJcbiAgICBiOiBJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZSBpbXBsZW1lbnRzIElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxle1xyXG4gICAgXCJzdHlsZVwiOiBudW1iZXJcclxuICAgIFwiY29sb3JcIjogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreVNoZWV0Q29uZmlnTWVyZ2UgaW1wbGVtZW50cyBJbHVja3lTaGVldENvbmZpZ01lcmdle1xyXG4gICAgcjogbnVtYmVyXHJcbiAgICBjOiBudW1iZXJcclxuICAgIHJzOiBudW1iZXJcclxuICAgIGNzOiBudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5c2hlZXRDYWxjQ2hhaW4gaW1wbGVtZW50cyBJbHVja3lzaGVldENhbGNDaGFpbntcclxuICAgIHI6bnVtYmVyXHJcbiAgICBjOm51bWJlclxyXG4gICAgaW5kZXg6c3RyaW5nIHwgdW5kZWZpbmVkXHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lJbWFnZUJhc2UgaW1wbGVtZW50cyBJbHVja3lJbWFnZXtcclxuICAgIGJvcmRlcjogSWx1Y2t5SW1hZ2VCb3JkZXJcclxuICAgIGNyb3A6IElsdWNreUltYWdlQ3JvcFxyXG4gICAgZGVmYXVsdDogSWx1Y2t5SW1hZ2VEZWZhdWx0XHJcblxyXG4gICAgZml4ZWRMZWZ0OiBudW1iZXJcclxuICAgIGZpeGVkVG9wOiBudW1iZXJcclxuICAgIGlzRml4ZWRQb3M6IEJvb2xlYW5cclxuICAgIG9yaWdpbkhlaWdodDogbnVtYmVyXHJcbiAgICBvcmlnaW5XaWR0aDogbnVtYmVyXHJcbiAgICBzcmM6IHN0cmluZ1xyXG4gICAgdHlwZTogc3RyaW5nXHJcbn0iLCJpbXBvcnQgeyBJbHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wLElsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSxJbHVja3lTaGVldENlbGxkYXRhVmFsdWVNZXJnZSxJTHVja3lTaGVldENlbGxGb3JtYXQgfSBmcm9tIFwiLi9JTHVja1wiO1xyXG5pbXBvcnQgeyBSZWFkWG1sLCBFbGVtZW50LCBJU3R5bGVDb2xsZWN0aW9ucyxnZXRDb2xvcixnZXRsaW5lU3RyaW5nQXR0ciB9IGZyb20gXCIuL1JlYWRYbWxcIjtcclxuaW1wb3J0IHtnZXRYbWxBdHRpYnV0ZSwgZ2V0Q29sdW1uV2lkdGhQaXhlbCwgZ2V0Um93SGVpZ2h0UGl4ZWwsZ2V0Y2VsbHJhbmdlLCBlc2NhcGVDaGFyYWN0ZXIsIGlzQ2hpbmVzZSwgaXNKYXBhbmVzZSwgaXNLb2VyYSxpc0NvbnRhaW5NdWx0aVR5cGV9IGZyb20gXCIuLi9jb21tb24vbWV0aG9kXCI7XHJcbmltcG9ydCB7IFNUX0NlbGxUeXBlLCBpbmRleGVkQ29sb3JzLCBPRU1fQ0hBUlNFVCxib3JkZXJUeXBlcyxmb250RmFtaWx5cyB9IGZyb20gXCIuLi9jb21tb24vY29uc3RhbnRcIlxyXG5pbXBvcnQgeyBJYXR0cmlidXRlTGlzdCwgc3RyaW5nVG9OdW0gfSBmcm9tIFwiLi4vSUNvbW1vblwiO1xyXG5pbXBvcnQgeyBMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxlLEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCxMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZSxMdWNreVNoZWV0Q2VsbGRhdGFCYXNlLEx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlLEx1Y2t5U2hlZXRDZWxsRm9ybWF0LEx1Y2t5SW5saW5lU3RyaW5nIH0gZnJvbSBcIi4vTHVja3lCYXNlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldENlbGxkYXRhIGV4dGVuZHMgTHVja3lTaGVldENlbGxkYXRhQmFzZXtcclxuICAgIF9ib3JkZXJPYmplY3Q6SWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcFxyXG4gICAgX2ZvbXVsYVJlZjpzdHJpbmdcclxuICAgIF9mb3JtdWxhU2k6c3RyaW5nXHJcbiAgICBfZm9ybXVsYVR5cGU6c3RyaW5nXHJcblxyXG4gICAgcHJpdmF0ZSBzaGVldEZpbGU6c3RyaW5nXHJcbiAgICBwcml2YXRlIHJlYWRYbWw6UmVhZFhtbFxyXG4gICAgcHJpdmF0ZSBjZWxsOkVsZW1lbnRcclxuICAgIHByaXZhdGUgc3R5bGVzOklTdHlsZUNvbGxlY3Rpb25zXHJcbiAgICBwcml2YXRlIHNoYXJlZFN0cmluZ3M6RWxlbWVudFtdXHJcbiAgICBwcml2YXRlIG1lcmdlQ2VsbHM6RWxlbWVudFtdXHJcblxyXG4gICAgY29uc3RydWN0b3IoY2VsbDpFbGVtZW50LCBzdHlsZXM6SVN0eWxlQ29sbGVjdGlvbnMsIHNoYXJlZFN0cmluZ3M6RWxlbWVudFtdLCBtZXJnZUNlbGxzOkVsZW1lbnRbXSwgc2hlZXRGaWxlOnN0cmluZywgUmVhZFhtbDpSZWFkWG1sKXtcclxuICAgICAgICAvL1ByaXZhdGVcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY2VsbCA9IGNlbGw7XHJcbiAgICAgICAgdGhpcy5zaGVldEZpbGUgPSBzaGVldEZpbGU7XHJcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRTdHJpbmdzID0gc2hhcmVkU3RyaW5ncztcclxuICAgICAgICB0aGlzLnJlYWRYbWwgPSBSZWFkWG1sO1xyXG4gICAgICAgIHRoaXMubWVyZ2VDZWxscyA9IG1lcmdlQ2VsbHM7XHJcblxyXG4gICAgICAgIGxldCBhdHRyTGlzdCA9IGNlbGwuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICBsZXQgciA9IGF0dHJMaXN0LnIsIHMgPSBhdHRyTGlzdC5zLCB0ID0gYXR0ckxpc3QudDtcclxuICAgICAgICBsZXQgcmFuZ2UgPSBnZXRjZWxscmFuZ2Uocik7XHJcblxyXG4gICAgICAgIHRoaXMuciA9IHJhbmdlLnJvd1swXTtcclxuICAgICAgICB0aGlzLmMgPSByYW5nZS5jb2x1bW5bMF07XHJcbiAgICAgICAgdGhpcy52ID0gdGhpcy5nZW5lcmF0ZVZhbHVlKHMsIHQpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQHBhcmFtIHMgU3R5bGUgaW5kZXggLHN0YXJ0IDFcclxuICAgICogQHBhcmFtIHQgQ2VsbCB0eXBlLCBPcHRpb25hbCB2YWx1ZSBpcyBTVF9DZWxsVHlwZSwgaXQncyBmb3VuZCBhdCBjb25zdGF0LnRzXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZVZhbHVlKHM6c3RyaW5nLCB0OnN0cmluZyl7XHJcbiAgICAgICAgbGV0IHYgPSB0aGlzLmNlbGwuZ2V0SW5uZXJFbGVtZW50cyhcInZcIik7XHJcbiAgICAgICAgbGV0IGYgPSB0aGlzLmNlbGwuZ2V0SW5uZXJFbGVtZW50cyhcImZcIik7XHJcblxyXG4gICAgICAgIGlmKHY9PW51bGwpe1xyXG4gICAgICAgICAgICB2ID0gdGhpcy5jZWxsLmdldElubmVyRWxlbWVudHMoXCJ0XCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNlbGxYZnMgPSB0aGlzLnN0eWxlc1tcImNlbGxYZnNcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgICAgIGxldCBjZWxsU3R5bGVYZnMgPSB0aGlzLnN0eWxlc1tcImNlbGxTdHlsZVhmc1wiXSBhcyBFbGVtZW50W107XHJcbiAgICAgICAgbGV0IGNlbGxTdHlsZXMgPSB0aGlzLnN0eWxlc1tcImNlbGxTdHlsZXNcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgICAgIGxldCBmb250cyA9IHRoaXMuc3R5bGVzW1wiZm9udHNcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgICAgIGxldCBmaWxscyA9IHRoaXMuc3R5bGVzW1wiZmlsbHNcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgICAgIGxldCBib3JkZXJzID0gdGhpcy5zdHlsZXNbXCJib3JkZXJzXCJdIGFzIEVsZW1lbnRbXTtcclxuICAgICAgICBsZXQgbnVtZm10cyA9IHRoaXMuc3R5bGVzW1wibnVtZm10c1wiXSBhcyBJYXR0cmlidXRlTGlzdDtcclxuICAgICAgICBsZXQgY2xyU2NoZW1lID0gdGhpcy5zdHlsZXNbXCJjbHJTY2hlbWVcIl0gYXMgRWxlbWVudFtdO1xyXG5cclxuICAgICAgICBsZXQgc2hhcmVkU3RyaW5ncyA9IHRoaXMuc2hhcmVkU3RyaW5ncztcclxuICAgICAgICBsZXQgY2VsbFZhbHVlID0gbmV3IEx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlKCk7XHJcblxyXG4gICAgICAgIGlmKGYhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgZm9ybXVsYSA9IGZbMF0sIGF0dHJMaXN0ID0gZm9ybXVsYS5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICBsZXQgdCA9IGF0dHJMaXN0LnQsIHJlZiA9IGF0dHJMaXN0LnJlZiwgc2kgPSBhdHRyTGlzdC5zaTtcclxuICAgICAgICAgICAgbGV0IGZvcm11bGFWYWx1ZSA9ZlswXS52YWx1ZTtcclxuICAgICAgICAgICAgaWYodD09XCJzaGFyZWRcIil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb211bGFSZWYgPSByZWY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JtdWxhVHlwZSA9IHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JtdWxhU2kgPSBzaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZWYsIHQsIHNpKTtcclxuICAgICAgICAgICAgaWYocmVmIT1udWxsIHx8IChmb3JtdWxhVmFsdWUhPW51bGwgJiYgZm9ybXVsYVZhbHVlLmxlbmd0aD4wKSl7XHJcbiAgICAgICAgICAgICAgICBmb3JtdWxhVmFsdWUgPSBlc2NhcGVDaGFyYWN0ZXIoZm9ybXVsYVZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5mID0gXCI9XCIgKyBmb3JtdWxhVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZmFtaWx5Rm9udCA9IG51bGw7XHJcbiAgICAgICAgbGV0IHF1b3RlUHJlZml4O1xyXG4gICAgICAgIGlmKHMhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgc051bSA9IHBhcnNlSW50KHMpO1xyXG4gICAgICAgICAgICBsZXQgY2VsbFhmID0gY2VsbFhmc1tzTnVtXTtcclxuICAgICAgICAgICAgbGV0IHhmSWQgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC54ZklkO1xyXG5cclxuICAgICAgICAgICAgbGV0IG51bUZtdElkLGZvbnRJZCxmaWxsSWQsYm9yZGVySWQ7XHJcbiAgICAgICAgICAgIGxldCBob3Jpem9udGFsLHZlcnRpY2FsLCB3cmFwVGV4dCwgdGV4dFJvdGF0aW9uLCBzaHJpbmtUb0ZpdCwgaW5kZW50LGFwcGx5UHJvdGVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGlmKHhmSWQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbGxTdHlsZVhmID0gY2VsbFN0eWxlWGZzW3BhcnNlSW50KHhmSWQpXTtcclxuICAgICAgICAgICAgICAgIGxldCBhdHRyTGlzdCA9IGNlbGxTdHlsZVhmLmF0dHJpYnV0ZUxpc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGFwcGx5TnVtYmVyRm9ybWF0ID0gYXR0ckxpc3QuYXBwbHlOdW1iZXJGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXBwbHlGb250ID0gYXR0ckxpc3QuYXBwbHlGb250O1xyXG4gICAgICAgICAgICAgICAgbGV0IGFwcGx5RmlsbCA9IGF0dHJMaXN0LmFwcGx5RmlsbDtcclxuICAgICAgICAgICAgICAgIGxldCBhcHBseUJvcmRlciA9IGF0dHJMaXN0LmFwcGx5Qm9yZGVyO1xyXG4gICAgICAgICAgICAgICAgbGV0IGFwcGx5QWxpZ25tZW50ID0gYXR0ckxpc3QuYXBwbHlBbGlnbm1lbnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBsZXQgYXBwbHlQcm90ZWN0aW9uID0gYXR0ckxpc3QuYXBwbHlQcm90ZWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIGFwcGx5UHJvdGVjdGlvbiA9IGF0dHJMaXN0LmFwcGx5UHJvdGVjdGlvbjtcclxuICAgICAgICAgICAgICAgIHF1b3RlUHJlZml4ID0gYXR0ckxpc3QucXVvdGVQcmVmaXg7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYXBwbHlOdW1iZXJGb3JtYXQhPVwiMFwiICYmIGF0dHJMaXN0Lm51bUZtdElkIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZihhdHRyTGlzdC5udW1GbXRJZCE9XCIwXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1GbXRJZCA9IGF0dHJMaXN0Lm51bUZtdElkO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGFwcGx5Rm9udCE9XCIwXCIgJiYgYXR0ckxpc3QuZm9udElkIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBmb250SWQgPSBhdHRyTGlzdC5mb250SWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihhcHBseUZpbGwhPVwiMFwiICYmIGF0dHJMaXN0LmZpbGxJZCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbElkID0gYXR0ckxpc3QuZmlsbElkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoYXBwbHlCb3JkZXIhPVwiMFwiICYmIGF0dHJMaXN0LmJvcmRlcklkIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJJZCA9IGF0dHJMaXN0LmJvcmRlcklkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoYXBwbHlBbGlnbm1lbnQhPW51bGwgJiYgYXBwbHlBbGlnbm1lbnQhPVwiMFwiKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gY2VsbFN0eWxlWGYuZ2V0SW5uZXJFbGVtZW50cyhcImFsaWdubWVudFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihhbGlnbm1lbnQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSBhbGlnbm1lbnRbMF0uYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QuaG9yaXpvbnRhbCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsID0gYXR0ckxpc3QuaG9yaXpvbnRhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC52ZXJ0aWNhbCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbCA9IGF0dHJMaXN0LnZlcnRpY2FsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LndyYXBUZXh0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBUZXh0ID0gYXR0ckxpc3Qud3JhcFRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QudGV4dFJvdGF0aW9uIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRSb3RhdGlvbiA9IGF0dHJMaXN0LnRleHRSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC5zaHJpbmtUb0ZpdCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHJpbmtUb0ZpdCA9IGF0dHJMaXN0LnNocmlua1RvRml0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LmluZGVudCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSBhdHRyTGlzdC5pbmRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBhcHBseU51bWJlckZvcm1hdCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LmFwcGx5TnVtYmVyRm9ybWF0O1xyXG4gICAgICAgICAgICBsZXQgYXBwbHlGb250ID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlGb250O1xyXG4gICAgICAgICAgICBsZXQgYXBwbHlGaWxsID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlGaWxsO1xyXG4gICAgICAgICAgICBsZXQgYXBwbHlCb3JkZXIgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5hcHBseUJvcmRlcjtcclxuICAgICAgICAgICAgbGV0IGFwcGx5QWxpZ25tZW50ID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlBbGlnbm1lbnQ7XHJcblxyXG4gICAgICAgICAgICBpZihjZWxsWGYuYXR0cmlidXRlTGlzdC5hcHBseVByb3RlY3Rpb24hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgYXBwbHlQcm90ZWN0aW9uID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlQcm90ZWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihjZWxsWGYuYXR0cmlidXRlTGlzdC5xdW90ZVByZWZpeCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBxdW90ZVByZWZpeCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LnF1b3RlUHJlZml4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihhcHBseU51bWJlckZvcm1hdCE9XCIwXCIgJiYgY2VsbFhmLmF0dHJpYnV0ZUxpc3QubnVtRm10SWQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgbnVtRm10SWQgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5udW1GbXRJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihhcHBseUZvbnQhPVwiMFwiKXtcclxuICAgICAgICAgICAgICAgIGZvbnRJZCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LmZvbnRJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihhcHBseUZpbGwhPVwiMFwiKXtcclxuICAgICAgICAgICAgICAgIGZpbGxJZCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LmZpbGxJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihhcHBseUJvcmRlciE9XCIwXCIpe1xyXG4gICAgICAgICAgICAgICAgYm9yZGVySWQgPWNlbGxYZi5hdHRyaWJ1dGVMaXN0LmJvcmRlcklkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGFwcGx5QWxpZ25tZW50IT1cIjBcIil7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gY2VsbFhmLmdldElubmVyRWxlbWVudHMoXCJhbGlnbm1lbnRcIik7XHJcbiAgICAgICAgICAgICAgICBpZihhbGlnbm1lbnQhPW51bGwgJiYgYWxpZ25tZW50Lmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSBhbGlnbm1lbnRbMF0uYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC5ob3Jpem9udGFsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbCA9IGF0dHJMaXN0Lmhvcml6b250YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LnZlcnRpY2FsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWwgPSBhdHRyTGlzdC52ZXJ0aWNhbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3Qud3JhcFRleHQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwVGV4dCA9IGF0dHJMaXN0LndyYXBUZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC50ZXh0Um90YXRpb24hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Um90YXRpb24gPSBhdHRyTGlzdC50ZXh0Um90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LnNocmlua1RvRml0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hyaW5rVG9GaXQgPSBhdHRyTGlzdC5zaHJpbmtUb0ZpdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QuaW5kZW50IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gYXR0ckxpc3QuaW5kZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBpZihudW1GbXRJZCE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIGxldCBudW1mID0gbnVtZm10c1twYXJzZUludChudW1GbXRJZCldO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbGxGb3JtYXQgPSBuZXcgTHVja3lTaGVldENlbGxGb3JtYXQoKTtcclxuICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQuZmEgPSBlc2NhcGVDaGFyYWN0ZXIobnVtZik7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhudW1mLCBudW1GbXRJZCwgdGhpcy52KTtcclxuICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQudCA9IHQgfHwgJ2QnO1xyXG4gICAgICAgICAgICAgICAgY2VsbFZhbHVlLmN0ID0gY2VsbEZvcm1hdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZmlsbElkIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGxJZE51bSA9IHBhcnNlSW50KGZpbGxJZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsbCAgPSBmaWxsc1tmaWxsSWROdW1dO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY2VsbFZhbHVlLnYpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJnID0gdGhpcy5nZXRCYWNrZ3JvdW5kQnlGaWxsKGZpbGwsIGNsclNjaGVtZSk7XHJcbiAgICAgICAgICAgICAgICBpZihiZyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmJnID0gYmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBpZihmb250SWQhPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZm9udElkTnVtID0gcGFyc2VJbnQoZm9udElkKTtcclxuICAgICAgICAgICAgICAgIGxldCBmb250ID0gZm9udHNbZm9udElkTnVtXTtcclxuICAgICAgICAgICAgICAgIGlmKGZvbnQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzeiA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcInN6XCIpOy8vZm9udCBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9ycyA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcImNvbG9yXCIpOy8vZm9udCBjb2xvclxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmYW1pbHkgPSBmb250LmdldElubmVyRWxlbWVudHMoXCJuYW1lXCIpOy8vZm9udCBmYW1pbHlcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmFtaWx5T3ZlcnJpZGVzID0gZm9udC5nZXRJbm5lckVsZW1lbnRzKFwiZmFtaWx5XCIpOy8vZm9udCBmYW1pbHkgd2lsbCBiZSBvdmVycmlkZWQgYnkgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGFyc2V0ID0gZm9udC5nZXRJbm5lckVsZW1lbnRzKFwiY2hhcnNldFwiKTsvL2ZvbnQgY2hhcnNldFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBib2xkcyA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcImJcIik7Ly9mb250IGJvbGRcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXRhbGljcyA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcImlcIik7Ly9mb250IGl0YWxpY1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHJpa2VzID0gZm9udC5nZXRJbm5lckVsZW1lbnRzKFwic3RyaWtlXCIpOy8vZm9udCBpdGFsaWNcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdW5kZXJsaW5lcyA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcInVcIik7Ly9mb250IGl0YWxpY1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihzeiE9bnVsbCAmJiBzei5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcyA9IHN6WzBdLmF0dHJpYnV0ZUxpc3QudmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmcyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuZnMgPSBwYXJzZUludChmcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihjb2xvcnMhPW51bGwgJiYgY29sb3JzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gY29sb3JzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmMgPSBnZXRDb2xvcihjb2xvciwgdGhpcy5zdHlsZXMsIFwidFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmZjID0gZmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihmYW1pbHlPdmVycmlkZXMhPW51bGwgJiYgZmFtaWx5T3ZlcnJpZGVzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IGZhbWlseU92ZXJyaWRlc1swXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodmFsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbWlseUZvbnQgPSBmb250RmFtaWx5c1t2YWxdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihmYW1pbHkhPW51bGwgJiYgZmFtaWx5Lmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IGZhbWlseVswXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodmFsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5mZiA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGJvbGRzIT1udWxsICYmIGJvbGRzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJvbGQgPSBib2xkc1swXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYm9sZD09XCIwXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmJsID0gIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5ibCA9ICAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihpdGFsaWNzIT1udWxsICYmIGl0YWxpY3MubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRhbGljID0gaXRhbGljc1swXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRhbGljPT1cIjBcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaXQgPSAgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLml0ID0gIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN0cmlrZXMhPW51bGwgJiYgc3RyaWtlcy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdHJpa2UgPSBzdHJpa2VzWzBdLmF0dHJpYnV0ZUxpc3QudmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzdHJpa2U9PVwiMFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5jbCA9ICAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuY2wgPSAgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodW5kZXJsaW5lcyE9bnVsbMKgJibCoHVuZGVybGluZXMubGVuZ3RoPjApe1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBsZXTCoHVuZGVybGluZcKgPcKgdW5kZXJsaW5lc1swXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgaWYodW5kZXJsaW5lPT1cInNpbmdsZVwiKXtcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjZWxsVmFsdWUudW7CoD3CoMKgMTtcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfVxyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBlbHNlwqBpZih1bmRlcmxpbmU9PVwiZG91YmxlXCIpe1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNlbGxWYWx1ZS51bsKgPcKgwqAyO1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGVsc2XCoGlmKHVuZGVybGluZT09XCJzaW5nbGVBY2NvdW50aW5nXCIpe1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNlbGxWYWx1ZS51bsKgPcKgwqAzO1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGVsc2XCoGlmKHVuZGVybGluZT09XCJkb3VibGVBY2NvdW50aW5nXCIpe1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNlbGxWYWx1ZS51bsKgPcKgwqA0O1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGVsc2V7XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY2VsbFZhbHVlLnVuwqA9wqDCoDA7XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH1cclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdnQ6IG51bWJlciB8IHVuZGVmaW5lZC8vVmVydGljYWwgYWxpZ25tZW50LCAwIG1pZGRsZSwgMSB1cCwgMiBkb3duLCBhbGlnbm1lbnRcclxuICAgICAgICAgICAgLy8gaHQ6IG51bWJlciB8IHVuZGVmaW5lZC8vSG9yaXpvbnRhbCBhbGlnbm1lbnQsMCBjZW50ZXIsIDEgbGVmdCwgMiByaWdodCwgYWxpZ25tZW50XHJcbiAgICAgICAgICAgIC8vIHRyOiBudW1iZXIgfCB1bmRlZmluZWQgLy9UZXh0IHJvdGF0aW9uLDA6IDDjgIExOiA0NSDjgIEyOiAtNDXjgIEzIFZlcnRpY2FsIHRleHTjgIE0OiA5MCDjgIE1OiAtOTAsIGFsaWdubWVudFxyXG4gICAgICAgICAgICAvLyB0YjogbnVtYmVyIHwgdW5kZWZpbmVkIC8vVGV4dCB3cmFwLDAgdHJ1bmNhdGlvbiwgMSBvdmVyZmxvdywgMiB3b3JkIHdyYXAsIGFsaWdubWVudFxyXG5cclxuICAgICAgICAgICAgaWYoaG9yaXpvbnRhbCE9dW5kZWZpbmVkKXsvL0hvcml6b250YWwgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICBpZihob3Jpem9udGFsPT1cImNlbnRlclwiKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihob3Jpem9udGFsPT1cImNlbnRlckNvbnRpbnVvdXNcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmh0ID0gMDsvL2x1Y2t5c2hlZXQgdW5zdXBwb3J0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGhvcml6b250YWw9PVwibGVmdFwiKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaHQgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihob3Jpem9udGFsPT1cInJpZ2h0XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5odCA9IDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGhvcml6b250YWw9PVwiZGlzdHJpYnV0ZWRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmh0ID0gMDsvL2x1Y2t5c2hlZXQgdW5zdXBwb3J0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGhvcml6b250YWw9PVwiZmlsbFwiKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaHQgPSAxOy8vbHVja3lzaGVldCB1bnN1cHBvcnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaG9yaXpvbnRhbD09XCJnZW5lcmFsXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5odCA9IDE7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihob3Jpem9udGFsPT1cImp1c3RpZnlcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmh0ID0gMDsvL2x1Y2t5c2hlZXQgdW5zdXBwb3J0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5odCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHZlcnRpY2FsIT11bmRlZmluZWQpey8vVmVydGljYWwgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICBpZih2ZXJ0aWNhbD09XCJib3R0b21cIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnZ0ID0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodmVydGljYWw9PVwiY2VudGVyXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52dCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHZlcnRpY2FsPT1cImRpc3RyaWJ1dGVkXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52dCA9IDA7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZih2ZXJ0aWNhbD09XCJqdXN0aWZ5XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52dCA9IDA7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZih2ZXJ0aWNhbD09XCJ0b3BcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnZ0ID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnZ0ID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vc29tZXRpbWVzIGJvdHRvbSBzdHlsZSBpcyBsb3N0IGFmdGVyIHNldHRpbmcgaXQgaW4gZXhjZWxcclxuICAgICAgICAgICAgICAgIC8vd2hlbiB2ZXJ0aWNhbCBpcyB1bmRlZmluZWQgc2V0IGl0IHRvIDIuXHJcbiAgICAgICAgICAgICAgICBjZWxsVmFsdWUudnQgPSAyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih3cmFwVGV4dCE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIGlmKHdyYXBUZXh0PT1cIjFcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnRiID0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnRiID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgY2VsbFZhbHVlLnRiID0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYodGV4dFJvdGF0aW9uIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgLy8gdHI6IG51bWJlciB8IHVuZGVmaW5lZCAvL1RleHQgcm90YXRpb24sMDogMOOAgTE6IDQ1IOOAgTI6IC00NeOAgTMgVmVydGljYWwgdGV4dOOAgTQ6IDkwIOOAgTU6IC05MCwgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICBpZih0ZXh0Um90YXRpb249PVwiMjU1XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS50ciA9IDM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBlbHNlIGlmKHRleHRSb3RhdGlvbj09XCI0NVwiKXtcclxuICAgICAgICAgICAgICAgIC8vICAgICBjZWxsVmFsdWUudHIgPSAxO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgLy8gZWxzZSBpZih0ZXh0Um90YXRpb249PVwiOTBcIil7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgY2VsbFZhbHVlLnRyID0gNDtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYodGV4dFJvdGF0aW9uPT1cIjEzNVwiKXtcclxuICAgICAgICAgICAgICAgIC8vICAgICBjZWxsVmFsdWUudHIgPSAyO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgLy8gZWxzZSBpZih0ZXh0Um90YXRpb249PVwiMTgwXCIpe1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGNlbGxWYWx1ZS50ciA9IDU7XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS50ciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnJ0ID0gIHBhcnNlSW50KHRleHRSb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoc2hyaW5rVG9GaXQhPXVuZGVmaW5lZCl7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoaW5kZW50IT11bmRlZmluZWQpey8vbHVja3lzaGVldCB1bnN1cHBvcnRcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGJvcmRlcklkIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvcmRlcklkTnVtID0gcGFyc2VJbnQoYm9yZGVySWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvcmRlciA9IGJvcmRlcnNbYm9yZGVySWROdW1dO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fYm9yZGVySWQgPSBib3JkZXJJZE51bTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgYm9yZGVyT2JqZWN0ID0gbmV3IEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCgpO1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyT2JqZWN0LnJhbmdlVHlwZSA9IFwiY2VsbFwiO1xyXG4gICAgICAgICAgICAgICAgLy8gYm9yZGVyT2JqZWN0LmNlbGxzID0gW107XHJcbiAgICAgICAgICAgICAgICBsZXQgYm9yZGVyQ2VsbFZhbHVlID0gbmV3IEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLnJvd19pbmRleCA9IHRoaXMucjtcclxuICAgICAgICAgICAgICAgIGJvcmRlckNlbGxWYWx1ZS5jb2xfaW5kZXggPSB0aGlzLmM7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGxlZnRzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJsZWZ0XCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0cyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwicmlnaHRcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG9wcyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwidG9wXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvdHRvbXMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcImJvdHRvbVwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBkaWFnb25hbHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcImRpYWdvbmFsXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBzdGFydHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcInN0YXJ0XCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVuZHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcImVuZFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhsZWZ0cyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLmdldEJvcmRlckluZm8ocmlnaHRzKTtcclxuICAgICAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLmdldEJvcmRlckluZm8odG9wcyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgYm90dG9tID0gdGhpcy5nZXRCb3JkZXJJbmZvKGJvdHRvbXMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpYWdvbmFsID0gdGhpcy5nZXRCb3JkZXJJbmZvKGRpYWdvbmFscyk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5nZXRCb3JkZXJJbmZvKHN0YXJ0cyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5nZXRCb3JkZXJJbmZvKGVuZHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBpc0FkZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN0YXJ0IT1udWxsICYmIHN0YXJ0LmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUubCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWRkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihlbmQhPW51bGwgJiYgZW5kLmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUuciA9IGVuZDtcclxuICAgICAgICAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYobGVmdCE9bnVsbCAmJiBsZWZ0LmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUubCA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHJpZ2h0IT1udWxsICYmIHJpZ2h0LmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUuciA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWRkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZih0b3AhPW51bGwgJiYgdG9wLmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUudCA9IHRvcDtcclxuICAgICAgICAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYm90dG9tIT1udWxsICYmIGJvdHRvbS5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLmIgPSBib3R0b207XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGlzQWRkKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJPYmplY3QudmFsdWUgPSBib3JkZXJDZWxsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5jb25maWcuX2JvcmRlckluZm9bYm9yZGVySWRdID0gYm9yZGVyT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JvcmRlck9iamVjdCA9IGJvcmRlck9iamVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgY2VsbFZhbHVlLnRiID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHYhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPXZbMF0udmFsdWU7XHJcblxyXG4gICAgICAgICAgICBpZigvJiNcXGQrOy8udGVzdCh2YWx1ZSkpe1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmh0bWxEZWNvZGUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih0PT1TVF9DZWxsVHlwZVtcIlNoYXJlZFN0cmluZ1wiXSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2lJbmRleCA9IHBhcnNlSW50KHZbMF0udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNoYXJlZFNJID0gc2hhcmVkU3RyaW5nc1tzaUluZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgckZsYWcgPSBzaGFyZWRTSS5nZXRJbm5lckVsZW1lbnRzKFwiclwiKTtcclxuICAgICAgICAgICAgICAgIGlmKHJGbGFnPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdEZsYWcgPSBzaGFyZWRTSS5nZXRJbm5lckVsZW1lbnRzKFwidFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZih0RmxhZyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdEZsYWcuZm9yRWFjaCgodCk9PntcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gdC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlQ2hhcmFjdGVyKHRleHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pc0NvbnRhaW5NdWx0aVR5cGUodGV4dCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmFtaWx5Rm9udD09XCJSb21hblwiICYmIHRleHQubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHRBcnJheSA9IHRleHQuc3BsaXQoXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJlV29yZFR5cGU6c3RyaW5nID0gbnVsbCwgd29yZFRleHQ9XCJcIiwgcHJlV2hvbGVmOnN0cmluZz1udWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdob2xlZiA9IFwiVGltZXMgTmV3IFJvbWFuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZmYhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdob2xlZiA9IGNlbGxWYWx1ZS5mZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbEZvcm1hdCA9IGNlbGxWYWx1ZS5jdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxGb3JtYXQ9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQgPSBuZXcgTHVja3lTaGVldENlbGxGb3JtYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsRm9ybWF0LnM9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8dGV4dEFycmF5Lmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3ID0gdGV4dEFycmF5W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eXBlOnN0cmluZyA9IG51bGwsIGZmPXdob2xlZjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNDaGluZXNlKHcpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwiY1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZj1cIuWui+S9k1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGlzSmFwYW5lc2Uodykpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJqXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZmPVwiWXUgR290aGljXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNLb2VyYSh3KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImtcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmY9XCJNYWxndW4gR290aGljXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImVcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCh0eXBlIT1wcmVXb3JkVHlwZSAmJiBwcmVXb3JkVHlwZSE9bnVsbCkgfHwgaT09dGV4dEFycmF5Lmxlbmd0aC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IElubGluZVN0cmluZyA9IG5ldyBMdWNreUlubGluZVN0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZmID0gcHJlV2hvbGVmO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmZjIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mYyA9IGNlbGxWYWx1ZS5mYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmZzIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mcyA9IGNlbGxWYWx1ZS5mcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmNsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5jbCA9IGNlbGxWYWx1ZS5jbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLnVuIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy51biA9IGNlbGxWYWx1ZS51bjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmJsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5ibCA9IGNlbGxWYWx1ZS5ibDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLml0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5pdCA9IGNlbGxWYWx1ZS5pdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaT09dGV4dEFycmF5Lmxlbmd0aC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGU9PXByZVdvcmRUeXBlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmYgPSBmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudiA9IHdvcmRUZXh0ICsgdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZmID0gcHJlV2hvbGVmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy52ID0gd29yZFRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEZvcm1hdC5zLnB1c2goSW5saW5lU3RyaW5nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IElubGluZVN0cmluZ0xhc3QgPSBuZXcgTHVja3lJbmxpbmVTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmdMYXN0LmZmID0gZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC52ID0gdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZmMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmdMYXN0LmZjID0gY2VsbFZhbHVlLmZjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmZzIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC5mcyA9IGNlbGxWYWx1ZS5mcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5jbCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZ0xhc3QuY2wgPSBjZWxsVmFsdWUuY2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUudW4hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmdMYXN0LnVuID0gY2VsbFZhbHVlLnVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmJsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC5ibCA9IGNlbGxWYWx1ZS5ibDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5pdCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZ0xhc3QuaXQgPSBjZWxsVmFsdWUuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQucy5wdXNoKElubGluZVN0cmluZ0xhc3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnYgPSB3b3JkVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQucy5wdXNoKElubGluZVN0cmluZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkVGV4dCA9IHc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRUZXh0ICs9IHc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlV29yZFR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZVdob2xlZiA9IGZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQudCA9IFwiaW5saW5lU3RyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjZWxsRm9ybWF0LnMgPSBbSW5saW5lU3RyaW5nXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5jdCA9IGNlbGxGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjZWxsVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLnJlcGxhY2VTcGVjaWFsV3JhcCh0ZXh0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0ZXh0LmluZGV4T2YoXCJcXHJcXG5cIik+LTEgfHwgdGV4dC5pbmRleE9mKFwiXFxuXCIpPi0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgSW5saW5lU3RyaW5nID0gbmV3IEx1Y2t5SW5saW5lU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnYgPSB0ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjZWxsRm9ybWF0ID0gY2VsbFZhbHVlLmN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxGb3JtYXQ9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0ID0gbmV3IEx1Y2t5U2hlZXRDZWxsRm9ybWF0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZmYhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmYgPSBjZWxsVmFsdWUuZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZmMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjZWxsVmFsdWUuZmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZnMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZnMgPSBjZWxsVmFsdWUuZnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuY2whPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuY2wgPSBjZWxsVmFsdWUuY2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUudW4hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudW4gPSBjZWxsVmFsdWUudW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuYmwhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuYmwgPSBjZWxsVmFsdWUuYmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuaXQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuaXQgPSBjZWxsVmFsdWUuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnQgPSBcImlubGluZVN0clwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQucyA9IFtJbmxpbmVTdHJpbmddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5jdCA9IGNlbGxGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52ID0gdGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90ZVByZWZpeCA9IFwiMVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlczpMdWNreUlubGluZVN0cmluZ1tdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgckZsYWcuZm9yRWFjaCgocik9PntcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRGbGFnID0gci5nZXRJbm5lckVsZW1lbnRzKFwidFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJQciA9IHIuZ2V0SW5uZXJFbGVtZW50cyhcInJQclwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBJbmxpbmVTdHJpbmcgPSBuZXcgTHVja3lJbmxpbmVTdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRGbGFnIT1udWxsICYmIHRGbGFnLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gdEZsYWdbMF0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5yZXBsYWNlU3BlY2lhbFdyYXAodGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlQ2hhcmFjdGVyKHRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnYgPSB0ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyUHIhPW51bGwgJiYgclByLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcnByID0gclByWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN6ID0gZ2V0bGluZVN0cmluZ0F0dHIoZnJwcixcInN6XCIpLCByRm9udD1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwickZvbnRcIiksIGZhbWlseT1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwiZmFtaWx5XCIpLCBjaGFyc2V0PWdldGxpbmVTdHJpbmdBdHRyKGZycHIsXCJjaGFyc2V0XCIpLCBzY2hlbWU9Z2V0bGluZVN0cmluZ0F0dHIoZnJwcixcInNjaGVtZVwiKSwgYj1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwiYlwiKSwgaT1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwiaVwiKSwgdT1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwidVwiKSwgc3RyaWtlPWdldGxpbmVTdHJpbmdBdHRyKGZycHIsXCJzdHJpa2VcIiksIHZlcnRBbGlnbj1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwidmVydEFsaWduXCIpLCBjb2xvcjtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNFbGUgPSBmcnByLmdldElubmVyRWxlbWVudHMoXCJjb2xvclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNFbGUhPW51bGwgJiYgY0VsZS5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBnZXRDb2xvcihjRWxlWzBdLHRoaXMuc3R5bGVzLCBcInRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmKGZhbWlseSE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgZmYgPSBmb250RmFtaWx5c1tmYW1pbHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYockZvbnQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZmID0gckZvbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmZiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZmID0gZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNlbGxWYWx1ZS5mZiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZmID0gY2VsbFZhbHVlLmZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY2VsbFZhbHVlLmZjIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjZWxsVmFsdWUuZmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ohPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mcyA9IHBhcnNlSW50KHN6KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY2VsbFZhbHVlLmZzIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZnMgPSBjZWxsVmFsdWUuZnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RyaWtlIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuY2wgPSBwYXJzZUludChzdHJpa2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjZWxsVmFsdWUuY2whPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5jbCA9IGNlbGxWYWx1ZS5jbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih1IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudW4gPSBwYXJzZUludCh1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY2VsbFZhbHVlLnVuIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudW4gPSBjZWxsVmFsdWUudW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmJsID0gcGFyc2VJbnQoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNlbGxWYWx1ZS5ibCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmJsID0gY2VsbFZhbHVlLmJsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGkhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5pdCA9IHBhcnNlSW50KGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjZWxsVmFsdWUuaXQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5pdCA9IGNlbGxWYWx1ZS5pdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih2ZXJ0QWxpZ24hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy52YSA9IHBhcnNlSW50KHZlcnRBbGlnbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZmOnN0cmluZyB8IHVuZGVmaW5lZCAvL2ZvbnQgZmFtaWx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYzpzdHJpbmcgfCB1bmRlZmluZWQvL2ZvbnQgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZzOm51bWJlciB8IHVuZGVmaW5lZC8vZm9udCBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbDpudW1iZXIgfCB1bmRlZmluZWQvL3N0cmlrZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW46bnVtYmVyIHwgdW5kZWZpbmVkLy91bmRlcmxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJsOm51bWJlciB8IHVuZGVmaW5lZC8vYmxvZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQ6bnVtYmVyIHwgdW5kZWZpbmVkLy9pdGFsaWNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHY6c3RyaW5nIHwgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5mZj09bnVsbCAmJiBjZWxsVmFsdWUuZmYhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mZiA9IGNlbGxWYWx1ZS5mZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihJbmxpbmVTdHJpbmcuZmM9PW51bGwgJiYgY2VsbFZhbHVlLmZjIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjZWxsVmFsdWUuZmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoSW5saW5lU3RyaW5nLmZzPT1udWxsICYmIGNlbGxWYWx1ZS5mcyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZzID0gY2VsbFZhbHVlLmZzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5jbD09bnVsbCAmJiBjZWxsVmFsdWUuY2whPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5jbCA9IGNlbGxWYWx1ZS5jbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihJbmxpbmVTdHJpbmcudW49PW51bGwgJiYgY2VsbFZhbHVlLnVuIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudW4gPSBjZWxsVmFsdWUudW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoSW5saW5lU3RyaW5nLmJsPT1udWxsICYmIGNlbGxWYWx1ZS5ibCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmJsID0gY2VsbFZhbHVlLmJsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5pdD09bnVsbCAmJiBjZWxsVmFsdWUuaXQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5pdCA9IGNlbGxWYWx1ZS5pdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKElubGluZVN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsRm9ybWF0ID0gY2VsbFZhbHVlLmN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNlbGxGb3JtYXQ9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0ID0gbmV3IEx1Y2t5U2hlZXRDZWxsRm9ybWF0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQudCA9IFwiaW5saW5lU3RyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbEZvcm1hdC5zID0gc3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5jdCA9IGNlbGxGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdG8gYmUgY29uZmlybWVkXHJcbiAgICAgICAgICAgIGVsc2UgaWYodD09U1RfQ2VsbFR5cGVbXCJJbmxpbmVTdHJpbmdcIl0gJiYgdiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBjZWxsVmFsdWUudiA9IFwiJ1wiKyB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXNjYXBlQ2hhcmFjdGVyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHF1b3RlUHJlZml4IT1udWxsKXtcclxuICAgICAgICAgICAgY2VsbFZhbHVlLnFwID0gcGFyc2VJbnQocXVvdGVQcmVmaXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNlbGxWYWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZXBsYWNlU3BlY2lhbFdyYXAodGV4dDpzdHJpbmcpOnN0cmluZ3tcclxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9feDAwMERfL2csIFwiXCIpLnJlcGxhY2UoLyYjMTM7JiMxMDsvZywgXCJcXHJcXG5cIikucmVwbGFjZSgvJiMxMzsvZywgXCJcXHJcIikucmVwbGFjZSgvJiMxMDsvZywgXCJcXG5cIik7XHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgZ2V0QmFja2dyb3VuZEJ5RmlsbChmaWxsOkVsZW1lbnQsIGNsclNjaGVtZTpFbGVtZW50W10pOnN0cmluZ3xudWxse1xyXG4gICAgICAgIGxldCBwYXR0ZXJuRmlsbHMgPSBmaWxsLmdldElubmVyRWxlbWVudHMoXCJwYXR0ZXJuRmlsbFwiKTtcclxuICAgICAgICBpZihwYXR0ZXJuRmlsbHMhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgcGF0dGVybkZpbGwgPSBwYXR0ZXJuRmlsbHNbMF07XHJcbiAgICAgICAgICAgIGxldCBmZ0NvbG9ycyA9IHBhdHRlcm5GaWxsLmdldElubmVyRWxlbWVudHMoXCJmZ0NvbG9yXCIpO1xyXG4gICAgICAgICAgICBsZXQgYmdDb2xvcnMgPSBwYXR0ZXJuRmlsbC5nZXRJbm5lckVsZW1lbnRzKFwiYmdDb2xvclwiKTtcclxuICAgICAgICAgICAgbGV0IGZnLCBiZztcclxuICAgICAgICAgICAgaWYoZmdDb2xvcnMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGZnQ29sb3IgPSBmZ0NvbG9yc1swXTtcclxuICAgICAgICAgICAgICAgIGZnID0gZ2V0Q29sb3IoZmdDb2xvciwgdGhpcy5zdHlsZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihiZ0NvbG9ycyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgYmdDb2xvciA9IGJnQ29sb3JzWzBdO1xyXG4gICAgICAgICAgICAgICAgYmcgPSBnZXRDb2xvcihiZ0NvbG9yLCB0aGlzLnN0eWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZmdDb2xvcnMsYmdDb2xvcnMsY2xyU2NoZW1lKTtcclxuICAgICAgICAgICAgaWYoZmchPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoYmchPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGxldCBncmFkaWVudGZpbGxzID0gZmlsbC5nZXRJbm5lckVsZW1lbnRzKFwiZ3JhZGllbnRGaWxsXCIpO1xyXG4gICAgICAgICAgICBpZihncmFkaWVudGZpbGxzIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIC8vZ3JhaWVudCBjb2xvciBmaWxsIGhhbmRsZXJcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEJvcmRlckluZm8oYm9yZGVyczpFbGVtZW50W10pOkx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGV7XHJcbiAgICAgICAgaWYoYm9yZGVycz09bnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGJvcmRlciA9IGJvcmRlcnNbMF0sIGF0dHJMaXN0ID0gYm9yZGVyLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgbGV0IGNsclNjaGVtZSA9IHRoaXMuc3R5bGVzW1wiY2xyU2NoZW1lXCJdIGFzIEVsZW1lbnRbXTtcclxuICAgICAgICBsZXQgc3R5bGU6c3RyaW5nID0gYXR0ckxpc3Quc3R5bGU7XHJcbiAgICAgICAgaWYoc3R5bGU9PW51bGwgfHwgc3R5bGU9PVwibm9uZVwiKXtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY29sb3JzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJjb2xvclwiKTtcclxuICAgICAgICBsZXQgY29sb3JSZXQgPSBcIiMwMDAwMDBcIjtcclxuICAgICAgICBpZihjb2xvcnMhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgY29sb3IgPSBjb2xvcnNbMF07XHJcbiAgICAgICAgICAgIGNvbG9yUmV0ID0gZ2V0Q29sb3IoY29sb3IsIHRoaXMuc3R5bGVzLCBcImJcIik7XHJcbiAgICAgICAgICAgIGlmKGNvbG9yUmV0PT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGNvbG9yUmV0ID0gXCIjMDAwMDAwXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZXQgPSBuZXcgTHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZSgpO1xyXG4gICAgICAgIHJldC5zdHlsZSA9IGJvcmRlclR5cGVzW3N0eWxlXTtcclxuICAgICAgICByZXQuY29sb3IgPSBjb2xvclJldDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGh0bWxEZWNvZGUgKHN0cjpzdHJpbmcpOnN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIyh4KT8oW14mXXsxLDV9KTsvZyxmdW5jdGlvbigkLCQxLCQyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KCQyICwgJDEgPyAxNjoxMCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbn1cclxuXHJcbiIsIu+7v2ltcG9ydCB7IElMdWNreUZpbGUsSWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5IaWRkZW4sSWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5MZW59IGZyb20gXCIuL0lMdWNrXCI7XHJcbmltcG9ydCB7IEx1Y2t5U2hlZXR9IGZyb20gXCIuL0x1Y2t5U2hlZXRcIjtcclxuaW1wb3J0IHtJdXBsb2FkZmlsZUxpc3QsIElhdHRyaWJ1dGVMaXN0fSBmcm9tIFwiLi4vSUNvbW1vblwiO1xyXG5pbXBvcnQge3dvcmtCb29rRmlsZSwgY29yZUZpbGUsIGFwcEZpbGUsIHN0eWxlc0ZpbGUsIHNoYXJlZFN0cmluZ3NGaWxlLG51bUZtdERlZmF1bHQsdGhlbWUxRmlsZSxjYWxjQ2hhaW5GaWxlLHdvcmtib29rUmVscywgbnVtRm10RGVmYXVsdE1hcH0gZnJvbSBcIi4uL2NvbW1vbi9jb25zdGFudFwiO1xyXG5pbXBvcnQgeyBSZWFkWG1sLElTdHlsZUNvbGxlY3Rpb25zLEVsZW1lbnQgfSBmcm9tIFwiLi9SZWFkWG1sXCI7XHJcbmltcG9ydCB7Z2V0WG1sQXR0aWJ1dGV9IGZyb20gXCIuLi9jb21tb24vbWV0aG9kXCI7XHJcbmltcG9ydCB7IEx1Y2t5RmlsZUJhc2UsTHVja3lGaWxlSW5mbyxMdWNreVNoZWV0QmFzZSxMdWNreVNoZWV0Q2VsbGRhdGFCYXNlLEx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlLEx1Y2t5U2hlZXRDZWxsRm9ybWF0IH0gZnJvbSBcIi4vTHVja3lCYXNlXCI7XHJcbmltcG9ydCB7SW1hZ2VMaXN0fSBmcm9tIFwiLi9MdWNreUltYWdlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lGaWxlIGV4dGVuZHMgTHVja3lGaWxlQmFzZSB7XHJcblxyXG4gICAgcHJpdmF0ZSBmaWxlczpJdXBsb2FkZmlsZUxpc3RcclxuICAgIHByaXZhdGUgc2hlZXROYW1lTGlzdDpJYXR0cmlidXRlTGlzdFxyXG4gICAgcHJpdmF0ZSByZWFkWG1sOlJlYWRYbWxcclxuICAgIHByaXZhdGUgZmlsZU5hbWU6c3RyaW5nXHJcbiAgICBwcml2YXRlIHN0eWxlczpJU3R5bGVDb2xsZWN0aW9uc1xyXG4gICAgcHJpdmF0ZSBzaGFyZWRTdHJpbmdzOkVsZW1lbnRbXVxyXG4gICAgcHJpdmF0ZSBjYWxjQ2hhaW46RWxlbWVudFtdXHJcbiAgICBwcml2YXRlIGltYWdlTGlzdDpJbWFnZUxpc3RcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihmaWxlczpJdXBsb2FkZmlsZUxpc3QsIGZpbGVOYW1lOnN0cmluZykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5maWxlcyA9IGZpbGVzO1xyXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBmaWxlTmFtZTtcclxuICAgICAgICB0aGlzLnJlYWRYbWwgPSBuZXcgUmVhZFhtbChmaWxlcyk7XHJcbiAgICAgICAgdGhpcy5nZXRTaGVldE5hbWVMaXN0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcmVkU3RyaW5ncyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNzdC9zaVwiLCBzaGFyZWRTdHJpbmdzRmlsZSk7XHJcbiAgICAgICAgdGhpcy5jYWxjQ2hhaW4gPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjYWxjQ2hhaW4vY1wiLCBjYWxjQ2hhaW5GaWxlKTtcclxuICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuc3R5bGVzW1wiY2VsbFhmc1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjZWxsWGZzL3hmXCIsIHN0eWxlc0ZpbGUpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzW1wiY2VsbFN0eWxlWGZzXCJdID0gIHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNlbGxTdHlsZVhmcy94ZlwiLCBzdHlsZXNGaWxlKTtcclxuICAgICAgICB0aGlzLnN0eWxlc1tcImNlbGxTdHlsZXNcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY2VsbFN0eWxlcy9jZWxsU3R5bGVcIiwgc3R5bGVzRmlsZSk7XHJcbiAgICAgICAgdGhpcy5zdHlsZXNbXCJmb250c1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmb250cy9mb250XCIsIHN0eWxlc0ZpbGUpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzW1wiZmlsbHNcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZmlsbHMvZmlsbFwiLCBzdHlsZXNGaWxlKTtcclxuICAgICAgICB0aGlzLnN0eWxlc1tcImJvcmRlcnNcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9yZGVycy9ib3JkZXJcIiwgc3R5bGVzRmlsZSk7XHJcbiAgICAgICAgdGhpcy5zdHlsZXNbXCJjbHJTY2hlbWVcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYTpjbHJTY2hlbWUvYTpkazF8YTpsdDF8YTpkazJ8YTpsdDJ8YTphY2NlbnQxfGE6YWNjZW50MnxhOmFjY2VudDN8YTphY2NlbnQ0fGE6YWNjZW50NXxhOmFjY2VudDZ8YTpobGlua3xhOmZvbEhsaW5rXCIsIHRoZW1lMUZpbGUpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzW1wiaW5kZXhlZENvbG9yc1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjb2xvcnMvaW5kZXhlZENvbG9ycy9yZ2JDb2xvclwiLCBzdHlsZXNGaWxlKTtcclxuICAgICAgICB0aGlzLnN0eWxlc1tcIm1ydUNvbG9yc1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjb2xvcnMvbXJ1Q29sb3JzL2NvbG9yXCIsIHN0eWxlc0ZpbGUpO1xyXG5cclxuICAgICAgICB0aGlzLmltYWdlTGlzdCA9IG5ldyBJbWFnZUxpc3QoZmlsZXMpO1xyXG5cclxuICAgICAgICBsZXQgbnVtZm10cyA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJudW1GbXQvbnVtRm10XCIsIHN0eWxlc0ZpbGUpO1xyXG4gICAgICAgIGxldCBudW1GbXREZWZhdWx0QyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobnVtRm10RGVmYXVsdCkpO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8bnVtZm10cy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgbGV0IGF0dHJMaXN0ID0gbnVtZm10c1tpXS5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICBsZXQgbnVtZm10aWQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJudW1GbXRJZFwiLCBcIjQ5XCIpO1xyXG4gICAgICAgICAgICBsZXQgZm9ybWF0Y29kZSA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcImZvcm1hdENvZGVcIiwgXCJAXCIpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhudW1mbXRpZCwgZm9ybWF0Y29kZSk7XHJcbiAgICAgICAgICAgIGlmKCEobnVtZm10aWQgaW4gbnVtRm10RGVmYXVsdCkpe1xyXG4gICAgICAgICAgICAgICAgbnVtRm10RGVmYXVsdENbbnVtZm10aWRdID0gbnVtRm10RGVmYXVsdE1hcFtmb3JtYXRjb2RlXSB8fCBmb3JtYXRjb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShudW1GbXREZWZhdWx0QyksIG51bWZtdHMpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzW1wibnVtZm10c1wiXSA9ICBudW1GbXREZWZhdWx0QztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQHJldHVybiBBbGwgc2hlZXQgbmFtZSBvZiB3b3JrYm9va1xyXG4gICAgKi9cclxuICAgIHByaXZhdGUgZ2V0U2hlZXROYW1lTGlzdCgpe1xyXG4gICAgICAgIGxldCB3b3JrYm9va1JlbExpc3QgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJSZWxhdGlvbnNoaXBzL1JlbGF0aW9uc2hpcFwiLCB3b3JrYm9va1JlbHMpO1xyXG4gICAgICAgIGlmKHdvcmtib29rUmVsTGlzdD09bnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZWdleCA9IG5ldyBSZWdFeHAoXCJ3b3Jrc2hlZXRzL1teL10qPy54bWxcIik7XHJcbiAgICAgICAgbGV0IHNoZWV0TmFtZXM6SWF0dHJpYnV0ZUxpc3QgPSB7fTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHdvcmtib29rUmVsTGlzdC5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgbGV0IHJlbCA9IHdvcmtib29rUmVsTGlzdFtpXSwgYXR0ckxpc3QgPSByZWwuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgbGV0IGlkID0gYXR0ckxpc3RbXCJJZFwiXSwgdGFyZ2V0ID0gYXR0ckxpc3RbXCJUYXJnZXRcIl07XHJcbiAgICAgICAgICAgIGlmKHJlZ2V4LnRlc3QodGFyZ2V0KSl7XHJcbiAgICAgICAgICAgICAgICBpZih0YXJnZXQuaW5kZXhPZignL3hsJykgPT09IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0TmFtZXNbaWRdID0gICB0YXJnZXQuc3Vic3RyKDEpO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hlZXROYW1lc1tpZF0gPSAgIFwieGwvXCIgKyB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNoZWV0TmFtZUxpc3QgPSBzaGVldE5hbWVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcGFyYW0gc2hlZXROYW1lIFdvcmtTaGVldCduYW1lXHJcbiAgICAqIEByZXR1cm4gc2hlZXQgZmlsZSBuYW1lIGFuZCBwYXRoIGluIHppcFxyXG4gICAgKi9cclxuICAgcHJpdmF0ZSBnZXRTaGVldEZpbGVCeXNoZWV0SWQoc2hlZXRJZDpzdHJpbmcpe1xyXG4gICAgICAgIC8vIGZvcihsZXQgaT0wO2k8dGhpcy5zaGVldE5hbWVMaXN0Lmxlbmd0aDtpKyspe1xyXG4gICAgICAgIC8vICAgICBsZXQgc2hlZXRGaWxlTmFtZSA9IHRoaXMuc2hlZXROYW1lTGlzdFtpXTtcclxuICAgICAgICAvLyAgICAgaWYoc2hlZXRGaWxlTmFtZS5pbmRleE9mKFwic2hlZXRcIitzaGVldElkKT4tMSl7XHJcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gc2hlZXRGaWxlTmFtZTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zaGVldE5hbWVMaXN0W3NoZWV0SWRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcmV0dXJuIHdvcmtCb29rIGluZm9ybWF0aW9uXHJcbiAgICAqL1xyXG4gICAgZ2V0V29ya0Jvb2tJbmZvKCl7XHJcbiAgICAgICAgbGV0IENvbXBhbnkgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJDb21wYW55XCIsIGFwcEZpbGUpO1xyXG4gICAgICAgIGxldCBBcHBWZXJzaW9uID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiQXBwVmVyc2lvblwiLCBhcHBGaWxlKTtcclxuICAgICAgICBsZXQgY3JlYXRvciA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRjOmNyZWF0b3JcIiwgY29yZUZpbGUpO1xyXG4gICAgICAgIGxldCBsYXN0TW9kaWZpZWRCeSA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNwOmxhc3RNb2RpZmllZEJ5XCIsIGNvcmVGaWxlKTtcclxuICAgICAgICBsZXQgY3JlYXRlZCA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRjdGVybXM6Y3JlYXRlZFwiLCBjb3JlRmlsZSk7XHJcbiAgICAgICAgbGV0IG1vZGlmaWVkID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGN0ZXJtczptb2RpZmllZFwiLCBjb3JlRmlsZSk7XHJcbiAgICAgICAgdGhpcy5pbmZvID0gbmV3IEx1Y2t5RmlsZUluZm8oKTtcclxuICAgICAgICB0aGlzLmluZm8ubmFtZSA9IHRoaXMuZmlsZU5hbWU7XHJcbiAgICAgICAgdGhpcy5pbmZvLmNyZWF0b3IgPSBjcmVhdG9yLmxlbmd0aD4wP2NyZWF0b3JbMF0udmFsdWU6XCJcIjtcclxuICAgICAgICB0aGlzLmluZm8ubGFzdG1vZGlmaWVkYnkgPSBsYXN0TW9kaWZpZWRCeS5sZW5ndGg+MD9sYXN0TW9kaWZpZWRCeVswXS52YWx1ZTpcIlwiO1xyXG4gICAgICAgIHRoaXMuaW5mby5jcmVhdGVkVGltZSA9IGNyZWF0ZWQubGVuZ3RoPjA/Y3JlYXRlZFswXS52YWx1ZTpcIlwiO1xyXG4gICAgICAgIHRoaXMuaW5mby5tb2RpZmllZFRpbWUgPSBtb2RpZmllZC5sZW5ndGg+MD9tb2RpZmllZFswXS52YWx1ZTpcIlwiO1xyXG4gICAgICAgIHRoaXMuaW5mby5jb21wYW55ID0gQ29tcGFueS5sZW5ndGg+MD9Db21wYW55WzBdLnZhbHVlOlwiXCI7XHJcbiAgICAgICAgdGhpcy5pbmZvLmFwcHZlcnNpb24gPSBBcHBWZXJzaW9uLmxlbmd0aD4wP0FwcFZlcnNpb25bMF0udmFsdWU6XCJcIjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQHJldHVybiBBbGwgc2hlZXQgLCBpbmNsdWRlIHdob2xlIGluZm9ybWF0aW9uXHJcbiAgICAqL1xyXG4gICAgZ2V0U2hlZXRzRnVsbChpc0luaXRpYWxDZWxsOmJvb2xlYW49dHJ1ZSl7XHJcbiAgICAgICAgbGV0IHNoZWV0cyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNoZWV0cy9zaGVldFwiLCB3b3JrQm9va0ZpbGUpO1xyXG4gICAgICAgIGxldCBzaGVldExpc3Q6SWF0dHJpYnV0ZUxpc3QgPSB7fTtcclxuICAgICAgICBmb3IobGV0IGtleSBpbiBzaGVldHMpe1xyXG4gICAgICAgICAgICBsZXQgc2hlZXQgPSBzaGVldHNba2V5XTtcclxuICAgICAgICAgICAgc2hlZXRMaXN0W3NoZWV0LmF0dHJpYnV0ZUxpc3QubmFtZV0gPSBzaGVldC5hdHRyaWJ1dGVMaXN0W1wic2hlZXRJZFwiXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zaGVldHMgPSBbXTtcclxuICAgICAgICBsZXQgb3JkZXIgPSAwO1xyXG4gICAgICAgIGZvcihsZXQga2V5IGluIHNoZWV0cyl7XHJcbiAgICAgICAgICAgIGxldCBzaGVldCA9IHNoZWV0c1trZXldO1xyXG4gICAgICAgICAgICBsZXQgc2hlZXROYW1lID0gc2hlZXQuYXR0cmlidXRlTGlzdC5uYW1lO1xyXG4gICAgICAgICAgICBsZXQgc2hlZXRJZCA9IHNoZWV0LmF0dHJpYnV0ZUxpc3RbXCJzaGVldElkXCJdO1xyXG4gICAgICAgICAgICBsZXQgcmlkID0gc2hlZXQuYXR0cmlidXRlTGlzdFtcInI6aWRcIl07XHJcbiAgICAgICAgICAgIGxldCBzaGVldEZpbGUgPSB0aGlzLmdldFNoZWV0RmlsZUJ5c2hlZXRJZChyaWQpO1xyXG4gICAgICAgICAgICBsZXQgaGlkZSA9IHNoZWV0LmF0dHJpYnV0ZUxpc3Quc3RhdGUgPT09IFwiaGlkZGVuXCIgPyAxIDogMDtcclxuXHJcbiAgICAgICAgICAgIGxldCBkcmF3aW5nID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwid29ya3NoZWV0L2RyYXdpbmdcIiwgc2hlZXRGaWxlKSwgZHJhd2luZ0ZpbGUsIGRyYXdpbmdSZWxzRmlsZTtcclxuICAgICAgICAgICAgaWYoZHJhd2luZyE9bnVsbCAmJiBkcmF3aW5nLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgIGxldCBhdHRyTGlzdCA9IGRyYXdpbmdbMF0uYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgICAgIGxldCByaWQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJyOmlkXCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgaWYocmlkIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBkcmF3aW5nRmlsZSA9IHRoaXMuZ2V0RHJhd2luZ0ZpbGUocmlkLCBzaGVldEZpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYXdpbmdSZWxzRmlsZSA9IHRoaXMuZ2V0RHJhd2luZ1JlbHNGaWxlKGRyYXdpbmdGaWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoc2hlZXRGaWxlIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGxldCBzaGVldCA9IG5ldyBMdWNreVNoZWV0KHNoZWV0TmFtZSwgc2hlZXRJZCwgb3JkZXIsIGlzSW5pdGlhbENlbGwsXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGVldEZpbGU6c2hlZXRGaWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkWG1sOnRoaXMucmVhZFhtbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hlZXRMaXN0OnNoZWV0TGlzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOnRoaXMuc3R5bGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRTdHJpbmdzOnRoaXMuc2hhcmVkU3RyaW5ncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsY0NoYWluOnRoaXMuY2FsY0NoYWluLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZUxpc3Q6dGhpcy5pbWFnZUxpc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdpbmdGaWxlOmRyYXdpbmdGaWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3aW5nUmVsc0ZpbGU6IGRyYXdpbmdSZWxzRmlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogaGlkZSxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbldpZHRoU2V0ID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvd0hlaWdodFNldCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VQb3NpdGlvbkNhY3VsYXRpb24oc2hlZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc2hlZXRzLnB1c2goc2hlZXQpO1xyXG4gICAgICAgICAgICAgICAgb3JkZXIrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNvbHVtbldpZHRoU2V0Om51bWJlcltdID0gW107XHJcbiAgICBwcml2YXRlIHJvd0hlaWdodFNldDpudW1iZXJbXSA9IFtdO1xyXG5cclxuICAgIHByaXZhdGUgZXh0ZW5kQXJyYXkoaW5kZXg6bnVtYmVyLCBzZXRzOm51bWJlcltdLGRlZjpudW1iZXIsIGhpZGRlbjpJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlbiwgbGVuczpJbHVja3lTaGVldFJvd0FuZENvbHVtbkxlbil7XHJcbiAgICAgICAgaWYoaW5kZXg8c2V0cy5sZW5ndGgpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHNldHMubGVuZ3RoLCBlbmRJbmRleCA9IGluZGV4O1xyXG4gICAgICAgIGxldCBhbGxHYXAgPSAwO1xyXG4gICAgICAgIGlmKHN0YXJ0SW5kZXg+MCl7XHJcbiAgICAgICAgICAgIGFsbEdhcCA9IHNldHNbc3RhcnRJbmRleC0xXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZWxzZXtcclxuICAgICAgICAvLyAgICAgc2V0cy5wdXNoKDApO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBmb3IobGV0IGk9c3RhcnRJbmRleDtpPD1lbmRJbmRleDtpKyspe1xyXG4gICAgICAgICAgICBsZXQgZ2FwID0gZGVmLCBpc3RyaW5nICA9IGkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYoaXN0cmluZyBpbiBoaWRkZW4pe1xyXG4gICAgICAgICAgICAgICAgZ2FwID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGlzdHJpbmcgaW4gbGVucyl7XHJcbiAgICAgICAgICAgICAgICBnYXAgPSBsZW5zW2lzdHJpbmddO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhbGxHYXAgKz0gTWF0aC5yb3VuZChnYXAgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIHNldHMucHVzaChhbGxHYXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGltYWdlUG9zaXRpb25DYWN1bGF0aW9uKHNoZWV0Okx1Y2t5U2hlZXQpe1xyXG4gICAgICAgIGxldCBpbWFnZXMgPSBzaGVldC5pbWFnZXMsIGRlZmF1bHRDb2xXaWR0aCA9IHNoZWV0LmRlZmF1bHRDb2xXaWR0aCwgZGVmYXVsdFJvd0hlaWdodCA9IHNoZWV0LmRlZmF1bHRSb3dIZWlnaHQ7XHJcbiAgICAgICAgbGV0IGNvbGhpZGRlbiA9IHt9O1xyXG4gICAgICAgIGlmKHNoZWV0LmNvbmZpZy5jb2xoaWRkZW4pe1xyXG4gICAgICAgICAgICBjb2xoaWRkZW4gPSBzaGVldC5jb25maWcuY29saGlkZGVuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNvbHVtbmxlbiA9IHt9O1xyXG4gICAgICAgIGlmKHNoZWV0LmNvbmZpZy5jb2x1bW5sZW4pe1xyXG4gICAgICAgICAgICBjb2x1bW5sZW4gPSBzaGVldC5jb25maWcuY29sdW1ubGVuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJvd2hpZGRlbiA9IHt9O1xyXG4gICAgICAgIGlmKHNoZWV0LmNvbmZpZy5yb3doaWRkZW4pe1xyXG4gICAgICAgICAgICByb3doaWRkZW4gPSBzaGVldC5jb25maWcucm93aGlkZGVuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJvd2xlbiA9IHt9O1xyXG4gICAgICAgIGlmKHNoZWV0LmNvbmZpZy5yb3dsZW4pe1xyXG4gICAgICAgICAgICByb3dsZW4gPSBzaGVldC5jb25maWcucm93bGVuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gaW1hZ2VzKXtcclxuICAgICAgICAgICAgbGV0IGltYWdlT2JqZWN0OmFueSA9IGltYWdlc1trZXldOy8vSW1hZ2UsIGx1Y2t5SW1hZ2VcclxuICAgICAgICAgICAgbGV0IGZyb21Db2wgPSBpbWFnZU9iamVjdC5mcm9tQ29sO1xyXG4gICAgICAgICAgICBsZXQgZnJvbUNvbE9mZiA9IGltYWdlT2JqZWN0LmZyb21Db2xPZmY7XHJcbiAgICAgICAgICAgIGxldCBmcm9tUm93ID0gaW1hZ2VPYmplY3QuZnJvbVJvdztcclxuICAgICAgICAgICAgbGV0IGZyb21Sb3dPZmYgPSBpbWFnZU9iamVjdC5mcm9tUm93T2ZmO1xyXG5cclxuICAgICAgICAgICAgbGV0IHRvQ29sID0gaW1hZ2VPYmplY3QudG9Db2w7XHJcbiAgICAgICAgICAgIGxldCB0b0NvbE9mZiA9IGltYWdlT2JqZWN0LnRvQ29sT2ZmO1xyXG4gICAgICAgICAgICBsZXQgdG9Sb3cgPSBpbWFnZU9iamVjdC50b1JvdztcclxuICAgICAgICAgICAgbGV0IHRvUm93T2ZmID0gaW1hZ2VPYmplY3QudG9Sb3dPZmY7XHJcblxyXG4gICAgICAgICAgICBsZXQgeF9uID0wLHlfbiA9IDA7XHJcbiAgICAgICAgICAgIGxldCBjeF9uID0gMCwgY3lfbiA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZihmcm9tQ29sPj10aGlzLmNvbHVtbldpZHRoU2V0Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZEFycmF5KGZyb21Db2wsIHRoaXMuY29sdW1uV2lkdGhTZXQsIGRlZmF1bHRDb2xXaWR0aCwgY29saGlkZGVuLCBjb2x1bW5sZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGZyb21Db2w9PTApe1xyXG4gICAgICAgICAgICAgICAgeF9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgeF9uID0gdGhpcy5jb2x1bW5XaWR0aFNldFtmcm9tQ29sLTFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHhfbiA9IHhfbiArIGZyb21Db2xPZmY7XHJcblxyXG4gICAgICAgICAgICBpZihmcm9tUm93Pj10aGlzLnJvd0hlaWdodFNldC5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRBcnJheShmcm9tUm93LCB0aGlzLnJvd0hlaWdodFNldCwgZGVmYXVsdFJvd0hlaWdodCwgcm93aGlkZGVuLCByb3dsZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGZyb21Sb3c9PTApe1xyXG4gICAgICAgICAgICAgICAgeV9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgeV9uID0gdGhpcy5yb3dIZWlnaHRTZXRbZnJvbVJvdy0xXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5X24gPSB5X24gKyBmcm9tUm93T2ZmO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmKHRvQ29sPj10aGlzLmNvbHVtbldpZHRoU2V0Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZEFycmF5KHRvQ29sLCB0aGlzLmNvbHVtbldpZHRoU2V0LCBkZWZhdWx0Q29sV2lkdGgsIGNvbGhpZGRlbiwgY29sdW1ubGVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0b0NvbD09MCl7XHJcbiAgICAgICAgICAgICAgICBjeF9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgY3hfbiA9IHRoaXMuY29sdW1uV2lkdGhTZXRbdG9Db2wtMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3hfbiA9IGN4X24gKyB0b0NvbE9mZi0geF9uO1xyXG5cclxuICAgICAgICAgICAgaWYodG9Sb3c+PXRoaXMucm93SGVpZ2h0U2V0Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZEFycmF5KHRvUm93LCB0aGlzLnJvd0hlaWdodFNldCwgZGVmYXVsdFJvd0hlaWdodCwgcm93aGlkZGVuLCByb3dsZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHRvUm93PT0wKXtcclxuICAgICAgICAgICAgICAgIGN5X24gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBjeV9uID0gdGhpcy5yb3dIZWlnaHRTZXRbdG9Sb3ctMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN5X24gPSBjeV9uICsgdG9Sb3dPZmYgLSB5X247XHJcblxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhkZWZhdWx0Q29sV2lkdGgsIGNvbGhpZGRlbiAsIGNvbHVtbmxlbik7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGZyb21Db2wsIHRoaXMuY29sdW1uV2lkdGhTZXRbZnJvbUNvbF0gLCBmcm9tQ29sT2ZmKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codG9Db2wsIHRoaXMuY29sdW1uV2lkdGhTZXRbdG9Db2xdICwgdG9Db2xPZmYsIEpTT04uc3RyaW5naWZ5KHRoaXMuY29sdW1uV2lkdGhTZXQpKTtcclxuXHJcbiAgICAgICAgICAgIGltYWdlT2JqZWN0Lm9yaWdpbldpZHRoID0gY3hfbjtcclxuICAgICAgICAgICAgaW1hZ2VPYmplY3Qub3JpZ2luSGVpZ2h0ID0gY3lfbjtcclxuXHJcbiAgICAgICAgICAgIGltYWdlT2JqZWN0LmNyb3AuaGVpZ2h0ID0gY3lfbjtcclxuICAgICAgICAgICAgaW1hZ2VPYmplY3QuY3JvcC53aWR0aCA9IGN4X247XHJcblxyXG4gICAgICAgICAgICBpbWFnZU9iamVjdC5kZWZhdWx0LmhlaWdodCA9IGN5X247XHJcbiAgICAgICAgICAgIGltYWdlT2JqZWN0LmRlZmF1bHQubGVmdCA9IHhfbjtcclxuICAgICAgICAgICAgaW1hZ2VPYmplY3QuZGVmYXVsdC50b3AgPSB5X247XHJcbiAgICAgICAgICAgIGltYWdlT2JqZWN0LmRlZmF1bHQud2lkdGggPSBjeF9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLmNvbHVtbldpZHRoU2V0LCB0aGlzLnJvd0hlaWdodFNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEByZXR1cm4gZHJhd2luZyBmaWxlIHN0cmluZ1xyXG4gICAgKi9cclxuICAgcHJpdmF0ZSBnZXREcmF3aW5nRmlsZShyaWQ6c3RyaW5nLCBzaGVldEZpbGU6c3RyaW5nKTpzdHJpbmd7XHJcbiAgICAgICAgbGV0IHNoZWV0UmVsc1BhdGggPSBcInhsL3dvcmtzaGVldHMvX3JlbHMvXCI7XHJcbiAgICAgICAgbGV0IHNoZWV0RmlsZUFyciA9IHNoZWV0RmlsZS5zcGxpdChcIi9cIik7XHJcbiAgICAgICAgbGV0IHNoZWV0UmVsc05hbWUgPSBzaGVldEZpbGVBcnJbc2hlZXRGaWxlQXJyLmxlbmd0aC0xXTtcclxuXHJcbiAgICAgICAgbGV0IHNoZWV0UmVsc0ZpbGUgPSBzaGVldFJlbHNQYXRoICsgc2hlZXRSZWxzTmFtZSArIFwiLnJlbHNcIjtcclxuXHJcbiAgICAgICAgbGV0IGRyYXdpbmcgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJSZWxhdGlvbnNoaXBzL1JlbGF0aW9uc2hpcFwiLCBzaGVldFJlbHNGaWxlKTtcclxuICAgICAgICBpZihkcmF3aW5nLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTxkcmF3aW5nLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlbGF0aW9uc2hpcCA9IGRyYXdpbmdbaV07XHJcbiAgICAgICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSByZWxhdGlvbnNoaXAuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgICAgIGxldCByZWxhdGlvbnNoaXBJZCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIklkXCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgaWYocmVsYXRpb25zaGlwSWQ9PXJpZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIlRhcmdldFwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZih0YXJnZXQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnJlcGxhY2UoL1xcLlxcLlxcLy9nLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBnZXREcmF3aW5nUmVsc0ZpbGUoZHJhd2luZ0ZpbGU6c3RyaW5nKTpzdHJpbmd7XHJcbiAgICAgICAgbGV0IGRyYXdpbmdSZWxzUGF0aCA9IFwieGwvZHJhd2luZ3MvX3JlbHMvXCI7XHJcbiAgICAgICAgbGV0IGRyYXdpbmdGaWxlQXJyID0gZHJhd2luZ0ZpbGUuc3BsaXQoXCIvXCIpO1xyXG4gICAgICAgIGxldCBkcmF3aW5nUmVsc05hbWUgPSBkcmF3aW5nRmlsZUFycltkcmF3aW5nRmlsZUFyci5sZW5ndGgtMV07XHJcblxyXG4gICAgICAgIGxldCBkcmF3aW5nUmVsc0ZpbGUgPSBkcmF3aW5nUmVsc1BhdGggKyBkcmF3aW5nUmVsc05hbWUgKyBcIi5yZWxzXCI7XHJcblxyXG4gICAgICAgIHJldHVybiBkcmF3aW5nUmVsc0ZpbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEByZXR1cm4gQWxsIHNoZWV0IGJhc2UgaW5mb3JtYXRpb24gd2lkdGhvdXQgY2VsbCBhbmQgY29uZmlnXHJcbiAgICAqL1xyXG4gICAgZ2V0U2hlZXRzV2l0aG91dENlbGwoKXtcclxuICAgICAgICB0aGlzLmdldFNoZWV0c0Z1bGwoZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcmV0dXJuIEx1Y2t5U2hlZXQgZmlsZSBqc29uXHJcbiAgICAqL1xyXG4gICAgUGFyc2UoKTpzdHJpbmd7XHJcbiAgICAgICAgLy8gbGV0IHhtbCA9IHRoaXMucmVhZFhtbDtcclxuICAgICAgICAvLyBmb3IobGV0IGtleSBpbiB0aGlzLnNoZWV0TmFtZUxpc3Qpe1xyXG4gICAgICAgIC8vICAgICBsZXQgc2hlZXROYW1lPXRoaXMuc2hlZXROYW1lTGlzdFtrZXldO1xyXG4gICAgICAgIC8vICAgICBsZXQgc2hlZXRDb2x1bW5zID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicm93L2MvZlwiLCBzaGVldE5hbWUpO1xyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhzaGVldENvbHVtbnMpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRXb3JrQm9va0luZm8oKTtcclxuICAgICAgICB0aGlzLmdldFNoZWV0c0Z1bGwoKTtcclxuXHJcbiAgICAgICAgLy8gZm9yKGxldCBpPTA7aTx0aGlzLnNoZWV0cy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAvLyAgICAgbGV0IHNoZWV0ID0gdGhpcy5zaGVldHNbaV07XHJcbiAgICAgICAgLy8gICAgIGxldCBfYm9yZGVySW5mbyA9IHNoZWV0LmNvbmZpZy5fYm9yZGVySW5mbztcclxuICAgICAgICAvLyAgICAgaWYoX2JvcmRlckluZm89PW51bGwpe1xyXG4gICAgICAgIC8vICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgbGV0IF9ib3JkZXJJbmZvS2V5cyA9IE9iamVjdC5rZXlzKF9ib3JkZXJJbmZvKTtcclxuICAgICAgICAvLyAgICAgX2JvcmRlckluZm9LZXlzLnNvcnQoKTtcclxuICAgICAgICAvLyAgICAgZm9yKGxldCBhPTA7YTxfYm9yZGVySW5mb0tleXMubGVuZ3RoO2ErKyl7XHJcbiAgICAgICAgLy8gICAgICAgICBsZXQga2V5ID0gcGFyc2VJbnQoX2JvcmRlckluZm9LZXlzW2FdKTtcclxuICAgICAgICAvLyAgICAgICAgIGxldCBiID0gX2JvcmRlckluZm9ba2V5XTtcclxuICAgICAgICAvLyAgICAgICAgIGlmKGIuY2VsbHMubGVuZ3RoPT0wKXtcclxuICAgICAgICAvLyAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgIGlmKHNoZWV0LmNvbmZpZy5ib3JkZXJJbmZvPT1udWxsKXtcclxuICAgICAgICAvLyAgICAgICAgICAgICBzaGVldC5jb25maWcuYm9yZGVySW5mbyA9IFtdO1xyXG4gICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICAgc2hlZXQuY29uZmlnLmJvcmRlckluZm8ucHVzaChiKTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Kc29uU3RyaW5nKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdG9Kc29uU3RyaW5nKGZpbGU6SUx1Y2t5RmlsZSk6c3RyaW5ne1xyXG4gICAgICAgIGxldCBMdWNreU91dFB1dEZpbGUgPSBuZXcgTHVja3lGaWxlQmFzZSgpO1xyXG4gICAgICAgIEx1Y2t5T3V0UHV0RmlsZS5pbmZvID0gZmlsZS5pbmZvO1xyXG4gICAgICAgIEx1Y2t5T3V0UHV0RmlsZS5zaGVldHMgPSBbXTtcclxuXHJcbiAgICAgICAgZmlsZS5zaGVldHMuZm9yRWFjaCgoc2hlZXQpPT57XHJcbiAgICAgICAgICAgIGxldCBzaGVldG91dCA9IG5ldyBMdWNreVNoZWV0QmFzZSgpO1xyXG4gICAgICAgICAgICAvL2xldCBhdHRyTmFtZSA9IFtcIm5hbWVcIixcImNvbG9yXCIsXCJjb25maWdcIixcImluZGV4XCIsXCJzdGF0dXNcIixcIm9yZGVyXCIsXCJyb3dcIixcImNvbHVtblwiLFwibHVja3lzaGVldF9zZWxlY3Rfc2F2ZVwiLFwic2Nyb2xsTGVmdFwiLFwic2Nyb2xsVG9wXCIsXCJ6b29tUmF0aW9cIixcInNob3dHcmlkTGluZXNcIixcImRlZmF1bHRDb2xXaWR0aFwiLFwiZGVmYXVsdFJvd0hlaWdodFwiLFwiY2VsbGRhdGFcIixcImNoYXJ0XCIsXCJpc1Bpdm90VGFibGVcIixcInBpdm90VGFibGVcIixcImx1Y2t5c2hlZXRfY29uZGl0aW9uZm9ybWF0X3NhdmVcIixcImZyZWV6ZW5cIixcImNhbGNDaGFpblwiXTtcclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0Lm5hbWUhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQubmFtZSA9IHNoZWV0Lm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmNvbG9yID0gc2hlZXQuY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmNvbmZpZyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5jb25maWcgPSBzaGVldC5jb25maWc7XHJcbiAgICAgICAgICAgICAgICAvLyBpZihzaGVldG91dC5jb25maWcuX2JvcmRlckluZm8hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGRlbGV0ZSBzaGVldG91dC5jb25maWcuX2JvcmRlckluZm87XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmluZGV4IT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmluZGV4ID0gc2hlZXQuaW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LnN0YXR1cyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5zdGF0dXMgPSBzaGVldC5zdGF0dXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0Lm9yZGVyIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0Lm9yZGVyID0gc2hlZXQub3JkZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LnJvdyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5yb3cgPSBzaGVldC5yb3c7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmNvbHVtbiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5jb2x1bW4gPSBzaGVldC5jb2x1bW47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0Lmx1Y2t5c2hlZXRfc2VsZWN0X3NhdmUhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQubHVja3lzaGVldF9zZWxlY3Rfc2F2ZSA9IHNoZWV0Lmx1Y2t5c2hlZXRfc2VsZWN0X3NhdmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LnNjcm9sbExlZnQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuc2Nyb2xsTGVmdCA9IHNoZWV0LnNjcm9sbExlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LnNjcm9sbFRvcCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5zY3JvbGxUb3AgPSBzaGVldC5zY3JvbGxUb3A7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0Lnpvb21SYXRpbyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC56b29tUmF0aW8gPSBzaGVldC56b29tUmF0aW87XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LnNob3dHcmlkTGluZXMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuc2hvd0dyaWRMaW5lcyA9IHNoZWV0LnNob3dHcmlkTGluZXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmRlZmF1bHRDb2xXaWR0aCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5kZWZhdWx0Q29sV2lkdGggPSBzaGVldC5kZWZhdWx0Q29sV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmRlZmF1bHRSb3dIZWlnaHQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuZGVmYXVsdFJvd0hlaWdodCA9IHNoZWV0LmRlZmF1bHRSb3dIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmNlbGxkYXRhIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIC8vIHNoZWV0b3V0LmNlbGxkYXRhID0gc2hlZXQuY2VsbGRhdGE7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5jZWxsZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgc2hlZXQuY2VsbGRhdGEuZm9yRWFjaCgoY2VsbCk9PntcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbG91dCA9IG5ldyBMdWNreVNoZWV0Q2VsbGRhdGFCYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbG91dC5yID0gY2VsbC5yO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxvdXQuYyA9IGNlbGwuYztcclxuICAgICAgICAgICAgICAgICAgICBjZWxsb3V0LnYgPSBjZWxsLnY7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hlZXRvdXQuY2VsbGRhdGEucHVzaChjZWxsb3V0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5jaGFydCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5jaGFydCA9IHNoZWV0LmNoYXJ0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5pc1Bpdm90VGFibGUhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuaXNQaXZvdFRhYmxlID0gc2hlZXQuaXNQaXZvdFRhYmxlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5waXZvdFRhYmxlIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LnBpdm90VGFibGUgPSBzaGVldC5waXZvdFRhYmxlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5sdWNreXNoZWV0X2NvbmRpdGlvbmZvcm1hdF9zYXZlIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0Lmx1Y2t5c2hlZXRfY29uZGl0aW9uZm9ybWF0X3NhdmUgPSBzaGVldC5sdWNreXNoZWV0X2NvbmRpdGlvbmZvcm1hdF9zYXZlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5mcmVlemVuIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmZyZWV6ZW4gPSBzaGVldC5mcmVlemVuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5jYWxjQ2hhaW4hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuY2FsY0NoYWluID0gc2hlZXQuY2FsY0NoYWluO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5pbWFnZXMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuaW1hZ2VzID0gc2hlZXQuaW1hZ2VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHNoZWV0Lmh5cGVybGluayAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0Lmh5cGVybGluayA9IHNoZWV0Lmh5cGVybGluaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChzaGVldC5oaWRlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICBzaGVldG91dC5oaWRlID0gc2hlZXQuaGlkZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgTHVja3lPdXRQdXRGaWxlLnNoZWV0cy5wdXNoKHNoZWV0b3V0KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KEx1Y2t5T3V0UHV0RmlsZSk7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbHVja3lJbWFnZSB9IGZyb20gXCIuL0lMdWNrXCI7XHJcbmltcG9ydCB7THVja3lTaGVldENlbGxkYXRhfSBmcm9tIFwiLi9MdWNreUNlbGxcIjtcclxuaW1wb3J0IHsgSXVwbG9hZGZpbGVMaXN0LCBJYXR0cmlidXRlTGlzdCB9IGZyb20gXCIuLi9JQ29tbW9uXCI7XHJcbmltcG9ydCB7Z2V0WG1sQXR0aWJ1dGUsIGdldENvbHVtbldpZHRoUGl4ZWwsIGZyb211bGFSZWYsZ2V0Um93SGVpZ2h0UGl4ZWwsZ2V0Y2VsbHJhbmdlfSBmcm9tIFwiLi4vY29tbW9uL21ldGhvZFwiO1xyXG5pbXBvcnQge2JvcmRlclR5cGVzfSBmcm9tIFwiLi4vY29tbW9uL2NvbnN0YW50XCI7XHJcbmltcG9ydCB7IFJlYWRYbWwsIElTdHlsZUNvbGxlY3Rpb25zLCBFbGVtZW50LGdldENvbG9yIH0gZnJvbSBcIi4vUmVhZFhtbFwiO1xyXG5pbXBvcnQgeyBMdWNreUltYWdlQmFzZSB9IGZyb20gXCIuL0x1Y2t5QmFzZVwiO1xyXG5pbXBvcnQgeyBVRE9DLEZyb21FTUYsVG9Db250ZXh0MkQgIH0gZnJvbSBcIi4uL2NvbW1vbi9lbWZcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgSW1hZ2VMaXN0IHtcclxuICAgIHByaXZhdGUgaW1hZ2VzOklhdHRyaWJ1dGVMaXN0XHJcbiAgICBjb25zdHJ1Y3RvcihmaWxlczpJdXBsb2FkZmlsZUxpc3QpIHtcclxuICAgICAgICBpZihmaWxlcz09bnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbWFnZXMgPSB7fTtcclxuICAgICAgICBmb3IobGV0IGZpbGVLZXkgaW4gZmlsZXMpe1xyXG4gICAgICAgICAgICAvLyBsZXQgcmVnID0gbmV3IFJlZ0V4cChcInhsL21lZGlhL2ltYWdlMS5wbmdcIiwgXCJnXCIpO1xyXG4gICAgICAgICAgICBpZihmaWxlS2V5LmluZGV4T2YoXCJ4bC9tZWRpYS9cIik+LTEpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lQXJyID0gZmlsZUtleS5zcGxpdChcIi5cIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3VmZml4ID0gZmlsZU5hbWVBcnJbZmlsZU5hbWVBcnIubGVuZ3RoLTFdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZihzdWZmaXggaW4ge1wicG5nXCI6MSwgXCJqcGVnXCI6MSwgXCJqcGdcIjoxLCBcImdpZlwiOjEsXCJibXBcIjoxLFwidGlmXCI6MSxcIndlYnBcIjoxLFwiZW1mXCI6MX0pe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN1ZmZpeD09XCJlbWZcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwTnVtICA9IDA7ICAvLyBudW1iZXIgb2YgdGhlIHBhZ2UsIHRoYXQgeW91IHdhbnQgdG8gcmVuZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IDE7ICAvLyB0aGUgc2NhbGUgb2YgdGhlIGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3cnQgPSBuZXcgVG9Db250ZXh0MkQocE51bSwgc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wLCBvdXQsIHN0dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRnJvbUVNRi5LID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucCA9IEZyb21FTUYuQzsgICBvdXQgPSBGcm9tRU1GLks7ICAgc3R0PTQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgcCBpbiBpbnApIG91dFtpbnBbcF1dID0gcC5zbGljZShzdHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBGcm9tRU1GLlBhcnNlKGZpbGVzW2ZpbGVLZXldLCB3cnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlc1tmaWxlS2V5XSA9IHdydC5jYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlc1tmaWxlS2V5XSA9IGZpbGVzW2ZpbGVLZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRJbWFnZUJ5TmFtZShwYXRoTmFtZTpzdHJpbmcpOkltYWdle1xyXG4gICAgICAgIGlmKHBhdGhOYW1lIGluIHRoaXMuaW1hZ2VzKXtcclxuICAgICAgICAgICAgbGV0IGJhc2U2NCA9IHRoaXMuaW1hZ2VzW3BhdGhOYW1lXTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbWFnZShwYXRoTmFtZSwgYmFzZTY0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5jbGFzcyBJbWFnZSBleHRlbmRzIEx1Y2t5SW1hZ2VCYXNlIHtcclxuXHJcbiAgICBmcm9tQ29sOm51bWJlclxyXG4gICAgZnJvbUNvbE9mZjpudW1iZXJcclxuICAgIGZyb21Sb3c6bnVtYmVyXHJcbiAgICBmcm9tUm93T2ZmOm51bWJlclxyXG5cclxuICAgIHRvQ29sOm51bWJlclxyXG4gICAgdG9Db2xPZmY6bnVtYmVyXHJcbiAgICB0b1JvdzpudW1iZXJcclxuICAgIHRvUm93T2ZmOm51bWJlclxyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBhdGhOYW1lOnN0cmluZywgYmFzZTY0OnN0cmluZykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5zcmMgPSBiYXNlNjQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0RGVmYXVsdCgpe1xyXG5cclxuICAgIH1cclxufSIsIu+7v2ltcG9ydCB7IElsdWNreUltYWdlQm9yZGVyLElsdWNreUltYWdlQ3JvcCxJbHVja3lJbWFnZURlZmF1bHQsSWx1Y2t5SW1hZ2VzLElsdWNreVNoZWV0Q2VsbGRhdGEsSWx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlLElNYXBsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxGb3JJbXAsSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlLElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxlLElGb3JtdWxhU0ksSWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5MZW4sSWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5IaWRkZW4sSWx1Y2t5U2hlZXRTZWxlY3Rpb24sSWNlbGxPdGhlckluZm8sSWZvcm11bGFMaXN0LElmb3JtdWxhTGlzdEl0ZW0sIElsdWNreXNoZWV0SHlwZXJsaW5rLCBJbHVja3lzaGVldEh5cGVybGlua1R5cGV9IGZyb20gXCIuL0lMdWNrXCI7XHJcbmltcG9ydCB7THVja3lTaGVldENlbGxkYXRhfSBmcm9tIFwiLi9MdWNreUNlbGxcIjtcclxuaW1wb3J0IHsgSWF0dHJpYnV0ZUxpc3QgfSBmcm9tIFwiLi4vSUNvbW1vblwiO1xyXG5pbXBvcnQge2dldFhtbEF0dGlidXRlLCBnZXRDb2x1bW5XaWR0aFBpeGVsLCBmcm9tdWxhUmVmLGdldFJvd0hlaWdodFBpeGVsLGdldGNlbGxyYW5nZSxnZW5lcmF0ZVJhbmRvbUluZGV4LGdldFB4QnlFTVVzLCBnZXRNdWx0aVNlcXVlbmNlVG9OdW0sIGdldFRyYW5zUjFDMVRvU2VxdWVuY2V9IGZyb20gXCIuLi9jb21tb24vbWV0aG9kXCI7XHJcbmltcG9ydCB7Ym9yZGVyVHlwZXMsIHdvcmtzaGVldEZpbGVQYXRofSBmcm9tIFwiLi4vY29tbW9uL2NvbnN0YW50XCI7XHJcbmltcG9ydCB7IFJlYWRYbWwsIElTdHlsZUNvbGxlY3Rpb25zLCBFbGVtZW50LGdldENvbG9yIH0gZnJvbSBcIi4vUmVhZFhtbFwiO1xyXG5pbXBvcnQgeyBMdWNreUZpbGVCYXNlLEx1Y2t5U2hlZXRCYXNlLEx1Y2t5Q29uZmlnLEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCxMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZSxMdWNreXNoZWV0Q2FsY0NoYWluLEx1Y2t5U2hlZXRDb25maWdNZXJnZSB9IGZyb20gXCIuL0x1Y2t5QmFzZVwiO1xyXG5pbXBvcnQge0ltYWdlTGlzdH0gZnJvbSBcIi4vTHVja3lJbWFnZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXQgZXh0ZW5kcyBMdWNreVNoZWV0QmFzZSB7XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkWG1sOlJlYWRYbWxcclxuICAgIHByaXZhdGUgc2hlZXRGaWxlOnN0cmluZ1xyXG4gICAgcHJpdmF0ZSBpc0luaXRpYWxDZWxsOmJvb2xlYW5cclxuICAgIHByaXZhdGUgc3R5bGVzOklTdHlsZUNvbGxlY3Rpb25zXHJcbiAgICBwcml2YXRlIHNoYXJlZFN0cmluZ3M6RWxlbWVudFtdXHJcbiAgICBwcml2YXRlIG1lcmdlQ2VsbHM6RWxlbWVudFtdXHJcbiAgICBwcml2YXRlIGNhbGNDaGFpbkVsZXM6RWxlbWVudFtdXHJcbiAgICBwcml2YXRlIHNoZWV0TGlzdDpJYXR0cmlidXRlTGlzdFxyXG5cclxuICAgIHByaXZhdGUgaW1hZ2VMaXN0OkltYWdlTGlzdFxyXG5cclxuICAgIHByaXZhdGUgZm9ybXVsYVJlZkxpc3Q6SUZvcm11bGFTSVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKHNoZWV0TmFtZTpzdHJpbmcsIHNoZWV0SWQ6c3RyaW5nLCBzaGVldE9yZGVyOm51bWJlcixpc0luaXRpYWxDZWxsOmJvb2xlYW49ZmFsc2UsIGFsbEZpbGVPcHRpb246YW55KXtcclxuICAgICAgICAvL1ByaXZhdGVcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaXNJbml0aWFsQ2VsbCA9IGlzSW5pdGlhbENlbGw7XHJcblxyXG4gICAgICAgIHRoaXMucmVhZFhtbCA9IGFsbEZpbGVPcHRpb24ucmVhZFhtbDtcclxuICAgICAgICB0aGlzLnNoZWV0RmlsZSA9IGFsbEZpbGVPcHRpb24uc2hlZXRGaWxlO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzID0gYWxsRmlsZU9wdGlvbi5zdHlsZXM7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRTdHJpbmdzID0gYWxsRmlsZU9wdGlvbi5zaGFyZWRTdHJpbmdzO1xyXG4gICAgICAgIHRoaXMuY2FsY0NoYWluRWxlcyA9IGFsbEZpbGVPcHRpb24uY2FsY0NoYWluO1xyXG4gICAgICAgIHRoaXMuc2hlZXRMaXN0ID0gYWxsRmlsZU9wdGlvbi5zaGVldExpc3Q7XHJcbiAgICAgICAgdGhpcy5pbWFnZUxpc3QgPSBhbGxGaWxlT3B0aW9uLmltYWdlTGlzdDtcclxuICAgICAgICB0aGlzLmhpZGUgPSBhbGxGaWxlT3B0aW9uLmhpZGU7XHJcblxyXG4gICAgICAgIC8vT3V0cHV0XHJcbiAgICAgICAgdGhpcy5uYW1lID0gc2hlZXROYW1lO1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBzaGVldElkO1xyXG4gICAgICAgIHRoaXMub3JkZXIgPSBzaGVldE9yZGVyLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBuZXcgTHVja3lDb25maWcoKTtcclxuICAgICAgICB0aGlzLmNlbGxkYXRhID0gW107XHJcbiAgICAgICAgdGhpcy5tZXJnZUNlbGxzID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibWVyZ2VDZWxscy9tZXJnZUNlbGxcIiwgdGhpcy5zaGVldEZpbGUpO1xyXG4gICAgICAgIGxldCBjbHJTY2hlbWUgPSB0aGlzLnN0eWxlc1tcImNsclNjaGVtZVwiXSBhcyBFbGVtZW50W107XHJcbiAgICAgICAgbGV0IHNoZWV0VmlldyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNoZWV0Vmlld3Mvc2hlZXRWaWV3XCIsIHRoaXMuc2hlZXRGaWxlKTtcclxuICAgICAgICBsZXQgc2hvd0dyaWRMaW5lcyA9IFwiMVwiLCB0YWJTZWxlY3RlZD1cIjBcIiwgem9vbVNjYWxlID0gXCIxMDBcIiwgYWN0aXZlQ2VsbCA9IFwiQTFcIjtcclxuICAgICAgICBpZihzaGVldFZpZXcubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSBzaGVldFZpZXdbMF0uYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgc2hvd0dyaWRMaW5lcyA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcInNob3dHcmlkTGluZXNcIiwgXCIxXCIpO1xyXG4gICAgICAgICAgICB0YWJTZWxlY3RlZCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcInRhYlNlbGVjdGVkXCIsIFwiMFwiKTtcclxuICAgICAgICAgICAgem9vbVNjYWxlID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiem9vbVNjYWxlXCIsIFwiMTAwXCIpO1xyXG4gICAgICAgICAgICAvLyBsZXQgY29sb3JJZCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcImNvbG9ySWRcIiwgXCIwXCIpO1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9ucyA9IHNoZWV0Vmlld1swXS5nZXRJbm5lckVsZW1lbnRzKFwic2VsZWN0aW9uXCIpO1xyXG4gICAgICAgICAgICBpZihzZWxlY3Rpb25zIT1udWxsICYmIHNlbGVjdGlvbnMubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlQ2VsbCA9IGdldFhtbEF0dGlidXRlKHNlbGVjdGlvbnNbMF0uYXR0cmlidXRlTGlzdCwgXCJhY3RpdmVDZWxsXCIsIFwiQTFcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2U6SWx1Y2t5U2hlZXRTZWxlY3Rpb24gPSBnZXRjZWxscmFuZ2UoYWN0aXZlQ2VsbCwgdGhpcy5zaGVldExpc3QsIHNoZWV0SWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sdWNreXNoZWV0X3NlbGVjdF9zYXZlID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLmx1Y2t5c2hlZXRfc2VsZWN0X3NhdmUucHVzaChyYW5nZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zaG93R3JpZExpbmVzID0gc2hvd0dyaWRMaW5lcztcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IHRhYlNlbGVjdGVkO1xyXG4gICAgICAgIHRoaXMuem9vbVJhdGlvID0gcGFyc2VJbnQoem9vbVNjYWxlKS8xMDA7XHJcblxyXG4gICAgICAgIGxldCB0YWJDb2xvcnMgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzaGVldFByL3RhYkNvbG9yXCIsIHRoaXMuc2hlZXRGaWxlKTtcclxuICAgICAgICBpZih0YWJDb2xvcnMhPW51bGwgJiYgdGFiQ29sb3JzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgbGV0IHRhYkNvbG9yID0gdGFiQ29sb3JzWzBdLCBhdHRyTGlzdCA9IHRhYkNvbG9yLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgIC8vIGlmKGF0dHJMaXN0LnJnYiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGMgPSBnZXRDb2xvcih0YWJDb2xvciwgdGhpcy5zdHlsZXMsIFwiYlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSB0YztcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHNoZWV0Rm9ybWF0UHIgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzaGVldEZvcm1hdFByXCIsIHRoaXMuc2hlZXRGaWxlKTtcclxuICAgICAgICBsZXQgZGVmYXVsdENvbFdpZHRoLCBkZWZhdWx0Um93SGVpZ2h0O1xyXG4gICAgICAgIGlmKHNoZWV0Rm9ybWF0UHIubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSBzaGVldEZvcm1hdFByWzBdLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgIGRlZmF1bHRDb2xXaWR0aCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcImRlZmF1bHRDb2xXaWR0aFwiLCBcIjkuMjFcIik7XHJcbiAgICAgICAgICAgIGRlZmF1bHRSb3dIZWlnaHQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJkZWZhdWx0Um93SGVpZ2h0XCIsIFwiMTlcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRlZmF1bHRDb2xXaWR0aCA9IGdldENvbHVtbldpZHRoUGl4ZWwocGFyc2VGbG9hdChkZWZhdWx0Q29sV2lkdGgpKTtcclxuICAgICAgICB0aGlzLmRlZmF1bHRSb3dIZWlnaHQgPSBnZXRSb3dIZWlnaHRQaXhlbChwYXJzZUZsb2F0KGRlZmF1bHRSb3dIZWlnaHQpKTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDb25maWdDb2x1bW5MZW5BbmRIaWRkZW4oKTtcclxuICAgICAgICBsZXQgY2VsbE90aGVySW5mbzpJY2VsbE90aGVySW5mbyA9ICB0aGlzLmdlbmVyYXRlQ29uZmlnUm93TGVuQW5kSGlkZGVuQWRkQ2VsbCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMuY2FsY0NoYWluPT1udWxsKXtcclxuICAgICAgICAgICAgdGhpcy5jYWxjQ2hhaW4gPSBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBmb3JtdWxhTGlzdEV4aXN0Oklmb3JtdWxhTGlzdD17fTtcclxuICAgICAgICBmb3IobGV0IGM9MDtjPHRoaXMuY2FsY0NoYWluRWxlcy5sZW5ndGg7YysrKXtcclxuICAgICAgICAgICAgbGV0IGNhbGNDaGFpbkVsZSA9IHRoaXMuY2FsY0NoYWluRWxlc1tjXSwgYXR0ckxpc3QgPSBjYWxjQ2hhaW5FbGUuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgaWYoYXR0ckxpc3QuaSE9c2hlZXRJZCl7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHIgPSBhdHRyTGlzdC5yICwgaSA9IGF0dHJMaXN0LmksIGwgPSBhdHRyTGlzdC5sLCBzID0gYXR0ckxpc3QucywgYSA9IGF0dHJMaXN0LmEsIHQgPSBhdHRyTGlzdC50O1xyXG5cclxuICAgICAgICAgICAgbGV0IHJhbmdlID0gZ2V0Y2VsbHJhbmdlKHIpO1xyXG4gICAgICAgICAgICBsZXQgY2hhaW4gPSBuZXcgTHVja3lzaGVldENhbGNDaGFpbigpO1xyXG4gICAgICAgICAgICBjaGFpbi5yID0gcmFuZ2Uucm93WzBdO1xyXG4gICAgICAgICAgICBjaGFpbi5jID0gcmFuZ2UuY29sdW1uWzBdO1xyXG4gICAgICAgICAgICBjaGFpbi5pbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY0NoYWluLnB1c2goY2hhaW4pO1xyXG4gICAgICAgICAgICBmb3JtdWxhTGlzdEV4aXN0W1wiclwiK3IrXCJjXCIrY10gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgaWYodGhpcy5mb3JtdWxhUmVmTGlzdCE9bnVsbCl7XHJcbiAgICAgICAgICAgIGZvcihsZXQga2V5IGluIHRoaXMuZm9ybXVsYVJlZkxpc3Qpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGZ1bmNsaXN0ID0gdGhpcy5mb3JtdWxhUmVmTGlzdFtrZXldO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1haW5GdW5jID0gZnVuY2xpc3RbXCJtYWluUmVmXCJdLCBtYWluQ2VsbFZhbHVlID0gbWFpbkZ1bmMuY2VsbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZvcm11bGFUeHQgPSBtYWluRnVuYy5mdjtcclxuICAgICAgICAgICAgICAgIGxldCBtYWluUiA9IG1haW5DZWxsVmFsdWUuciwgbWFpbkMgPSBtYWluQ2VsbFZhbHVlLmM7XHJcbiAgICAgICAgICAgICAgICAvLyBsZXQgcmVmUmFuZ2UgPSBnZXRjZWxscmFuZ2UocmVmKTtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgbmFtZSBpbiBmdW5jbGlzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobmFtZSA9PSBcIm1haW5SZWZcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZ1bmNWYWx1ZSA9IGZ1bmNsaXN0W25hbWVdLCBjZWxsVmFsdWUgPSBmdW5jVmFsdWUuY2VsbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZT09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgciA9IGNlbGxWYWx1ZS5yLCBjID0gY2VsbFZhbHVlLmM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmdW5jID0gZm9ybXVsYVR4dDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0Um93ID0gciAtIG1haW5SLCBvZmZzZXRDb2wgPSBjIC0gbWFpbkM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9mZnNldFJvdyA+IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jID0gXCI9XCIgKyBmcm9tdWxhUmVmLmZ1bmN0aW9uQ29weShmdW5jLCBcImRvd25cIiwgb2Zmc2V0Um93KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihvZmZzZXRSb3cgPCAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYyA9IFwiPVwiICsgZnJvbXVsYVJlZi5mdW5jdGlvbkNvcHkoZnVuYywgXCJ1cFwiLCBNYXRoLmFicyhvZmZzZXRSb3cpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9mZnNldENvbCA+IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jID0gXCI9XCIgKyBmcm9tdWxhUmVmLmZ1bmN0aW9uQ29weShmdW5jLCBcInJpZ2h0XCIsIG9mZnNldENvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYob2Zmc2V0Q29sIDwgMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMgPSBcIj1cIiArIGZyb211bGFSZWYuZnVuY3Rpb25Db3B5KGZ1bmMsIFwibGVmdFwiLCBNYXRoLmFicyhvZmZzZXRDb2wpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG9mZnNldFJvdywgb2Zmc2V0Q29sLCBmdW5jKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgKGNlbGxWYWx1ZS52IGFzIElsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSApLmYgPSBmdW5jO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8v5re75Yqg5YWx5Lqr5YWs5byP6ZO+XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoYWluID0gbmV3IEx1Y2t5c2hlZXRDYWxjQ2hhaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFpbi5yID0gY2VsbFZhbHVlLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhaW4uYyA9IGNlbGxWYWx1ZS5jO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYWluLmluZGV4ID0gdGhpcy5pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGNDaGFpbi5wdXNoKGNoYWluKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vVGhlcmUgbWF5IGJlIGZvcm11bGFzIHRoYXQgZG8gbm90IGFwcGVhciBpbiBjYWxjQ2hhaW5cclxuICAgICAgICBmb3IobGV0IGtleSBpbiBjZWxsT3RoZXJJbmZvLmZvcm11bGFMaXN0KXtcclxuICAgICAgICAgICAgaWYoIShrZXkgaW4gZm9ybXVsYUxpc3RFeGlzdCkpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGZvcm11bGFMaXN0SXRlbSA9IGNlbGxPdGhlckluZm8uZm9ybXVsYUxpc3Rba2V5XTtcclxuICAgICAgICAgICAgICAgIGxldCBjaGFpbiA9IG5ldyBMdWNreXNoZWV0Q2FsY0NoYWluKCk7XHJcbiAgICAgICAgICAgICAgICBjaGFpbi5yID0gZm9ybXVsYUxpc3RJdGVtLnI7XHJcbiAgICAgICAgICAgICAgICBjaGFpbi5jID0gZm9ybXVsYUxpc3RJdGVtLmM7XHJcbiAgICAgICAgICAgICAgICBjaGFpbi5pbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGNDaGFpbi5wdXNoKGNoYWluKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaHlwZXJsaW5rIGNvbmZpZ1xyXG4gICAgICAgIHRoaXMuaHlwZXJsaW5rID0gdGhpcy5nZW5lcmF0ZUNvbmZpZ0h5cGVybGlua3MoKTtcclxuICAgICAgXHJcbiAgICAgICAgLy8gc2hlZXQgaGlkZVxyXG4gICAgICAgIHRoaXMuaGlkZSA9IHRoaXMuaGlkZTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5tZXJnZUNlbGxzIT1udWxsKXtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLm1lcmdlQ2VsbHMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWVyZ2UgPSB0aGlzLm1lcmdlQ2VsbHNbaV0sIGF0dHJMaXN0ID0gbWVyZ2UuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgICAgIGxldCByZWYgPSBhdHRyTGlzdC5yZWY7XHJcbiAgICAgICAgICAgICAgICBpZihyZWY9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZ2V0Y2VsbHJhbmdlKHJlZiwgdGhpcy5zaGVldExpc3QsIHNoZWV0SWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1lcmdlVmFsdWUgPSBuZXcgTHVja3lTaGVldENvbmZpZ01lcmdlKCk7XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZhbHVlLnIgPSByYW5nZS5yb3dbMF07XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZhbHVlLmMgPSByYW5nZS5jb2x1bW5bMF07XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZhbHVlLnJzID0gcmFuZ2Uucm93WzFdLXJhbmdlLnJvd1swXSsxO1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VWYWx1ZS5jcyA9IHJhbmdlLmNvbHVtblsxXS1yYW5nZS5jb2x1bW5bMF0rMTtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLm1lcmdlPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5tZXJnZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubWVyZ2VbcmFuZ2Uucm93WzBdICsgXCJfXCIgKyByYW5nZS5jb2x1bW5bMF1dID0gbWVyZ2VWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGRyYXdpbmdGaWxlID0gYWxsRmlsZU9wdGlvbi5kcmF3aW5nRmlsZSwgZHJhd2luZ1JlbHNGaWxlID0gYWxsRmlsZU9wdGlvbi5kcmF3aW5nUmVsc0ZpbGU7XHJcbiAgICAgICAgaWYoZHJhd2luZ0ZpbGUhPW51bGwgJiYgZHJhd2luZ1JlbHNGaWxlIT1udWxsKXtcclxuICAgICAgICAgICAgbGV0IHR3b0NlbGxBbmNob3JzID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwieGRyOnR3b0NlbGxBbmNob3JcIiwgZHJhd2luZ0ZpbGUpO1xyXG5cclxuICAgICAgICAgICAgaWYodHdvQ2VsbEFuY2hvcnMhPW51bGwgJiYgdHdvQ2VsbEFuY2hvcnMubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0d29DZWxsQW5jaG9ycy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHdvQ2VsbEFuY2hvciA9IHR3b0NlbGxBbmNob3JzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlZGl0QXMgPSBnZXRYbWxBdHRpYnV0ZSh0d29DZWxsQW5jaG9yLmF0dHJpYnV0ZUxpc3QsIFwiZWRpdEFzXCIsIFwidHdvQ2VsbFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHhkckZyb21zID0gdHdvQ2VsbEFuY2hvci5nZXRJbm5lckVsZW1lbnRzKFwieGRyOmZyb21cIiksIHhkclRvcyA9IHR3b0NlbGxBbmNob3IuZ2V0SW5uZXJFbGVtZW50cyhcInhkcjp0b1wiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHhkcl9ibGlwZmlsbHMgPSB0d29DZWxsQW5jaG9yLmdldElubmVyRWxlbWVudHMoXCJhOmJsaXBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoeGRyRnJvbXMhPW51bGwgJiYgeGRyX2JsaXBmaWxscyE9bnVsbCAmJiB4ZHJGcm9tcy5sZW5ndGg+MCAmJiB4ZHJfYmxpcGZpbGxzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHhkckZyb20gPSB4ZHJGcm9tc1swXSwgeGRyVG8gPSB4ZHJUb3NbMF0seGRyX2JsaXBmaWxsID0geGRyX2JsaXBmaWxsc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZW1iZWQgPSBnZXRYbWxBdHRpYnV0ZSh4ZHJfYmxpcGZpbGwuYXR0cmlidXRlTGlzdCwgXCJyOmVtYmVkXCIsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlT2JqZWN0ID0gdGhpcy5nZXRCYXNlNjRCeVJpZChyZW1iZWQsIGRyYXdpbmdSZWxzRmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2VPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBhb2ZmID0geGRyX3hmcm0uZ2V0SW5uZXJFbGVtZW50cyhcImE6b2ZmXCIpLCBhZXh0ID0geGRyX3hmcm0uZ2V0SW5uZXJFbGVtZW50cyhcImE6ZXh0XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZihhb2ZmIT1udWxsICYmIGFleHQhPW51bGwgJiYgYW9mZi5sZW5ndGg+MCAmJiBhZXh0Lmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxldCBhb2ZmQXR0cmlidXRlID0gYW9mZlswXS5hdHRyaWJ1dGVMaXN0LCBhZXh0QXR0cmlidXRlID0gYWV4dFswXS5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgbGV0IHggPSBnZXRYbWxBdHRpYnV0ZShhb2ZmQXR0cmlidXRlLCBcInhcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBsZXQgeSA9IGdldFhtbEF0dGlidXRlKGFvZmZBdHRyaWJ1dGUsIFwieVwiLCBudWxsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBsZXQgY3ggPSBnZXRYbWxBdHRpYnV0ZShhZXh0QXR0cmlidXRlLCBcImN4XCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgbGV0IGN5ID0gZ2V0WG1sQXR0aWJ1dGUoYWV4dEF0dHJpYnV0ZSwgXCJjeVwiLCBudWxsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBpZih4IT1udWxsICYmIHkhPW51bGwgJiYgY3ghPW51bGwgJiYgY3khPW51bGwgJiYgaW1hZ2VPYmplY3QgIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IHhfbiA9IGdldFB4QnlFTVVzKHBhcnNlSW50KHgpLCBcImNcIikseV9uID0gZ2V0UHhCeUVNVXMocGFyc2VJbnQoeSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgY3hfbiA9IGdldFB4QnlFTVVzKHBhcnNlSW50KGN4KSwgXCJjXCIpLGN5X24gPSBnZXRQeEJ5RU1VcyhwYXJzZUludChjeSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHhfbiA9MCx5X24gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3hfbiA9IDAsIGN5X24gPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QuZnJvbUNvbCA9IHRoaXMuZ2V0WGRyVmFsdWUoeGRyRnJvbS5nZXRJbm5lckVsZW1lbnRzKFwieGRyOmNvbFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmZyb21Db2xPZmYgPSBnZXRQeEJ5RU1Vcyh0aGlzLmdldFhkclZhbHVlKHhkckZyb20uZ2V0SW5uZXJFbGVtZW50cyhcInhkcjpjb2xPZmZcIikpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QuZnJvbVJvdz0gdGhpcy5nZXRYZHJWYWx1ZSh4ZHJGcm9tLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6cm93XCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QuZnJvbVJvd09mZiA9IGdldFB4QnlFTVVzKHRoaXMuZ2V0WGRyVmFsdWUoeGRyRnJvbS5nZXRJbm5lckVsZW1lbnRzKFwieGRyOnJvd09mZlwiKSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QudG9Db2wgPSB0aGlzLmdldFhkclZhbHVlKHhkclRvLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6Y29sXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QudG9Db2xPZmYgPSBnZXRQeEJ5RU1Vcyh0aGlzLmdldFhkclZhbHVlKHhkclRvLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6Y29sT2ZmXCIpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LnRvUm93ID0gdGhpcy5nZXRYZHJWYWx1ZSh4ZHJUby5nZXRJbm5lckVsZW1lbnRzKFwieGRyOnJvd1wiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LnRvUm93T2ZmID0gZ2V0UHhCeUVNVXModGhpcy5nZXRYZHJWYWx1ZSh4ZHJUby5nZXRJbm5lckVsZW1lbnRzKFwieGRyOnJvd09mZlwiKSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3Qub3JpZ2luV2lkdGggPSBjeF9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5vcmlnaW5IZWlnaHQgPSBjeV9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWRpdEFzPT1cImFic29sdXRlXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QudHlwZSA9IFwiM1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZWRpdEFzPT1cIm9uZUNlbGxcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC50eXBlID0gXCIyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LnR5cGUgPSBcIjFcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QuaXNGaXhlZFBvcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5maXhlZExlZnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5maXhlZFRvcCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VCb3JkZXI6SWx1Y2t5SW1hZ2VCb3JkZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIjMDAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5ib3JkZXIgPSBpbWFnZUJvcmRlcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUNyb3A6SWx1Y2t5SW1hZ2VDcm9wID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjeV9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjeF9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QuY3JvcCA9IGltYWdlQ3JvcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZURlZmF1bHQ6SWx1Y2t5SW1hZ2VEZWZhdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjeV9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogeF9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB5X24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY3hfblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmRlZmF1bHQgPSBpbWFnZURlZmF1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmltYWdlcz09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzW2dlbmVyYXRlUmFuZG9tSW5kZXgoXCJpbWFnZVwiKV0gPSBpbWFnZU9iamVjdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9IFxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0WGRyVmFsdWUoZWxlOkVsZW1lbnRbXSk6bnVtYmVye1xyXG4gICAgICAgIGlmKGVsZT09bnVsbCB8fCBlbGUubGVuZ3RoPT0wKXtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoZWxlWzBdLnZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEJhc2U2NEJ5UmlkKHJpZDpzdHJpbmcsIGRyYXdpbmdSZWxzRmlsZTpzdHJpbmcpe1xyXG4gICAgICAgIGxldCBSZWxhdGlvbnNoaXBzID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiUmVsYXRpb25zaGlwcy9SZWxhdGlvbnNoaXBcIiwgZHJhd2luZ1JlbHNGaWxlKTtcclxuXHJcbiAgICAgICAgaWYoUmVsYXRpb25zaGlwcyE9bnVsbCAmJiBSZWxhdGlvbnNoaXBzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTxSZWxhdGlvbnNoaXBzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgbGV0IFJlbGF0aW9uc2hpcCA9IFJlbGF0aW9uc2hpcHNbaV07XHJcbiAgICAgICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSBSZWxhdGlvbnNoaXAuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgICAgIGxldCBJZCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIklkXCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNyYyA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIlRhcmdldFwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIGlmKElkID09IHJpZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcLlxcLlxcLy9nLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBzcmMgPSBcInhsL1wiICsgc3JjO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbWdhZ2UgPSB0aGlzLmltYWdlTGlzdC5nZXRJbWFnZUJ5TmFtZShzcmMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbWdhZ2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAZGVzYyBUaGlzIHdpbGwgY29udmVydCBjb2xzL2NvbCB0byBsdWNreXNoZWV0IGNvbmZpZyBvZiBjb2x1bW4nd2lkdGhcclxuICAgICovXHJcbiAgICBwcml2YXRlIGdlbmVyYXRlQ29uZmlnQ29sdW1uTGVuQW5kSGlkZGVuKCl7XHJcbiAgICAgICAgbGV0IGNvbHMgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjb2xzL2NvbFwiLCB0aGlzLnNoZWV0RmlsZSk7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTxjb2xzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICBsZXQgY29sID0gY29sc1tpXSwgYXR0ckxpc3QgPSBjb2wuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgbGV0IG1pbiA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIm1pblwiLCBudWxsKTtcclxuICAgICAgICAgICAgbGV0IG1heCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIm1heFwiLCBudWxsKTtcclxuICAgICAgICAgICAgbGV0IHdpZHRoID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwid2lkdGhcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgIGxldCBoaWRkZW4gPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJoaWRkZW5cIiwgbnVsbCk7XHJcbiAgICAgICAgICAgIGxldCBjdXN0b21XaWR0aCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcImN1c3RvbVdpZHRoXCIsIG51bGwpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmKG1pbj09bnVsbCB8fCBtYXg9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBtaW5OdW0gPSBwYXJzZUludChtaW4pLTEsIG1heE51bT1wYXJzZUludChtYXgpLTEsIHdpZHRoTnVtPXBhcnNlRmxvYXQod2lkdGgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yKGxldCBtPW1pbk51bTttPD1tYXhOdW07bSsrKXtcclxuICAgICAgICAgICAgICAgIGlmKHdpZHRoIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5jb2x1bW5sZW49PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jb2x1bW5sZW4gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY29sdW1ubGVuW21dID0gZ2V0Q29sdW1uV2lkdGhQaXhlbCh3aWR0aE51bSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoaGlkZGVuPT1cIjFcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcuY29saGlkZGVuPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY29saGlkZGVuID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmNvbGhpZGRlblttXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLmNvbHVtbmxlbil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbmZpZy5jb2x1bW5sZW5bbV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGN1c3RvbVdpZHRoIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5jdXN0b21XaWR0aD09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmN1c3RvbVdpZHRoID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmN1c3RvbVdpZHRoW21dID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBkZXNjIFRoaXMgd2lsbCBjb252ZXJ0IGNvbHMvY29sIHRvIGx1Y2t5c2hlZXQgY29uZmlnIG9mIGNvbHVtbid3aWR0aFxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgZ2VuZXJhdGVDb25maWdSb3dMZW5BbmRIaWRkZW5BZGRDZWxsKCk6SWNlbGxPdGhlckluZm97XHJcbiAgICAgICAgbGV0IHJvd3MgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzaGVldERhdGEvcm93XCIsIHRoaXMuc2hlZXRGaWxlKTtcclxuICAgICAgICBsZXQgY2VsbE90aGVySW5mbzpJY2VsbE90aGVySW5mbyA9IHt9O1xyXG4gICAgICAgIGxldCBmb3JtdWxhTGlzdDpJZm9ybXVsYUxpc3QgPSB7fTtcclxuICAgICAgICBjZWxsT3RoZXJJbmZvLmZvcm11bGFMaXN0ID0gZm9ybXVsYUxpc3Q7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTxyb3dzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICBsZXQgcm93ID0gcm93c1tpXSwgYXR0ckxpc3QgPSByb3cuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgbGV0IHJvd05vID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiclwiLCBudWxsKTtcclxuICAgICAgICAgICAgbGV0IGhlaWdodCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcImh0XCIsIG51bGwpO1xyXG4gICAgICAgICAgICBsZXQgaGlkZGVuID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiaGlkZGVuXCIsIG51bGwpO1xyXG4gICAgICAgICAgICBsZXQgY3VzdG9tSGVpZ2h0ID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiY3VzdG9tSGVpZ2h0XCIsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgaWYocm93Tm89PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCByb3dOb051bSA9IHBhcnNlSW50KHJvd05vKSAtIDE7XHJcbiAgICAgICAgICAgIGlmKGhlaWdodCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0TnVtID0gcGFyc2VGbG9hdChoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcucm93bGVuPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5yb3dsZW4gPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnJvd2xlbltyb3dOb051bV0gPSBnZXRSb3dIZWlnaHRQaXhlbChoZWlnaHROdW0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihoaWRkZW49PVwiMVwiKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLnJvd2hpZGRlbj09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcucm93aGlkZGVuID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5yb3doaWRkZW5bcm93Tm9OdW1dID0gMDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcucm93bGVuKXtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jb25maWcucm93bGVuW3Jvd05vTnVtXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihjdXN0b21IZWlnaHQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcuY3VzdG9tSGVpZ2h0PT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jdXN0b21IZWlnaHQgPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmN1c3RvbUhlaWdodFtyb3dOb051bV0gPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5pc0luaXRpYWxDZWxsKXtcclxuICAgICAgICAgICAgICAgIGxldCBjZWxscyA9IHJvdy5nZXRJbm5lckVsZW1lbnRzKFwiY1wiKTtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQga2V5IGluIGNlbGxzKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IGNlbGxzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGxWYWx1ZSA9IG5ldyBMdWNreVNoZWV0Q2VsbGRhdGEoY2VsbCwgdGhpcy5zdHlsZXMsIHRoaXMuc2hhcmVkU3RyaW5ncywgdGhpcy5tZXJnZUNlbGxzLHRoaXMuc2hlZXRGaWxlLCB0aGlzLnJlYWRYbWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5fYm9yZGVyT2JqZWN0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcuYm9yZGVySW5mbz09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5ib3JkZXJJbmZvID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYm9yZGVySW5mby5wdXNoKGNlbGxWYWx1ZS5fYm9yZGVyT2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNlbGxWYWx1ZS5fYm9yZGVyT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQgYm9yZGVySWQgPSBjZWxsVmFsdWUuX2JvcmRlcklkO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmKGJvcmRlcklkIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgbGV0IGJvcmRlcnMgPSB0aGlzLnN0eWxlc1tcImJvcmRlcnNcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBpZih0aGlzLmNvbmZpZy5fYm9yZGVySW5mbz09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICB0aGlzLmNvbmZpZy5fYm9yZGVySW5mbyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGlmKCBib3JkZXJJZCBpbiB0aGlzLmNvbmZpZy5fYm9yZGVySW5mbyl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICB0aGlzLmNvbmZpZy5fYm9yZGVySW5mb1tib3JkZXJJZF0uY2VsbHMucHVzaChjZWxsVmFsdWUuciArIFwiX1wiICsgY2VsbFZhbHVlLmMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgYm9yZGVyID0gYm9yZGVyc1tib3JkZXJJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgYm9yZGVyT2JqZWN0ID0gbmV3IEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgYm9yZGVyT2JqZWN0LnJhbmdlVHlwZSA9IFwiY2VsbEdyb3VwXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBib3JkZXJPYmplY3QuY2VsbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBib3JkZXJDZWxsVmFsdWUgPSBuZXcgTHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGxlZnRzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJsZWZ0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IHJpZ2h0cyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwicmlnaHRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgdG9wcyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwidG9wXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGJvdHRvbXMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcImJvdHRvbVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBkaWFnb25hbHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcImRpYWdvbmFsXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBsZWZ0ID0gdGhpcy5nZXRCb3JkZXJJbmZvKGxlZnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCByaWdodCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhyaWdodHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IHRvcCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyh0b3BzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBib3R0b20gPSB0aGlzLmdldEJvcmRlckluZm8oYm90dG9tcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgZGlhZ29uYWwgPSB0aGlzLmdldEJvcmRlckluZm8oZGlhZ29uYWxzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgaXNBZGQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGlmKGxlZnQhPW51bGwgJiYgbGVmdC5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLmwgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGlzQWRkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBpZihyaWdodCE9bnVsbCAmJiByaWdodC5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLnIgPSByaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYodG9wIT1udWxsICYmIHRvcC5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLnQgPSB0b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgaXNBZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGlmKGJvdHRvbSE9bnVsbCAmJiBib3R0b20uY29sb3IhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGJvcmRlckNlbGxWYWx1ZS5iID0gYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGlzQWRkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBpZihpc0FkZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgYm9yZGVyT2JqZWN0LnZhbHVlID0gYm9yZGVyQ2VsbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHRoaXMuY29uZmlnLl9ib3JkZXJJbmZvW2JvcmRlcklkXSA9IGJvcmRlck9iamVjdDtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLl9mb3JtdWxhVHlwZT09XCJzaGFyZWRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZm9ybXVsYVJlZkxpc3Q9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtdWxhUmVmTGlzdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmZvcm11bGFSZWZMaXN0W2NlbGxWYWx1ZS5fZm9ybXVsYVNpXT09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm11bGFSZWZMaXN0W2NlbGxWYWx1ZS5fZm9ybXVsYVNpXSA9IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmdjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLnYhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnYgPSAoY2VsbFZhbHVlLnYgYXMgSWx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlKS5mO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVmVmFsdWUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0OmNlbGxWYWx1ZS5fZm9ybXVsYVR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6Y2VsbFZhbHVlLl9mb211bGFSZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaTpjZWxsVmFsdWUuX2Zvcm11bGFTaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ2OmZ2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlOmNlbGxWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuX2ZvbXVsYVJlZiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm11bGFSZWZMaXN0W2NlbGxWYWx1ZS5fZm9ybXVsYVNpXVtcIm1haW5SZWZcIl0gPSByZWZWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtdWxhUmVmTGlzdFtjZWxsVmFsdWUuX2Zvcm11bGFTaV1bY2VsbFZhbHVlLnIrXCJfXCIrY2VsbFZhbHVlLmNdID0gcmVmVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHJlZlZhbHVlLCB0aGlzLmZvcm11bGFSZWZMaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vVGhlcmUgbWF5IGJlIGZvcm11bGFzIHRoYXQgZG8gbm90IGFwcGVhciBpbiBjYWxjQ2hhaW5cclxuICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUudiE9bnVsbCAmJiAoY2VsbFZhbHVlLnYgYXMgSWx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlKS5mIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvcm11bGFDZWxsOklmb3JtdWxhTGlzdEl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByOmNlbGxWYWx1ZS5yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzpjZWxsVmFsdWUuY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxPdGhlckluZm8uZm9ybXVsYUxpc3RbXCJyXCIrY2VsbFZhbHVlLnIrXCJjXCIrY2VsbFZhbHVlLmNdID0gZm9ybXVsYUNlbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxkYXRhLnB1c2goY2VsbFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2VsbE90aGVySW5mbztcclxuICAgIH1cclxuICBcclxuICAgIC8qKlxyXG4gICAgICogbHVja3lzaGVldCBjb25maWcgb2YgaHlwZXJsaW5rXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm5zIHtJbHVja3lzaGVldEh5cGVybGlua30gLSBoeXBlcmxpbmsgY29uZmlnXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2VuZXJhdGVDb25maWdIeXBlcmxpbmtzKCk6IElsdWNreXNoZWV0SHlwZXJsaW5rIHtcclxuICAgICAgbGV0IHJvd3MgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXHJcbiAgICAgICAgXCJoeXBlcmxpbmtzL2h5cGVybGlua1wiLFxyXG4gICAgICAgIHRoaXMuc2hlZXRGaWxlXHJcbiAgICAgICk7XHJcbiAgICAgIGxldCBoeXBlcmxpbms6IElsdWNreXNoZWV0SHlwZXJsaW5rID0ge307XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCByb3cgPSByb3dzW2ldO1xyXG4gICAgICAgIGxldCBhdHRyTGlzdCA9IHJvdy5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgIGxldCByZWYgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJyZWZcIiwgbnVsbCksXHJcbiAgICAgICAgICAgIHJlZkFyciA9IGdldE11bHRpU2VxdWVuY2VUb051bShyZWYpLFxyXG4gICAgICAgICAgICBfZGlzcGxheSA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcImRpc3BsYXlcIiwgbnVsbCksXHJcbiAgICAgICAgICAgIF9hZGRyZXNzID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwibG9jYXRpb25cIiwgbnVsbCksXHJcbiAgICAgICAgICAgIF90b29sdGlwID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwidG9vbHRpcFwiLCBudWxsKTtcclxuICAgICAgICBsZXQgX3R5cGU6IElsdWNreXNoZWV0SHlwZXJsaW5rVHlwZSA9IF9hZGRyZXNzID8gXCJpbnRlcm5hbFwiIDogXCJleHRlcm5hbFwiO1xyXG4gIFxyXG4gICAgICAgIC8vIGV4dGVybmFsIGh5cGVybGlua1xyXG4gICAgICAgIGlmICghX2FkZHJlc3MpIHtcclxuICAgICAgICAgIGxldCByaWQgPSBhdHRyTGlzdFtcInI6aWRcIl07XHJcbiAgICAgICAgICBsZXQgc2hlZXRGaWxlID0gdGhpcy5zaGVldEZpbGU7XHJcbiAgICAgICAgICBsZXQgcmVsYXRpb25zaGlwTGlzdCA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcclxuICAgICAgICAgICAgXCJSZWxhdGlvbnNoaXBzL1JlbGF0aW9uc2hpcFwiLFxyXG4gICAgICAgICAgICBgeGwvd29ya3NoZWV0cy9fcmVscy8ke3NoZWV0RmlsZS5yZXBsYWNlKHdvcmtzaGVldEZpbGVQYXRoLCBcIlwiKX0ucmVsc2BcclxuICAgICAgICAgICk7XHJcbiAgXHJcbiAgICAgICAgICBjb25zdCBmaW5kUmlkID0gcmVsYXRpb25zaGlwTGlzdD8uZmluZChcclxuICAgICAgICAgICAgKGUpID0+IGUuYXR0cmlidXRlTGlzdFtcIklkXCJdID09PSByaWRcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgaWYgKGZpbmRSaWQpIHtcclxuICAgICAgICAgICAgX2FkZHJlc3MgPSBmaW5kUmlkLmF0dHJpYnV0ZUxpc3RbXCJUYXJnZXRcIl07XHJcbiAgICAgICAgICAgIF90eXBlID0gZmluZFJpZC5hdHRyaWJ1dGVMaXN0W1xyXG4gICAgICAgICAgICAgIFwiVGFyZ2V0TW9kZVwiXHJcbiAgICAgICAgICAgIF0/LnRvTG9jYWxlTG93ZXJDYXNlKCkgYXMgSWx1Y2t5c2hlZXRIeXBlcmxpbmtUeXBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWF0Y2ggUjFDMVxyXG4gICAgICAgIGNvbnN0IGFkZHJlc3NSZWcgPSBuZXcgUmVnRXhwKC9eLiohUihbXFxkJF0pK0MoW1xcZCRdKSokL2cpXHJcbiAgICAgICAgaWYgKGFkZHJlc3NSZWcudGVzdChfYWRkcmVzcykpIHtcclxuICAgICAgICAgIF9hZGRyZXNzID0gZ2V0VHJhbnNSMUMxVG9TZXF1ZW5jZShfYWRkcmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGR5bmFtaWNhbGx5IGFkZCBoeXBlcmxpbmtzXHJcbiAgICAgICAgZm9yIChjb25zdCByZWYgb2YgcmVmQXJyKSB7XHJcbiAgICAgICAgICBoeXBlcmxpbmtbcmVmXSA9IHtcclxuICAgICAgICAgICAgbGlua0FkZHJlc3M6IF9hZGRyZXNzLFxyXG4gICAgICAgICAgICBsaW5rVG9vbHRpcDogX3Rvb2x0aXAgfHwgXCJcIixcclxuICAgICAgICAgICAgbGlua1R5cGU6IF90eXBlLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiBfZGlzcGxheSB8fCBcIlwiLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBoeXBlcmxpbms7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHJpdmF0ZSBnZXRCb3JkZXJJbmZvKGJvcmRlcnM6RWxlbWVudFtdKTpMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxle1xyXG4gICAgLy8gICAgIGlmKGJvcmRlcnM9PW51bGwpe1xyXG4gICAgLy8gICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIC8vICAgICB9XHJcblxyXG4gICAgLy8gICAgIGxldCBib3JkZXIgPSBib3JkZXJzWzBdLCBhdHRyTGlzdCA9IGJvcmRlci5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgLy8gICAgIGxldCBjbHJTY2hlbWUgPSB0aGlzLnN0eWxlc1tcImNsclNjaGVtZVwiXSBhcyBFbGVtZW50W107XHJcbiAgICAvLyAgICAgbGV0IHN0eWxlOnN0cmluZyA9IGF0dHJMaXN0LnN0eWxlO1xyXG4gICAgLy8gICAgIGlmKHN0eWxlPT1udWxsIHx8IHN0eWxlPT1cIm5vbmVcIil7XHJcbiAgICAvLyAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgLy8gICAgIH1cclxuXHJcbiAgICAvLyAgICAgbGV0IGNvbG9ycyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwiY29sb3JcIik7XHJcbiAgICAvLyAgICAgbGV0IGNvbG9yUmV0ID0gXCIjMDAwMDAwXCI7XHJcbiAgICAvLyAgICAgaWYoY29sb3JzIT1udWxsKXtcclxuICAgIC8vICAgICAgICAgbGV0IGNvbG9yID0gY29sb3JzWzBdO1xyXG4gICAgLy8gICAgICAgICBjb2xvclJldCA9IGdldENvbG9yKGNvbG9yLCBjbHJTY2hlbWUpO1xyXG4gICAgLy8gICAgIH1cclxuXHJcbiAgICAvLyAgICAgbGV0IHJldCA9IG5ldyBMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxlKCk7XHJcbiAgICAvLyAgICAgcmV0LnN0eWxlID0gYm9yZGVyVHlwZXNbc3R5bGVdO1xyXG4gICAgLy8gICAgIHJldC5jb2xvciA9IGNvbG9yUmV0O1xyXG5cclxuICAgIC8vICAgICByZXR1cm4gcmV0O1xyXG4gICAgLy8gfVxyXG59XHJcbiIsImltcG9ydCB7SXVwbG9hZGZpbGVMaXN0LCBJYXR0cmlidXRlTGlzdCwgc3RyaW5nVG9OdW19IGZyb20gXCIuLi9JQ29tbW9uXCI7XHJcbmltcG9ydCB7aW5kZXhlZENvbG9yc30gIGZyb20gXCIuLi9jb21tb24vY29uc3RhbnRcIjtcclxuaW1wb3J0IHtMaWdodGVuRGFya2VuQ29sb3J9ICBmcm9tIFwiLi4vY29tbW9uL21ldGhvZFwiO1xyXG5cclxuXHJcbmNsYXNzIHhtbG9wZXJhdGlvbiB7XHJcbiAgICAvKipcclxuICAgICogQHBhcmFtIHRhZyBTZWFyY2ggeG1sIHRhZyBuYW1lICwgZGl2LHRpdGxlIGV0Yy5cclxuICAgICogQHBhcmFtIGZpbGUgWG1sIHN0cmluZ1xyXG4gICAgKiBAcmV0dXJuIFhtbCBlbGVtZW50IHN0cmluZyBcclxuICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZ2V0RWxlbWVudHNCeU9uZVRhZyh0YWc6c3RyaW5nLCBmaWxlOnN0cmluZyk6c3RyaW5nW117XHJcbiAgICAgICAgLy88YTpbXi8+OiBdKz8+Lio/PC9hOlteLz46IF0rPz5cclxuICAgICAgICBsZXQgcmVhZFRhZ1JlZztcclxuICAgICAgICBpZih0YWcuaW5kZXhPZihcInxcIik+LTEpe1xyXG4gICAgICAgICAgICBsZXQgdGFncyA9IHRhZy5zcGxpdChcInxcIiksIHRhZ3NSZWdUeHQ9XCJcIjtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0YWdzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgbGV0IHQgPSB0YWdzW2ldO1xyXG4gICAgICAgICAgICAgICAgdGFnc1JlZ1R4dCArPSBcInw8XCIrIHQgK1wiIFtePl0rP1teL10+W1xcXFxzXFxcXFNdKj88L1wiKyB0ICtcIj58PFwiKyB0ICtcIiBbXj5dKz8vPnw8XCIrIHQgK1wiPltcXFxcc1xcXFxTXSo/PC9cIisgdCArXCI+fDxcIisgdCArXCIvPlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhZ3NSZWdUeHQgPSB0YWdzUmVnVHh0LnN1YnN0cigxLCB0YWdzUmVnVHh0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHJlYWRUYWdSZWcgPSBuZXcgUmVnRXhwKHRhZ3NSZWdUeHQsIFwiZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgcmVhZFRhZ1JlZyA9IG5ldyBSZWdFeHAoXCI8XCIrIHRhZyArXCIgW14+XSs/W14vXT5bXFxcXHNcXFxcU10qPzwvXCIrIHRhZyArXCI+fDxcIisgdGFnICtcIiBbXj5dKz8vPnw8XCIrIHRhZyArXCI+W1xcXFxzXFxcXFNdKj88L1wiKyB0YWcgK1wiPnw8XCIrIHRhZyArXCIvPlwiLCBcImdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCByZXQgPSBmaWxlLm1hdGNoKHJlYWRUYWdSZWcpO1xyXG4gICAgICAgIGlmKHJldD09bnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBSZWFkWG1sIGV4dGVuZHMgeG1sb3BlcmF0aW9ue1xyXG4gICAgb3JpZ2luRmlsZTpJdXBsb2FkZmlsZUxpc3RcclxuICAgIGNvbnN0cnVjdG9yKGZpbGVzOkl1cGxvYWRmaWxlTGlzdCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm9yaWdpbkZpbGUgPSBmaWxlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgKiBAcGFyYW0gcGF0aCBTZWFyY2ggeG1sIHRhZyBncm91cCAsIGRpdix0aXRsZSBldGMuXHJcbiAgICAqIEBwYXJhbSBmaWxlTmFtZSBPbmUgb2YgdXBsb2FkZmlsZUxpc3QsIHVwbG9hZGZpbGVMaXN0IGlzIGZpbGUgZ3JvdXAsIHtrZXk6dmFsdWV9XHJcbiAgICAqIEByZXR1cm4gWG1sIGVsZW1lbnQgY2Fsc3NcclxuICAgICovXHJcbiAgICBnZXRFbGVtZW50c0J5VGFnTmFtZShwYXRoOnN0cmluZywgZmlsZU5hbWU6c3RyaW5nKTogRWxlbWVudFtde1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBmaWxlID0gdGhpcy5nZXRGaWxlQnlOYW1lKGZpbGVOYW1lKTtcclxuICAgICAgICBsZXQgcGF0aEFyciA9IHBhdGguc3BsaXQoXCIvXCIpLCByZXQ6c3RyaW5nW10gfCBzdHJpbmc7XHJcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gcGF0aEFycil7XHJcbiAgICAgICAgICAgIGxldCBwYXRoID0gcGF0aEFycltrZXldO1xyXG4gICAgICAgICAgICBpZihyZXQ9PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLmdldEVsZW1lbnRzQnlPbmVUYWcocGF0aCxmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgaWYocmV0IGluc3RhbmNlb2YgQXJyYXkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtczpzdHJpbmdbXT1bXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGtleSBpbiByZXQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHJldFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdCh0aGlzLmdldEVsZW1lbnRzQnlPbmVUYWcocGF0aCxpdGVtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGl0ZW1zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICByZXQgPSB0aGlzLmdldEVsZW1lbnRzQnlPbmVUYWcocGF0aCxyZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZWxlbWVudHM6RWxlbWVudFtdID0gW107XHJcblxyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8cmV0Lmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICBsZXQgZWxlID0gbmV3IEVsZW1lbnQocmV0W2ldKTtcclxuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcGFyYW0gbmFtZSBPbmUgb2YgdXBsb2FkZmlsZUxpc3QncyBuYW1lLCBzZWFyY2ggZm9yIGZpbGUgYnkgdGhpcyBwYXJhbWV0ZXJcclxuICAgICogQHJldHJ1biBTZWxlY3QgYSBmaWxlIGZyb20gdXBsb2FkZmlsZUxpc3RcclxuICAgICovXHJcbiAgICBwcml2YXRlIGdldEZpbGVCeU5hbWUobmFtZTpzdHJpbmcpOnN0cmluZ3tcclxuICAgICAgICBmb3IobGV0IGZpbGVLZXkgaW4gdGhpcy5vcmlnaW5GaWxlKXtcclxuICAgICAgICAgICAgaWYoZmlsZUtleS5pbmRleE9mKG5hbWUpPi0xKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbkZpbGVbZmlsZUtleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBFbGVtZW50IGV4dGVuZHMgeG1sb3BlcmF0aW9uIHtcclxuICAgIGVsZW1lbnRTdHJpbmc6c3RyaW5nXHJcbiAgICBhdHRyaWJ1dGVMaXN0OklhdHRyaWJ1dGVMaXN0XHJcbiAgICB2YWx1ZTpzdHJpbmdcclxuICAgIGNvbnRhaW5lcjpzdHJpbmdcclxuICAgIGNvbnN0cnVjdG9yKHN0cjpzdHJpbmcpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50U3RyaW5nID0gc3RyO1xyXG4gICAgICAgIHRoaXMuc2V0VmFsdWUoKTtcclxuICAgICAgICBjb25zdCByZWFkQXR0clJlZyA9IG5ldyBSZWdFeHAoJ1thLXpBLVowLTlfOl0qPz1cIi4qP1wiJywgXCJnXCIpO1xyXG4gICAgICAgIGxldCBhdHRyTGlzdCA9IHRoaXMuY29udGFpbmVyLm1hdGNoKHJlYWRBdHRyUmVnKTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZUxpc3QgPSB7fTtcclxuICAgICAgICBpZihhdHRyTGlzdCE9bnVsbCl7XHJcbiAgICAgICAgICAgIGZvcihsZXQga2V5IGluIGF0dHJMaXN0KXtcclxuICAgICAgICAgICAgICAgIGxldCBhdHRyRnVsbCA9IGF0dHJMaXN0W2tleV07XHJcbiAgICAgICAgICAgICAgICAvLyBsZXQgYWw9IGF0dHJGdWxsLnNwbGl0KFwiPVwiKTtcclxuICAgICAgICAgICAgICAgIGlmKGF0dHJGdWxsLmxlbmd0aD09MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgYXR0cktleSA9IGF0dHJGdWxsLnN1YnN0cigwLCBhdHRyRnVsbC5pbmRleE9mKCc9JykpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGF0dHJWYWx1ZSA9IGF0dHJGdWxsLnN1YnN0cihhdHRyRnVsbC5pbmRleE9mKCc9JykgKyAxKTtcclxuICAgICAgICAgICAgICAgIGlmKGF0dHJLZXk9PW51bGwgfHwgYXR0clZhbHVlPT1udWxsIHx8YXR0cktleS5sZW5ndGg9PTAgfHwgYXR0clZhbHVlLmxlbmd0aD09MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZUxpc3RbYXR0cktleV0gPSBhdHRyVmFsdWUuc3Vic3RyKDEsIGF0dHJWYWx1ZS5sZW5ndGgtMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwYXJhbSBuYW1lIEdldCBhdHRyaWJ1dGUgYnkga2V5IGluIGVsZW1lbnRcclxuICAgICogQHJldHVybiBTaW5nbGUgYXR0cmlidXRlXHJcbiAgICAqL1xyXG4gICAgZ2V0KG5hbWU6c3RyaW5nKTpzdHJpbmd8bnVtYmVyfGJvb2xlYW57XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlTGlzdFtuYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQHBhcmFtIHRhZyBHZXQgZWxlbWVudHMgYnkgdGFnIGluIGVsZW1lbnRTdHJpbmdcclxuICAgICogQHJldHVybiBFbGVtZW50IGdyb3VwXHJcbiAgICAqL1xyXG4gICAgZ2V0SW5uZXJFbGVtZW50cyh0YWc6c3RyaW5nKTpFbGVtZW50W117XHJcbiAgICAgICAgbGV0IHJldCA9IHRoaXMuZ2V0RWxlbWVudHNCeU9uZVRhZyh0YWcsdGhpcy5lbGVtZW50U3RyaW5nKTtcclxuICAgICAgICBsZXQgZWxlbWVudHM6RWxlbWVudFtdID0gW107XHJcblxyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8cmV0Lmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICBsZXQgZWxlID0gbmV3IEVsZW1lbnQocmV0W2ldKTtcclxuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoZWxlbWVudHMubGVuZ3RoPT0wKXtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQGRlc2MgZ2V0IHhtbCBkb20gdmFsdWUgYW5kIGNvbnRhaW5lciwgPGNvbnRhaW5lcj52YWx1ZTwvY29udGFpbmVyPlxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgc2V0VmFsdWUoKXtcclxuICAgICAgICBsZXQgc3RyID0gdGhpcy5lbGVtZW50U3RyaW5nO1xyXG4gICAgICAgIGlmKHN0ci5zdWJzdHIoc3RyLmxlbmd0aC0yLCAyKT09XCIvPlwiKXtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gc3RyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBsZXQgZmlyc3RUYWcgPSB0aGlzLmdldEZpcnN0VGFnKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0VGFnUmVnID0gbmV3IFJlZ0V4cChcIig8XCIrIGZpcnN0VGFnICtcIiBbXj5dKz9bXi9dPikoW1xcXFxzXFxcXFNdKj8pPC9cIisgZmlyc3RUYWcgK1wiPnwoPFwiKyBmaXJzdFRhZyArXCI+KShbXFxcXHNcXFxcU10qPyk8L1wiKyBmaXJzdFRhZyArXCI+XCIsIFwiZ1wiKTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGZpcnN0VGFnUmVnLmV4ZWMoc3RyKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZihyZXN1bHRbMV0hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gcmVzdWx0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSByZXN1bHRbMl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gcmVzdWx0WzNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSByZXN1bHRbNF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBkZXNjIGdldCB4bWwgZG9tIGZpcnN0IHRhZywgPGE+PGI+PC9iPjwvYT4sIGdldCBhXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRGaXJzdFRhZygpe1xyXG4gICAgICAgIGxldCBzdHIgPSB0aGlzLmVsZW1lbnRTdHJpbmc7XHJcbiAgICAgICAgbGV0IGZpcnN0VGFnID0gc3RyLnN1YnN0cigwLCBzdHIuaW5kZXhPZignICcpKTtcclxuICAgICAgICBpZihmaXJzdFRhZz09XCJcIiB8fCBmaXJzdFRhZy5pbmRleE9mKFwiPlwiKT4tMSl7XHJcbiAgICAgICAgICAgIGZpcnN0VGFnID0gc3RyLnN1YnN0cigwLCBzdHIuaW5kZXhPZignPicpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmlyc3RUYWcgPSBmaXJzdFRhZy5zdWJzdHIoMSxmaXJzdFRhZy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBmaXJzdFRhZztcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVN0eWxlQ29sbGVjdGlvbnMge1xyXG4gICAgW2luZGV4OnN0cmluZ106RWxlbWVudFtdIHwgSWF0dHJpYnV0ZUxpc3RcclxufVxyXG5cclxuZnVuY3Rpb24gY29tYmluZUluZGV4ZWRDb2xvcihpbmRleGVkQ29sb3JzSW5uZXI6RWxlbWVudFtdLCBpbmRleGVkQ29sb3JzOklhdHRyaWJ1dGVMaXN0KTpJYXR0cmlidXRlTGlzdHtcclxuICAgIGxldCByZXQ6SWF0dHJpYnV0ZUxpc3QgPSB7fTtcclxuICAgIGlmKGluZGV4ZWRDb2xvcnNJbm5lcj09bnVsbCB8fCBpbmRleGVkQ29sb3JzSW5uZXIubGVuZ3RoPT0wKXtcclxuICAgICAgICByZXR1cm4gaW5kZXhlZENvbG9ycztcclxuICAgIH1cclxuICAgIGZvcihsZXQga2V5IGluIGluZGV4ZWRDb2xvcnMpe1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IGluZGV4ZWRDb2xvcnNba2V5XSwga24gPSBwYXJzZUludChrZXkpO1xyXG4gICAgICAgIGxldCBpbm5lciA9IGluZGV4ZWRDb2xvcnNJbm5lcltrbl07XHJcbiAgICAgICAgaWYoaW5uZXI9PW51bGwpe1xyXG4gICAgICAgICAgICByZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBsZXQgcmdiID0gaW5uZXIuYXR0cmlidXRlTGlzdC5yZ2I7XHJcbiAgICAgICAgICAgIHJldFtrZXldID0gcmdiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vL2NsclNjaGVtZTpFbGVtZW50W11cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbG9yKGNvbG9yOkVsZW1lbnQsIHN0eWxlczpJU3R5bGVDb2xsZWN0aW9ucyAsIHR5cGU6c3RyaW5nPVwiZ1wiKXtcclxuICAgIGxldCBhdHRyTGlzdCA9IGNvbG9yLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICBsZXQgY2xyU2NoZW1lID0gc3R5bGVzW1wiY2xyU2NoZW1lXCJdIGFzIEVsZW1lbnRbXTtcclxuICAgIGxldCBpbmRleGVkQ29sb3JzSW5uZXIgPSBzdHlsZXNbXCJpbmRleGVkQ29sb3JzXCJdIGFzIEVsZW1lbnRbXTtcclxuICAgIGxldCBtcnVDb2xvcnNJbm5lciA9IHN0eWxlc1tcIm1ydUNvbG9yc1wiXTtcclxuICAgIGxldCBpbmRleGVkQ29sb3JzTGlzdCA9IGNvbWJpbmVJbmRleGVkQ29sb3IoaW5kZXhlZENvbG9yc0lubmVyLCBpbmRleGVkQ29sb3JzKTtcclxuICAgIGxldCBpbmRleGVkID0gYXR0ckxpc3QuaW5kZXhlZCwgcmdiID0gYXR0ckxpc3QucmdiLCB0aGVtZSA9IGF0dHJMaXN0LnRoZW1lLCB0aW50ID0gYXR0ckxpc3QudGludDtcclxuICAgIGxldCBiZztcclxuICAgIGlmKGluZGV4ZWQhPW51bGwpe1xyXG4gICAgICAgIGxldCBpbmRleGVkTnVtID0gcGFyc2VJbnQoaW5kZXhlZCk7XHJcbiAgICAgICAgYmcgPSBpbmRleGVkQ29sb3JzTGlzdFtpbmRleGVkTnVtXTtcclxuICAgICAgICBpZihiZyE9bnVsbCl7XHJcbiAgICAgICAgICAgIGJnID0gYmcuc3Vic3RyaW5nKGJnLmxlbmd0aC02LCBiZy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBiZyA9IFwiI1wiK2JnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYocmdiIT1udWxsKXtcclxuICAgICAgICByZ2IgPSByZ2Iuc3Vic3RyaW5nKHJnYi5sZW5ndGgtNiwgcmdiLmxlbmd0aCk7XHJcbiAgICAgICAgYmcgPSBcIiNcIityZ2I7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKHRoZW1lIT1udWxsKXtcclxuICAgICAgICBsZXQgdGhlbWVOdW0gPSBwYXJzZUludCh0aGVtZSk7XHJcbiAgICAgICAgaWYodGhlbWVOdW09PTApe1xyXG4gICAgICAgICAgICB0aGVtZU51bSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhlbWVOdW09PTEpe1xyXG4gICAgICAgICAgICB0aGVtZU51bSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhlbWVOdW09PTIpe1xyXG4gICAgICAgICAgICB0aGVtZU51bSA9IDM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhlbWVOdW09PTMpe1xyXG4gICAgICAgICAgICB0aGVtZU51bSA9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjbHJTY2hlbWVFbGVtZW50ID0gY2xyU2NoZW1lW3RoZW1lTnVtXTtcclxuICAgICAgICBpZihjbHJTY2hlbWVFbGVtZW50IT1udWxsKXtcclxuICAgICAgICAgICAgbGV0IGNscnMgPSBjbHJTY2hlbWVFbGVtZW50LmdldElubmVyRWxlbWVudHMoXCJhOnN5c0NscnxhOnNyZ2JDbHJcIik7XHJcbiAgICAgICAgICAgIGlmKGNscnMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGNsciA9IGNscnNbMF07XHJcbiAgICAgICAgICAgICAgICBsZXQgY2xyQXR0ckxpc3QgPSBjbHIuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGNsci5jb250YWluZXIsICk7XHJcbiAgICAgICAgICAgICAgICBpZihjbHIuY29udGFpbmVyLmluZGV4T2YoXCJzeXNDbHJcIik+LTEpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmKHR5cGU9PVwiZ1wiICYmIGNsckF0dHJMaXN0LnZhbD09XCJ3aW5kb3dUZXh0XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBiZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYoKHR5cGU9PVwidFwiIHx8IHR5cGU9PVwiYlwiKSAmJiBjbHJBdHRyTGlzdC52YWw9PVwid2luZG93XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBiZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gfSAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBcclxuICAgICAgICAgICAgICAgICAgICBpZihjbHJBdHRyTGlzdC5sYXN0Q2xyIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmcgPSBcIiNcIiArIGNsckF0dHJMaXN0Lmxhc3RDbHI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY2xyQXR0ckxpc3QudmFsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmcgPSBcIiNcIiArIGNsckF0dHJMaXN0LnZhbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihjbHIuY29udGFpbmVyLmluZGV4T2YoXCJzcmdiQ2xyXCIpPi0xKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjbHJBdHRyTGlzdC52YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJnID0gXCIjXCIgKyBjbHJBdHRyTGlzdC52YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmKHRpbnQhPW51bGwpe1xyXG4gICAgICAgIGxldCB0aW50TnVtID0gcGFyc2VGbG9hdCh0aW50KTtcclxuICAgICAgICBpZihiZyE9bnVsbCl7XHJcbiAgICAgICAgICAgIGJnID0gTGlnaHRlbkRhcmtlbkNvbG9yKGJnLCB0aW50TnVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJnO1xyXG59XHJcblxyXG5cclxuLyoqIFxyXG4gKiBAZG9tIHhtbCBhdHRyaWJ1dGUgb2JqZWN0XHJcbiAqIEBhdHRyIGF0dHJpYnV0ZSBuYW1lXHJcbiAqIEBkIGlmIGF0dHJpYnV0ZSBpcyBudWxsLCByZXR1cm4gZGVmYXVsdCB2YWx1ZSBcclxuICogQHJldHVybiBhdHRyaWJ1dGUgdmFsdWVcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldGxpbmVTdHJpbmdBdHRyKGZycHI6RWxlbWVudCwgYXR0cjpzdHJpbmcpOnN0cmluZ3tcclxuICAgIGxldCBhdHRyRWxlID0gZnJwci5nZXRJbm5lckVsZW1lbnRzKGF0dHIpLCB2YWx1ZTtcclxuXHJcbiAgICBpZihhdHRyRWxlIT1udWxsICYmIGF0dHJFbGUubGVuZ3RoPjApe1xyXG4gICAgICAgIGlmKGF0dHI9PVwiYlwiIHx8IGF0dHI9PVwiaVwiIHx8IGF0dHI9PVwic3RyaWtlXCIpe1xyXG4gICAgICAgICAgICB2YWx1ZSA9IFwiMVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGF0dHI9PVwidVwiKXtcclxuICAgICAgICAgICAgbGV0IHYgPSBhdHRyRWxlWzBdLmF0dHJpYnV0ZUxpc3QudmFsO1xyXG4gICAgICAgICAgICBpZih2PT1cImRvdWJsZVwiKXtcclxuICAgICAgICAgICAgICAgIHZhbHVlwqA9wqDCoFwiMlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2XCoGlmKHY9PVwic2luZ2xlQWNjb3VudGluZ1wiKXtcclxuICAgICAgICAgICAgICAgIHZhbHVlwqA9wqDCoFwiM1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2XCoGlmKHY9PVwiZG91YmxlQWNjb3VudGluZ1wiKXtcclxuICAgICAgICAgICAgICAgIHZhbHVlwqA9wqDCoFwiNFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiMVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoYXR0cj09XCJ2ZXJ0QWxpZ25cIil7XHJcbiAgICAgICAgICAgIGxldCB2ID0gYXR0ckVsZVswXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICAgICAgaWYodj09XCJzdWJzY3JpcHRcIil7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiMVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodj09XCJzdXBlcnNjcmlwdFwiKXtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIyXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdmFsdWUgPSBhdHRyRWxlWzBdLmF0dHJpYnV0ZUxpc3QudmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn0iLCJpbXBvcnQge3N0cmluZ1RvTnVtLCBJYXR0cmlidXRlTGlzdCwgbnVtVG9zdHJpbmd9IGZyb20gXCIuLi9JQ29tbW9uXCI7XHJcblxyXG5leHBvcnQgY29uc3QgY29sdW1lSGVhZGVyX3dvcmQ6c3RyaW5nW10gPSBbJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWiddO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbHVtZUhlYWRlcl93b3JkX2luZGV4OnN0cmluZ1RvTnVtID0geyAnQSc6IDAsICdCJzogMSwgJ0MnOiAyLCAnRCc6IDMsICdFJzogNCwgJ0YnOiA1LCAnRyc6IDYsICdIJzogNywgJ0knOiA4LCAnSic6IDksICdLJzogMTAsICdMJzogMTEsICdNJzogMTIsICdOJzogMTMsICdPJzogMTQsICdQJzogMTUsICdRJzogMTYsICdSJzogMTcsICdTJzogMTgsICdUJzogMTksICdVJzogMjAsICdWJzogMjEsICdXJzogMjIsICdYJzogMjMsICdZJzogMjQsICdaJzogMjUgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb3JlRmlsZSA9IFwiZG9jUHJvcHMvY29yZS54bWxcIjtcclxuZXhwb3J0IGNvbnN0IGFwcEZpbGUgPSBcImRvY1Byb3BzL2FwcC54bWxcIjtcclxuZXhwb3J0IGNvbnN0IGNvbnRlbnRUeXBlc0ZpbGUgPSBcIltDb250ZW50X1R5cGVzXS54bWxcIjtcclxuZXhwb3J0IGNvbnN0IHdvcmtCb29rRmlsZSA9IFwieGwvd29ya2Jvb2sueG1sXCI7XHJcbmV4cG9ydCBjb25zdCBjYWxjQ2hhaW5GaWxlID0gXCJ4bC9jYWxjQ2hhaW4ueG1sXCI7XHJcbmV4cG9ydCBjb25zdCBzdHlsZXNGaWxlID0gXCJ4bC9zdHlsZXMueG1sXCI7XHJcbmV4cG9ydCBjb25zdCBzaGFyZWRTdHJpbmdzRmlsZSA9IFwieGwvc2hhcmVkU3RyaW5ncy54bWxcIjtcclxuZXhwb3J0IGNvbnN0IHdvcmtzaGVldEZpbGVQYXRoID0gXCJ4bC93b3Jrc2hlZXRzL1wiO1xyXG5leHBvcnQgY29uc3QgdGhlbWUxRmlsZSA9IFwieGwvdGhlbWUvdGhlbWUxLnhtbFwiO1xyXG5leHBvcnQgY29uc3Qgd29ya2Jvb2tSZWxzPSBcInhsL19yZWxzL3dvcmtib29rLnhtbC5yZWxzXCI7XHJcblxyXG5cclxuXHJcblxyXG4vL0V4Y2VsIEJ1aWx0LUluIGNlbGwgdHlwZVxyXG5leHBvcnQgY29uc3QgU1RfQ2VsbFR5cGU6SWF0dHJpYnV0ZUxpc3QgPXtcclxuICAgIFwiQm9vbGVhblwiOlwiYlwiLFxyXG4gICAgXCJEYXRlXCI6XCJkXCIsXHJcbiAgICBcIkVycm9yXCI6XCJlXCIsXHJcbiAgICBcIklubGluZVN0cmluZ1wiOlwiaW5saW5lU3RyXCIsXHJcbiAgICBcIk51bWJlclwiOlwiblwiLFxyXG4gICAgXCJTaGFyZWRTdHJpbmdcIjpcInNcIixcclxuICAgIFwiU3RyaW5nXCI6XCJzdHJcIixcclxufVxyXG5cclxuLy9FeGNlbCBCdWlsdC1JbiBjZWxsIHN0eWxlXHJcbmV4cG9ydCBjb25zdCBCdWlsdEluQ2VsbFN0eWxlczpJYXR0cmlidXRlTGlzdCA9IHtcclxuICAgIFwiMFwiOlwiTm9ybWFsXCIsXHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IGxldCBudW1GbXREZWZhdWx0OklhdHRyaWJ1dGVMaXN0ID0ge1xyXG4gICAgXCIwXCI6J0dlbmVyYWwnLFxyXG4gICAgXCIxXCI6ICcwJyxcclxuICAgIFwiMlwiOiAnMC4wMCcsXHJcbiAgICBcIjNcIjogJyMsIyMwJyxcclxuICAgIFwiNFwiOiAnIywjIzAuMDAnLFxyXG4gICAgXCI5XCI6JzAlJyxcclxuICAgIFwiMTBcIjogJzAuMDAlJyxcclxuICAgIFwiMTFcIjogJzAuMDBFKzAwJyxcclxuICAgIFwiMTJcIjogJyMgPy8/JyxcclxuICAgIFwiMTNcIjogJyMgPz8vPz8nLFxyXG4gICAgXCIxNFwiOiAnbS9kL3l5JyxcclxuICAgIFwiMTVcIjogJ2QtbW1tLXl5JyxcclxuICAgIFwiMTZcIjogJ2QtbW1tJyxcclxuICAgIFwiMTdcIjogJ21tbS15eScsXHJcbiAgICBcIjE4XCI6ICdoOm1tIEFNL1BNJyxcclxuICAgIFwiMTlcIjogJ2g6bW06c3MgQU0vUE0nLFxyXG4gICAgXCIyMFwiOiAnaDptbScsXHJcbiAgICBcIjIxXCI6ICdoOm1tOnNzJyxcclxuICAgIFwiMjJcIjogJ20vZC95eSBoOm1tJyxcclxuICAgIFwiMzdcIjogJyMsIyMwIDsoIywjIzApJyxcclxuICAgIFwiMzhcIjogJyMsIyMwIDtbUmVkXSgjLCMjMCknLFxyXG4gICAgXCIzOVwiOiAnIywjIzAuMDA7KCMsIyMwLjAwKScsXHJcbiAgICBcIjQwXCI6ICcjLCMjMC4wMDtbUmVkXSgjLCMjMC4wMCknLFxyXG4gICAgXCI0NVwiOiAnbW06c3MnLFxyXG4gICAgXCI0NlwiOiAnW2hdOm1tOnNzJyxcclxuICAgIFwiNDdcIjogJ21tc3MuMCcsXHJcbiAgICBcIjQ4XCI6ICcjIzAuMEUrMCcsXHJcbiAgICBcIjQ5XCI6ICdAJ1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgaW5kZXhlZENvbG9yczpJYXR0cmlidXRlTGlzdCA9IHtcclxuICAgIFwiMFwiOicwMDAwMDAwMCcsXHJcbiAgICBcIjFcIjonMDBGRkZGRkYnLFxyXG4gICAgXCIyXCI6JzAwRkYwMDAwJyxcclxuICAgIFwiM1wiOicwMDAwRkYwMCcsXHJcbiAgICBcIjRcIjonMDAwMDAwRkYnLFxyXG4gICAgXCI1XCI6JzAwRkZGRjAwJyxcclxuICAgIFwiNlwiOicwMEZGMDBGRicsXHJcbiAgICBcIjdcIjonMDAwMEZGRkYnLFxyXG4gICAgXCI4XCI6JzAwMDAwMDAwJyxcclxuICAgIFwiOVwiOicwMEZGRkZGRicsXHJcbiAgICBcIjEwXCI6JzAwRkYwMDAwJyxcclxuICAgIFwiMTFcIjonMDAwMEZGMDAnLFxyXG4gICAgXCIxMlwiOicwMDAwMDBGRicsXHJcbiAgICBcIjEzXCI6JzAwRkZGRjAwJyxcclxuICAgIFwiMTRcIjonMDBGRjAwRkYnLFxyXG4gICAgXCIxNVwiOicwMDAwRkZGRicsXHJcbiAgICBcIjE2XCI6JzAwODAwMDAwJyxcclxuICAgIFwiMTdcIjonMDAwMDgwMDAnLFxyXG4gICAgXCIxOFwiOicwMDAwMDA4MCcsXHJcbiAgICBcIjE5XCI6JzAwODA4MDAwJyxcclxuICAgIFwiMjBcIjonMDA4MDAwODAnLFxyXG4gICAgXCIyMVwiOicwMDAwODA4MCcsXHJcbiAgICBcIjIyXCI6JzAwQzBDMEMwJyxcclxuICAgIFwiMjNcIjonMDA4MDgwODAnLFxyXG4gICAgXCIyNFwiOicwMDk5OTlGRicsXHJcbiAgICBcIjI1XCI6JzAwOTkzMzY2JyxcclxuICAgIFwiMjZcIjonMDBGRkZGQ0MnLFxyXG4gICAgXCIyN1wiOicwMENDRkZGRicsXHJcbiAgICBcIjI4XCI6JzAwNjYwMDY2JyxcclxuICAgIFwiMjlcIjonMDBGRjgwODAnLFxyXG4gICAgXCIzMFwiOicwMDAwNjZDQycsXHJcbiAgICBcIjMxXCI6JzAwQ0NDQ0ZGJyxcclxuICAgIFwiMzJcIjonMDAwMDAwODAnLFxyXG4gICAgXCIzM1wiOicwMEZGMDBGRicsXHJcbiAgICBcIjM0XCI6JzAwRkZGRjAwJyxcclxuICAgIFwiMzVcIjonMDAwMEZGRkYnLFxyXG4gICAgXCIzNlwiOicwMDgwMDA4MCcsXHJcbiAgICBcIjM3XCI6JzAwODAwMDAwJyxcclxuICAgIFwiMzhcIjonMDAwMDgwODAnLFxyXG4gICAgXCIzOVwiOicwMDAwMDBGRicsXHJcbiAgICBcIjQwXCI6JzAwMDBDQ0ZGJyxcclxuICAgIFwiNDFcIjonMDBDQ0ZGRkYnLFxyXG4gICAgXCI0MlwiOicwMENDRkZDQycsXHJcbiAgICBcIjQzXCI6JzAwRkZGRjk5JyxcclxuICAgIFwiNDRcIjonMDA5OUNDRkYnLFxyXG4gICAgXCI0NVwiOicwMEZGOTlDQycsXHJcbiAgICBcIjQ2XCI6JzAwQ0M5OUZGJyxcclxuICAgIFwiNDdcIjonMDBGRkNDOTknLFxyXG4gICAgXCI0OFwiOicwMDMzNjZGRicsXHJcbiAgICBcIjQ5XCI6JzAwMzNDQ0NDJyxcclxuICAgIFwiNTBcIjonMDA5OUNDMDAnLFxyXG4gICAgXCI1MVwiOicwMEZGQ0MwMCcsXHJcbiAgICBcIjUyXCI6JzAwRkY5OTAwJyxcclxuICAgIFwiNTNcIjonMDBGRjY2MDAnLFxyXG4gICAgXCI1NFwiOicwMDY2NjY5OScsXHJcbiAgICBcIjU1XCI6JzAwOTY5Njk2JyxcclxuICAgIFwiNTZcIjonMDAwMDMzNjYnLFxyXG4gICAgXCI1N1wiOicwMDMzOTk2NicsXHJcbiAgICBcIjU4XCI6JzAwMDAzMzAwJyxcclxuICAgIFwiNTlcIjonMDAzMzMzMDAnLFxyXG4gICAgXCI2MFwiOicwMDk5MzMwMCcsXHJcbiAgICBcIjYxXCI6JzAwOTkzMzY2JyxcclxuICAgIFwiNjJcIjonMDAzMzMzOTknLFxyXG4gICAgXCI2M1wiOicwMDMzMzMzMycsXHJcbiAgICBcIjY0XCI6bnVsbCwvL3N5c3RlbSBGb3JlZ3JvdW5kIG4vYVxyXG4gICAgXCI2NVwiOm51bGwsLy9zeXN0ZW0gQmFja2dyb3VuZCBuL2FcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IE9FTV9DSEFSU0VUOklhdHRyaWJ1dGVMaXN0ID0ge1xyXG4gICAgXCIwXCI6IFwiQU5TSV9DSEFSU0VUXCIsXHJcbiAgICBcIjFcIjogXCJERUZBVUxUX0NIQVJTRVRcIixcclxuICAgIFwiMlwiOiBcIlNZTUJPTF9DSEFSU0VUXCIsXHJcbiAgICBcIjc3XCI6IFwiTUFDX0NIQVJTRVRcIixcclxuICAgIFwiMTI4XCI6IFwiU0hJRlRKSVNfQ0hBUlNFVFwiLFxyXG4gICAgXCIxMjlcIjogXCJIQU5HVUxfQ0hBUlNFVFwiLFxyXG4gICAgXCIxMzBcIjogXCJKT0hBQl9DSEFSU0VUXCIsXHJcbiAgICBcIjEzNFwiOiBcIkdCMjMxMl9DSEFSU0VUXCIsXHJcbiAgICBcIjEzNlwiOiBcIkNISU5FU0VCSUc1X0NIQVJTRVRcIixcclxuICAgIFwiMTYxXCI6IFwiR1JFRUtfQ0hBUlNFVFwiLFxyXG4gICAgXCIxNjJcIjogXCJUVVJLSVNIX0NIQVJTRVRcIixcclxuICAgIFwiMTYzXCI6IFwiVklFVE5BTUVTRV9DSEFSU0VUXCIsXHJcbiAgICBcIjE3N1wiOiBcIkhFQlJFV19DSEFSU0VUXCIsXHJcbiAgICBcIjE3OFwiOiBcIkFSQUJJQ19DSEFSU0VUXCIsXHJcbiAgICBcIjE4NlwiOiBcIkJBTFRJQ19DSEFSU0VUXCIsXHJcbiAgICBcIjIwNFwiOiBcIlJVU1NJQU5fQ0hBUlNFVFwiLFxyXG4gICAgXCIyMjJcIjogXCJUSEFJX0NIQVJTRVRcIixcclxuICAgIFwiMjM4XCI6IFwiRUFTVEVVUk9QRV9DSEFSU0VUXCIsXHJcbiAgICBcIjI1NVwiOiBcIk9FTV9DSEFSU0VUXCIsXHJcbn1cclxuXHJcblxyXG5leHBvcnQgY29uc3QgYm9yZGVyVHlwZXM6c3RyaW5nVG9OdW0gPSB7XHJcbiAgICBcIm5vbmVcIjowLFxyXG4gICAgXCJ0aGluXCI6MSwgXHJcbiAgICBcImhhaXJcIjoyLCBcclxuICAgIFwiZG90dGVkXCI6MywgXHJcbiAgICBcImRhc2hlZFwiOjQsIFxyXG4gICAgXCJkYXNoRG90XCI6NSwgXHJcbiAgICBcImRhc2hEb3REb3RcIjo2LCBcclxuICAgIFwiZG91YmxlXCI6NywgXHJcbiAgICBcIm1lZGl1bVwiOjgsIFxyXG4gICAgXCJtZWRpdW1EYXNoZWRcIjo5LCBcclxuICAgIFwibWVkaXVtRGFzaERvdFwiOjEwLCBcclxuICAgIFwibWVkaXVtRGFzaERvdERvdFwiOjExLCBcclxuICAgIFwic2xhbnREYXNoRG90XCI6MTIsIFxyXG4gICAgXCJ0aGlja1wiOjEzXHJcbn1cclxuXHJcblxyXG5leHBvcnQgbGV0IG51bUZtdERlZmF1bHRNYXA6IElhdHRyaWJ1dGVMaXN0ID0ge1xyXG4gICAgXCJ5eXl5L20vZDtAXCI6IFwieXl5eS9NTS9kZFwiLFxyXG4gICAgXCJ5eXl5JnF1b3Q75bm0JnF1b3Q7bSZxdW90O+aciCZxdW90O2QmcXVvdDvml6UmcXVvdDs7QFwiOlxyXG4gICAgICBcInl5eXkmcXVvdDvlubQmcXVvdDtNTSZxdW90O+aciCZxdW90O2RkJnF1b3Q75pelJnF1b3Q7XCIsXHJcbiAgICBcIlskLTQwOV15eXl5L20vZFxcXFwgaDptbVxcXFwgQU0vUE07QFwiOiBcInl5eXkvTU0vZGQgaGg6bW0gQU0vUE1cIixcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBmb250RmFtaWx5czpJYXR0cmlidXRlTGlzdCA9IHtcclxuICAgIFwiMFwiOlwiZGVmdWFsdFwiLFxyXG4gICAgXCIxXCI6XCJSb21hblwiLFxyXG4gICAgXCIyXCI6XCJTd2lzc1wiLFxyXG4gICAgXCIzXCI6XCJNb2Rlcm5cIixcclxuICAgIFwiNFwiOlwiU2NyaXB0XCIsXHJcbiAgICBcIjVcIjpcIkRlY29yYXRpdmVcIlxyXG59IiwiZXhwb3J0IGxldCBVRE9DOmFueSA9IHt9O1xyXG5cdFxyXG5cdFVET0MuRyA9IHtcclxuXHRcdGNvbmNhdCA6IGZ1bmN0aW9uKHA6YW55LHI6YW55KSB7XHJcblx0XHRcdGZvcih2YXIgaT0wOyBpPHIuY21kcy5sZW5ndGg7IGkrKykgcC5jbWRzLnB1c2goci5jbWRzW2ldKTtcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8ci5jcmRzLmxlbmd0aDsgaSsrKSBwLmNyZHMucHVzaChyLmNyZHNbaV0pO1xyXG5cdFx0fSxcclxuXHRcdGdldEJCICA6IGZ1bmN0aW9uKHBzOmFueSkge1xyXG5cdFx0XHR2YXIgeDA9MWU5OSwgeTA9MWU5OSwgeDE9LXgwLCB5MT0teTA7XHJcblx0XHRcdGZvcih2YXIgaT0wOyBpPHBzLmxlbmd0aDsgaSs9MikgeyAgdmFyIHg9cHNbaV0seT1wc1tpKzFdOyAgaWYoeDx4MCl4MD14OyBlbHNlIGlmKHg+eDEpeDE9eDsgIGlmKHk8eTApeTA9eTsgIGVsc2UgaWYoeT55MSl5MT15OyAgfVxyXG5cdFx0XHRyZXR1cm4gW3gwLHkwLHgxLHkxXTtcclxuXHRcdH0sXHJcblx0XHRyZWN0VG9QYXRoOiBmdW5jdGlvbihyOmFueSkgeyAgcmV0dXJuICB7Y21kczpbXCJNXCIsXCJMXCIsXCJMXCIsXCJMXCIsXCJaXCJdLGNyZHM6W3JbMF0sclsxXSxyWzJdLHJbMV0sIHJbMl0sclszXSxyWzBdLHJbM11dfTsgIH0sXHJcblx0XHQvLyBhIGluc2lkZSBiXHJcblx0XHRpbnNpZGVCb3g6IGZ1bmN0aW9uKGE6YW55LGI6YW55KSB7ICByZXR1cm4gYlswXTw9YVswXSAmJiBiWzFdPD1hWzFdICYmIGFbMl08PWJbMl0gJiYgYVszXTw9YlszXTsgICB9LFxyXG5cdFx0aXNCb3ggOiBmdW5jdGlvbihwOmFueSwgYmI6YW55KSB7XHJcblx0XHRcdHZhciBzYW1lQ3JkOCA9IGZ1bmN0aW9uKHBjcmQ6YW55LCBjcmRzOmFueSkge1xyXG5cdFx0XHRcdGZvcih2YXIgbz0wOyBvPDg7IG8rPTIpIHsgIHZhciBlcSA9IHRydWU7ICBmb3IodmFyIGo9MDsgajw4OyBqKyspIGlmKE1hdGguYWJzKGNyZHNbal0tcGNyZFsoaitvKSY3XSk+PTIpIHsgIGVxID0gZmFsc2U7ICBicmVhazsgIH0gICAgaWYoZXEpIHJldHVybiB0cnVlOyAgfVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fTtcclxuXHRcdFx0aWYocC5jbWRzLmxlbmd0aD4xMCkgcmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR2YXIgY21kcz1wLmNtZHMuam9pbihcIlwiKSwgY3Jkcz1wLmNyZHM7XHJcblx0XHRcdHZhciBzYW1lUmVjdCA9IGZhbHNlO1xyXG5cdFx0XHRpZigoY21kcz09XCJNTExMWlwiICAmJiBjcmRzLmxlbmd0aD09IDgpIFxyXG5cdFx0XHQgfHwoY21kcz09XCJNTExMTFpcIiAmJiBjcmRzLmxlbmd0aD09MTApICkge1xyXG5cdFx0XHRcdGlmKGNyZHMubGVuZ3RoPT0xMCkgY3Jkcz1jcmRzLnNsaWNlKDAsOCk7XHJcblx0XHRcdFx0dmFyIHgwPWJiWzBdLHkwPWJiWzFdLHgxPWJiWzJdLHkxPWJiWzNdO1xyXG5cdFx0XHRcdGlmKCFzYW1lUmVjdCkgc2FtZVJlY3QgPSBzYW1lQ3JkOChjcmRzLCBbeDAseTAseDEseTAseDEseTEseDAseTFdKTtcclxuXHRcdFx0XHRpZighc2FtZVJlY3QpIHNhbWVSZWN0ID0gc2FtZUNyZDgoY3JkcywgW3gwLHkxLHgxLHkxLHgxLHkwLHgwLHkwXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHNhbWVSZWN0O1xyXG5cdFx0fSxcclxuXHRcdGJveEFyZWE6IGZ1bmN0aW9uKGE6YW55KSB7ICB2YXIgdz1hWzJdLWFbMF0sIGg9YVszXS1hWzFdOyAgcmV0dXJuIHcqaDsgIH0sXHJcblx0XHRuZXdQYXRoOiBmdW5jdGlvbihnc3Q6YW55ICAgICkgeyAgZ3N0LnB0aCA9IHtjbWRzOltdLCBjcmRzOltdfTsgIH0sXHJcblx0XHRtb3ZlVG8gOiBmdW5jdGlvbihnc3Q6YW55LHg6YW55LHk6YW55KSB7ICB2YXIgcD1VRE9DLk0ubXVsdFBvaW50KGdzdC5jdG0sW3gseV0pOyAgLy9pZihnc3QuY3Bvc1swXT09cFswXSAmJiBnc3QuY3Bvc1sxXT09cFsxXSkgcmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGdzdC5wdGguY21kcy5wdXNoKFwiTVwiKTsgIGdzdC5wdGguY3Jkcy5wdXNoKHBbMF0scFsxXSk7ICBnc3QuY3BvcyA9IHA7ICB9LFxyXG5cdFx0bGluZVRvIDogZnVuY3Rpb24oZ3N0OmFueSx4OmFueSx5OmFueSkgeyAgdmFyIHA9VURPQy5NLm11bHRQb2ludChnc3QuY3RtLFt4LHldKTsgIGlmKGdzdC5jcG9zWzBdPT1wWzBdICYmIGdzdC5jcG9zWzFdPT1wWzFdKSByZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Z3N0LnB0aC5jbWRzLnB1c2goXCJMXCIpOyAgZ3N0LnB0aC5jcmRzLnB1c2gocFswXSxwWzFdKTsgIGdzdC5jcG9zID0gcDsgIH0sXHJcblx0XHRjdXJ2ZVRvOiBmdW5jdGlvbihnc3Q6YW55LHgxOmFueSx5MTphbnkseDI6YW55LHkyOmFueSx4MzphbnkseTM6YW55KSB7ICAgdmFyIHA7ICBcclxuXHRcdFx0cD1VRE9DLk0ubXVsdFBvaW50KGdzdC5jdG0sW3gxLHkxXSk7ICB4MT1wWzBdOyAgeTE9cFsxXTtcclxuXHRcdFx0cD1VRE9DLk0ubXVsdFBvaW50KGdzdC5jdG0sW3gyLHkyXSk7ICB4Mj1wWzBdOyAgeTI9cFsxXTtcclxuXHRcdFx0cD1VRE9DLk0ubXVsdFBvaW50KGdzdC5jdG0sW3gzLHkzXSk7ICB4Mz1wWzBdOyAgeTM9cFsxXTsgIGdzdC5jcG9zID0gcDtcclxuXHRcdFx0Z3N0LnB0aC5jbWRzLnB1c2goXCJDXCIpOyAgXHJcblx0XHRcdGdzdC5wdGguY3Jkcy5wdXNoKHgxLHkxLHgyLHkyLHgzLHkzKTsgIFxyXG5cdFx0fSxcclxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24oZ3N0OmFueSAgKSB7ICBnc3QucHRoLmNtZHMucHVzaChcIlpcIik7ICB9LFxyXG5cdFx0YXJjIDogZnVuY3Rpb24oZ3N0OmFueSx4OmFueSx5OmFueSxyOmFueSxhMDphbnksYTE6YW55LCBuZWc6YW55KSB7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBjaXJjbGUgZnJvbSBhMCBjb3VudGVyLWNsb2NrLXdpc2UgdG8gYTFcclxuXHRcdFx0aWYobmVnKSB3aGlsZShhMT5hMCkgYTEtPTIqTWF0aC5QSTtcclxuXHRcdFx0ZWxzZSAgICB3aGlsZShhMTxhMCkgYTErPTIqTWF0aC5QSTtcclxuXHRcdFx0dmFyIHRoID0gKGExLWEwKS80O1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHgwID0gTWF0aC5jb3ModGgvMiksIHkwID0gLU1hdGguc2luKHRoLzIpO1xyXG5cdFx0XHR2YXIgeDEgPSAoNC14MCkvMywgeTEgPSB5MD09MCA/IHkwIDogKDEteDApKigzLXgwKS8oMyp5MCk7XHJcblx0XHRcdHZhciB4MiA9IHgxLCB5MiA9IC15MTtcclxuXHRcdFx0dmFyIHgzID0geDAsIHkzID0gLXkwO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHAwID0gW3gwLHkwXSwgcDEgPSBbeDEseTFdLCBwMiA9IFt4Mix5Ml0sIHAzID0gW3gzLHkzXTtcclxuXHRcdFx0XHJcblx0XHRcdHZhciBwdGggPSB7Y21kczpbKGdzdC5wdGguY21kcy5sZW5ndGg9PTApP1wiTVwiOlwiTFwiLFwiQ1wiLFwiQ1wiLFwiQ1wiLFwiQ1wiXSwgY3JkczpbeDAseTAseDEseTEseDIseTIseDMseTNdfTtcclxuXHRcdFx0XHJcblx0XHRcdHZhciByb3QgPSBbMSwwLDAsMSwwLDBdOyAgVURPQy5NLnJvdGF0ZShyb3QsLXRoKTtcclxuXHRcdFx0XHJcblx0XHRcdGZvcih2YXIgaT0wOyBpPDM7IGkrKykge1xyXG5cdFx0XHRcdHAxID0gVURPQy5NLm11bHRQb2ludChyb3QscDEpOyAgcDIgPSBVRE9DLk0ubXVsdFBvaW50KHJvdCxwMik7ICBwMyA9IFVET0MuTS5tdWx0UG9pbnQocm90LHAzKTtcclxuXHRcdFx0XHRwdGguY3Jkcy5wdXNoKHAxWzBdLHAxWzFdLHAyWzBdLHAyWzFdLHAzWzBdLHAzWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHNjID0gW3IsMCwwLHIseCx5XTsgIFxyXG5cdFx0XHRVRE9DLk0ucm90YXRlKHJvdCwgLWEwK3RoLzIpOyAgVURPQy5NLmNvbmNhdChyb3QsIHNjKTsgIFVET0MuTS5tdWx0QXJyYXkocm90LCBwdGguY3Jkcyk7XHJcblx0XHRcdFVET0MuTS5tdWx0QXJyYXkoZ3N0LmN0bSwgcHRoLmNyZHMpO1xyXG5cdFx0XHRcclxuXHRcdFx0VURPQy5HLmNvbmNhdChnc3QucHRoLCBwdGgpO1xyXG5cdFx0XHR2YXIgeTphbnk9cHRoLmNyZHMucG9wKCk7ICB4PXB0aC5jcmRzLnBvcCgpO1xyXG5cdFx0XHRnc3QuY3BvcyA9IFt4LHldO1xyXG5cdFx0fSxcclxuXHRcdHRvUG9seSA6IGZ1bmN0aW9uKHA6YW55KSB7XHJcblx0XHRcdGlmKHAuY21kc1swXSE9XCJNXCIgfHwgcC5jbWRzW3AuY21kcy5sZW5ndGgtMV0hPVwiWlwiKSByZXR1cm4gbnVsbDtcclxuXHRcdFx0Zm9yKHZhciBpPTE7IGk8cC5jbWRzLmxlbmd0aC0xOyBpKyspIGlmKHAuY21kc1tpXSE9XCJMXCIpIHJldHVybiBudWxsO1xyXG5cdFx0XHR2YXIgb3V0ID0gW10sIGNsID0gcC5jcmRzLmxlbmd0aDtcclxuXHRcdFx0aWYocC5jcmRzWzBdPT1wLmNyZHNbY2wtMl0gJiYgcC5jcmRzWzFdPT1wLmNyZHNbY2wtMV0pIGNsLT0yO1xyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTxjbDsgaSs9Mikgb3V0LnB1c2goW3AuY3Jkc1tpXSxwLmNyZHNbaSsxXV0pO1xyXG5cdFx0XHRpZihVRE9DLkcucG9seUFyZWEocC5jcmRzKTwwKSBvdXQucmV2ZXJzZSgpO1xyXG5cdFx0XHRyZXR1cm4gb3V0O1xyXG5cdFx0fSxcclxuXHRcdGZyb21Qb2x5IDogZnVuY3Rpb24ocDphbnkpIHtcclxuXHRcdFx0dmFyIG86YW55ID0ge2NtZHM6W10sY3JkczpbXX07XHJcblx0XHRcdGZvcih2YXIgaT0wOyBpPHAubGVuZ3RoOyBpKyspIHsgby5jcmRzLnB1c2gocFtpXVswXSwgcFtpXVsxXSk7ICBvLmNtZHMucHVzaChpPT0wP1wiTVwiOlwiTFwiKTsgIH1cclxuXHRcdFx0by5jbWRzLnB1c2goXCJaXCIpO1xyXG5cdFx0XHRyZXR1cm4gbztcclxuXHRcdH0sXHJcblx0XHRwb2x5QXJlYSA6IGZ1bmN0aW9uKHA6YW55KSB7XHJcblx0XHRcdGlmKHAubGVuZ3RoIDw2KSByZXR1cm4gMDtcclxuXHRcdFx0dmFyIGwgPSBwLmxlbmd0aCAtIDI7XHJcblx0XHRcdHZhciBzdW0gPSAocFswXS1wW2xdKSAqIChwW2wrMV0rcFsxXSk7XHJcblx0XHRcdGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXHJcblx0XHRcdFx0c3VtICs9IChwW2krMl0tcFtpXSkgKiAocFtpKzFdK3BbaSszXSk7XHJcblx0XHRcdHJldHVybiAtIHN1bSAqIDAuNTtcclxuXHRcdH0sXHJcblx0XHRwb2x5Q2xpcCA6IGZ1bmN0aW9uKHAwOmFueSwgcDE6YW55KSB7ICAvLyBwMCBjbGlwcGVkIGJ5IHAxXHJcbiAgICAgICAgICAgIHZhciBjcDE6YW55LCBjcDI6YW55LCBzOmFueSwgZTphbnk7XHJcbiAgICAgICAgICAgIHZhciBpbnNpZGUgPSBmdW5jdGlvbiAocDphbnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoY3AyWzBdLWNwMVswXSkqKHBbMV0tY3AxWzFdKSA+IChjcDJbMV0tY3AxWzFdKSoocFswXS1jcDFbMF0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgaXNjID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRjID0gWyBjcDFbMF0gLSBjcDJbMF0sIGNwMVsxXSAtIGNwMlsxXSBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGRwID0gWyBzWzBdIC0gZVswXSwgc1sxXSAtIGVbMV0gXSxcclxuICAgICAgICAgICAgICAgICAgICBuMSA9IGNwMVswXSAqIGNwMlsxXSAtIGNwMVsxXSAqIGNwMlswXSxcclxuICAgICAgICAgICAgICAgICAgICBuMiA9IHNbMF0gKiBlWzFdIC0gc1sxXSAqIGVbMF0sIFxyXG4gICAgICAgICAgICAgICAgICAgIG4zID0gMS4wIC8gKGRjWzBdICogZHBbMV0gLSBkY1sxXSAqIGRwWzBdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbKG4xKmRwWzBdIC0gbjIqZGNbMF0pICogbjMsIChuMSpkcFsxXSAtIG4yKmRjWzFdKSAqIG4zXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIG91dCA9IHAwO1xyXG4gICAgICAgICAgICBjcDEgPSBwMVtwMS5sZW5ndGgtMV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogaW4gcDEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjcDIgPSBwMVtqXTtcclxuICAgICAgICAgICAgICAgIHZhciBpbnAgPSBvdXQ7XHJcbiAgICAgICAgICAgICAgICBvdXQgPSBbXTtcclxuICAgICAgICAgICAgICAgIHMgPSBpbnBbaW5wLmxlbmd0aCAtIDFdOyAvL2xhc3Qgb24gdGhlIGlucHV0IGxpc3RcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gaW5wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBpbnBbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2lkZShlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2lkZShzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goaXNjKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnNpZGUocykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goaXNjKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzID0gZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNwMSA9IGNwMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3V0XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHRVRE9DLk0gPSB7XHJcblx0XHRnZXRTY2FsZSA6IGZ1bmN0aW9uKG06YW55KSB7ICByZXR1cm4gTWF0aC5zcXJ0KE1hdGguYWJzKG1bMF0qbVszXS1tWzFdKm1bMl0pKTsgIH0sXHJcblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uKG06YW55LHg6YW55LHk6YW55KSB7ICBVRE9DLk0uY29uY2F0KG0sIFsxLDAsMCwxLHgseV0pOyAgfSxcclxuXHRcdHJvdGF0ZSAgIDogZnVuY3Rpb24obTphbnksYTphbnkgICkgeyAgVURPQy5NLmNvbmNhdChtLCBbTWF0aC5jb3MoYSksIC1NYXRoLnNpbihhKSwgTWF0aC5zaW4oYSksIE1hdGguY29zKGEpLDAsMF0pOyAgfSxcclxuXHRcdHNjYWxlICAgIDogZnVuY3Rpb24obTphbnkseDphbnkseTphbnkpIHsgIFVET0MuTS5jb25jYXQobSwgW3gsMCwwLHksMCwwXSk7ICB9LFxyXG5cdFx0Y29uY2F0ICAgOiBmdW5jdGlvbihtOmFueSx3OmFueSAgKSB7ICBcclxuXHRcdFx0dmFyIGE9bVswXSxiPW1bMV0sYz1tWzJdLGQ9bVszXSx0eD1tWzRdLHR5PW1bNV07XHJcblx0XHRcdG1bMF0gPSAoYSAqd1swXSkrKGIgKndbMl0pOyAgICAgICBtWzFdID0gKGEgKndbMV0pKyhiICp3WzNdKTtcclxuXHRcdFx0bVsyXSA9IChjICp3WzBdKSsoZCAqd1syXSk7ICAgICAgIG1bM10gPSAoYyAqd1sxXSkrKGQgKndbM10pO1xyXG5cdFx0XHRtWzRdID0gKHR4KndbMF0pKyh0eSp3WzJdKSt3WzRdOyAgbVs1XSA9ICh0eCp3WzFdKSsodHkqd1szXSkrd1s1XTsgXHJcblx0XHR9LFxyXG5cdFx0aW52ZXJ0ICAgOiBmdW5jdGlvbihtOmFueSAgICApIHsgIFxyXG5cdFx0XHR2YXIgYT1tWzBdLGI9bVsxXSxjPW1bMl0sZD1tWzNdLHR4PW1bNF0sdHk9bVs1XSwgYWRiYz1hKmQtYipjO1xyXG5cdFx0XHRtWzBdID0gZC9hZGJjOyAgbVsxXSA9IC1iL2FkYmM7ICBtWzJdID0tYy9hZGJjOyAgbVszXSA9ICBhL2FkYmM7XHJcblx0XHRcdG1bNF0gPSAoYyp0eSAtIGQqdHgpL2FkYmM7ICBtWzVdID0gKGIqdHggLSBhKnR5KS9hZGJjO1xyXG5cdFx0fSxcclxuXHRcdG11bHRQb2ludDogZnVuY3Rpb24obTphbnksIHA6YW55ICkgeyAgdmFyIHg9cFswXSx5PXBbMV07ICByZXR1cm4gW3gqbVswXSt5Km1bMl0rbVs0XSwgICB4Km1bMV0reSptWzNdK21bNV1dOyAgfSxcclxuXHRcdG11bHRBcnJheTogZnVuY3Rpb24obTphbnksIGE6YW55ICkgeyAgZm9yKHZhciBpPTA7IGk8YS5sZW5ndGg7IGkrPTIpIHsgIHZhciB4PWFbaV0seT1hW2krMV07ICBhW2ldPXgqbVswXSt5Km1bMl0rbVs0XTsgIGFbaSsxXT14Km1bMV0reSptWzNdK21bNV07ICB9ICB9XHJcblx0fVxyXG5cdFVET0MuQyA9IHtcclxuXHRcdHNyZ2JHYW1tYSA6IGZ1bmN0aW9uKHg6YW55KSB7ICByZXR1cm4geCA8IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMS4wIC8gMi40KSAtIDAuMDU1OyAgfSxcclxuXHRcdGNteWtUb1JnYiA6IGZ1bmN0aW9uKGNscjphbnkpIHsgXHJcblx0XHRcdHZhciBjPWNsclswXSwgbT1jbHJbMV0sIHk9Y2xyWzJdLCBrPWNsclszXTtcclxuXHRcdFx0Ly8gcmV0dXJuIFsxLU1hdGgubWluKDEsYytrKSwgMS1NYXRoLm1pbigxLCBtK2spLCAxLU1hdGgubWluKDEseStrKV07XHJcblx0XHRcdHZhciByID0gMjU1XHJcblx0XHRcdCsgYyAqICgtNC4zODczMzIzODQ2MDk5ODggICogYyArIDU0LjQ4NjE1MTk0MTg5MTc2ICAqIG0gKyAgMTguODIyOTA1MDIxNjUzMDIgICogeSArIDIxMi4yNTY2MjQ1MTYzOTU4NSAqIGsgKyAgLTI4NS4yMzMxMDI2MTM3MDA0KSBcclxuXHRcdFx0KyBtICogKCAxLjcxNDk3NjM0NzczNjIxMzQgKiBtIC0gNS42MDk2NzM2OTA0MDQ3MzE1ICogeSArIC0xNy44NzM4NzA4NjE0MTU0NDQgKiBrIC0gNS40OTcwMDY0MjcxOTYzNjYpIFxyXG5cdFx0XHQrIHkgKiAoLTIuNTIxNzM0MDEzMTY4MzAzMyAqIHkgLSAyMS4yNDg5MjMzMzczNTMwNzMgKiBrICsgIDE3LjUxMTkyNzA4NDE4MTMpIFxyXG5cdFx0XHQrIGsgKiAoLTIxLjg2MTIyMTQ3NDYzNjA1ICAqIGsgLSAxODkuNDgxODA4MzU5MjI3NDcpO1xyXG5cdFx0XHR2YXIgZyA9IDI1NVxyXG5cdFx0XHQrIGMgKiAoOC44NDEwNDE0MjIwMzYxNDkgICAqIGMgKyA2MC4xMTgwMjcwNDU1OTczNjYgKiBtICsgIDYuODcxNDI1NTkyMDQ5MDA3ICAqIHkgKyAzMS4xNTkxMDAxMzAwNTU5MjIgKiBrICsgIC03OS4yOTcwODQ0ODE2NTQ4KSBcclxuXHRcdFx0KyBtICogKC0xNS4zMTAzNjEzMDY5Njc4MTcgKiBtICsgMTcuNTc1MjUxMjYxMTA5NDgyICogeSArICAxMzEuMzUyNTA5MTI0OTM5NzYgKiBrIC0gMTkwLjk0NTMzMDI1ODg5NTEpIFxyXG5cdFx0XHQrIHkgKiAoNC40NDQzMzkxMDI4NTI3MzkgICAqIHkgKyA5Ljg2MzI4NjE0OTM0MDUgICAgKiBrIC0gIDI0Ljg2NzQxNTgyNTU1ODc4KSBcclxuXHRcdFx0KyBrICogKC0yMC43MzczMjU0NzExODEwMzQgKiBrIC0gMTg3LjgwNDUzNzA5NzE5NTc4KTtcclxuXHRcdFx0dmFyIGIgPSAyNTVcclxuXHRcdFx0KyBjICogKDAuODg0MjUyMjQzMDAwMzI5NiAgKiBjICsgOC4wNzg2Nzc1MDMxMTI5MjggICogbSArICAzMC44OTk3ODMwOTcwMzcyOSAgKiB5IC0gMC4yMzg4MzIzODY4OTE3ODkzNCAqIGsgKyAtMTQuMTgzNTc2Nzk5NjczMjg2KSBcclxuXHRcdFx0KyBtICogKDEwLjQ5NTkzMjczNDMyMDcyICAgKiBtICsgNjMuMDIzNzg0OTQ3NTQwNTIgICogeSArICA1MC42MDY5NTc2NTYzNjA3MzQgKiBrIC0gMTEyLjIzODg0MjUzNzE5MjQ4KSBcclxuXHRcdFx0KyB5ICogKDAuMDMyOTYwNDExMTQ4NzMyMTcgKiB5ICsgMTE1LjYwMzg0NDQ5NjQ2NjQxICogayArIC0xOTMuNTgyMDkzNTY4NjE1MDUpXHJcblx0XHRcdCsgayAqICgtMjIuMzM4MTY4MDczMDk4ODYgICogayAtIDE4MC4xMjYxMzk3NDcwODM2Nyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gW01hdGgubWF4KDAsIE1hdGgubWluKDEsIHIvMjU1KSksIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGcvMjU1KSksIE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGIvMjU1KSldO1xyXG5cdFx0XHQvL3ZhciBpSyA9IDEtY1szXTsgIFxyXG5cdFx0XHQvL3JldHVybiBbKDEtY1swXSkqaUssICgxLWNbMV0pKmlLLCAoMS1jWzJdKSppS107ICBcclxuXHRcdH0sXHJcblx0XHRsYWJUb1JnYiAgOiBmdW5jdGlvbihsYWI6YW55KSB7XHJcblx0XHRcdHZhciBrID0gOTAzLjMsIGUgPSAwLjAwODg1NiwgTCA9IGxhYlswXSwgYSA9IGxhYlsxXSwgYiA9IGxhYlsyXTtcclxuXHRcdFx0dmFyIGZ5ID0gKEwrMTYpLzExNiwgZnkzID0gZnkqZnkqZnk7XHJcblx0XHRcdHZhciBmeiA9IGZ5IC0gYi8yMDAsIGZ6MyA9IGZ6KmZ6KmZ6O1xyXG5cdFx0XHR2YXIgZnggPSBhLzUwMCArIGZ5LCBmeDMgPSBmeCpmeCpmeDtcclxuXHRcdFx0dmFyIHpyID0gZnozPmUgPyBmejMgOiAoMTE2KmZ6LTE2KS9rO1xyXG5cdFx0XHR2YXIgeXIgPSBmeTM+ZSA/IGZ5MyA6ICgxMTYqZnktMTYpL2s7XHJcblx0XHRcdHZhciB4ciA9IGZ4Mz5lID8gZngzIDogKDExNipmeC0xNikvaztcclxuXHRcdFx0XHRcclxuXHRcdFx0dmFyIFggPSB4cio5Ni43MiwgWSA9IHlyKjEwMCwgWiA9IHpyKjgxLjQyNywgeHl6ID0gW1gvMTAwLFkvMTAwLFovMTAwXTtcclxuXHRcdFx0dmFyIHgycyA9IFszLjEzMzg1NjEsIC0xLjYxNjg2NjcsIC0wLjQ5MDYxNDYsIC0wLjk3ODc2ODQsICAxLjkxNjE0MTUsICAwLjAzMzQ1NDAsIDAuMDcxOTQ1MywgLTAuMjI4OTkxNCwgIDEuNDA1MjQyN107XHJcblx0XHRcdFxyXG5cdFx0XHR2YXIgcmdiID0gWyB4MnNbMF0qeHl6WzBdICsgeDJzWzFdKnh5elsxXSArIHgyc1syXSp4eXpbMl0sXHJcblx0XHRcdFx0XHRcdHgyc1szXSp4eXpbMF0gKyB4MnNbNF0qeHl6WzFdICsgeDJzWzVdKnh5elsyXSxcclxuXHRcdFx0XHRcdFx0eDJzWzZdKnh5elswXSArIHgyc1s3XSp4eXpbMV0gKyB4MnNbOF0qeHl6WzJdICBdO1xyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTwzOyBpKyspIHJnYltpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIFVET0MuQy5zcmdiR2FtbWEocmdiW2ldKSkpO1xyXG5cdFx0XHRyZXR1cm4gcmdiO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHRVRE9DLmdldFN0YXRlID0gZnVuY3Rpb24oY3JkczphbnkpOmFueSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRmb250IDogVURPQy5nZXRGb250KCksXHJcblx0XHRcdGRkOiB7ZmxhdDoxfSwgIC8vIGRldmljZS1kZXBlbmRlbnRcclxuXHRcdFx0c3BhY2UgOlwiL0RldmljZUdyYXlcIixcclxuXHRcdFx0Ly8gZmlsbFxyXG5cdFx0XHRjYTogMSxcclxuXHRcdFx0Y29sciAgOiBbMCwwLDBdLFxyXG5cdFx0XHRzc3BhY2U6XCIvRGV2aWNlR3JheVwiLFxyXG5cdFx0XHQvLyBzdHJva2VcclxuXHRcdFx0Q0E6IDEsXHJcblx0XHRcdENPTFIgOiBbMCwwLDBdLFxyXG5cdFx0XHRibW9kZTogXCIvTm9ybWFsXCIsXHJcblx0XHRcdFNBOmZhbHNlLCBPUE06MCwgQUlTOmZhbHNlLCBPUDpmYWxzZSwgb3A6ZmFsc2UsIFNNYXNrOlwiL05vbmVcIixcclxuXHRcdFx0bHdpZHRoIDogMSxcclxuXHRcdFx0bGNhcDogMCxcclxuXHRcdFx0bGpvaW46IDAsXHJcblx0XHRcdG1saW1pdDogMTAsXHJcblx0XHRcdFNNIDogMC4xLFxyXG5cdFx0XHRkb2ZmOiAwLFxyXG5cdFx0XHRkYXNoOiBbXSxcclxuXHRcdFx0Y3RtIDogWzEsMCwwLDEsMCwwXSxcclxuXHRcdFx0Y3BvczogWzAsMF0sXHJcblx0XHRcdHB0aCA6IHtjbWRzOltdLGNyZHM6W119LCBcclxuXHRcdFx0Y3B0aDogY3JkcyA/IFVET0MuRy5yZWN0VG9QYXRoKGNyZHMpIDogbnVsbCAgLy8gY2xpcHBpbmcgcGF0aFxyXG5cdFx0fTtcclxuXHR9XHJcblx0XHJcblx0VURPQy5nZXRGb250ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRUYzogMCwgLy8gY2hhcmFjdGVyIHNwYWNpbmdcclxuXHRcdFx0VHc6IDAsIC8vIHdvcmQgc3BhY2luZ1xyXG5cdFx0XHRUaDoxMDAsIC8vIGhvcml6b250YWwgc2NhbGVcclxuXHRcdFx0VGw6IDAsIC8vIGxlYWRpbmdcclxuXHRcdFx0VGY6XCJIZWx2ZXRpY2EtQm9sZFwiLCBcclxuXHRcdFx0VGZzOjEsIC8vIGZvbnQgc2l6ZVxyXG5cdFx0XHRUbW9kZTowLCAvLyByZW5kZXJpbmcgbW9kZVxyXG5cdFx0XHRUcmlzZTowLCAvLyByaXNlXHJcblx0XHRcdFRrOiAwLCAgLy8ga25vY2tvdXRcclxuXHRcdFx0VGFsOjAsICAvLyBhbGlnbiwgMDogbGVmdCwgMTogcmlnaHQsIDI6IGNlbnRlclxyXG5cdFx0XHRUdW46MCwgIC8vIDA6IG5vLCAxOiB1bmRlcmxpbmVcclxuXHRcdFx0XHJcblx0XHRcdFRtIDpbMSwwLDAsMSwwLDBdLFxyXG5cdFx0XHRUbG06WzEsMCwwLDEsMCwwXSxcclxuXHRcdFx0VHJtOlsxLDAsMCwxLDAsMF1cclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHJcbmV4cG9ydCBsZXQgRnJvbUVNRjphbnkgPSBmdW5jdGlvbigpXHJcbntcclxufVxyXG5cclxuRnJvbUVNRi5QYXJzZSA9IGZ1bmN0aW9uKGJ1ZmY6YW55LCBnZW52OmFueSlcclxue1xyXG4gICAgYnVmZiA9IG5ldyBVaW50OEFycmF5KGJ1ZmYpOyAgdmFyIG9mZj0wO1xyXG4gICAgLy9jb25zb2xlLmxvZyhidWZmLnNsaWNlKDAsMzIpKTtcclxuICAgIHZhciBwcm1zOmFueSA9IHtmaWxsOmZhbHNlLCBzdHJrOmZhbHNlLCBiYjpbMCwwLDEsMV0sIHdiYjpbMCwwLDEsMV0sIGZudDp7bmFtOlwiQXJpYWxcIixoZ2g6MjUsdW5kOmZhbHNlLG9ybjowfSwgdGNscjpbMCwwLDBdLCB0YWxnOjB9LCBnc3QsIHRhYiA9IFtdLCBzdHM9W107XHJcbiAgICBcclxuICAgIHZhciBySSA9IEZyb21FTUYuQi5yZWFkU2hvcnQsIHJVID0gRnJvbUVNRi5CLnJlYWRVc2hvcnQsIHJJMzIgPSBGcm9tRU1GLkIucmVhZEludCwgclUzMiA9IEZyb21FTUYuQi5yZWFkVWludCwgckYzMiA9IEZyb21FTUYuQi5yZWFkRmxvYXQ7XHRcclxuICAgIFxyXG4gICAgdmFyIG9wbj0wO1xyXG4gICAgd2hpbGUodHJ1ZSkge1xyXG4gICAgICAgIHZhciBmbmMgPSByVTMyKGJ1ZmYsIG9mZik7ICBvZmYrPTQ7XHJcbiAgICAgICAgdmFyIGZubSA9IEZyb21FTUYuS1tmbmNdOyBcclxuICAgICAgICB2YXIgc2l6ID0gclUzMihidWZmLCBvZmYpOyAgb2ZmKz00O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vaWYoZ3N0ICYmIGlzTmFOKGdzdC5jdG1bMF0pKSB0aHJvdyBcImVcIjtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKGZuYyxmbm0sc2l6KTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbG9mZiA9IG9mZjtcclxuICAgICAgICBcclxuICAgICAgICAvL2lmKG9wbisrPT0yNTMpIGJyZWFrO1xyXG4gICAgICAgIHZhciBvYmo6YW55ID0gbnVsbCwgb2lkID0gMDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKGZubSwgc2l6KTtcclxuICAgICAgICBcclxuICAgICAgICBpZihmYWxzZSkge31cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJFT0ZcIikgeyAgYnJlYWs7ICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiSEVBREVSXCIpIHtcclxuICAgICAgICAgICAgcHJtcy5iYiA9IEZyb21FTUYuX3JlYWRCb3goYnVmZixsb2ZmKTsgICBsb2ZmKz0xNjsgIC8vY29uc29sZS5sb2coZm5tLCBwcm1zLmJiKTtcclxuICAgICAgICAgICAgZ2Vudi5TdGFydFBhZ2UocHJtcy5iYlswXSxwcm1zLmJiWzFdLHBybXMuYmJbMl0scHJtcy5iYlszXSk7XHJcbiAgICAgICAgICAgIGdzdCA9IFVET0MuZ2V0U3RhdGUocHJtcy5iYik7XHRcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0FWRURDXCIpIHN0cy5wdXNoKEpTT04uc3RyaW5naWZ5KGdzdCksIEpTT04uc3RyaW5naWZ5KHBybXMpKTtcclxuICAgICAgICBlbHNlIGlmKGZubT09XCJSRVNUT1JFRENcIikge1xyXG4gICAgICAgICAgICB2YXIgZGlmID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHdoaWxlKGRpZjwtMSkgeyAgc3RzLnBvcCgpOyAgc3RzLnBvcCgpOyAgfVxyXG4gICAgICAgICAgICBwcm1zID0gSlNPTi5wYXJzZShzdHMucG9wKCkpOyAgZ3N0ID0gSlNPTi5wYXJzZShzdHMucG9wKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTRUxFQ1RDTElQUEFUSFwiKSB7ICBnc3QuY3B0aCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZ3N0LnB0aCkpOyAgfVxyXG4gICAgICAgIGVsc2UgaWYoW1wiU0VUTUFQTU9ERVwiLFwiU0VUUE9MWUZJTExNT0RFXCIsXCJTRVRCS01PREVcIi8qLFwiU0VUVklFV1BPUlRFWFRFWFwiKi8sXCJTRVRJQ01NT0RFXCIsXCJTRVRST1AyXCIsXCJFWFRTRUxFQ1RDTElQUkdOXCJdLmluZGV4T2YoZm5tKSE9LTEpIHt9XHJcbiAgICAgICAgLy9lbHNlIGlmKGZubT09XCJJTlRFUlNFQ1RDTElQUkVDVFwiKSB7ICB2YXIgcj1wcm1zLmNyY3Q9RnJvbUVNRi5fcmVhZEJveChidWZmLCBsb2ZmKTsgIC8qdmFyIHkwPXJbMV0seTE9clszXTsgaWYoeTA+eTEpe3JbMV09eTE7IHJbM109eTA7fSovIGNvbnNvbGUubG9nKHBybXMuY3JjdCk7ICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VUTUlURVJMSU1JVFwiKSBnc3QubWxpbWl0ID0gclUzMihidWZmLCBsb2ZmKTtcclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTRVRURVhUQ09MT1JcIikgcHJtcy50Y2xyID0gW2J1ZmZbbG9mZl0vMjU1LCBidWZmW2xvZmYrMV0vMjU1LCBidWZmW2xvZmYrMl0vMjU1XTsgXHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VUVEVYVEFMSUdOXCIpIHBybXMudGFsZyA9IHJVMzIoYnVmZiwgbG9mZik7XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VUVklFV1BPUlRFWFRFWFwiIHx8IGZubT09XCJTRVRWSUVXUE9SVE9SR0VYXCIpIHtcclxuICAgICAgICAgICAgaWYocHJtcy52YmI9PW51bGwpIHBybXMudmJiPVtdO1xyXG4gICAgICAgICAgICB2YXIgY29mZiA9IGZubT09XCJTRVRWSUVXUE9SVE9SR0VYXCIgPyAwIDogMjtcclxuICAgICAgICAgICAgcHJtcy52YmJbY29mZiAgXSA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICBwcm1zLnZiYltjb2ZmKzFdID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocHJtcy52YmIpO1xyXG4gICAgICAgICAgICBpZihmbm09PVwiU0VUVklFV1BPUlRFWFRFWFwiKSBGcm9tRU1GLl91cGRhdGVDdG0ocHJtcywgZ3N0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VUV0lORE9XRVhURVhcIiB8fCBmbm09PVwiU0VUV0lORE9XT1JHRVhcIikge1xyXG4gICAgICAgICAgICB2YXIgY29mZiA9IGZubT09XCJTRVRXSU5ET1dPUkdFWFwiID8gMCA6IDI7XHJcbiAgICAgICAgICAgIHBybXMud2JiW2NvZmYgIF0gPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgcHJtcy53YmJbY29mZisxXSA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICBpZihmbm09PVwiU0VUV0lORE9XRVhURVhcIikgRnJvbUVNRi5fdXBkYXRlQ3RtKHBybXMsIGdzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vZWxzZSBpZihmbm09PVwiU0VUTUVUQVJHTlwiKSB7fVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkNPTU1FTlRcIikgeyAgdmFyIGRzID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VMRUNUT0JKRUNUXCIpIHtcclxuICAgICAgICAgICAgdmFyIGluZCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGluZC50b1N0cmluZygxNiksIHRhYiwgdGFiW2luZF0pO1xyXG4gICAgICAgICAgICBpZiAgICAgKGluZD09MHg4MDAwMDAwMCkgeyAgcHJtcy5maWxsPXRydWUgOyAgZ3N0LmNvbHI9WzEsMSwxXTsgIH0gLy8gd2hpdGUgYnJ1c2hcclxuICAgICAgICAgICAgZWxzZSBpZihpbmQ9PTB4ODAwMDAwMDUpIHsgIHBybXMuZmlsbD1mYWxzZTsgIH0gLy8gbnVsbCBicnVzaFxyXG4gICAgICAgICAgICBlbHNlIGlmKGluZD09MHg4MDAwMDAwNykgeyAgcHJtcy5zdHJrPXRydWUgOyAgcHJtcy5sd2lkdGg9MTsgIGdzdC5DT0xSPVswLDAsMF07ICB9IC8vIGJsYWNrIHBlblxyXG4gICAgICAgICAgICBlbHNlIGlmKGluZD09MHg4MDAwMDAwOCkgeyAgcHJtcy5zdHJrPWZhbHNlOyAgfSAvLyBudWxsICBwZW5cclxuICAgICAgICAgICAgZWxzZSBpZihpbmQ9PTB4ODAwMDAwMGQpIHt9IC8vIHN5c3RlbSBmb250XHJcbiAgICAgICAgICAgIGVsc2UgaWYoaW5kPT0weDgwMDAwMDBlKSB7fSAgLy8gZGV2aWNlIGRlZmF1bHQgZm9udFxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBjbzphbnkgPSB0YWJbaW5kXTsgIC8vY29uc29sZS5sb2coaW5kLCBjbyk7XHJcbiAgICAgICAgICAgICAgICBpZihjby50PT1cImJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBybXMuZmlsbD1jby5zdGwhPTE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgICAgIChjby5zdGw9PTApIHt9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjby5zdGw9PTEpIHt9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBjby5zdGwrXCIgZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGdzdC5jb2xyPWNvLmNscjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoY28udD09XCJwXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm1zLnN0cms9Y28uc3RsIT01O1xyXG4gICAgICAgICAgICAgICAgICAgIGdzdC5sd2lkdGggPSBjby53aWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3N0LkNPTFI9Y28uY2xyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihjby50PT1cImZcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBybXMuZm50ID0gY287XHJcbiAgICAgICAgICAgICAgICAgICAgZ3N0LmZvbnQuVGYgPSBjby5uYW07XHJcbiAgICAgICAgICAgICAgICAgICAgZ3N0LmZvbnQuVGZzID0gTWF0aC5hYnMoY28uaGdoKTtcclxuICAgICAgICAgICAgICAgICAgICBnc3QuZm9udC5UdW4gPSBjby51bmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IFwiZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkRFTEVURU9CSkVDVFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgaWYodGFiW2luZF0hPW51bGwpIHRhYltpbmRdPW51bGw7XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgXCJlXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkNSRUFURUJSVVNISU5ESVJFQ1RcIikge1xyXG4gICAgICAgICAgICBvaWQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgb2JqID0ge3Q6XCJiXCJ9O1xyXG4gICAgICAgICAgICBvYmouc3RsID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIG9iai5jbHIgPSBbYnVmZltsb2ZmXS8yNTUsIGJ1ZmZbbG9mZisxXS8yNTUsIGJ1ZmZbbG9mZisyXS8yNTVdOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgb2JqLmh0YyA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG9pZCwgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiQ1JFQVRFUEVOXCIgfHwgZm5tPT1cIkVYVENSRUFURVBFTlwiKSB7XHJcbiAgICAgICAgICAgIG9pZCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICBvYmogPSB7dDpcInBcIn07XHJcbiAgICAgICAgICAgIGlmKGZubT09XCJFWFRDUkVBVEVQRU5cIikge1xyXG4gICAgICAgICAgICAgICAgbG9mZis9MTY7XHJcbiAgICAgICAgICAgICAgICBvYmouc3RsID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgICAgICBvYmoud2lkID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgICAgICAvL29iai5zdGwgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgXHJcbiAgICAgICAgICAgICAgICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb2JqLnN0bCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICAgICAgb2JqLndpZCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00OyAgbG9mZis9NDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmouY2xyID0gW2J1ZmZbbG9mZl0vMjU1LCBidWZmW2xvZmYrMV0vMjU1LCBidWZmW2xvZmYrMl0vMjU1XTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkVYVENSRUFURUZPTlRJTkRJUkVDVFdcIikge1xyXG4gICAgICAgICAgICBvaWQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgb2JqID0ge3Q6XCJmXCIsIG5hbTpcIlwifTtcclxuICAgICAgICAgICAgb2JqLmhnaCA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmICs9IDQ7XHJcbiAgICAgICAgICAgIGxvZmYgKz0gNCoyO1xyXG4gICAgICAgICAgICBvYmoub3JuID0gckkzMihidWZmLCBsb2ZmKS8xMDsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciB3Z2ggPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIC8vY29uc29sZS5sb2coZm5tLCBvYmoub3JuLCB3Z2gpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJVMzIoYnVmZixsb2ZmKSwgclUzMihidWZmLGxvZmYrNCksIGJ1ZmYuc2xpY2UobG9mZixsb2ZmKzgpKTtcclxuICAgICAgICAgICAgb2JqLnVuZCA9IGJ1ZmZbbG9mZisxXTsgIG9iai5zdGsgPSBidWZmW2xvZmYrMl07ICBsb2ZmICs9IDQqMjtcclxuICAgICAgICAgICAgd2hpbGUoclUoYnVmZixsb2ZmKSE9MCkgeyAgb2JqLm5hbSs9U3RyaW5nLmZyb21DaGFyQ29kZShyVShidWZmLGxvZmYpKTsgIGxvZmYrPTI7ICB9XHJcbiAgICAgICAgICAgIGlmKHdnaD41MDApIG9iai5uYW0rPVwiLUJvbGRcIjtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh3Z2gsIG9iai5uYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJFWFRURVhUT1VUV1wiKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYnVmZi5zbGljZShsb2ZmLTgsIGxvZmYtOCtzaXopKTtcclxuICAgICAgICAgICAgbG9mZis9MTY7XHJcbiAgICAgICAgICAgIHZhciBtb2QgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIC8vY29uc29sZS5sb2cobW9kKTtcclxuICAgICAgICAgICAgdmFyIHNjeCA9IHJGMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgc2N5ID0gckYzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciByZnggPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHJmeSA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG1vZCwgc2N4LCBzY3kscmZ4LHJmeSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBnc3QuZm9udC5UbSA9IFsxLDAsMCwtMSwwLDBdO1xyXG4gICAgICAgICAgICBVRE9DLk0ucm90YXRlKGdzdC5mb250LlRtLCBwcm1zLmZudC5vcm4qTWF0aC5QSS8xODApO1xyXG4gICAgICAgICAgICBVRE9DLk0udHJhbnNsYXRlKGdzdC5mb250LlRtLCByZngsIHJmeSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgYWxnID0gcHJtcy50YWxnOyAgLy9jb25zb2xlLmxvZyhhbGcudG9TdHJpbmcoMikpO1xyXG4gICAgICAgICAgICBpZiAgICAgKChhbGcmNik9PTYpIGdzdC5mb250LlRhbCA9IDI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYoKGFsZyY3KT09MCkgZ3N0LmZvbnQuVGFsID0gMDtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBhbGcrXCIgZVwiO1xyXG4gICAgICAgICAgICBpZigoYWxnJjI0KT09MjQpIHt9ICAvLyBiYXNlbGluZVxyXG4gICAgICAgICAgICBlbHNlIGlmKChhbGcmMjQpPT0wKSBVRE9DLk0udHJhbnNsYXRlKGdzdC5mb250LlRtLCAwLCBnc3QuZm9udC5UZnMpO1xyXG4gICAgICAgICAgICBlbHNlIHRocm93IFwiZVwiO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBjcnMgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIG9mcyA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgb3BzID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICAvL2lmKG9wcyE9MCkgdGhyb3cgXCJlXCI7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cob2ZzLG9wcyxjcnMpO1xyXG4gICAgICAgICAgICBsb2ZmKz0xNjtcclxuICAgICAgICAgICAgdmFyIG9mRCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00OyAgLy9jb25zb2xlLmxvZyhvcHMsIG9mRCwgbG9mZiwgb2ZzK29mZi04KTtcclxuICAgICAgICAgICAgb2ZzICs9IG9mZi04OyAgLy9jb25zb2xlLmxvZyhjcnMsIG9wcyk7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIlwiO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxjcnM7IGkrKykgeyAgdmFyIGNjPXJVKGJ1ZmYsb2ZzK2kqMik7ICBzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoY2MpOyAgfTtcclxuICAgICAgICAgICAgdmFyIG9jbHIgPSBnc3QuY29scjsgIGdzdC5jb2xyID0gcHJtcy50Y2xyO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHN0ciwgZ3N0LmNvbHIsIGdzdC5mb250LlRtKTtcclxuICAgICAgICAgICAgLy92YXIgb3RmcyA9IGdzdC5mb250LlRmczsgIGdzdC5mb250LlRmcyAqPSAxL2dzdC5jdG1bMF07XHJcbiAgICAgICAgICAgIGdlbnYuUHV0VGV4dChnc3QsIHN0ciwgc3RyLmxlbmd0aCpnc3QuZm9udC5UZnMqMC41KTsgIGdzdC5jb2xyPW9jbHI7XHJcbiAgICAgICAgICAgIC8vZ3N0LmZvbnQuVGZzID0gb3RmcztcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZngsIHJmeSwgc2N4LCBvcHMsIHJjWCwgcmNZLCByY1csIHJjSCwgb2ZmRHgsIHN0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkJFR0lOUEFUSFwiKSB7ICBVRE9DLkcubmV3UGF0aChnc3QpOyAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkVORFBBVEhcIiAgKSB7ICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJDTE9TRUZJR1VSRVwiKSBVRE9DLkcuY2xvc2VQYXRoKGdzdCk7XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiTU9WRVRPRVhcIiApIHsgIFVET0MuRy5tb3ZlVG8oZ3N0LCBySTMyKGJ1ZmYsbG9mZiksIHJJMzIoYnVmZixsb2ZmKzQpKTsgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJMSU5FVE9cIiAgICkgeyAgXHJcbiAgICAgICAgICAgIGlmKGdzdC5wdGguY21kcy5sZW5ndGg9PTApIHsgIHZhciBpbT1nc3QuY3RtLnNsaWNlKDApOyAgVURPQy5NLmludmVydChpbSk7ICB2YXIgcCA9IFVET0MuTS5tdWx0UG9pbnQoaW0sIGdzdC5jcG9zKTsgIFVET0MuRy5tb3ZlVG8oZ3N0LCBwWzBdLCBwWzFdKTsgIH0gIFxyXG4gICAgICAgICAgICBVRE9DLkcubGluZVRvKGdzdCwgckkzMihidWZmLGxvZmYpLCBySTMyKGJ1ZmYsbG9mZis0KSk7ICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiUE9MWUdPTlwiIHx8IGZubT09XCJQT0xZR09OMTZcIiB8fCBmbm09PVwiUE9MWUxJTkVcIiB8fCBmbm09PVwiUE9MWUxJTkUxNlwiIHx8IGZubT09XCJQT0xZTElORVRPXCIgfHwgZm5tPT1cIlBPTFlMSU5FVE8xNlwiKSB7XHJcbiAgICAgICAgICAgIGxvZmYrPTE2O1xyXG4gICAgICAgICAgICB2YXIgbmRmID0gZm5tLnN0YXJ0c1dpdGgoXCJQT0xZR09OXCIpLCBpc1RvID0gZm5tLmluZGV4T2YoXCJUT1wiKSE9LTE7XHJcbiAgICAgICAgICAgIHZhciBjbnQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgaWYoIWlzVG8pIFVET0MuRy5uZXdQYXRoKGdzdCk7XHJcbiAgICAgICAgICAgIGxvZmYgPSBGcm9tRU1GLl9kcmF3UG9seShidWZmLGxvZmYsY250LGdzdCwgZm5tLmVuZHNXaXRoKFwiMTZcIik/Mjo0LCAgbmRmLCBpc1RvKTtcclxuICAgICAgICAgICAgaWYoIWlzVG8pIEZyb21FTUYuX2RyYXcoZ2Vudixnc3QscHJtcywgbmRmKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhwcm1zLCBnc3QubHdpZHRoKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdzdC5wdGgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlBPTFlQT0xZR09OMTZcIikge1xyXG4gICAgICAgICAgICBsb2ZmKz0xNjtcclxuICAgICAgICAgICAgdmFyIG5kZiA9IGZubS5zdGFydHNXaXRoKFwiUE9MWVBPTFlHT05cIiksIGlzVG8gPSBmbm0uaW5kZXhPZihcIlRPXCIpIT0tMTtcclxuICAgICAgICAgICAgdmFyIG5vcCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00OyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHBpID0gbG9mZjsgIGxvZmYrPSBub3AqNDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKCFpc1RvKSBVRE9DLkcubmV3UGF0aChnc3QpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxub3A7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBwcCA9IHJVKGJ1ZmYsIHBpK2kqNCk7XHJcbiAgICAgICAgICAgICAgICBsb2ZmID0gRnJvbUVNRi5fZHJhd1BvbHkoYnVmZixsb2ZmLHBwcCxnc3QsIGZubS5lbmRzV2l0aChcIjE2XCIpPzI6NCwgbmRmLCBpc1RvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZighaXNUbykgRnJvbUVNRi5fZHJhdyhnZW52LGdzdCxwcm1zLCBuZGYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJQT0xZQkVaSUVSXCIgfHwgZm5tPT1cIlBPTFlCRVpJRVIxNlwiIHx8IGZubT09XCJQT0xZQkVaSUVSVE9cIiB8fCBmbm09PVwiUE9MWUJFWklFUlRPMTZcIikge1xyXG4gICAgICAgICAgICBsb2ZmKz0xNjtcclxuICAgICAgICAgICAgdmFyIGlzMTYgPSBmbm0uZW5kc1dpdGgoXCIxNlwiKSwgckMgPSBpczE2P3JJOnJJMzIsIG5sID0gaXMxNj8yOjQ7XHJcbiAgICAgICAgICAgIHZhciBjbnQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgaWYoZm5tLmluZGV4T2YoXCJUT1wiKT09LTEpIHtcclxuICAgICAgICAgICAgICAgIFVET0MuRy5tb3ZlVG8oZ3N0LCByQyhidWZmLGxvZmYpLCByQyhidWZmLGxvZmYrbmwpKTsgIGxvZmYrPTIqbmw7ICBjbnQtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZShjbnQ+MCkge1xyXG4gICAgICAgICAgICAgICAgVURPQy5HLmN1cnZlVG8oZ3N0LCByQyhidWZmLGxvZmYpLCByQyhidWZmLGxvZmYrbmwpLCByQyhidWZmLGxvZmYrMipubCksIHJDKGJ1ZmYsbG9mZiszKm5sKSwgckMoYnVmZixsb2ZmKzQqbmwpLCByQyhidWZmLGxvZmYrNSpubCkgKTtcclxuICAgICAgICAgICAgICAgIGxvZmYrPTYqbmw7XHJcbiAgICAgICAgICAgICAgICBjbnQtPTM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdzdC5wdGgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlJFQ1RBTkdMRVwiIHx8IGZubT09XCJFTExJUFNFXCIpIHtcclxuICAgICAgICAgICAgVURPQy5HLm5ld1BhdGgoZ3N0KTtcclxuICAgICAgICAgICAgdmFyIGJ4ID0gRnJvbUVNRi5fcmVhZEJveChidWZmLCBsb2ZmKTtcclxuICAgICAgICAgICAgaWYoZm5tPT1cIlJFQ1RBTkdMRVwiKSB7XHJcbiAgICAgICAgICAgICAgICBVRE9DLkcubW92ZVRvKGdzdCwgYnhbMF0sYnhbMV0pO1xyXG4gICAgICAgICAgICAgICAgVURPQy5HLmxpbmVUbyhnc3QsIGJ4WzJdLGJ4WzFdKTtcclxuICAgICAgICAgICAgICAgIFVET0MuRy5saW5lVG8oZ3N0LCBieFsyXSxieFszXSk7XHJcbiAgICAgICAgICAgICAgICBVRE9DLkcubGluZVRvKGdzdCwgYnhbMF0sYnhbM10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSAoYnhbMF0rYnhbMl0pLzIsIHkgPSAoYnhbMV0rYnhbM10pLzI7XHJcbiAgICAgICAgICAgICAgICBVRE9DLkcuYXJjKGdzdCx4LHksKGJ4WzJdLWJ4WzBdKS8yLDAsMipNYXRoLlBJLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVURPQy5HLmNsb3NlUGF0aChnc3QpO1xyXG4gICAgICAgICAgICBGcm9tRU1GLl9kcmF3KGdlbnYsZ3N0LHBybXMsIHRydWUpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBybXMsIGdzdC5sd2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJGSUxMUEFUSFwiICApIGdlbnYuRmlsbChnc3QsIGZhbHNlKTtcclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTVFJPS0VQQVRIXCIpIGdlbnYuU3Ryb2tlKGdzdCk7XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU1RST0tFQU5ERklMTFBBVEhcIikgeyAgZ2Vudi5GaWxsKGdzdCwgZmFsc2UpOyAgZ2Vudi5TdHJva2UoZ3N0KTsgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTRVRXT1JMRFRSQU5TRk9STVwiIHx8IGZubT09XCJNT0RJRllXT1JMRFRSQU5TRk9STVwiKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXQgPSBbXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8NjsgaSsrKSBtYXQucHVzaChyRjMyKGJ1ZmYsbG9mZitpKjQpKTsgIGxvZmYrPTI0O1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGZubSwgZ3N0LmN0bS5zbGljZSgwKSwgbWF0KTtcclxuICAgICAgICAgICAgaWYoZm5tPT1cIlNFVFdPUkxEVFJBTlNGT1JNXCIpIGdzdC5jdG09bWF0O1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb2QgPSByVTMyKGJ1ZmYsbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICAgICAgaWYobW9kPT0yKSB7ICB2YXIgb209Z3N0LmN0bTsgIGdzdC5jdG09bWF0OyAgVURPQy5NLmNvbmNhdChnc3QuY3RtLCBvbSk7ICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IFwiZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFVFNUUkVUQ0hCTFRNT0RFXCIpIHsgIHZhciBzbSA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00OyAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNUUkVUQ0hESUJJVFNcIikge1xyXG4gICAgICAgICAgICB2YXIgYnggPSBGcm9tRU1GLl9yZWFkQm94KGJ1ZmYsIGxvZmYpOyAgbG9mZis9MTY7XHJcbiAgICAgICAgICAgIHZhciB4RCA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgeUQgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHhTID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciB5UyA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgd1MgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIGhTID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciBvZkggPSByVTMyKGJ1ZmYsIGxvZmYpK29mZi04OyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHN6SCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgb2ZCID0gclUzMihidWZmLCBsb2ZmKStvZmYtODsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciBzekIgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHVzZyA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00OyAgaWYodXNnIT0wKSB0aHJvdyBcImVcIjtcclxuICAgICAgICAgICAgdmFyIGJvcCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgd0QgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIGhEID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICAvL2NvbnNvbGUubG9nKGJvcCwgd0QsIGhEKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cob2ZILCBzekgsIG9mQiwgc3pCLCBvZkgrNDApO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGJ4LCB4RCx5RCx3RCxoRCk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coeFMseVMsd1MsaFMpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG9mSCxzekgsb2ZCLHN6Qix1c2csYm9wKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBobCA9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDtcclxuICAgICAgICAgICAgdmFyIHcgID0gclUzMihidWZmLCBvZkgpOyAgb2ZIKz00O1xyXG4gICAgICAgICAgICB2YXIgaCAgPSByVTMyKGJ1ZmYsIG9mSCk7ICBvZkgrPTQ7ICBpZih3IT13UyB8fCBoIT1oUykgdGhyb3cgXCJlXCI7XHJcbiAgICAgICAgICAgIHZhciBwcyA9IHJVICAoYnVmZiwgb2ZIKTsgIG9mSCs9MjtcclxuICAgICAgICAgICAgdmFyIGJjID0gclUgIChidWZmLCBvZkgpOyAgb2ZIKz0yOyAgaWYoYmMhPTggJiYgYmMhPTI0ICYmIGJjIT0zMikgdGhyb3cgYmMrXCIgZVwiO1xyXG4gICAgICAgICAgICB2YXIgY3ByPSByVTMyKGJ1ZmYsIG9mSCk7ICBvZkgrPTQ7ICBpZihjcHIhPTApIHRocm93IGNwcitcIiBlXCI7XHJcbiAgICAgICAgICAgIHZhciBzeiA9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDtcclxuICAgICAgICAgICAgdmFyIHhwbT0gclUzMihidWZmLCBvZkgpOyAgb2ZIKz00O1xyXG4gICAgICAgICAgICB2YXIgeXBtPSByVTMyKGJ1ZmYsIG9mSCk7ICBvZkgrPTQ7XHJcbiAgICAgICAgICAgIHZhciBjdSA9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDtcclxuICAgICAgICAgICAgdmFyIGNpID0gclUzMihidWZmLCBvZkgpOyAgb2ZIKz00OyAgLy9jb25zb2xlLmxvZyhobCwgdywgaCwgcHMsIGJjLCBjcHIsIHN6LCB4cG0sIHlwbSwgY3UsIGNpKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coaGwsdyxoLFwiLFwiLHhTLHlTLHdTLGhTLFwiLFwiLHhELHlELHdELGhELFwiLFwiLHhwbSx5cG0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHJsID0gTWF0aC5mbG9vcigoKHcgKiBwcyAqIGJjICsgMzEpICYgfjMxKSAvIDgpO1xyXG4gICAgICAgICAgICB2YXIgaW1nID0gbmV3IFVpbnQ4QXJyYXkodypoKjQpO1xyXG4gICAgICAgICAgICBpZihiYz09OCkge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB5PTA7IHk8aDsgeSsrKSBcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHFpID0gKHkqdyt4KTw8MiwgaW5kOmFueSA9IGJ1ZmZbb2ZCKyhoLTEteSkqcmwreF08PDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSAgXSA9IGJ1ZmZbb2ZIK2luZCsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzFdID0gYnVmZltvZkgraW5kKzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkrMl0gPSBidWZmW29mSCtpbmQrMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSszXSA9IDI1NTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoYmM9PTI0KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHk9MDsgeTxoOyB5KyspIFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeD0wOyB4PHc7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcWkgPSAoeSp3K3gpPDwyLCB0aT1vZkIrKGgtMS15KSpybCt4KjM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSAgXSA9IGJ1ZmZbdGkrMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSsxXSA9IGJ1ZmZbdGkrMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSsyXSA9IGJ1ZmZbdGkrMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSszXSA9IDI1NTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoYmM9PTMyKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHk9MDsgeTxoOyB5KyspIFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeD0wOyB4PHc7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcWkgPSAoeSp3K3gpPDwyLCB0aT1vZkIrKGgtMS15KSpybCt4KjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSAgXSA9IGJ1ZmZbdGkrMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSsxXSA9IGJ1ZmZbdGkrMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSsyXSA9IGJ1ZmZbdGkrMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSszXSA9IGJ1ZmZbdGkrM107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgY3RtID0gZ3N0LmN0bS5zbGljZSgwKTtcclxuICAgICAgICAgICAgZ3N0LmN0bSA9IFsxLDAsMCwxLDAsMF07XHJcbiAgICAgICAgICAgIFVET0MuTS5zY2FsZShnc3QuY3RtLCB3RCwgLWhEKTtcclxuICAgICAgICAgICAgVURPQy5NLnRyYW5zbGF0ZShnc3QuY3RtLCB4RCwgeUQraEQpO1xyXG4gICAgICAgICAgICBVRE9DLk0uY29uY2F0KGdzdC5jdG0sIGN0bSk7XHJcbiAgICAgICAgICAgIGdlbnYuUHV0SW1hZ2UoZ3N0LCBpbWcsIHcsIGgpO1xyXG4gICAgICAgICAgICBnc3QuY3RtID0gY3RtO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZm5tLCBzaXopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZihvYmohPW51bGwpIHRhYltvaWRdPW9iajtcclxuICAgICAgICBcclxuICAgICAgICBvZmYrPXNpei04O1xyXG4gICAgfVxyXG4gICAgLy9nZW52LlN0cm9rZShnc3QpO1xyXG4gICAgZ2Vudi5TaG93UGFnZSgpOyAgZ2Vudi5Eb25lKCk7XHJcbn1cclxuRnJvbUVNRi5fcmVhZEJveCA9IGZ1bmN0aW9uKGJ1ZmY6YW55LCBvZmY6YW55KSB7ICB2YXIgYj1bXTsgIGZvcih2YXIgaT0wOyBpPDQ7IGkrKykgYltpXSA9IEZyb21FTUYuQi5yZWFkSW50KGJ1ZmYsb2ZmK2kqNCk7ICByZXR1cm4gYjsgIH1cdFxyXG5cclxuRnJvbUVNRi5fdXBkYXRlQ3RtID0gZnVuY3Rpb24ocHJtczphbnksIGdzdDphbnkpIHtcclxuICAgIHZhciBtYXQgPSBbMSwwLDAsMSwwLDBdO1xyXG4gICAgdmFyIHdiYiA9IHBybXMud2JiLCBiYiA9IHBybXMuYmIsIHZiYj0ocHJtcy52YmIgJiYgcHJtcy52YmIubGVuZ3RoPT00KSA/IHBybXMudmJiOnBybXMuYmI7XHJcbiAgICBcclxuICAgIC8vdmFyIHkwID0gYmJbMV0sIHkxID0gYmJbM107ICBiYlsxXT1NYXRoLm1pbih5MCx5MSk7ICBiYlszXT1NYXRoLm1heCh5MCx5MSk7XHJcbiAgICBcclxuICAgIFVET0MuTS50cmFuc2xhdGUobWF0LCAtd2JiWzBdLC13YmJbMV0pO1xyXG4gICAgVURPQy5NLnNjYWxlKG1hdCwgMS93YmJbMl0sIDEvd2JiWzNdKTtcclxuICAgIFxyXG4gICAgVURPQy5NLnNjYWxlKG1hdCwgdmJiWzJdLCB2YmJbM10pO1xyXG4gICAgLy9VRE9DLk0uc2NhbGUobWF0LCB2YmJbMl0vKGJiWzJdLWJiWzBdKSwgdmJiWzNdLyhiYlszXS1iYlsxXSkpO1xyXG4gICAgXHJcbiAgICAvL1VET0MuTS5zY2FsZShtYXQsIGJiWzJdLWJiWzBdLGJiWzNdLWJiWzFdKTtcclxuICAgIFxyXG4gICAgZ3N0LmN0bSA9IG1hdDtcclxufVxyXG5Gcm9tRU1GLl9kcmF3ID0gZnVuY3Rpb24oZ2VudjphbnksIGdzdDphbnksIHBybXM6YW55LCBuZWVkRmlsbDphbnkpIHtcclxuICAgIGlmKHBybXMuZmlsbCAmJiBuZWVkRmlsbCAgICAgKSBnZW52LkZpbGwgIChnc3QsIGZhbHNlKTtcclxuICAgIGlmKHBybXMuc3RyayAmJiBnc3QubHdpZHRoIT0wKSBnZW52LlN0cm9rZShnc3QpO1xyXG59XHJcbkZyb21FTUYuX2RyYXdQb2x5ID0gZnVuY3Rpb24oYnVmZjphbnksIG9mZjphbnksIHBwcDphbnksIGdzdDphbnksIG5sOmFueSwgY2xvczphbnksIGp1c3RMaW5lOmFueSkge1xyXG4gICAgdmFyIHJTID0gbmw9PTIgPyBGcm9tRU1GLkIucmVhZFNob3J0IDogRnJvbUVNRi5CLnJlYWRJbnQ7XHJcbiAgICBmb3IodmFyIGo9MDsgajxwcHA7IGorKykge1xyXG4gICAgICAgIHZhciBweCA9IHJTKGJ1ZmYsIG9mZik7ICBvZmYrPW5sOyAgXHJcbiAgICAgICAgdmFyIHB5ID0gclMoYnVmZiwgb2ZmKTsgIG9mZis9bmw7XHJcbiAgICAgICAgaWYoaj09MCAmJiAhanVzdExpbmUpIFVET0MuRy5tb3ZlVG8oZ3N0LHB4LHB5KTsgIGVsc2UgVURPQy5HLmxpbmVUbyhnc3QscHgscHkpO1xyXG4gICAgfVxyXG4gICAgaWYoY2xvcykgVURPQy5HLmNsb3NlUGF0aChnc3QpO1xyXG4gICAgcmV0dXJuIG9mZjtcclxufVxyXG5cclxuRnJvbUVNRi5CID0ge1xyXG4gICAgdWludDggOiBuZXcgVWludDhBcnJheSg0KSxcclxuICAgIHJlYWRTaG9ydCAgOiBmdW5jdGlvbihidWZmOmFueSxwOmFueSk6YW55ICB7ICB2YXIgdTg9RnJvbUVNRi5CLnVpbnQ4OyAgdThbMF09YnVmZltwXTsgIHU4WzFdPWJ1ZmZbcCsxXTsgIHJldHVybiBGcm9tRU1GLkIuaW50MTYgWzBdOyAgfSxcclxuICAgIHJlYWRVc2hvcnQgOiBmdW5jdGlvbihidWZmOmFueSxwOmFueSk6YW55ICB7ICB2YXIgdTg9RnJvbUVNRi5CLnVpbnQ4OyAgdThbMF09YnVmZltwXTsgIHU4WzFdPWJ1ZmZbcCsxXTsgIHJldHVybiBGcm9tRU1GLkIudWludDE2WzBdOyAgfSxcclxuICAgIHJlYWRJbnQgICAgOiBmdW5jdGlvbihidWZmOmFueSxwOmFueSk6YW55ICB7ICB2YXIgdTg9RnJvbUVNRi5CLnVpbnQ4OyAgdThbMF09YnVmZltwXTsgIHU4WzFdPWJ1ZmZbcCsxXTsgIHU4WzJdPWJ1ZmZbcCsyXTsgIHU4WzNdPWJ1ZmZbcCszXTsgIHJldHVybiBGcm9tRU1GLkIuaW50MzIgWzBdOyAgfSxcclxuICAgIHJlYWRVaW50ICAgOiBmdW5jdGlvbihidWZmOmFueSxwOmFueSk6YW55ICB7ICB2YXIgdTg9RnJvbUVNRi5CLnVpbnQ4OyAgdThbMF09YnVmZltwXTsgIHU4WzFdPWJ1ZmZbcCsxXTsgIHU4WzJdPWJ1ZmZbcCsyXTsgIHU4WzNdPWJ1ZmZbcCszXTsgIHJldHVybiBGcm9tRU1GLkIudWludDMyWzBdOyAgfSxcclxuICAgIHJlYWRGbG9hdCAgOiBmdW5jdGlvbihidWZmOmFueSxwOmFueSk6YW55ICB7ICB2YXIgdTg9RnJvbUVNRi5CLnVpbnQ4OyAgdThbMF09YnVmZltwXTsgIHU4WzFdPWJ1ZmZbcCsxXTsgIHU4WzJdPWJ1ZmZbcCsyXTsgIHU4WzNdPWJ1ZmZbcCszXTsgIHJldHVybiBGcm9tRU1GLkIuZmxvdDMyWzBdOyAgfSxcclxuICAgIHJlYWRBU0NJSSAgOiBmdW5jdGlvbihidWZmOmFueSxwOmFueSxsOmFueSk6YW55IHsgIHZhciBzID0gXCJcIjsgIGZvcih2YXIgaT0wOyBpPGw7IGkrKykgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZbcCtpXSk7ICByZXR1cm4gczsgICAgfVxyXG59XHJcbkZyb21FTUYuQi5pbnQxNiAgPSBuZXcgSW50MTZBcnJheSAoRnJvbUVNRi5CLnVpbnQ4LmJ1ZmZlcik7XHJcbkZyb21FTUYuQi51aW50MTYgPSBuZXcgVWludDE2QXJyYXkoRnJvbUVNRi5CLnVpbnQ4LmJ1ZmZlcik7XHJcbkZyb21FTUYuQi5pbnQzMiAgPSBuZXcgSW50MzJBcnJheSAoRnJvbUVNRi5CLnVpbnQ4LmJ1ZmZlcik7XHJcbkZyb21FTUYuQi51aW50MzIgPSBuZXcgVWludDMyQXJyYXkoRnJvbUVNRi5CLnVpbnQ4LmJ1ZmZlcik7XHJcbkZyb21FTUYuQi5mbG90MzIgPSBuZXcgRmxvYXQzMkFycmF5KEZyb21FTUYuQi51aW50OC5idWZmZXIpO1xyXG5cclxuXHJcbkZyb21FTUYuQyA9IHtcclxuICAgIEVNUl9IRUFERVIgOiAweDAwMDAwMDAxLFxyXG4gICAgRU1SX1BPTFlCRVpJRVIgOiAweDAwMDAwMDAyLFxyXG4gICAgRU1SX1BPTFlHT04gOiAweDAwMDAwMDAzLFxyXG4gICAgRU1SX1BPTFlMSU5FIDogMHgwMDAwMDAwNCxcclxuICAgIEVNUl9QT0xZQkVaSUVSVE8gOiAweDAwMDAwMDA1LFxyXG4gICAgRU1SX1BPTFlMSU5FVE8gOiAweDAwMDAwMDA2LFxyXG4gICAgRU1SX1BPTFlQT0xZTElORSA6IDB4MDAwMDAwMDcsXHJcbiAgICBFTVJfUE9MWVBPTFlHT04gOiAweDAwMDAwMDA4LFxyXG4gICAgRU1SX1NFVFdJTkRPV0VYVEVYIDogMHgwMDAwMDAwOSxcclxuICAgIEVNUl9TRVRXSU5ET1dPUkdFWCA6IDB4MDAwMDAwMEEsXHJcbiAgICBFTVJfU0VUVklFV1BPUlRFWFRFWCA6IDB4MDAwMDAwMEIsXHJcbiAgICBFTVJfU0VUVklFV1BPUlRPUkdFWCA6IDB4MDAwMDAwMEMsXHJcbiAgICBFTVJfU0VUQlJVU0hPUkdFWCA6IDB4MDAwMDAwMEQsXHJcbiAgICBFTVJfRU9GIDogMHgwMDAwMDAwRSxcclxuICAgIEVNUl9TRVRQSVhFTFYgOiAweDAwMDAwMDBGLFxyXG4gICAgRU1SX1NFVE1BUFBFUkZMQUdTIDogMHgwMDAwMDAxMCxcclxuICAgIEVNUl9TRVRNQVBNT0RFIDogMHgwMDAwMDAxMSxcclxuICAgIEVNUl9TRVRCS01PREUgOiAweDAwMDAwMDEyLFxyXG4gICAgRU1SX1NFVFBPTFlGSUxMTU9ERSA6IDB4MDAwMDAwMTMsXHJcbiAgICBFTVJfU0VUUk9QMiA6IDB4MDAwMDAwMTQsXHJcbiAgICBFTVJfU0VUU1RSRVRDSEJMVE1PREUgOiAweDAwMDAwMDE1LFxyXG4gICAgRU1SX1NFVFRFWFRBTElHTiA6IDB4MDAwMDAwMTYsXHJcbiAgICBFTVJfU0VUQ09MT1JBREpVU1RNRU5UIDogMHgwMDAwMDAxNyxcclxuICAgIEVNUl9TRVRURVhUQ09MT1IgOiAweDAwMDAwMDE4LFxyXG4gICAgRU1SX1NFVEJLQ09MT1IgOiAweDAwMDAwMDE5LFxyXG4gICAgRU1SX09GRlNFVENMSVBSR04gOiAweDAwMDAwMDFBLFxyXG4gICAgRU1SX01PVkVUT0VYIDogMHgwMDAwMDAxQixcclxuICAgIEVNUl9TRVRNRVRBUkdOIDogMHgwMDAwMDAxQyxcclxuICAgIEVNUl9FWENMVURFQ0xJUFJFQ1QgOiAweDAwMDAwMDFELFxyXG4gICAgRU1SX0lOVEVSU0VDVENMSVBSRUNUIDogMHgwMDAwMDAxRSxcclxuICAgIEVNUl9TQ0FMRVZJRVdQT1JURVhURVggOiAweDAwMDAwMDFGLFxyXG4gICAgRU1SX1NDQUxFV0lORE9XRVhURVggOiAweDAwMDAwMDIwLFxyXG4gICAgRU1SX1NBVkVEQyA6IDB4MDAwMDAwMjEsXHJcbiAgICBFTVJfUkVTVE9SRURDIDogMHgwMDAwMDAyMixcclxuICAgIEVNUl9TRVRXT1JMRFRSQU5TRk9STSA6IDB4MDAwMDAwMjMsXHJcbiAgICBFTVJfTU9ESUZZV09STERUUkFOU0ZPUk0gOiAweDAwMDAwMDI0LFxyXG4gICAgRU1SX1NFTEVDVE9CSkVDVCA6IDB4MDAwMDAwMjUsXHJcbiAgICBFTVJfQ1JFQVRFUEVOIDogMHgwMDAwMDAyNixcclxuICAgIEVNUl9DUkVBVEVCUlVTSElORElSRUNUIDogMHgwMDAwMDAyNyxcclxuICAgIEVNUl9ERUxFVEVPQkpFQ1QgOiAweDAwMDAwMDI4LFxyXG4gICAgRU1SX0FOR0xFQVJDIDogMHgwMDAwMDAyOSxcclxuICAgIEVNUl9FTExJUFNFIDogMHgwMDAwMDAyQSxcclxuICAgIEVNUl9SRUNUQU5HTEUgOiAweDAwMDAwMDJCLFxyXG4gICAgRU1SX1JPVU5EUkVDVCA6IDB4MDAwMDAwMkMsXHJcbiAgICBFTVJfQVJDIDogMHgwMDAwMDAyRCxcclxuICAgIEVNUl9DSE9SRCA6IDB4MDAwMDAwMkUsXHJcbiAgICBFTVJfUElFIDogMHgwMDAwMDAyRixcclxuICAgIEVNUl9TRUxFQ1RQQUxFVFRFIDogMHgwMDAwMDAzMCxcclxuICAgIEVNUl9DUkVBVEVQQUxFVFRFIDogMHgwMDAwMDAzMSxcclxuICAgIEVNUl9TRVRQQUxFVFRFRU5UUklFUyA6IDB4MDAwMDAwMzIsXHJcbiAgICBFTVJfUkVTSVpFUEFMRVRURSA6IDB4MDAwMDAwMzMsXHJcbiAgICBFTVJfUkVBTElaRVBBTEVUVEUgOiAweDAwMDAwMDM0LFxyXG4gICAgRU1SX0VYVEZMT09ERklMTCA6IDB4MDAwMDAwMzUsXHJcbiAgICBFTVJfTElORVRPIDogMHgwMDAwMDAzNixcclxuICAgIEVNUl9BUkNUTyA6IDB4MDAwMDAwMzcsXHJcbiAgICBFTVJfUE9MWURSQVcgOiAweDAwMDAwMDM4LFxyXG4gICAgRU1SX1NFVEFSQ0RJUkVDVElPTiA6IDB4MDAwMDAwMzksXHJcbiAgICBFTVJfU0VUTUlURVJMSU1JVCA6IDB4MDAwMDAwM0EsXHJcbiAgICBFTVJfQkVHSU5QQVRIIDogMHgwMDAwMDAzQixcclxuICAgIEVNUl9FTkRQQVRIIDogMHgwMDAwMDAzQyxcclxuICAgIEVNUl9DTE9TRUZJR1VSRSA6IDB4MDAwMDAwM0QsXHJcbiAgICBFTVJfRklMTFBBVEggOiAweDAwMDAwMDNFLFxyXG4gICAgRU1SX1NUUk9LRUFOREZJTExQQVRIIDogMHgwMDAwMDAzRixcclxuICAgIEVNUl9TVFJPS0VQQVRIIDogMHgwMDAwMDA0MCxcclxuICAgIEVNUl9GTEFUVEVOUEFUSCA6IDB4MDAwMDAwNDEsXHJcbiAgICBFTVJfV0lERU5QQVRIIDogMHgwMDAwMDA0MixcclxuICAgIEVNUl9TRUxFQ1RDTElQUEFUSCA6IDB4MDAwMDAwNDMsXHJcbiAgICBFTVJfQUJPUlRQQVRIIDogMHgwMDAwMDA0NCxcclxuICAgIEVNUl9DT01NRU5UIDogMHgwMDAwMDA0NixcclxuICAgIEVNUl9GSUxMUkdOIDogMHgwMDAwMDA0NyxcclxuICAgIEVNUl9GUkFNRVJHTiA6IDB4MDAwMDAwNDgsXHJcbiAgICBFTVJfSU5WRVJUUkdOIDogMHgwMDAwMDA0OSxcclxuICAgIEVNUl9QQUlOVFJHTiA6IDB4MDAwMDAwNEEsXHJcbiAgICBFTVJfRVhUU0VMRUNUQ0xJUFJHTiA6IDB4MDAwMDAwNEIsXHJcbiAgICBFTVJfQklUQkxUIDogMHgwMDAwMDA0QyxcclxuICAgIEVNUl9TVFJFVENIQkxUIDogMHgwMDAwMDA0RCxcclxuICAgIEVNUl9NQVNLQkxUIDogMHgwMDAwMDA0RSxcclxuICAgIEVNUl9QTEdCTFQgOiAweDAwMDAwMDRGLFxyXG4gICAgRU1SX1NFVERJQklUU1RPREVWSUNFIDogMHgwMDAwMDA1MCxcclxuICAgIEVNUl9TVFJFVENIRElCSVRTIDogMHgwMDAwMDA1MSxcclxuICAgIEVNUl9FWFRDUkVBVEVGT05USU5ESVJFQ1RXIDogMHgwMDAwMDA1MixcclxuICAgIEVNUl9FWFRURVhUT1VUQSA6IDB4MDAwMDAwNTMsXHJcbiAgICBFTVJfRVhUVEVYVE9VVFcgOiAweDAwMDAwMDU0LFxyXG4gICAgRU1SX1BPTFlCRVpJRVIxNiA6IDB4MDAwMDAwNTUsXHJcbiAgICBFTVJfUE9MWUdPTjE2IDogMHgwMDAwMDA1NixcclxuICAgIEVNUl9QT0xZTElORTE2IDogMHgwMDAwMDA1NyxcclxuICAgIEVNUl9QT0xZQkVaSUVSVE8xNiA6IDB4MDAwMDAwNTgsXHJcbiAgICBFTVJfUE9MWUxJTkVUTzE2IDogMHgwMDAwMDA1OSxcclxuICAgIEVNUl9QT0xZUE9MWUxJTkUxNiA6IDB4MDAwMDAwNUEsXHJcbiAgICBFTVJfUE9MWVBPTFlHT04xNiA6IDB4MDAwMDAwNUIsXHJcbiAgICBFTVJfUE9MWURSQVcxNiA6IDB4MDAwMDAwNUMsXHJcbiAgICBFTVJfQ1JFQVRFTU9OT0JSVVNIIDogMHgwMDAwMDA1RCxcclxuICAgIEVNUl9DUkVBVEVESUJQQVRURVJOQlJVU0hQVCA6IDB4MDAwMDAwNUUsXHJcbiAgICBFTVJfRVhUQ1JFQVRFUEVOIDogMHgwMDAwMDA1RixcclxuICAgIEVNUl9QT0xZVEVYVE9VVEEgOiAweDAwMDAwMDYwLFxyXG4gICAgRU1SX1BPTFlURVhUT1VUVyA6IDB4MDAwMDAwNjEsXHJcbiAgICBFTVJfU0VUSUNNTU9ERSA6IDB4MDAwMDAwNjIsXHJcbiAgICBFTVJfQ1JFQVRFQ09MT1JTUEFDRSA6IDB4MDAwMDAwNjMsXHJcbiAgICBFTVJfU0VUQ09MT1JTUEFDRSA6IDB4MDAwMDAwNjQsXHJcbiAgICBFTVJfREVMRVRFQ09MT1JTUEFDRSA6IDB4MDAwMDAwNjUsXHJcbiAgICBFTVJfR0xTUkVDT1JEIDogMHgwMDAwMDA2NixcclxuICAgIEVNUl9HTFNCT1VOREVEUkVDT1JEIDogMHgwMDAwMDA2NyxcclxuICAgIEVNUl9QSVhFTEZPUk1BVCA6IDB4MDAwMDAwNjgsXHJcbiAgICBFTVJfRFJBV0VTQ0FQRSA6IDB4MDAwMDAwNjksXHJcbiAgICBFTVJfRVhURVNDQVBFIDogMHgwMDAwMDA2QSxcclxuICAgIEVNUl9TTUFMTFRFWFRPVVQgOiAweDAwMDAwMDZDLFxyXG4gICAgRU1SX0ZPUkNFVUZJTUFQUElORyA6IDB4MDAwMDAwNkQsXHJcbiAgICBFTVJfTkFNRURFU0NBUEUgOiAweDAwMDAwMDZFLFxyXG4gICAgRU1SX0NPTE9SQ09SUkVDVFBBTEVUVEUgOiAweDAwMDAwMDZGLFxyXG4gICAgRU1SX1NFVElDTVBST0ZJTEVBIDogMHgwMDAwMDA3MCxcclxuICAgIEVNUl9TRVRJQ01QUk9GSUxFVyA6IDB4MDAwMDAwNzEsXHJcbiAgICBFTVJfQUxQSEFCTEVORCA6IDB4MDAwMDAwNzIsXHJcbiAgICBFTVJfU0VUTEFZT1VUIDogMHgwMDAwMDA3MyxcclxuICAgIEVNUl9UUkFOU1BBUkVOVEJMVCA6IDB4MDAwMDAwNzQsXHJcbiAgICBFTVJfR1JBRElFTlRGSUxMIDogMHgwMDAwMDA3NixcclxuICAgIEVNUl9TRVRMSU5LRURVRklTIDogMHgwMDAwMDA3NyxcclxuICAgIEVNUl9TRVRURVhUSlVTVElGSUNBVElPTiA6IDB4MDAwMDAwNzgsXHJcbiAgICBFTVJfQ09MT1JNQVRDSFRPVEFSR0VUVyA6IDB4MDAwMDAwNzksXHJcbiAgICBFTVJfQ1JFQVRFQ09MT1JTUEFDRVcgOiAweDAwMDAwMDdBXHJcbn07XHJcbkZyb21FTUYuSyA9IFtdO1xyXG5cclxuLy8gKGZ1bmN0aW9uKCkge1xyXG4vLyAgICAgdmFyIGlucCwgb3V0LCBzdHQ7XHJcbi8vICAgICBpbnAgPSBGcm9tRU1GLkM7ICAgb3V0ID0gRnJvbUVNRi5LOyAgIHN0dD00O1xyXG4vLyAgICAgZm9yKHZhciBwIGluIGlucCkgb3V0W2lucFtwXV0gPSBwLnNsaWNlKHN0dCk7XHJcbi8vIH0gICkoKTtcclxuXHJcblxyXG5cclxuZXhwb3J0IGxldCBUb0NvbnRleHQyRDphbnkgPSBmdW5jdGlvbiAobmVlZFBhZ2U6YW55LCBzY2FsZTphbnkpXHJcbntcclxuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgdGhpcy5iYiA9IG51bGw7XHJcbiAgICB0aGlzLmN1cnJQYWdlID0gMDtcclxuICAgIHRoaXMubmVlZFBhZ2UgPSBuZWVkUGFnZTtcclxuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcclxufVxyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuU3RhcnRQYWdlID0gZnVuY3Rpb24oeDphbnkseTphbnksdzphbnksaDphbnkpIHtcclxuICAgIGlmKHRoaXMuY3VyclBhZ2UhPXRoaXMubmVlZFBhZ2UpIHJldHVybjtcclxuICAgIHRoaXMuYmIgPSBbeCx5LHcsaF07XHJcbiAgICB2YXIgc2NsID0gdGhpcy5zY2FsZSwgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XHJcbiAgICB2YXIgY252ID0gdGhpcy5jYW52YXMsIGN0eCA9IHRoaXMuY3R4O1xyXG4gICAgY252LndpZHRoID0gTWF0aC5yb3VuZCh3KnNjbCk7ICBjbnYuaGVpZ2h0ID0gTWF0aC5yb3VuZChoKnNjbCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKDAsaCpzY2wpOyAgY3R4LnNjYWxlKHNjbCwtc2NsKTtcclxuICAgIGNudi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImJvcmRlcjoxcHggc29saWQ7IHdpZHRoOlwiKyhjbnYud2lkdGgvZHByKStcInB4OyBoZWlnaHQ6XCIrKGNudi5oZWlnaHQvZHByKStcInB4XCIpO1xyXG59XHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5GaWxsID0gZnVuY3Rpb24oZ3N0OmFueSwgZXZlbk9kZDphbnkpIHtcclxuICAgIGlmKHRoaXMuY3VyclBhZ2UhPXRoaXMubmVlZFBhZ2UpIHJldHVybjtcclxuICAgIHZhciBjdHggPSB0aGlzLmN0eDtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIHRoaXMuX3NldFN0eWxlKGdzdCwgY3R4KTtcclxuICAgIHRoaXMuX2RyYXcoZ3N0LnB0aCwgY3R4KTtcclxuICAgIGN0eC5maWxsKCk7XHJcbn1cclxuVG9Db250ZXh0MkQucHJvdG90eXBlLlN0cm9rZSA9IGZ1bmN0aW9uKGdzdDphbnkpIHtcclxuICAgIGlmKHRoaXMuY3VyclBhZ2UhPXRoaXMubmVlZFBhZ2UpIHJldHVybjtcclxuICAgIHZhciBjdHggPSB0aGlzLmN0eDtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIHRoaXMuX3NldFN0eWxlKGdzdCwgY3R4KTtcclxuICAgIHRoaXMuX2RyYXcoZ3N0LnB0aCwgY3R4KTtcclxuICAgIGN0eC5zdHJva2UoKTtcclxufVxyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuUHV0VGV4dCA9IGZ1bmN0aW9uKGdzdDphbnksIHN0cjphbnksIHN0dzphbnkpIHtcclxuICAgIGlmKHRoaXMuY3VyclBhZ2UhPXRoaXMubmVlZFBhZ2UpIHJldHVybjtcclxuICAgIHZhciBzY2wgPSB0aGlzLl9zY2FsZShnc3QuY3RtKTtcclxuICAgIHZhciBjdHggPSB0aGlzLmN0eDtcclxuICAgIHRoaXMuX3NldFN0eWxlKGdzdCwgY3R4KTtcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICB2YXIgbSA9IFsxLDAsMCwtMSwwLDBdOyAgdGhpcy5fY29uY2F0KG0sIGdzdC5mb250LlRtKTsgIHRoaXMuX2NvbmNhdChtLCBnc3QuY3RtKTtcclxuICAgIC8vY29uc29sZS5sb2coc3RyLCBtLCBnc3QpOyAgdGhyb3cgXCJlXCI7XHJcbiAgICBjdHgudHJhbnNmb3JtKG1bMF0sbVsxXSxtWzJdLG1bM10sbVs0XSxtWzVdKTtcclxuICAgIGN0eC5maWxsVGV4dChzdHIsMCwwKTtcclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbn1cclxuVG9Db250ZXh0MkQucHJvdG90eXBlLlB1dEltYWdlID0gZnVuY3Rpb24oZ3N0OmFueSwgYnVmZjphbnksIHc6YW55LCBoOmFueSwgbXNrOmFueSkge1xyXG4gICAgaWYodGhpcy5jdXJyUGFnZSE9dGhpcy5uZWVkUGFnZSkgcmV0dXJuO1xyXG4gICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xyXG4gICAgXHJcbiAgICBpZihidWZmLmxlbmd0aD09dypoKjQpIHtcclxuICAgICAgICBidWZmID0gYnVmZi5zbGljZSgwKTtcclxuICAgICAgICBpZihtc2sgJiYgbXNrLmxlbmd0aD09dypoKjQpIGZvcih2YXIgaT0wOyBpPGJ1ZmYubGVuZ3RoOyBpKz00KSBidWZmW2krM10gPSBtc2tbaSsxXTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgY252ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgY2N0eCA9IGNudi5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgY252LndpZHRoID0gdzsgIGNudi5oZWlnaHQgPSBoO1xyXG4gICAgICAgIHZhciBpbWdkID0gY2N0eC5jcmVhdGVJbWFnZURhdGEodyxoKTtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTxidWZmLmxlbmd0aDsgaSsrKSBpbWdkLmRhdGFbaV09YnVmZltpXTtcclxuICAgICAgICBjY3R4LnB1dEltYWdlRGF0YShpbWdkLDAsMCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICB2YXIgbSA9IFsxLDAsMCwxLDAsMF07ICB0aGlzLl9jb25jYXQobSwgWzEvdywwLDAsLTEvaCwwLDFdKTsgIHRoaXMuX2NvbmNhdChtLCBnc3QuY3RtKTtcclxuICAgICAgICBjdHgudHJhbnNmb3JtKG1bMF0sbVsxXSxtWzJdLG1bM10sbVs0XSxtWzVdKTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGNudiwwLDApO1xyXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbn1cclxuVG9Db250ZXh0MkQucHJvdG90eXBlLlNob3dQYWdlID0gZnVuY3Rpb24oKSB7ICB0aGlzLmN1cnJQYWdlKys7ICB9XHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5Eb25lID0gZnVuY3Rpb24oKSB7fVxyXG5cclxuXHJcbmZ1bmN0aW9uIF9mbHQobjphbnkpICB7ICByZXR1cm4gXCJcIitwYXJzZUZsb2F0KG4udG9GaXhlZCgyKSk7ICB9XHJcblxyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuX3NldFN0eWxlID0gZnVuY3Rpb24oZ3N0OmFueSwgY3R4OmFueSkge1xyXG4gICAgdmFyIHNjbCA9IHRoaXMuX3NjYWxlKGdzdC5jdG0pO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2dldEZpbGwoZ3N0LmNvbHIsIGdzdC5jYSwgY3R4KTtcclxuICAgIGN0eC5zdHJva2VTdHlsZT10aGlzLl9nZXRGaWxsKGdzdC5DT0xSLCBnc3QuQ0EsIGN0eCk7XHJcbiAgICBcclxuICAgIGN0eC5saW5lQ2FwID0gW1wiYnV0dFwiLFwicm91bmRcIixcInNxdWFyZVwiXVtnc3QubGNhcF07XHJcbiAgICBjdHgubGluZUpvaW49IFtcIm1pdGVyXCIsXCJyb3VuZFwiLFwiYmV2ZWxcIl1bZ3N0Lmxqb2luXTtcclxuICAgIGN0eC5saW5lV2lkdGg9Z3N0Lmx3aWR0aCpzY2w7XHJcbiAgICB2YXIgZHNoID0gZ3N0LmRhc2guc2xpY2UoMCk7ICBmb3IodmFyIGk9MDsgaTxkc2gubGVuZ3RoOyBpKyspIGRzaFtpXSA9IF9mbHQoZHNoW2ldKnNjbCk7XHJcbiAgICBjdHguc2V0TGluZURhc2goZHNoKTsgXHJcbiAgICBjdHgubWl0ZXJMaW1pdCA9IGdzdC5tbGltaXQqc2NsO1xyXG4gICAgXHJcbiAgICB2YXIgZm4gPSBnc3QuZm9udC5UZiwgbG4gPSBmbi50b0xvd2VyQ2FzZSgpO1xyXG4gICAgdmFyIHAwID0gbG4uaW5kZXhPZihcImJvbGRcIikhPS0xID8gXCJib2xkIFwiIDogXCJcIjtcclxuICAgIHZhciBwMSA9IChsbi5pbmRleE9mKFwiaXRhbGljXCIpIT0tMSB8fCBsbi5pbmRleE9mKFwib2JsaXF1ZVwiKSE9LTEpID8gXCJpdGFsaWMgXCIgOiBcIlwiO1xyXG4gICAgY3R4LmZvbnQgPSBwMCtwMSArIGdzdC5mb250LlRmcytcInB4IFxcXCJcIitmbitcIlxcXCJcIjtcclxufVxyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuX2dldEZpbGwgPSBmdW5jdGlvbihjb2xyOmFueSwgY2E6YW55LCBjdHg6YW55KVxyXG57XHJcbiAgICBpZihjb2xyLnR5cD09bnVsbCkgcmV0dXJuIHRoaXMuX2NvbHIoY29scixjYSk7XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgZ3JkID0gY29sciwgY3JkID0gZ3JkLmNyZHMsIG1hdCA9IGdyZC5tYXQsIHNjbD10aGlzLl9zY2FsZShtYXQpLCBnZjtcclxuICAgICAgICBpZiAgICAgKGdyZC50eXA9PVwibGluXCIpIHtcclxuICAgICAgICAgICAgdmFyIHAwID0gdGhpcy5fbXVsdFBvaW50KG1hdCxjcmQuc2xpY2UoMCwyKSksIHAxID0gdGhpcy5fbXVsdFBvaW50KG1hdCxjcmQuc2xpY2UoMikpO1xyXG4gICAgICAgICAgICBnZj1jdHguY3JlYXRlTGluZWFyR3JhZGllbnQocDBbMF0scDBbMV0scDFbMF0scDFbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGdyZC50eXA9PVwicmFkXCIpIHtcclxuICAgICAgICAgICAgdmFyIHAwID0gdGhpcy5fbXVsdFBvaW50KG1hdCxjcmQuc2xpY2UoMCwyKSksIHAxID0gdGhpcy5fbXVsdFBvaW50KG1hdCxjcmQuc2xpY2UoMykpO1xyXG4gICAgICAgICAgICBnZj1jdHguY3JlYXRlUmFkaWFsR3JhZGllbnQocDBbMF0scDBbMV0sY3JkWzJdKnNjbCxwMVswXSxwMVsxXSxjcmRbNV0qc2NsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8Z3JkLmdyYWQubGVuZ3RoOyBpKyspICBnZi5hZGRDb2xvclN0b3AoZ3JkLmdyYWRbaV1bMF0sdGhpcy5fY29scihncmQuZ3JhZFtpXVsxXSwgY2EpKTtcclxuICAgICAgICByZXR1cm4gZ2Y7XHJcbiAgICB9XHJcbn1cclxuVG9Db250ZXh0MkQucHJvdG90eXBlLl9jb2xyICA9IGZ1bmN0aW9uKGM6YW55LGE6YW55KSB7ICByZXR1cm4gXCJyZ2JhKFwiK01hdGgucm91bmQoY1swXSoyNTUpK1wiLFwiK01hdGgucm91bmQoY1sxXSoyNTUpK1wiLFwiK01hdGgucm91bmQoY1syXSoyNTUpK1wiLFwiK2ErXCIpXCI7ICB9O1xyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuX3NjYWxlID0gZnVuY3Rpb24obTphbnkpICB7ICByZXR1cm4gTWF0aC5zcXJ0KE1hdGguYWJzKG1bMF0qbVszXS1tWzFdKm1bMl0pKTsgIH07XHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5fY29uY2F0PSBmdW5jdGlvbihtOmFueSx3OmFueSAgKSB7ICBcclxuICAgICAgICB2YXIgYT1tWzBdLGI9bVsxXSxjPW1bMl0sZD1tWzNdLHR4PW1bNF0sdHk9bVs1XTtcclxuICAgICAgICBtWzBdID0gKGEgKndbMF0pKyhiICp3WzJdKTsgICAgICAgbVsxXSA9IChhICp3WzFdKSsoYiAqd1szXSk7XHJcbiAgICAgICAgbVsyXSA9IChjICp3WzBdKSsoZCAqd1syXSk7ICAgICAgIG1bM10gPSAoYyAqd1sxXSkrKGQgKndbM10pO1xyXG4gICAgICAgIG1bNF0gPSAodHgqd1swXSkrKHR5KndbMl0pK3dbNF07ICBtWzVdID0gKHR4KndbMV0pKyh0eSp3WzNdKSt3WzVdOyBcclxufVxyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuX211bHRQb2ludD0gZnVuY3Rpb24obTphbnksIHA6YW55KSB7ICB2YXIgeD1wWzBdLHk9cFsxXTsgIHJldHVybiBbeCptWzBdK3kqbVsyXSttWzRdLCAgIHgqbVsxXSt5Km1bM10rbVs1XV07ICB9LFxyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuX2RyYXcgID0gZnVuY3Rpb24ocGF0aDphbnksIGN0eDphbnkpXHJcbntcclxuICAgIHZhciBjID0gMCwgY3JkcyA9IHBhdGguY3JkcztcclxuICAgIGZvcih2YXIgaj0wOyBqPHBhdGguY21kcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHZhciBjbWQgPSBwYXRoLmNtZHNbal07XHJcbiAgICAgICAgaWYgICAgIChjbWQ9PVwiTVwiKSB7ICBjdHgubW92ZVRvKGNyZHNbY10sIGNyZHNbYysxXSk7ICBjKz0yOyAgfVxyXG4gICAgICAgIGVsc2UgaWYoY21kPT1cIkxcIikgeyAgY3R4LmxpbmVUbyhjcmRzW2NdLCBjcmRzW2MrMV0pOyAgYys9MjsgIH1cclxuICAgICAgICBlbHNlIGlmKGNtZD09XCJDXCIpIHsgIGN0eC5iZXppZXJDdXJ2ZVRvKGNyZHNbY10sIGNyZHNbYysxXSwgY3Jkc1tjKzJdLCBjcmRzW2MrM10sIGNyZHNbYys0XSwgY3Jkc1tjKzVdKTsgIGMrPTY7ICB9XHJcbiAgICAgICAgZWxzZSBpZihjbWQ9PVwiUVwiKSB7ICBjdHgucXVhZHJhdGljQ3VydmVUbyhjcmRzW2NdLCBjcmRzW2MrMV0sIGNyZHNbYysyXSwgY3Jkc1tjKzNdKTsgIGMrPTQ7ICB9XHJcbiAgICAgICAgZWxzZSBpZihjbWQ9PVwiWlwiKSB7ICBjdHguY2xvc2VQYXRoKCk7ICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgY29sdW1lSGVhZGVyX3dvcmQsIGNvbHVtZUhlYWRlcl93b3JkX2luZGV4IH0gZnJvbSBcIi4vY29uc3RhbnRcIjtcclxuaW1wb3J0IHsgSWx1Y2t5U2hlZXRTZWxlY3Rpb24gfSBmcm9tIFwiLi4vVG9MdWNreVNoZWV0L0lMdWNrXCI7XHJcbmltcG9ydCB7IElhdHRyaWJ1dGVMaXN0LCBzdHJpbmdUb051bX0gZnJvbSBcIi4uL0lDb21tb25cIjtcclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZ2V0eHQocmFuZ2U6SWx1Y2t5U2hlZXRTZWxlY3Rpb24sIHNoZWV0dHh0OnN0cmluZykge1xyXG5cclxuICAgIGxldCByb3cwID0gcmFuZ2VbXCJyb3dcIl1bMF0sIHJvdzEgPSByYW5nZVtcInJvd1wiXVsxXTtcclxuICAgIGxldCBjb2x1bW4wID0gcmFuZ2VbXCJjb2x1bW5cIl1bMF0sIGNvbHVtbjEgPSByYW5nZVtcImNvbHVtblwiXVsxXTtcclxuXHJcbiAgICBpZiAocm93MCA9PSBudWxsICYmIHJvdzEgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBzaGVldHR4dCArIGNoYXRhdEFCQyhjb2x1bW4wKSArIFwiOlwiICsgY2hhdGF0QUJDKGNvbHVtbjEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29sdW1uMCA9PSBudWxsICYmIGNvbHVtbjEgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBzaGVldHR4dCArIChyb3cwICsgMSkgKyBcIjpcIiArIChyb3cxICsgMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoY29sdW1uMCA9PSBjb2x1bW4xICYmIHJvdzAgPT0gcm93MSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2hlZXR0eHQgKyBjaGF0YXRBQkMoY29sdW1uMCkgKyAocm93MCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNoZWV0dHh0ICsgY2hhdGF0QUJDKGNvbHVtbjApICsgKHJvdzAgKyAxKSArIFwiOlwiICsgY2hhdGF0QUJDKGNvbHVtbjEpICsgKHJvdzEgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Y2VsbHJhbmdlICh0eHQ6c3RyaW5nLCBzaGVldHM6SWF0dHJpYnV0ZUxpc3Q9e30sIHNoZWV0SWQ6c3RyaW5nPVwiMVwiKSB7XHJcbiAgICBsZXQgdmFsID0gdHh0LnNwbGl0KFwiIVwiKTtcclxuXHJcbiAgICBsZXQgc2hlZXR0eHQgPSBcIlwiLFxyXG4gICAgICAgIHJhbmdldHh0ID0gXCJcIixcclxuICAgICAgICBzaGVldEluZGV4ID0gLTE7XHJcblxyXG4gICAgaWYgKHZhbC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgc2hlZXR0eHQgPSB2YWxbMF07XHJcbiAgICAgICAgcmFuZ2V0eHQgPSB2YWxbMV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHNpID0gc2hlZXRzW3NoZWV0dHh0XTtcclxuICAgICAgICBpZihzaT09bnVsbCl7XHJcbiAgICAgICAgICAgIHNoZWV0SW5kZXggPSBwYXJzZUludChzaGVldElkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgc2hlZXRJbmRleCA9IHBhcnNlSW50KHNpKTtcclxuICAgICAgICB9XHJcbiAgICB9IFxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2hlZXRJbmRleCA9IHBhcnNlSW50KHNoZWV0SWQpO1xyXG4gICAgICAgIHJhbmdldHh0ID0gdmFsWzBdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAocmFuZ2V0eHQuaW5kZXhPZihcIjpcIikgPT0gLTEpIHtcclxuICAgICAgICBsZXQgcm93ID0gcGFyc2VJbnQocmFuZ2V0eHQucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKSAtIDE7XHJcbiAgICAgICAgbGV0IGNvbCA9IEFCQ2F0TnVtKHJhbmdldHh0LnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKSk7XHJcblxyXG4gICAgICAgIGlmICghaXNOYU4ocm93KSAmJiAhaXNOYU4oY29sKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgXCJyb3dcIjogW3Jvdywgcm93XSxcclxuICAgICAgICAgICAgICAgIFwiY29sdW1uXCI6IFtjb2wsIGNvbF0sXHJcbiAgICAgICAgICAgICAgICBcInNoZWV0SW5kZXhcIjogc2hlZXRJbmRleFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSBcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCByYW5nZXR4dEFycmF5OnN0cmluZ1tdID0gcmFuZ2V0eHQuc3BsaXQoXCI6XCIpO1xyXG4gICAgICAgIGxldCByb3cgPSBbXSxjb2wgPSBbXTtcclxuICAgICAgICByb3dbMF0gPSBwYXJzZUludChyYW5nZXR4dEFycmF5WzBdLnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSkgLSAxO1xyXG4gICAgICAgIHJvd1sxXSA9IHBhcnNlSW50KHJhbmdldHh0QXJyYXlbMV0ucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKSAtIDE7XHJcbiAgICAgICAgLy8gaWYgKGlzTmFOKHJvd1swXSkpIHtcclxuICAgICAgICAvLyAgICAgcm93WzBdID0gMDtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gaWYgKGlzTmFOKHJvd1sxXSkpIHtcclxuICAgICAgICAvLyAgICAgcm93WzFdID0gc2hlZXRkYXRhLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGlmIChyb3dbMF0gPiByb3dbMV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbFswXSA9IEFCQ2F0TnVtKHJhbmdldHh0QXJyYXlbMF0ucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcclxuICAgICAgICBjb2xbMV0gPSBBQkNhdE51bShyYW5nZXR4dEFycmF5WzFdLnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKSk7XHJcbiAgICAgICAgLy8gaWYgKGlzTmFOKGNvbFswXSkpIHtcclxuICAgICAgICAvLyAgICAgY29sWzBdID0gMDtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gaWYgKGlzTmFOKGNvbFsxXSkpIHtcclxuICAgICAgICAvLyAgICAgY29sWzFdID0gc2hlZXRkYXRhWzBdLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGlmIChjb2xbMF0gPiBjb2xbMV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBcInJvd1wiOiByb3csXHJcbiAgICAgICAgICAgIFwiY29sdW1uXCI6IGNvbCxcclxuICAgICAgICAgICAgXCJzaGVldEluZGV4XCI6IHNoZWV0SW5kZXhcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vL+WIl+S4i+aghyAg5a2X5q+N6L2s5pWw5a2XXHJcbmZ1bmN0aW9uIEFCQ2F0TnVtKGFiYzpzdHJpbmcpIHtcclxuICAgIGFiYyA9IGFiYy50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgIGxldCBhYmNfbGVuID0gYWJjLmxlbmd0aDtcclxuICAgIGlmIChhYmNfbGVuID09IDApIHtcclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBhYmNfYXJyYXkgPSBhYmMuc3BsaXQoXCJcIik7XHJcbiAgICBsZXQgd29yZGxlbiA9IGNvbHVtZUhlYWRlcl93b3JkLmxlbmd0aDtcclxuICAgIGxldCByZXQgPSAwO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBhYmNfbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBpZiAoaSA9PSBhYmNfbGVuIC0gMSkge1xyXG4gICAgICAgICAgICByZXQgKz0gY29sdW1lSGVhZGVyX3dvcmRfaW5kZXhbYWJjX2FycmF5W2ldXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldCArPSBNYXRoLnBvdyh3b3JkbGVuLCBhYmNfbGVuIC0gaSAtIDEpICogKGNvbHVtZUhlYWRlcl93b3JkX2luZGV4W2FiY19hcnJheVtpXV0gKyAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuLy/liJfkuIvmoIcgIOaVsOWtl+i9rOWtl+avjVxyXG5mdW5jdGlvbiBjaGF0YXRBQkMoaW5kZXg6bnVtYmVyKSB7XHJcbiAgICBsZXQgd29yZGxlbiA9IGNvbHVtZUhlYWRlcl93b3JkLmxlbmd0aDtcclxuXHJcbiAgICBpZiAoaW5kZXggPCB3b3JkbGVuKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbHVtZUhlYWRlcl93b3JkW2luZGV4XTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBsYXN0ID0gMCwgcHJlID0gMCwgcmV0ID0gXCJcIjtcclxuICAgICAgICBsZXQgaSA9IDEsIG4gPSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAoaW5kZXggPj0gKHdvcmRsZW4gLyAod29yZGxlbiAtIDEpKSAqIChNYXRoLnBvdyh3b3JkbGVuLCBpKyspIC0gMSkpIHtcclxuICAgICAgICAgICAgbiA9IGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaW5kZXhfYWIgPSBpbmRleCAtICh3b3JkbGVuIC8gKHdvcmRsZW4gLSAxKSkgKiAoTWF0aC5wb3cod29yZGxlbiwgbiAtIDEpIC0gMSk7Ly85NzBcclxuICAgICAgICBsYXN0ID0gaW5kZXhfYWIgKyAxO1xyXG5cclxuICAgICAgICBmb3IgKGxldCB4ID0gbjsgeCA+IDA7IHgtLSkge1xyXG4gICAgICAgICAgICBsZXQgbGFzdDEgPSBsYXN0LCB4MSA9IHg7Ly8tNzAyPTI2OCwgM1xyXG5cclxuICAgICAgICAgICAgaWYgKHggPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGFzdDEgPSBsYXN0MSAlIHdvcmRsZW47XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3QxID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0MSA9IDI2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXQgKyBjb2x1bWVIZWFkZXJfd29yZFtsYXN0MSAtIDFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsYXN0MSA9IE1hdGguY2VpbChsYXN0MSAvIE1hdGgucG93KHdvcmRsZW4sIHggLSAxKSk7XHJcbiAgICAgICAgICAgIC8vbGFzdDEgPSBsYXN0MSAlIHdvcmRsZW47XHJcbiAgICAgICAgICAgIHJldCArPSBjb2x1bWVIZWFkZXJfd29yZFtsYXN0MSAtIDFdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0ID0gbGFzdCAtIChsYXN0MSAtIDEpICogd29yZGxlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqIFxyXG4gKiBAcmV0dXJuIHJhdGlvLCBkZWZhdWx0IDAuNzUgMWluID0gMi41NGNtID0gMjUuNG1tID0gNzJwdCA9IDZwYywgIHB0ID0gMS83MiBJbiwgcHggPSAxL2RwaSBJblxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0cHRUb1B4UmF0aW9CeURQSSgpOm51bWJlcntcclxuICAgIHJldHVybiA3Mi85NjtcclxufVxyXG5cclxuLyoqIFxyXG4gKiBAZW11cyBFTVVzLCBFeGNlbCBkcmF3aW5nIHVuaXRcclxuICogQHJldHVybiBwaXhlbFxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHhCeUVNVXMoZW11czpudW1iZXIpe1xyXG4gICAgaWYoZW11cz09bnVsbCl7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBsZXQgaW5jaCA9IGVtdXMvOTE0NDAwO1xyXG4gICAgbGV0IHB0ID0gaW5jaCo3MjtcclxuICAgIGxldCBweCA9IHB0IC8gZ2V0cHRUb1B4UmF0aW9CeURQSSgpO1xyXG4gICAgcmV0dXJuIHB4O1xyXG59XHJcblxyXG4vKiogXHJcbiAqIEBkb20geG1sIGF0dHJpYnV0ZSBvYmplY3RcclxuICogQGF0dHIgYXR0cmlidXRlIG5hbWVcclxuICogQGQgaWYgYXR0cmlidXRlIGlzIG51bGwsIHJldHVybiBkZWZhdWx0IHZhbHVlIFxyXG4gKiBAcmV0dXJuIGF0dHJpYnV0ZSB2YWx1ZVxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0WG1sQXR0aWJ1dGUoZG9tOklhdHRyaWJ1dGVMaXN0LCBhdHRyOnN0cmluZywgZDpzdHJpbmcpe1xyXG4gICAgbGV0IHZhbHVlID0gZG9tW2F0dHJdO1xyXG4gICAgdmFsdWUgPSB2YWx1ZT09bnVsbD9kOnZhbHVlO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG4vKiogXHJcbiAqIEBjb2x1bW5XaWR0aCBFeGNlbCBjb2x1bW4gd2lkdGhcclxuICogQHJldHVybiBwaXhlbCBjb2x1bW4gd2lkdGhcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbHVtbldpZHRoUGl4ZWwoY29sdW1uV2lkdGg6bnVtYmVyKXtcclxuICAgIGxldCBwaXggPSBNYXRoLnJvdW5kKChjb2x1bW5XaWR0aC0wLjgzKSAqIDggKyA1KTtcclxuICAgIHJldHVybiBwaXg7XHJcbn1cclxuXHJcbi8qKiBcclxuICogQHJvd0hlaWdodCBFeGNlbCByb3cgaGVpZ2h0XHJcbiAqIEByZXR1cm4gcGl4ZWwgcm93IGhlaWdodFxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um93SGVpZ2h0UGl4ZWwocm93SGVpZ2h0Om51bWJlcil7XHJcbiAgICBsZXQgcGl4ID0gTWF0aC5yb3VuZChyb3dIZWlnaHQvZ2V0cHRUb1B4UmF0aW9CeURQSSgpKTtcclxuICAgIHJldHVybiBwaXg7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBMaWdodGVuRGFya2VuQ29sb3Ioc2l4Q29sb3I6c3RyaW5nLCB0aW50Om51bWJlcil7XHJcbiAgICBsZXQgaGV4OnN0cmluZyA9IHNpeENvbG9yLnN1YnN0cmluZyhzaXhDb2xvci5sZW5ndGgtNixzaXhDb2xvci5sZW5ndGgpO1xyXG4gICAgbGV0IHJnYkFycmF5Om51bWJlcltdID0gaGV4VG9SZ2JBcnJheShcIiNcIitoZXgpO1xyXG4gICAgbGV0IGhzbEFycmF5ID0gcmdiVG9Ic2wocmdiQXJyYXlbMF0sIHJnYkFycmF5WzFdLHJnYkFycmF5WzJdKTtcclxuICAgIGlmKHRpbnQ+MCl7XHJcbiAgICAgICAgaHNsQXJyYXlbMl0gPSBoc2xBcnJheVsyXSAqICgxLjAtdGludCkgKyB0aW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZih0aW50PDApe1xyXG4gICAgICAgIGhzbEFycmF5WzJdID0gaHNsQXJyYXlbMl0gKiAoMS4wICsgdGludClcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgcmV0dXJuIFwiI1wiK2hleDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbmV3UmdiQXJyYXkgPSBoc2xUb1JnYihoc2xBcnJheVswXSxoc2xBcnJheVsxXSxoc2xBcnJheVsyXSk7XHJcblxyXG4gICAgcmV0dXJuIHJnYlRvSGV4KFwiUkdCKFwiICsgbmV3UmdiQXJyYXkuam9pbihcIixcIikgKyBcIilcIik7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiByZ2JUb0hleChyZ2I6c3RyaW5nKXtcclxuICAgIC8v5Y2B5YWt6L+b5Yi26aKc6Imy5YC855qE5q2j5YiZ6KGo6L6+5byPXHJcbiAgICB2YXIgcmVnID0gL14jKFswLTlhLWZBLWZdezN9fFswLTlhLWZBLWZdezZ9KSQvO1xyXG4gICAgLy8g5aaC5p6c5pivcmdi6aKc6Imy6KGo56S6XHJcbiAgICBpZiAoL14ocmdifFJHQikvLnRlc3QocmdiKSkge1xyXG4gICAgICAgIHZhciBhQ29sb3IgPSByZ2IucmVwbGFjZSgvKD86XFwofFxcKXxyZ2J8UkdCKSovZywgXCJcIikuc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgIHZhciBzdHJIZXggPSBcIiNcIjtcclxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8YUNvbG9yLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBoZXggPSBOdW1iZXIoYUNvbG9yW2ldKS50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoIDwgMikge1xyXG4gICAgICAgICAgICAgICAgaGV4ID0gJzAnICsgaGV4OyAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHJIZXggKz0gaGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RySGV4Lmxlbmd0aCAhPT0gNykge1xyXG4gICAgICAgICAgICBzdHJIZXggPSByZ2I7ICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RySGV4O1xyXG4gICAgfSBlbHNlIGlmIChyZWcudGVzdChyZ2IpKSB7XHJcbiAgICAgICAgdmFyIGFOdW0gPSByZ2IucmVwbGFjZSgvIy8sXCJcIikuc3BsaXQoXCJcIik7XHJcbiAgICAgICAgaWYgKGFOdW0ubGVuZ3RoID09PSA2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZ2I7ICAgIFxyXG4gICAgICAgIH0gZWxzZSBpZihhTnVtLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICB2YXIgbnVtSGV4ID0gXCIjXCI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxhTnVtLmxlbmd0aDsgaSs9MSkge1xyXG4gICAgICAgICAgICAgICAgbnVtSGV4ICs9IChhTnVtW2ldICsgYU51bVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bUhleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmdiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoZXhUb1JnYihoZXg6c3RyaW5nKXtcclxuICAgIHZhciBzQ29sb3IgPSBoZXgudG9Mb3dlckNhc2UoKTtcclxuICAgIC8v5Y2B5YWt6L+b5Yi26aKc6Imy5YC855qE5q2j5YiZ6KGo6L6+5byPXHJcbiAgICB2YXIgcmVnID0gL14jKFswLTlhLWZBLWZdezN9fFswLTlhLWZBLWZdezZ9KSQvO1xyXG4gICAgLy8g5aaC5p6c5pivMTbov5vliLbpopzoibJcclxuICAgIGlmIChzQ29sb3IgJiYgcmVnLnRlc3Qoc0NvbG9yKSkge1xyXG4gICAgICAgIGlmIChzQ29sb3IubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgICAgICAgIHZhciBzQ29sb3JOZXcgPSBcIiNcIjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0xOyBpPDQ7IGkrPTEpIHtcclxuICAgICAgICAgICAgICAgIHNDb2xvck5ldyArPSBzQ29sb3Iuc2xpY2UoaSwgaSsxKS5jb25jYXQoc0NvbG9yLnNsaWNlKGksIGkrMSkpOyAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzQ29sb3IgPSBzQ29sb3JOZXc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5aSE55CG5YWt5L2N55qE6aKc6Imy5YC8XHJcbiAgICAgICAgdmFyIHNDb2xvckNoYW5nZSA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGk9MTsgaTw3OyBpKz0yKSB7XHJcbiAgICAgICAgICAgIHNDb2xvckNoYW5nZS5wdXNoKHBhcnNlSW50KFwiMHhcIitzQ29sb3Iuc2xpY2UoaSwgaSsyKSkpOyAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwiUkdCKFwiICsgc0NvbG9yQ2hhbmdlLmpvaW4oXCIsXCIpICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc0NvbG9yO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoZXhUb1JnYkFycmF5KGhleDpzdHJpbmcpe1xyXG4gICAgdmFyIHNDb2xvciA9IGhleC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgLy/ljYHlha3ov5vliLbpopzoibLlgLznmoTmraPliJnooajovr7lvI9cclxuICAgIHZhciByZWcgPSAvXiMoWzAtOWEtZkEtZl17M318WzAtOWEtZkEtZl17Nn0pJC87XHJcbiAgICAvLyDlpoLmnpzmmK8xNui/m+WItuminOiJslxyXG4gICAgaWYgKHNDb2xvciAmJiByZWcudGVzdChzQ29sb3IpKSB7XHJcbiAgICAgICAgaWYgKHNDb2xvci5sZW5ndGggPT09IDQpIHtcclxuICAgICAgICAgICAgdmFyIHNDb2xvck5ldyA9IFwiI1wiO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTE7IGk8NDsgaSs9MSkge1xyXG4gICAgICAgICAgICAgICAgc0NvbG9yTmV3ICs9IHNDb2xvci5zbGljZShpLCBpKzEpLmNvbmNhdChzQ29sb3Iuc2xpY2UoaSwgaSsxKSk7ICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNDb2xvciA9IHNDb2xvck5ldztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/lpITnkIblha3kvY3nmoTpopzoibLlgLxcclxuICAgICAgICB2YXIgc0NvbG9yQ2hhbmdlOm51bWJlcltdID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaT0xOyBpPDc7IGkrPTIpIHtcclxuICAgICAgICAgICAgc0NvbG9yQ2hhbmdlLnB1c2gocGFyc2VJbnQoXCIweFwiK3NDb2xvci5zbGljZShpLCBpKzIpKSk7ICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gIHNDb2xvckNoYW5nZTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogSFNM6aKc6Imy5YC86L2s5o2i5Li6UkdCLiBcclxuICog5o2i566X5YWs5byP5pS557yW6IeqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2NvbG9yX3NwYWNlLlxyXG4gKiBoLCBzLCDlkowgbCDorr7lrprlnKggWzAsIDFdIOS5i+mXtFxyXG4gKiDov5Tlm57nmoQgciwgZywg5ZKMIGIg5ZyoIFswLCAyNTVd5LmL6Ze0XHJcbiAqXHJcbiAqIEBwYXJhbSAgIE51bWJlciAgaCAgICAgICDoibLnm7hcclxuICogQHBhcmFtICAgTnVtYmVyICBzICAgICAgIOmlseWSjOW6plxyXG4gKiBAcGFyYW0gICBOdW1iZXIgIGwgICAgICAg5Lqu5bqmXHJcbiAqIEByZXR1cm4gIEFycmF5ICAgICAgICAgICBSR0LoibLlgLzmlbDlgLxcclxuICovXHJcbmZ1bmN0aW9uIGhzbFRvUmdiKGg6bnVtYmVyLCBzOm51bWJlciwgbDpudW1iZXIpIHtcclxuICAgIHZhciByLCBnLCBiO1xyXG5cclxuICAgIGlmKHMgPT0gMCkge1xyXG4gICAgICAgIHIgPSBnID0gYiA9IGw7IC8vIGFjaHJvbWF0aWNcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGh1ZTJyZ2IgPSBmdW5jdGlvbiBodWUycmdiKHA6bnVtYmVyLCBxOm51bWJlciwgdDpudW1iZXIpIHtcclxuICAgICAgICAgICAgaWYodCA8IDApIHQgKz0gMTtcclxuICAgICAgICAgICAgaWYodCA+IDEpIHQgLT0gMTtcclxuICAgICAgICAgICAgaWYodCA8IDEvNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XHJcbiAgICAgICAgICAgIGlmKHQgPCAxLzIpIHJldHVybiBxO1xyXG4gICAgICAgICAgICBpZih0IDwgMi8zKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMi8zIC0gdCkgKiA2O1xyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcclxuICAgICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcclxuICAgICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMS8zKTtcclxuICAgICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcclxuICAgICAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMS8zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW01hdGgucm91bmQociAqIDI1NSksIE1hdGgucm91bmQoZyAqIDI1NSksIE1hdGgucm91bmQoYiAqIDI1NSldO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFJHQiDpopzoibLlgLzovazmjaLkuLogSFNMLlxyXG4gKiDovazmjaLlhazlvI/lj4LogIPoh6ogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfY29sb3Jfc3BhY2UuXHJcbiAqIHIsIGcsIOWSjCBiIOmcgOimgeWcqCBbMCwgMjU1XSDojIPlm7TlhoVcclxuICog6L+U5Zue55qEIGgsIHMsIOWSjCBsIOWcqCBbMCwgMV0g5LmL6Ze0XHJcbiAqXHJcbiAqIEBwYXJhbSAgIE51bWJlciAgciAgICAgICDnuqLoibLoibLlgLxcclxuICogQHBhcmFtICAgTnVtYmVyICBnICAgICAgIOe7v+iJsuiJsuWAvFxyXG4gKiBAcGFyYW0gICBOdW1iZXIgIGIgICAgICAg6JOd6Imy6Imy5YC8XHJcbiAqIEByZXR1cm4gIEFycmF5ICAgICAgICAgICBIU0zlkITlgLzmlbDnu4RcclxuICovXHJcbmZ1bmN0aW9uIHJnYlRvSHNsKHI6bnVtYmVyLCBnOm51bWJlciwgYjpudW1iZXIpIHtcclxuICAgIHIgLz0gMjU1LCBnIC89IDI1NSwgYiAvPSAyNTU7XHJcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG4gICAgdmFyIGgsIHMsIGwgPSAobWF4ICsgbWluKSAvIDI7XHJcblxyXG4gICAgaWYgKG1heCA9PSBtaW4peyBcclxuICAgICAgICBoID0gcyA9IDA7IC8vIGFjaHJvbWF0aWNcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XHJcbiAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xyXG4gICAgICAgIHN3aXRjaChtYXgpIHtcclxuICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGI6IGggPSAociAtIGcpIC8gZCArIDQ7IGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoIC89IDY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtoLCBzLCBsXTtcclxufVxyXG4gXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUluZGV4KHByZWZpeDpzdHJpbmcpOnN0cmluZyB7XHJcbiAgICBpZihwcmVmaXggPT0gbnVsbCl7XHJcbiAgICAgICAgcHJlZml4ID0gXCJTaGVldFwiO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgXCJcIikuc3BsaXQoXCJcIik7XHJcblxyXG4gICAgbGV0IG1pZCA9IFwiXCI7XHJcblxyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IDU7IGkrKyl7XHJcbiAgICAgICAgbWlkICs9IHVzZXJBZ2VudFtNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAodXNlckFnZW50Lmxlbmd0aCAtIDEpKV07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHJcbiAgICByZXR1cm4gcHJlZml4ICsgXCJfXCIgKyBtaWQgKyBcIl9cIiArIHRpbWU7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlQ2hhcmFjdGVyKHN0cjpzdHJpbmcpe1xyXG4gICAgaWYoc3RyPT1udWxsIHx8IHN0ci5sZW5ndGg9PTApe1xyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mYW1wOy9nLCBcIiZcIikucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpLnJlcGxhY2UoLyZsdDsvZywgJzwnKS5yZXBsYWNlKC8mZ3Q7L2csICc+JykucmVwbGFjZSgvJm5ic3A7L2csICcgJykucmVwbGFjZSgvJmFwb3M7L2csIFwiJ1wiKS5yZXBsYWNlKC8maWV4Y2w7L2csIFwiwqFcIikucmVwbGFjZSgvJmNlbnQ7L2csIFwiwqJcIikucmVwbGFjZSgvJnBvdW5kOy9nLCBcIsKjXCIpLnJlcGxhY2UoLyZjdXJyZW47L2csIFwiwqRcIikucmVwbGFjZSgvJnllbjsvZywgXCLCpVwiKS5yZXBsYWNlKC8mYnJ2YmFyOy9nLCBcIsKmXCIpLnJlcGxhY2UoLyZzZWN0Oy9nLCBcIsKnXCIpLnJlcGxhY2UoLyZ1bWw7L2csIFwiwqhcIikucmVwbGFjZSgvJmNvcHk7L2csIFwiwqlcIikucmVwbGFjZSgvJm9yZGY7L2csIFwiwqpcIikucmVwbGFjZSgvJmxhcXVvOy9nLCBcIsKrXCIpLnJlcGxhY2UoLyZub3Q7L2csIFwiwqxcIikucmVwbGFjZSgvJnNoeTsvZywgXCLCrVwiKS5yZXBsYWNlKC8mcmVnOy9nLCBcIsKuXCIpLnJlcGxhY2UoLyZtYWNyOy9nLCBcIsKvXCIpLnJlcGxhY2UoLyZkZWc7L2csIFwiwrBcIikucmVwbGFjZSgvJnBsdXNtbjsvZywgXCLCsVwiKS5yZXBsYWNlKC8mc3VwMjsvZywgXCLCslwiKS5yZXBsYWNlKC8mc3VwMzsvZywgXCLCs1wiKS5yZXBsYWNlKC8mYWN1dGU7L2csIFwiwrRcIikucmVwbGFjZSgvJm1pY3JvOy9nLCBcIsK1XCIpLnJlcGxhY2UoLyZwYXJhOy9nLCBcIsK2XCIpLnJlcGxhY2UoLyZtaWRkb3Q7L2csIFwiwrdcIikucmVwbGFjZSgvJmNlZGlsOy9nLCBcIsK4XCIpLnJlcGxhY2UoLyZzdXAxOy9nLCBcIsK5XCIpLnJlcGxhY2UoLyZvcmRtOy9nLCBcIsK6XCIpLnJlcGxhY2UoLyZyYXF1bzsvZywgXCLCu1wiKS5yZXBsYWNlKC8mZnJhYzE0Oy9nLCBcIsK8XCIpLnJlcGxhY2UoLyZmcmFjMTI7L2csIFwiwr1cIikucmVwbGFjZSgvJmZyYWMzNDsvZywgXCLCvlwiKS5yZXBsYWNlKC8maXF1ZXN0Oy9nLCBcIsK/XCIpLnJlcGxhY2UoLyZ0aW1lczsvZywgXCLDl1wiKS5yZXBsYWNlKC8mZGl2aWRlOy9nLCBcIsO3XCIpLnJlcGxhY2UoLyZBZ3JhdmU7L2csIFwiw4BcIikucmVwbGFjZSgvJkFhY3V0ZTsvZywgXCLDgVwiKS5yZXBsYWNlKC8mQWNpcmM7L2csIFwiw4JcIikucmVwbGFjZSgvJkF0aWxkZTsvZywgXCLDg1wiKS5yZXBsYWNlKC8mQXVtbDsvZywgXCLDhFwiKS5yZXBsYWNlKC8mQXJpbmc7L2csIFwiw4VcIikucmVwbGFjZSgvJkFFbGlnOy9nLCBcIsOGXCIpLnJlcGxhY2UoLyZDY2VkaWw7L2csIFwiw4dcIikucmVwbGFjZSgvJkVncmF2ZTsvZywgXCLDiFwiKS5yZXBsYWNlKC8mRWFjdXRlOy9nLCBcIsOJXCIpLnJlcGxhY2UoLyZFY2lyYzsvZywgXCLDilwiKS5yZXBsYWNlKC8mRXVtbDsvZywgXCLDi1wiKS5yZXBsYWNlKC8mSWdyYXZlOy9nLCBcIsOMXCIpLnJlcGxhY2UoLyZJYWN1dGU7L2csIFwiw41cIikucmVwbGFjZSgvJkljaXJjOy9nLCBcIsOOXCIpLnJlcGxhY2UoLyZJdW1sOy9nLCBcIsOPXCIpLnJlcGxhY2UoLyZFVEg7L2csIFwiw5BcIikucmVwbGFjZSgvJk50aWxkZTsvZywgXCLDkVwiKS5yZXBsYWNlKC8mT2dyYXZlOy9nLCBcIsOSXCIpLnJlcGxhY2UoLyZPYWN1dGU7L2csIFwiw5NcIikucmVwbGFjZSgvJk9jaXJjOy9nLCBcIsOUXCIpLnJlcGxhY2UoLyZPdGlsZGU7L2csIFwiw5VcIikucmVwbGFjZSgvJk91bWw7L2csIFwiw5ZcIikucmVwbGFjZSgvJk9zbGFzaDsvZywgXCLDmFwiKS5yZXBsYWNlKC8mVWdyYXZlOy9nLCBcIsOZXCIpLnJlcGxhY2UoLyZVYWN1dGU7L2csIFwiw5pcIikucmVwbGFjZSgvJlVjaXJjOy9nLCBcIsObXCIpLnJlcGxhY2UoLyZVdW1sOy9nLCBcIsOcXCIpLnJlcGxhY2UoLyZZYWN1dGU7L2csIFwiw51cIikucmVwbGFjZSgvJlRIT1JOOy9nLCBcIsOeXCIpLnJlcGxhY2UoLyZzemxpZzsvZywgXCLDn1wiKS5yZXBsYWNlKC8mYWdyYXZlOy9nLCBcIsOgXCIpLnJlcGxhY2UoLyZhYWN1dGU7L2csIFwiw6FcIikucmVwbGFjZSgvJmFjaXJjOy9nLCBcIsOiXCIpLnJlcGxhY2UoLyZhdGlsZGU7L2csIFwiw6NcIikucmVwbGFjZSgvJmF1bWw7L2csIFwiw6RcIikucmVwbGFjZSgvJmFyaW5nOy9nLCBcIsOlXCIpLnJlcGxhY2UoLyZhZWxpZzsvZywgXCLDplwiKS5yZXBsYWNlKC8mY2NlZGlsOy9nLCBcIsOnXCIpLnJlcGxhY2UoLyZlZ3JhdmU7L2csIFwiw6hcIikucmVwbGFjZSgvJmVhY3V0ZTsvZywgXCLDqVwiKS5yZXBsYWNlKC8mZWNpcmM7L2csIFwiw6pcIikucmVwbGFjZSgvJmV1bWw7L2csIFwiw6tcIikucmVwbGFjZSgvJmlncmF2ZTsvZywgXCLDrFwiKS5yZXBsYWNlKC8maWFjdXRlOy9nLCBcIsOtXCIpLnJlcGxhY2UoLyZpY2lyYzsvZywgXCLDrlwiKS5yZXBsYWNlKC8maXVtbDsvZywgXCLDr1wiKS5yZXBsYWNlKC8mZXRoOy9nLCBcIsOwXCIpLnJlcGxhY2UoLyZudGlsZGU7L2csIFwiw7FcIikucmVwbGFjZSgvJm9ncmF2ZTsvZywgXCLDslwiKS5yZXBsYWNlKC8mb2FjdXRlOy9nLCBcIsOzXCIpLnJlcGxhY2UoLyZvY2lyYzsvZywgXCLDtFwiKS5yZXBsYWNlKC8mb3RpbGRlOy9nLCBcIsO1XCIpLnJlcGxhY2UoLyZvdW1sOy9nLCBcIsO2XCIpLnJlcGxhY2UoLyZvc2xhc2g7L2csIFwiw7hcIikucmVwbGFjZSgvJnVncmF2ZTsvZywgXCLDuVwiKS5yZXBsYWNlKC8mdWFjdXRlOy9nLCBcIsO6XCIpLnJlcGxhY2UoLyZ1Y2lyYzsvZywgXCLDu1wiKS5yZXBsYWNlKC8mdXVtbDsvZywgXCLDvFwiKS5yZXBsYWNlKC8meWFjdXRlOy9nLCBcIsO9XCIpLnJlcGxhY2UoLyZ0aG9ybjsvZywgXCLDvlwiKS5yZXBsYWNlKC8meXVtbDsvZywgXCLDv1wiKTtcclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgZnJvbXVsYVJlZiB7XHJcblxyXG4gICAgc3RhdGljIG9wZXJhdG9yID0gJz09fCE9fDw+fDw9fD49fD18K3wtfD58PHwvfCp8JXwmfF4nXHJcbiAgICBzdGF0aWMgZXJyb3IgPSB7XHJcbiAgICAgICAgdjogXCIjVkFMVUUhXCIsICAgIC8v6ZSZ6K+v55qE5Y+C5pWw5oiW6L+Q566X56ymXHJcbiAgICAgICAgbjogXCIjTkFNRT9cIiwgICAgIC8v5YWs5byP5ZCN56ew6ZSZ6K+vXHJcbiAgICAgICAgbmE6IFwiI04vQVwiLCAgICAgIC8v5Ye95pWw5oiW5YWs5byP5Lit5rKh5pyJ5Y+v55So5pWw5YC8XHJcbiAgICAgICAgcjogXCIjUkVGIVwiLCAgICAgIC8v5Yig6Zmk5LqG55Sx5YW25LuW5YWs5byP5byV55So55qE5Y2V5YWD5qC8XHJcbiAgICAgICAgZDogXCIjRElWLzAhXCIsICAgIC8v6Zmk5pWw5pivMOaIluepuuWNleWFg+agvFxyXG4gICAgICAgIG5tOiBcIiNOVU0hXCIsICAgICAvL+W9k+WFrOW8j+aIluWHveaVsOS4reafkOS4quaVsOWtl+aciemXrumimOaXtlxyXG4gICAgICAgIG5sOiBcIiNOVUxMIVwiLCAgICAvL+S6pOWPiei/kOeul+espu+8iOepuuagvO+8ieS9v+eUqOS4jeato+ehrlxyXG4gICAgICAgIHNwOiBcIiNTUElMTCFcIiAgICAvL+aVsOe7hOiMg+WbtOacieWFtuWug+WAvFxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBvcGVyYXRvcmpzb246c3RyaW5nVG9OdW0gPSBudWxsXHJcblxyXG4gICAgc3RhdGljIHRyaW0oc3RyOnN0cmluZykgeyAgXHJcbiAgICAgICAgaWYoc3RyID09IG51bGwpeyAgXHJcbiAgICAgICAgICAgIHN0ciA9IFwiXCI7ICBcclxuICAgICAgICB9ICBcclxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyheXFxzKil8KFxccyokKS9nLCBcIlwiKTsgIFxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBmdW5jdGlvbkNvcHkodHh0OnN0cmluZywgbW9kZTpzdHJpbmcsIHN0ZXA6bnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKF90aGlzLm9wZXJhdG9yanNvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCBhcnIgPSBfdGhpcy5vcGVyYXRvci5zcGxpdChcInxcIiksXHJcbiAgICAgICAgICAgICAgICBvcDpzdHJpbmdUb051bSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG9wW2FycltpXS50b1N0cmluZygpXSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF90aGlzLm9wZXJhdG9yanNvbiA9IG9wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtb2RlID0gXCJkb3duXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3RlcCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0ZXAgPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR4dC5zdWJzdHIoMCwgMSkgPT0gXCI9XCIpIHtcclxuICAgICAgICAgICAgdHh0ID0gdHh0LnN1YnN0cigxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBmdW5jc3RhY2sgPSB0eHQuc3BsaXQoXCJcIik7XHJcbiAgICAgICAgbGV0IGkgPSAwLFxyXG4gICAgICAgICAgICBzdHIgPSBcIlwiLFxyXG4gICAgICAgICAgICBmdW5jdGlvbl9zdHIgPSBcIlwiLFxyXG4gICAgICAgICAgICBpc3Bhc3NieSA9IHRydWU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IG1hdGNoQ29uZmlnID0ge1xyXG4gICAgICAgICAgICBcImJyYWNrZXRcIjogMCxcclxuICAgICAgICAgICAgXCJjb21tYVwiOiAwLFxyXG4gICAgICAgICAgICBcInNxdW90ZVwiOiAwLFxyXG4gICAgICAgICAgICBcImRxdW90ZVwiOiAwXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGkgPCBmdW5jc3RhY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCBzID0gZnVuY3N0YWNrW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHMgPT0gXCIoXCIgJiYgbWF0Y2hDb25maWcuZHF1b3RlID09IDApIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoQ29uZmlnLmJyYWNrZXQgKz0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gc3RyICsgXCIoXCI7XHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IFwiKFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gXCIpXCIgJiYgbWF0Y2hDb25maWcuZHF1b3RlID09IDApIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoQ29uZmlnLmJyYWNrZXQgLT0gMTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBfdGhpcy5mdW5jdGlvbkNvcHkoc3RyLCBtb2RlLCBzdGVwKSArIFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgc3RyID0gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzID09ICdcIicgJiYgbWF0Y2hDb25maWcuc3F1b3RlID09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaENvbmZpZy5kcXVvdGUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IHN0ciArICdcIic7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hDb25maWcuZHF1b3RlIC09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaENvbmZpZy5kcXVvdGUgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1wiJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAnLCcgJiYgbWF0Y2hDb25maWcuZHF1b3RlID09IDApIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBfdGhpcy5mdW5jdGlvbkNvcHkoc3RyLCBtb2RlLCBzdGVwKSArICcsJztcclxuICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gJyYnICYmIG1hdGNoQ29uZmlnLmRxdW90ZSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMuZnVuY3Rpb25Db3B5KHN0ciwgbW9kZSwgc3RlcCkgKyBcIiZcIjtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBcIiZcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAocyBpbiBfdGhpcy5vcGVyYXRvcmpzb24gJiYgbWF0Y2hDb25maWcuZHF1b3RlID09IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCBzX25leHQgPSBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgoaSArIDEpIDwgZnVuY3N0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNfbmV4dCA9IGZ1bmNzdGFja1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHAgPSBpIC0gMSwgXHJcbiAgICAgICAgICAgICAgICAgICAgc19wcmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHAgPj0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzX3ByZSA9IGZ1bmNzdGFja1twLS1dO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocD49MCAmJiBzX3ByZSA9PVwiIFwiKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICgocyArIHNfbmV4dCkgaW4gX3RoaXMub3BlcmF0b3Jqc29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBfdGhpcy5mdW5jdGlvbkNvcHkoc3RyLCBtb2RlLCBzdGVwKSArIHMgKyBzX25leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IHMgKyBzX25leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKCEoL1teMC05XS8udGVzdChzX25leHQpKSAmJiBzPT1cIi1cIiAmJiAoc19wcmU9PVwiKFwiIHx8IHNfcHJlID09IG51bGwgfHwgc19wcmUgPT0gXCIsXCIgfHwgc19wcmUgPT0gXCIgXCIgfHwgc19wcmUgaW4gX3RoaXMub3BlcmF0b3Jqc29uICkgKXtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMuZnVuY3Rpb25Db3B5KHN0ciwgbW9kZSwgc3RlcCkgKyBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGkgPT0gZnVuY3N0YWNrLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc2NlbGxkYXRhKF90aGlzLnRyaW0oc3RyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSBcImRvd25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMuZG93bnBhcmFtKF90aGlzLnRyaW0oc3RyKSwgc3RlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09IFwidXBcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMudXBwYXJhbShfdGhpcy50cmltKHN0ciksIHN0ZXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PSBcImxlZnRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMubGVmdHBhcmFtKF90aGlzLnRyaW0oc3RyKSwgc3RlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09IFwicmlnaHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMucmlnaHRwYXJhbShfdGhpcy50cmltKHN0ciksIHN0ZXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMudHJpbShzdHIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb25fc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBzdGF0aWMgZG93bnBhcmFtKHR4dDpzdHJpbmcsIHN0ZXA6bnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlcGFyYW0oXCJkXCIsIHR4dCwgc3RlcCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHVwcGFyYW0odHh0OnN0cmluZywgc3RlcDpudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVwYXJhbShcInVcIiwgdHh0LCBzdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgbGVmdHBhcmFtKHR4dDpzdHJpbmcsIHN0ZXA6bnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlcGFyYW0oXCJsXCIsIHR4dCwgc3RlcCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHJpZ2h0cGFyYW0gKHR4dDpzdHJpbmcsIHN0ZXA6bnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlcGFyYW0oXCJyXCIsIHR4dCwgc3RlcCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHN0YXRpYyB1cGRhdGVwYXJhbSAob3JpZW50OnN0cmluZywgdHh0OnN0cmluZywgc3RlcDpudW1iZXIpIHtcclxuICAgICAgICBsZXQgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGxldCB2YWwgPSB0eHQuc3BsaXQoXCIhXCIpLFxyXG4gICAgICAgICAgICByYW5nZXR4dCwgcHJlZml4ID0gXCJcIjtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodmFsLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmFuZ2V0eHQgPSB2YWxbMV07XHJcbiAgICAgICAgICAgIHByZWZpeCA9IHZhbFswXSArIFwiIVwiO1xyXG4gICAgICAgIH0gXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJhbmdldHh0ID0gdmFsWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJhbmdldHh0LmluZGV4T2YoXCI6XCIpID09IC0xKSB7XHJcbiAgICAgICAgICAgIGxldCByb3cgPSBwYXJzZUludChyYW5nZXR4dC5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikpO1xyXG4gICAgICAgICAgICBsZXQgY29sID0gQUJDYXROdW0ocmFuZ2V0eHQucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcclxuICAgICAgICAgICAgbGV0IGZyZWV6b25GdWMgPSBfdGhpcy5pc2ZyZWV6b25GdWMocmFuZ2V0eHQpO1xyXG4gICAgICAgICAgICBsZXQgJHJvdyA9IGZyZWV6b25GdWNbMF0gPyBcIiRcIiA6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAkY29sID0gZnJlZXpvbkZ1Y1sxXSA/IFwiJFwiIDogXCJcIjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChvcmllbnQgPT0gXCJ1XCIgJiYgIWZyZWV6b25GdWNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHJvdyAtPSBzdGVwO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcmllbnQgPT0gXCJyXCIgJiYgIWZyZWV6b25GdWNbMV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbCArPSBzdGVwO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcmllbnQgPT0gXCJsXCIgJiYgIWZyZWV6b25GdWNbMV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbCAtPSBzdGVwO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmICghZnJlZXpvbkZ1Y1swXSkge1xyXG4gICAgICAgICAgICAgICAgcm93ICs9IHN0ZXA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHJvdyA8IDAgfHwgY29sIDwgMCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXJyb3IucjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCFpc05hTihyb3cpICYmICFpc05hTihjb2wpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJGNvbCArIGNoYXRhdEFCQyhjb2wpICsgJHJvdyArIChyb3cpO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNOYU4ocm93KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICRyb3cgKyAocm93KTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTmFOKGNvbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAkY29sICsgY2hhdGF0QUJDKGNvbCk7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJhbmdldHh0ID0gcmFuZ2V0eHQuc3BsaXQoXCI6XCIpO1xyXG4gICAgICAgICAgICBsZXQgcm93ID0gW10sXHJcbiAgICAgICAgICAgICAgICBjb2wgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHJvd1swXSA9IHBhcnNlSW50KHJhbmdldHh0WzBdLnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSk7XHJcbiAgICAgICAgICAgIHJvd1sxXSA9IHBhcnNlSW50KHJhbmdldHh0WzFdLnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSk7XHJcbiAgICAgICAgICAgIGlmIChyb3dbMF0gPiByb3dbMV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbFswXSA9IEFCQ2F0TnVtKHJhbmdldHh0WzBdLnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKSk7XHJcbiAgICAgICAgICAgIGNvbFsxXSA9IEFCQ2F0TnVtKHJhbmdldHh0WzFdLnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKSk7XHJcbiAgICAgICAgICAgIGlmIChjb2xbMF0gPiBjb2xbMV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBmcmVlem9uRnVjMCA9IF90aGlzLmlzZnJlZXpvbkZ1YyhyYW5nZXR4dFswXSk7XHJcbiAgICAgICAgICAgIGxldCBmcmVlem9uRnVjMSA9IF90aGlzLmlzZnJlZXpvbkZ1YyhyYW5nZXR4dFsxXSk7XHJcbiAgICAgICAgICAgIGxldCAkcm93MCA9IGZyZWV6b25GdWMwWzBdID8gXCIkXCIgOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgJGNvbDAgPSBmcmVlem9uRnVjMFsxXSA/IFwiJFwiIDogXCJcIjtcclxuICAgICAgICAgICAgbGV0ICRyb3cxID0gZnJlZXpvbkZ1YzFbMF0gPyBcIiRcIiA6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAkY29sMSA9IGZyZWV6b25GdWMxWzFdID8gXCIkXCIgOiBcIlwiO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKG9yaWVudCA9PSBcInVcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmcmVlem9uRnVjMFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd1swXSAtPSBzdGVwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZnJlZXpvbkZ1YzFbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICByb3dbMV0gLT0gc3RlcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50ID09IFwiclwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZyZWV6b25GdWMwWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sWzBdICs9IHN0ZXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFmcmVlem9uRnVjMVsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbFsxXSArPSBzdGVwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcmllbnQgPT0gXCJsXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZnJlZXpvbkZ1YzBbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xbMF0gLT0gc3RlcDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWZyZWV6b25GdWMxWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sWzFdIC09IHN0ZXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmcmVlem9uRnVjMFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd1swXSArPSBzdGVwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZnJlZXpvbkZ1YzFbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICByb3dbMV0gKz0gc3RlcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYocm93WzBdIDwgMCB8fCBjb2xbMF0gPCAwKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5lcnJvci5yO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29sWzBdKSAmJiBpc05hTihjb2xbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJHJvdzAgKyAocm93WzBdKSArIFwiOlwiICsgJHJvdzEgKyAocm93WzFdKTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4ocm93WzBdKSAmJiBpc05hTihyb3dbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJGNvbDAgKyBjaGF0YXRBQkMoY29sWzBdKSArIFwiOlwiICsgJGNvbDEgKyBjaGF0YXRBQkMoY29sWzFdKTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJGNvbDAgKyBjaGF0YXRBQkMoY29sWzBdKSArICRyb3cwICsgKHJvd1swXSkgKyBcIjpcIiArICRjb2wxICsgY2hhdGF0QUJDKGNvbFsxXSkgKyAkcm93MSArIChyb3dbMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBzdGF0aWMgaXNjZWxsZGF0YSh0eHQ6c3RyaW5nKSB7IC8v5Yik5pat5piv5ZCm5Li65Y2V5YWD5qC85qC85byPXHJcbiAgICAgICAgbGV0IHZhbCA9IHR4dC5zcGxpdChcIiFcIiksXHJcbiAgICAgICAgICAgIHJhbmdldHh0O1xyXG5cclxuICAgICAgICBpZiAodmFsLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmFuZ2V0eHQgPSB2YWxbMV07XHJcbiAgICAgICAgfSBcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmFuZ2V0eHQgPSB2YWxbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcmVnX2NlbGwgPSAvXigoW2EtekEtWl0rKXwoWyRdW2EtekEtWl0rKSkoKFswLTldKyl8KFskXVswLTldKykpJC9nOyAvL+WinuWKoOato+WImeWIpOaWreWNleWFg+agvOS4uuWtl+avjSvmlbDlrZfnmoTmoLzlvI/vvJrlpoIgQTE6QjNcclxuICAgICAgICBsZXQgcmVnX2NlbGxSYW5nZSA9IC9eKCgoKFthLXpBLVpdKyl8KFskXVthLXpBLVpdKykpKChbMC05XSspfChbJF1bMC05XSspKSl8KCgoW2EtekEtWl0rKXwoWyRdW2EtekEtWl0rKSkpKSQvZzsgLy/lop7liqDmraPliJnliKTmlq3ljZXlhYPmoLzkuLrlrZfmr40r5pWw5a2X5oiW5a2X5q+N55qE5qC85byP77ya5aaCIEExOkIz77yMQTpBXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHJhbmdldHh0LmluZGV4T2YoXCI6XCIpID09IC0xKSB7XHJcbiAgICAgICAgICAgIGxldCByb3cgPSBwYXJzZUludChyYW5nZXR4dC5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikpIC0gMTtcclxuICAgICAgICAgICAgbGV0IGNvbCA9IEFCQ2F0TnVtKHJhbmdldHh0LnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHJvdykgJiYgIWlzTmFOKGNvbCkgJiYgcmFuZ2V0eHQudG9TdHJpbmcoKS5tYXRjaChyZWdfY2VsbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNOYU4ocm93KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNOYU4oY29sKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlZ19jZWxsUmFuZ2UgPSAvXigoKChbYS16QS1aXSspfChbJF1bYS16QS1aXSspKSgoWzAtOV0rKXwoWyRdWzAtOV0rKSkpfCgoKFthLXpBLVpdKyl8KFskXVthLXpBLVpdKykpKXwoKChbMC05XSspfChbJF1bMC05XStzKSkpKSQvZztcclxuXHJcbiAgICAgICAgICAgIHJhbmdldHh0ID0gcmFuZ2V0eHQuc3BsaXQoXCI6XCIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHJvdyA9IFtdLGNvbCA9IFtdO1xyXG4gICAgICAgICAgICByb3dbMF0gPSBwYXJzZUludChyYW5nZXR4dFswXS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikpIC0gMTtcclxuICAgICAgICAgICAgcm93WzFdID0gcGFyc2VJbnQocmFuZ2V0eHRbMV0ucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKSAtIDE7XHJcbiAgICAgICAgICAgIGlmIChyb3dbMF0gPiByb3dbMV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29sWzBdID0gQUJDYXROdW0ocmFuZ2V0eHRbMF0ucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcclxuICAgICAgICAgICAgY29sWzFdID0gQUJDYXROdW0ocmFuZ2V0eHRbMV0ucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcclxuICAgICAgICAgICAgaWYgKGNvbFswXSA+IGNvbFsxXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihyYW5nZXR4dFswXS50b1N0cmluZygpLm1hdGNoKHJlZ19jZWxsUmFuZ2UpICYmIHJhbmdldHh0WzFdLnRvU3RyaW5nKCkubWF0Y2gocmVnX2NlbGxSYW5nZSkpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgaXNmcmVlem9uRnVjKHR4dDpzdHJpbmcpIHtcclxuICAgICAgICBsZXQgcm93ID0gdHh0LnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKTtcclxuICAgICAgICBsZXQgY29sID0gdHh0LnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKTtcclxuICAgICAgICBsZXQgcm93JCA9IHR4dC5zdWJzdHIodHh0LmluZGV4T2Yocm93KSAtIDEsIDEpO1xyXG4gICAgICAgIGxldCBjb2wkID0gdHh0LnN1YnN0cih0eHQuaW5kZXhPZihjb2wpIC0gMSwgMSk7XHJcbiAgICAgICAgbGV0IHJldCA9IFtmYWxzZSwgZmFsc2VdO1xyXG5cclxuICAgICAgICBpZiAocm93JCA9PSBcIiRcIikge1xyXG4gICAgICAgICAgICByZXRbMF0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29sJCA9PSBcIiRcIikge1xyXG4gICAgICAgICAgICByZXRbMV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2hpbmVzZSh0ZW1wOnN0cmluZyk6Ym9vbGVhblxyXG57IFxyXG4gICAgdmFyIHJlID0gL1teXFx1NGUwMC1cXHU5ZmE1XS87IFxyXG4gICAgdmFyIHJlZyA9IC9bXFx1MzAwMnxcXHVmZjFmfFxcdWZmMDF8XFx1ZmYwY3xcXHUzMDAxfFxcdWZmMWJ8XFx1ZmYxYXxcXHUyMDFjfFxcdTIwMWR8XFx1MjAxOHxcXHUyMDE5fFxcdWZmMDh8XFx1ZmYwOXxcXHUzMDBhfFxcdTMwMGJ8XFx1MzAwOHxcXHUzMDA5fFxcdTMwMTB8XFx1MzAxMXxcXHUzMDBlfFxcdTMwMGZ8XFx1MzAwY3xcXHUzMDBkfFxcdWZlNDN8XFx1ZmU0NHxcXHUzMDE0fFxcdTMwMTV8XFx1MjAyNnxcXHUyMDE0fFxcdWZmNWV8XFx1ZmU0ZnxcXHVmZmU1XS87XHJcbiAgICBpZihyZWcudGVzdCh0ZW1wKSkgcmV0dXJuIHRydWU7IFxyXG4gICAgaWYocmUudGVzdCh0ZW1wKSkgcmV0dXJuIGZhbHNlOyBcclxuXHRyZXR1cm4gdHJ1ZTsgXHJcbn1cclxuIFxyXG5leHBvcnQgZnVuY3Rpb24gaXNKYXBhbmVzZSh0ZW1wOnN0cmluZyk6Ym9vbGVhblxyXG57IFxyXG5cdHZhciByZSA9IC9bXlxcdTA4MDAtXFx1NGUwMF0vOyBcclxuXHRpZihyZS50ZXN0KHRlbXApKSByZXR1cm4gZmFsc2U7IFxyXG5cdHJldHVybiB0cnVlOyBcclxufVxyXG4gXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0tvZXJhKGNocjphbnkpOmJvb2xlYW4ge1xyXG5cdFxyXG5cdGlmKCgoY2hyID4gMHgzMTMwICYmIGNociA8IDB4MzE4RikgfHwgXHJcblx0ICAgIChjaHIgPj0gMHhBQzAwICYmIGNociA8PSAweEQ3QTMpKSkgXHJcblx0e1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29udGFpbk11bHRpVHlwZShzdHI6c3RyaW5nKTpib29sZWFuIHtcclxuXHRcclxuICAgIGxldCBpc1VuaWNvZGUgPSBmYWxzZTtcclxuICAgIGlmKGVzY2FwZShzdHIpLmluZGV4T2YoXCIldVwiKT4tMSl7XHJcbiAgICAgICAgaXNVbmljb2RlID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaXNOb3QgPSBmYWxzZTtcclxuICAgIGxldCByZWcgPSAvWzAtOWEtel0vZ2k7IFxyXG4gICAgaWYocmVnLnRlc3Qoc3RyKSl7XHJcbiAgICAgICAgaXNOb3QgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCByZUVuU2lnbiA9IC9bXFx4MDAtXFx4ZmZdKy9nO1xyXG4gICAgaWYocmVFblNpZ24udGVzdChzdHIpKXtcclxuICAgICAgICBpc05vdCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoaXNVbmljb2RlICYmIGlzTm90KXtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcblxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJpbmFyeUNvbnRlbnQgKHBhdGg6YW55LCBvcHRpb25zOmFueSkge1xyXG4gICAgbGV0IHByb21pc2UsIHJlc29sdmU6YW55LCByZWplY3Q6YW55O1xyXG4gICAgbGV0IGNhbGxiYWNrOmFueTtcclxuXHJcbiAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGFrZW4gZnJvbSBqUXVlcnlcclxuICAgIGxldCBjcmVhdGVTdGFuZGFyZFhIUiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIH0gY2F0Y2goIGUgKSB7fVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBjcmVhdGVBY3RpdmVYSFIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xyXG4gICAgICAgIH0gY2F0Y2goIGUgKSB7fVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgcmVxdWVzdCBvYmplY3RcclxuICAgIHZhciBjcmVhdGVYSFIgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuQWN0aXZlWE9iamVjdCkgP1xyXG4gICAgICAgIC8qIE1pY3Jvc29mdCBmYWlsZWQgdG8gcHJvcGVybHlcclxuICAgICAgICAqIGltcGxlbWVudCB0aGUgWE1MSHR0cFJlcXVlc3QgaW4gSUU3IChjYW4ndCByZXF1ZXN0IGxvY2FsIGZpbGVzKSxcclxuICAgICAgICAqIHNvIHdlIHVzZSB0aGUgQWN0aXZlWE9iamVjdCB3aGVuIGl0IGlzIGF2YWlsYWJsZVxyXG4gICAgICAgICogQWRkaXRpb25hbGx5IFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBpbiBJRTcvSUU4IHNvXHJcbiAgICAgICAgKiB3ZSBuZWVkIGEgZmFsbGJhY2suXHJcbiAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlU3RhbmRhcmRYSFIoKSB8fCBjcmVhdGVBY3RpdmVYSFIoKTtcclxuICAgIH0gOlxyXG4gICAgICAgIC8vIEZvciBhbGwgb3RoZXIgYnJvd3NlcnMsIHVzZSB0aGUgc3RhbmRhcmQgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0XHJcbiAgICAgICAgY3JlYXRlU3RhbmRhcmRYSFI7XHJcblxyXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJsZSBjYWxsYmFja1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XHJcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIGNhbGxiYWNrIGluc2lkZSBvcHRpb25zIG9iamVjdFxyXG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcclxuICAgIH1cclxuXHJcbiAgICByZXNvbHZlID0gZnVuY3Rpb24gKGRhdGE6YW55KSB7IGNhbGxiYWNrKG51bGwsIGRhdGEpOyB9O1xyXG4gICAgcmVqZWN0ID0gZnVuY3Rpb24gKGVycjphbnkpIHsgY2FsbGJhY2soZXJyLCBudWxsKTsgfTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciB4aHIgPSBjcmVhdGVYSFIoKTtcclxuXHJcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHBhdGgsIHRydWUpO1xyXG5cclxuICAgICAgICAvLyByZWNlbnQgYnJvd3NlcnNcclxuICAgICAgICBpZiAoXCJyZXNwb25zZVR5cGVcIiBpbiB4aHIpIHtcclxuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG9sZGVyIGJyb3dzZXJcclxuICAgICAgICBpZih4aHIub3ZlcnJpZGVNaW1lVHlwZSkge1xyXG4gICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShcInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWRcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50OkV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIHVzZSBgeGhyYCBhbmQgbm90IGB0aGlzYC4uLiB0aGFua3MgSUVcclxuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwIHx8IHhoci5zdGF0dXMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZ1bmN0aW9uICh4aHI6WE1MSHR0cFJlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciB4aHIucmVzcG9uc2VUZXh0LCB0aGUgMHhGRiBtYXNrIGlzIGFwcGxpZWQgYnkgSlNaaXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSh4aHIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGVycikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFqYXggZXJyb3IgZm9yIFwiICsgcGF0aCArIFwiIDogXCIgKyB0aGlzLnN0YXR1cyArIFwiIFwiICsgdGhpcy5zdGF0dXNUZXh0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZihvcHRpb25zLnByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24oZTphbnkpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvZ3Jlc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcclxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50OiBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiBlLmxvYWRlZCxcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbDogZS50b3RhbFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4aHIuc2VuZCgpO1xyXG5cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZWplY3QobmV3IEVycm9yKGUpLCBudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXR1cm5zIGEgcHJvbWlzZSBvciB1bmRlZmluZWQgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYSBjYWxsYmFjayB3YXNcclxuICAgIC8vIHByb3ZpZGVkXHJcbiAgICByZXR1cm4gcHJvbWlzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIG11bHRpIHNlcXVlbmNlIGNvbnZlcnNpb25cclxuICogZXhhbXBsZTpcclxuICogIDHjgIFFMTQgLT4gMTNfNFxyXG4gKiAgMuOAgUUxNCBKMTQgTzE0IFQxNCBZMTQgQUQxNCBBSTE0IEFOMTQgQVMxNCBBWDE0IC0+XHJcbiAqICAgICBbJzEzXzQnLCAnMTNfOScsJzEzXzE0JywgJzEzXzE5JywgJzEzXzI0JywgJzEzXzMnLCAnMTNfOCcsICAnMTNfMTMnLCAnMTNfMTgnLCAnMTNfMjMnXVxyXG4gKiAgM+OAgUU0NjpFNDcgLT4gWyc0NV80JywgICc0Nl80J11cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHNxcmVmIC0gYmVmb3JlIHNlcXVlbmNlXHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNdWx0aVNlcXVlbmNlVG9OdW0oc3FyZWY6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuICBpZiAoIXNxcmVmIHx8IHNxcmVmPy5sZW5ndGggPD0gMCkgcmV0dXJuIFtdO1xyXG4gIHNxcmVmID0gc3FyZWYudG9VcHBlckNhc2UoKTtcclxuICBsZXQgc3FyZWZSYXdBcnIgPSBzcXJlZi5zcGxpdChcIiBcIik7XHJcbiAgbGV0IHNxcmVmQXJyID0gc3FyZWZSYXdBcnIuZmlsdGVyKChlKSA9PiBlICYmIGUudHJpbSgpKTtcclxuICBsZXQgc3FyZWZMYXN0QXJyID0gZ2V0U3FyZWZSYXdBcnJGb3JtYXQoc3FyZWZBcnIpO1xyXG5cclxuICBsZXQgcmVzQXJyOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3FyZWZMYXN0QXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBsZXQgX3JlcyA9IGdldFNpbmdsZVNlcXVlbmNlVG9OdW0oc3FyZWZMYXN0QXJyW2ldKTtcclxuICAgIGlmIChfcmVzKSByZXNBcnIucHVzaChfcmVzKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc0FycjtcclxufVxyXG5cclxuLyoqXHJcbiAqIHVuaWZpZWQgcHJvY2Vzc2luZyBvZiBjb252ZXJzaW9uIGZvcm1hdHNcclxuICogZXhhbXBsZTpcclxuICogIDHjgIFbJ0UzOCcsICdBMTpDMiddIC0+IFsnRTM4JywgJ0ExJywgJ0EyJywgJ0IxJywgJ0IyJywgJ0MxJywgJ0MyJ11cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmdbXX0gYXJyIC0gZm9ybWF0cyBhcnJcclxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIGFmdGVyIGFyclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNxcmVmUmF3QXJyRm9ybWF0KGFycjogc3RyaW5nW10pOiBzdHJpbmdbXSB7XHJcbiAgYXJyPy5tYXAoKGVsKSA9PiB7XHJcbiAgICBpZiAoZWwuaW5jbHVkZXMoXCI6XCIpKSB7XHJcbiAgICAgIGxldCB0ZW1wQXJyOiBzdHJpbmdbXSA9IGVsLnNwbGl0KFwiOlwiKTtcclxuICAgICAgaWYgKHRlbXBBcnI/Lmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIGxldCByZWdFbiA9IG5ldyBSZWdFeHAoL1tBLVpdK3xbMC05XSsvZyk7XHJcbiAgICAgICAgbGV0IHN0YXJ0QXJyID0gdGVtcEFyclswXT8ubWF0Y2gocmVnRW4pO1xyXG4gICAgICAgIGxldCBsYXN0QXJyID0gdGVtcEFyclsxXT8ubWF0Y2gocmVnRW4pO1xyXG4gICAgICAgIGxldCBjb2x1bW5NYXggPSBNYXRoLm1heChcclxuICAgICAgICAgIC4uLltBQkNhdE51bShzdGFydEFyclswXSksIEFCQ2F0TnVtKGxhc3RBcnJbMF0pXVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgbGV0IGNvbHVtbk1pbiA9IE1hdGgubWluKFxyXG4gICAgICAgICAgLi4uW0FCQ2F0TnVtKHN0YXJ0QXJyWzBdKSwgQUJDYXROdW0obGFzdEFyclswXSldXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsZXQgcm93TWF4ID0gTWF0aC5tYXgoLi4uW3BhcnNlSW50KHN0YXJ0QXJyWzFdKSwgcGFyc2VJbnQobGFzdEFyclsxXSldKTtcclxuICAgICAgICBsZXQgcm93TWluID0gTWF0aC5taW4oLi4uW3BhcnNlSW50KHN0YXJ0QXJyWzFdKSwgcGFyc2VJbnQobGFzdEFyclsxXSldKTtcclxuICAgICAgICBsZXQgZm9ybWF0QXJyOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAobGV0IGkgPSBjb2x1bW5NaW47IGkgPD0gY29sdW1uTWF4OyBpKyspIHtcclxuICAgICAgICAgIGZvciAobGV0IGogPSByb3dNaW47IGogPD0gcm93TWF4OyBqKyspIHtcclxuICAgICAgICAgICAgZm9ybWF0QXJyLnB1c2goYCR7Y2hhdGF0QUJDKGkpfSR7an1gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYXJyID0gYXJyLmNvbmNhdChmb3JtYXRBcnIpO1xyXG4gICAgICAgIGFyci5zcGxpY2UoYXJyLmluZGV4T2YoZWwpLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBhcnI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzaW5nbGUgc2VxdWVuY2UgdG8gbnVtYmVyXHJcbiAqIGV4YW1wbGU6XHJcbiAqICAx44CBQTEgLT4gMF8wXHJcbiAqICAy44CBRVMxNCAtPiAxM180XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcXJlZiAtIGJlZm9yZSBzZXF1ZW5jZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIGFmdGVyIHNlcXVlbmNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2luZ2xlU2VxdWVuY2VUb051bShzcXJlZjogc3RyaW5nKTogc3RyaW5nIHtcclxuICBsZXQgc3FyZWZBcnJheSA9IHNxcmVmLm1hdGNoKC9bQS1aXSt8WzAtOV0rL2cpO1xyXG4gIGxldCBzcXJlZkxlbiA9IHNxcmVmQXJyYXkubGVuZ3RoO1xyXG4gIGxldCByZWdFbiA9IG5ldyBSZWdFeHAoXCJeW0EtWl0rJFwiKTtcclxuICBsZXQgcmV0ID0gXCJcIjtcclxuICBmb3IgKGxldCBpID0gc3FyZWZMZW4gLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgbGV0IGN1ciA9IHNxcmVmQXJyYXlbaV07XHJcbiAgICBpZiAocmVnRW4udGVzdChjdXIpKSB7XHJcbiAgICAgIHJldCArPSBBQkNhdE51bShjdXIpICsgXCJfXCI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXQgKz0gcGFyc2VJbnQoY3VyKSAtIDEgKyBcIl9cIjtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJldC5zdWJzdHJpbmcoMCwgcmV0Lmxlbmd0aCAtIDEpO1xyXG59XHJcblxyXG4vKipcclxuICogUjFDMSB0byBTZXF1ZW5jZVxyXG4gKiBleGFtcGxlOiBzaGVldDIhUjFDMSA9PiBzaGVldCFBMVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBSMUMxIHZhbHVlXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG4gZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zUjFDMVRvU2VxdWVuY2UodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgaWYgKCF2YWx1ZSAmJiB2YWx1ZT8ubGVuZ3RoIDw9IDApIHJldHVybiBcIlwiO1xyXG4gIGxldCB2YWx1ZUFyciA9IHZhbHVlLnRvTG9jYWxlVXBwZXJDYXNlKCk/LnNwbGl0KFwiIVwiKTtcclxuICBsZXQgcmVwU3RyID0gdmFsdWVBcnJbMV0gfHwgXCJcIjtcclxuICBsZXQgaW5kZXhSID0gcmVwU3RyLmluZGV4T2YoXCJSXCIpO1xyXG4gIGxldCBpbmRleEMgPSByZXBTdHIuaW5kZXhPZihcIkNcIik7XHJcbiAgbGV0IHJvdyA9IE51bWJlcihyZXBTdHIuc2xpY2UoaW5kZXhSICsgMSwgaW5kZXhDKSk7XHJcbiAgbGV0IGNvbHVtbiA9IGNoYXRhdEFCQyhOdW1iZXIocmVwU3RyLnNsaWNlKGluZGV4QyArIDEsIHJlcFN0cj8ubGVuZ3RoKSkgLSAxKTtcclxuICByZXR1cm4gYCR7dmFsdWVBcnJbMF19ISR7Y29sdW1ufSR7cm93fWA7XHJcbn0iLCJpbXBvcnQgeyBMdWNreUZpbGUgfSBmcm9tIFwiLi9Ub0x1Y2t5U2hlZXQvTHVja3lGaWxlXCI7XHJcbi8vIGltcG9ydCB7U2VjdXJpdHlEb29yLENhcn0gZnJvbSAnLi9jb250ZW50JztcclxuXHJcbmltcG9ydCB7SGFuZGxlWmlwfSBmcm9tICcuL0hhbmRsZVppcCc7XHJcblxyXG5pbXBvcnQge0l1cGxvYWRmaWxlTGlzdH0gZnJvbSBcIi4vSUNvbW1vblwiO1xyXG5pbXBvcnQgeyBmc3RhdCB9IGZyb20gXCJmc1wiO1xyXG5cclxuLy8gLy9kZW1vXHJcbi8vIGZ1bmN0aW9uIGRlbW9IYW5kbGVyKCl7XHJcbi8vICAgICBsZXQgdXBsb2FkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJMdWNreWV4Y2VsLWRlbW8tZmlsZVwiKTtcclxuLy8gICAgIGxldCBzZWxlY3RBRGVtbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiTHVja3lleGNlbC1zZWxlY3QtZGVtb1wiKTtcclxuLy8gICAgIGxldCBkb3dubG9kRGVtbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiTHVja3lleGNlbC1kb3dubG9kLWZpbGVcIik7XHJcbi8vICAgICBsZXQgbWFzayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibHVja3ktbWFzay1kZW1vXCIpO1xyXG4vLyAgICAgaWYodXBsb2FkKXtcclxuICAgICAgICBcclxuLy8gICAgICAgICB3aW5kb3cub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBcclxuLy8gICAgICAgICAgICAgdXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZnVuY3Rpb24oZXZ0KXtcclxuLy8gICAgICAgICAgICAgICAgIHZhciBmaWxlczpGaWxlTGlzdCA9IChldnQudGFyZ2V0IGFzIGFueSkuZmlsZXM7XHJcbi8vICAgICAgICAgICAgICAgICBpZihmaWxlcz09bnVsbCB8fCBmaWxlcy5sZW5ndGg9PTApe1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiTm8gZmlsZXMgd2FpdCBmb3IgaW1wb3J0XCIpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuLy8gICAgICAgICAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGZpbGVzWzBdLm5hbWU7XHJcbi8vICAgICAgICAgICAgICAgICBsZXQgc3VmZml4QXJyID0gbmFtZS5zcGxpdChcIi5cIiksIHN1ZmZpeCA9IHN1ZmZpeEFycltzdWZmaXhBcnIubGVuZ3RoLTFdO1xyXG4vLyAgICAgICAgICAgICAgICAgaWYoc3VmZml4IT1cInhsc3hcIil7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJDdXJyZW50bHkgb25seSBzdXBwb3J0cyB0aGUgaW1wb3J0IG9mIHhsc3ggZmlsZXNcIik7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICAgICAgTHVja3lFeGNlbC50cmFuc2Zvcm1FeGNlbFRvTHVja3koZmlsZXNbMF0sIGZ1bmN0aW9uKGV4cG9ydEpzb246YW55LCBsdWNreXNoZWV0ZmlsZTpzdHJpbmcpe1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4vLyAgICAgICAgICAgICAgICAgICAgIGlmKGV4cG9ydEpzb24uc2hlZXRzPT1udWxsIHx8IGV4cG9ydEpzb24uc2hlZXRzLmxlbmd0aD09MCl7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHJlYWQgdGhlIGNvbnRlbnQgb2YgdGhlIGV4Y2VsIGZpbGUsIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHhscyBmaWxlcyFcIik7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuLy8gICAgICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXhwb3J0SnNvbiwgbHVja3lzaGVldGZpbGUpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sdWNreXNoZWV0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuLy8gICAgICAgICAgICAgICAgICAgICB3aW5kb3cubHVja3lzaGVldC5jcmVhdGUoe1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6ICdsdWNreXNoZWV0JywgLy9sdWNreXNoZWV0IGlzIHRoZSBjb250YWluZXIgaWRcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc2hvd2luZm9iYXI6ZmFsc2UsXHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6ZXhwb3J0SnNvbi5zaGVldHMsXHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOmV4cG9ydEpzb24uaW5mby5uYW1lLFxyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB1c2VySW5mbzpleHBvcnRKc29uLmluZm8ubmFtZS5jcmVhdG9yXHJcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbi8vICAgICAgICAgICAgICAgICB9KTtcclxuLy8gICAgICAgICAgICAgfSk7XHJcblxyXG4vLyAgICAgICAgICAgICBzZWxlY3RBRGVtby5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGV2dCl7XHJcbi8vICAgICAgICAgICAgICAgICB2YXIgb2JqOmFueSA9IHNlbGVjdEFEZW1vO1xyXG4vLyAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gb2JqLnNlbGVjdGVkSW5kZXg7XHJcbi8vICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmoub3B0aW9uc1tpbmRleF0udmFsdWU7XHJcbi8vICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG9iai5vcHRpb25zW2luZGV4XS5pbm5lckhUTUw7XHJcbi8vICAgICAgICAgICAgICAgICBpZih2YWx1ZT09XCJcIil7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICAgICAgbWFzay5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XHJcbi8vICAgICAgICAgICAgICAgICBMdWNreUV4Y2VsLnRyYW5zZm9ybUV4Y2VsVG9MdWNreUJ5VXJsKHZhbHVlLCBuYW1lLCBmdW5jdGlvbihleHBvcnRKc29uOmFueSwgbHVja3lzaGVldGZpbGU6c3RyaW5nKXtcclxuICAgICAgICAgICAgICAgICAgICBcclxuLy8gICAgICAgICAgICAgICAgICAgICBpZihleHBvcnRKc29uLnNoZWV0cz09bnVsbCB8fCBleHBvcnRKc29uLnNoZWV0cy5sZW5ndGg9PTApe1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChcIkZhaWxlZCB0byByZWFkIHRoZSBjb250ZW50IG9mIHRoZSBleGNlbCBmaWxlLCBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCB4bHMgZmlsZXMhXCIpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbi8vICAgICAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4cG9ydEpzb24sIGx1Y2t5c2hlZXRmaWxlKTtcclxuLy8gICAgICAgICAgICAgICAgICAgICBtYXNrLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuLy8gICAgICAgICAgICAgICAgICAgICB3aW5kb3cubHVja3lzaGVldC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbi8vICAgICAgICAgICAgICAgICAgICAgd2luZG93Lmx1Y2t5c2hlZXQuY3JlYXRlKHtcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiAnbHVja3lzaGVldCcsIC8vbHVja3lzaGVldCBpcyB0aGUgY29udGFpbmVyIGlkXHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dpbmZvYmFyOmZhbHNlLFxyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOmV4cG9ydEpzb24uc2hlZXRzLFxyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTpleHBvcnRKc29uLmluZm8ubmFtZSxcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdXNlckluZm86ZXhwb3J0SnNvbi5pbmZvLm5hbWUuY3JlYXRvclxyXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4vLyAgICAgICAgICAgICAgICAgfSk7XHJcbi8vICAgICAgICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgICAgICAgZG93bmxvZERlbW8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2dCl7XHJcbi8vICAgICAgICAgICAgICAgICB2YXIgb2JqOmFueSA9IHNlbGVjdEFEZW1vO1xyXG4vLyAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gb2JqLnNlbGVjdGVkSW5kZXg7XHJcbi8vICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmoub3B0aW9uc1tpbmRleF0udmFsdWU7XHJcblxyXG4vLyAgICAgICAgICAgICAgICAgaWYodmFsdWUubGVuZ3RoPT0wKXtcclxuLy8gICAgICAgICAgICAgICAgICAgICBhbGVydChcIlBsZWFzZSBzZWxlY3QgYSBkZW1vIGZpbGVcIik7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICAgICAgICAgIHZhciBlbGVtSUY6YW55ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJMdWNreS1kb3dubG9hZC1mcmFtZVwiKTtcclxuLy8gICAgICAgICAgICAgICAgIGlmKGVsZW1JRj09bnVsbCl7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgZWxlbUlGID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcclxuLy8gICAgICAgICAgICAgICAgICAgICBlbGVtSUYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIGVsZW1JRi5pZCA9IFwiTHVja3ktZG93bmxvYWQtZnJhbWVcIjtcclxuLy8gICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1JRik7XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgICBlbGVtSUYuc3JjID0gdmFsdWU7XHJcblxyXG4vLyAgICAgICAgICAgICAgICAgLy8gZWxlbUlGLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbUlGKTtcclxuLy8gICAgICAgICAgICAgfSk7XHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgfVxyXG4vLyB9XHJcbi8vIGRlbW9IYW5kbGVyKCk7XHJcblxyXG4vLyBhcGlcclxuZXhwb3J0IGNsYXNzIEx1Y2t5RXhjZWx7XHJcbiAgICBzdGF0aWMgdHJhbnNmb3JtRXhjZWxUb0x1Y2t5KGV4Y2VsRmlsZTogRmlsZSxcclxuICAgICAgICBjYWxsYmFjaz86IChmaWxlczogSXVwbG9hZGZpbGVMaXN0LCBmcz86IHN0cmluZykgPT4gdm9pZCxcclxuICAgICAgICBlcnJvckhhbmRsZXI/OiAoZXJyOiBFcnJvcikgPT4gdm9pZCkge1xyXG4gICAgICAgIGxldCBoYW5kbGVaaXA6SGFuZGxlWmlwID0gbmV3IEhhbmRsZVppcChleGNlbEZpbGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGhhbmRsZVppcC51bnppcEZpbGUoZnVuY3Rpb24gKGZpbGVzOiBJdXBsb2FkZmlsZUxpc3QpIHtcclxuICAgICAgICAgICAgbGV0IGx1Y2t5RmlsZSA9IG5ldyBMdWNreUZpbGUoZmlsZXMsIGV4Y2VsRmlsZS5uYW1lKTtcclxuICAgICAgICAgICAgbGV0IGx1Y2t5c2hlZXRmaWxlID0gbHVja3lGaWxlLlBhcnNlKCk7XHJcbiAgICAgICAgICAgIGxldCBleHBvcnRKc29uID0gSlNPTi5wYXJzZShsdWNreXNoZWV0ZmlsZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV4cG9ydEpzb24sIGx1Y2t5c2hlZXRmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnVuY3Rpb24oZXJyOkVycm9yKXtcclxuICAgICAgICAgICAgaWYgKGVycm9ySGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGVycik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHRyYW5zZm9ybUV4Y2VsVG9MdWNreUJ5VXJsKFxyXG4gICAgICAgIHVybDogc3RyaW5nLFxyXG4gICAgICAgIG5hbWU6IHN0cmluZyxcclxuICAgICAgICBjYWxsQmFjaz86IChmaWxlczogSXVwbG9hZGZpbGVMaXN0LCBmcz86IHN0cmluZykgPT4gdm9pZCxcclxuICAgICAgICBlcnJvckhhbmRsZXI/OiAoZXJyOiBFcnJvcikgPT4gdm9pZCkge1xyXG4gICAgICAgIGxldCBoYW5kbGVaaXA6SGFuZGxlWmlwID0gbmV3IEhhbmRsZVppcCgpO1xyXG4gICAgICAgIGhhbmRsZVppcC51bnppcEZpbGVCeVVybCh1cmwsIGZ1bmN0aW9uKGZpbGVzOkl1cGxvYWRmaWxlTGlzdCl7XHJcbiAgICAgICAgICAgIGxldCBsdWNreUZpbGUgPSBuZXcgTHVja3lGaWxlKGZpbGVzLCBuYW1lKTtcclxuICAgICAgICAgICAgbGV0IGx1Y2t5c2hlZXRmaWxlID0gbHVja3lGaWxlLlBhcnNlKCk7XHJcbiAgICAgICAgICAgIGxldCBleHBvcnRKc29uID0gSlNPTi5wYXJzZShsdWNreXNoZWV0ZmlsZSk7XHJcbiAgICAgICAgICAgIGlmKGNhbGxCYWNrICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICBjYWxsQmFjayhleHBvcnRKc29uLCBsdWNreXNoZWV0ZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZ1bmN0aW9uKGVycjpFcnJvcil7XHJcbiAgICAgICAgICAgIGlmIChlcnJvckhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyB0cmFuc2Zvcm1MdWNreVRvRXhjZWwoXHJcbiAgICAgICAgTHVja3lGaWxlOiBhbnksXHJcbiAgICAgICAgY2FsbEJhY2s/OiAoZmlsZXM6IHN0cmluZykgPT4gdm9pZCAsXHJcbiAgICAgICAgZXJyb3JIYW5kbGVyPzogKGVycjogRXJyb3IpID0+IHZvaWQpeyB9XHJcbn0iLCJpbXBvcnQge0x1Y2t5RXhjZWx9IGZyb20gXCIuL21haW5cIlxyXG4vLyBleHBvcnQgTm9kZSBtb2R1bGVcclxuZXhwb3J0ID0gTHVja3lFeGNlbDsiXX0="}