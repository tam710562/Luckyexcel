{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/base64-js/index.js","node_modules/browser-resolve/empty.js","node_modules/buffer/index.js","node_modules/core-util-is/lib/util.js","node_modules/dayjs/dayjs.min.js","node_modules/events/events.js","node_modules/ieee754/index.js","node_modules/immediate/lib/browser.js","node_modules/inherits/inherits_browser.js","node_modules/is-buffer/index.js","node_modules/isarray/index.js","node_modules/jszip/lib/base64.js","node_modules/jszip/lib/compressedObject.js","node_modules/jszip/lib/compressions.js","node_modules/jszip/lib/crc32.js","node_modules/jszip/lib/defaults.js","node_modules/jszip/lib/external.js","node_modules/jszip/lib/flate.js","node_modules/jszip/lib/generate/ZipFileWorker.js","node_modules/jszip/lib/generate/index.js","node_modules/jszip/lib/index.js","node_modules/jszip/lib/load.js","node_modules/jszip/lib/nodejsUtils.js","node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js","node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js","node_modules/jszip/lib/object.js","node_modules/jszip/lib/readable-stream-browser.js","node_modules/jszip/lib/reader/ArrayReader.js","node_modules/jszip/lib/reader/DataReader.js","node_modules/jszip/lib/reader/NodeBufferReader.js","node_modules/jszip/lib/reader/StringReader.js","node_modules/jszip/lib/reader/Uint8ArrayReader.js","node_modules/jszip/lib/reader/readerFor.js","node_modules/jszip/lib/signature.js","node_modules/jszip/lib/stream/ConvertWorker.js","node_modules/jszip/lib/stream/Crc32Probe.js","node_modules/jszip/lib/stream/DataLengthProbe.js","node_modules/jszip/lib/stream/DataWorker.js","node_modules/jszip/lib/stream/GenericWorker.js","node_modules/jszip/lib/stream/StreamHelper.js","node_modules/jszip/lib/support.js","node_modules/jszip/lib/utf8.js","node_modules/jszip/lib/utils.js","node_modules/jszip/lib/zipEntries.js","node_modules/jszip/lib/zipEntry.js","node_modules/jszip/lib/zipObject.js","node_modules/lie/lib/browser.js","node_modules/pako/index.js","node_modules/pako/lib/deflate.js","node_modules/pako/lib/inflate.js","node_modules/pako/lib/utils/common.js","node_modules/pako/lib/utils/strings.js","node_modules/pako/lib/zlib/adler32.js","node_modules/pako/lib/zlib/constants.js","node_modules/pako/lib/zlib/crc32.js","node_modules/pako/lib/zlib/deflate.js","node_modules/pako/lib/zlib/gzheader.js","node_modules/pako/lib/zlib/inffast.js","node_modules/pako/lib/zlib/inflate.js","node_modules/pako/lib/zlib/inftrees.js","node_modules/pako/lib/zlib/messages.js","node_modules/pako/lib/zlib/trees.js","node_modules/pako/lib/zlib/zstream.js","node_modules/process-nextick-args/index.js","node_modules/process/browser.js","node_modules/readable-stream/duplex-browser.js","node_modules/readable-stream/lib/_stream_duplex.js","node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/readable-stream/lib/_stream_readable.js","node_modules/readable-stream/lib/_stream_transform.js","node_modules/readable-stream/lib/_stream_writable.js","node_modules/readable-stream/lib/internal/streams/BufferList.js","node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/readable-stream/lib/internal/streams/stream-browser.js","node_modules/readable-stream/passthrough.js","node_modules/readable-stream/readable-browser.js","node_modules/readable-stream/transform.js","node_modules/readable-stream/writable-browser.js","node_modules/safe-buffer/index.js","node_modules/set-immediate-shim/index.js","node_modules/stream-browserify/index.js","node_modules/string_decoder/lib/string_decoder.js","node_modules/timers-browserify/main.js","node_modules/util-deprecate/browser.js","src/HandleZip.ts","src/ToLuckySheet/LuckyBase.ts","src/ToLuckySheet/LuckyCell.ts","src/ToLuckySheet/LuckyFile.ts","src/ToLuckySheet/LuckyImage.ts","src/ToLuckySheet/LuckySheet.ts","src/ToLuckySheet/ReadXml.ts","src/common/constant.ts","src/common/emf.ts","src/common/method.ts","src/main.ts","src/main.umd.ts"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7vDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3GA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACl1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACphDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxLA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnEA,IAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAGA,IAAA,SAAA;AAAA;AAAA,YAAA;AAII,WAAA,SAAA,CAAY,IAAZ,EAAsB;AAClB;AACA;AACI,SAAK,UAAL,GAAkB,IAAlB,CAHc,CAIlB;AACH;;AAED,EAAA,SAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,WAAV,EAAoD,SAApD,EAA+E;AAC3E;AACA,IAA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","file":"luckyexcel.umd.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs=e()}(this,(function(){\"use strict\";var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",f=\"month\",h=\"quarter\",c=\"year\",d=\"date\",$=\"Invalid Date\",l=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\")},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},g={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},D=\"en\",v={};v[D]=M;var p=function(t){return t instanceof _},S=function(t,e,n){var r;if(!t)return D;if(\"string\"==typeof t)v[t]&&(r=t),e&&(v[t]=e,r=t);else{var i=t.name;v[i]=t,r=i}return!n&&r&&(D=r),r||!n&&D},w=function(t,e){if(p(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=g;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t)}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match(l);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return O},m.isValid=function(){return!(this.$d.toString()===$)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,g=\"set\"+(this.$u?\"UTC\":\"\");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var D=this.$locale().weekStart||0,v=(y<D?y+7:y)-D;return $(r?m-v:m+(6-v),M);case a:case d:return l(g+\"Hours\",0);case u:return l(g+\"Minutes\",1);case s:return l(g+\"Seconds\",2);case i:return l(g+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h=\"set\"+(this.$u?\"UTC\":\"\"),$=(n={},n[a]=h+\"Date\",n[d]=h+\"Date\",n[f]=h+\"Month\",n[c]=h+\"FullYear\",n[u]=h+\"Hours\",n[s]=h+\"Minutes\",n[i]=h+\"Seconds\",n[r]=h+\"Milliseconds\",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else $&&this.$d[$](l);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$)};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||$;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].substr(0,s)},c=function(t){return O.s(s%12||12,t,\"0\")},d=n.meridiem||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,\"0\"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,\"0\"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,\"0\"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,\"0\"),s:String(this.$s),ss:O.s(this.$s,2,\"0\"),SSS:O.s(this.$ms,3,\"0\"),Z:i};return r.replace(y,(function(t,e){return e||l[t]||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,D=O.m(this,M);return D=(l={},l[c]=D/12,l[f]=D,l[h]=D/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?D:O.a(D)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return v[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),b=_.prototype;return w.prototype=b,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",f],[\"$y\",c],[\"$D\",d]].forEach((function(t){b[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=v[D],w.Ls=v,w.p={},w}));","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","'use strict';\nvar utils = require('./utils');\nvar support = require('./support');\n// private property\nvar _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n\n// public method for encoding\nexports.encode = function(input) {\n    var output = [];\n    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n    var i = 0, len = input.length, remainingBytes = len;\n\n    var isArray = utils.getTypeOf(input) !== \"string\";\n    while (i < input.length) {\n        remainingBytes = len - i;\n\n        if (!isArray) {\n            chr1 = input.charCodeAt(i++);\n            chr2 = i < len ? input.charCodeAt(i++) : 0;\n            chr3 = i < len ? input.charCodeAt(i++) : 0;\n        } else {\n            chr1 = input[i++];\n            chr2 = i < len ? input[i++] : 0;\n            chr3 = i < len ? input[i++] : 0;\n        }\n\n        enc1 = chr1 >> 2;\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;\n        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;\n\n        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));\n\n    }\n\n    return output.join(\"\");\n};\n\n// public method for decoding\nexports.decode = function(input) {\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0, resultIndex = 0;\n\n    var dataUrlPrefix = \"data:\";\n\n    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {\n        // This is a common error: people give a data url\n        // (data:image/png;base64,iVBOR...) with a {base64: true} and\n        // wonders why things don't work.\n        // We can detect that the string input looks like a data url but we\n        // *can't* be sure it is one: removing everything up to the comma would\n        // be too dangerous.\n        throw new Error(\"Invalid base64 input, it looks like a data url.\");\n    }\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n    var totalLength = input.length * 3 / 4;\n    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if (totalLength % 1 !== 0) {\n        // totalLength is not an integer, the length does not match a valid\n        // base64 content. That can happen if:\n        // - the input is not a base64 content\n        // - the input is *almost* a base64 content, with a extra chars at the\n        //   beginning or at the end\n        // - the input uses a base64 variant (base64url for example)\n        throw new Error(\"Invalid base64 input, bad content length.\");\n    }\n    var output;\n    if (support.uint8array) {\n        output = new Uint8Array(totalLength|0);\n    } else {\n        output = new Array(totalLength|0);\n    }\n\n    while (i < input.length) {\n\n        enc1 = _keyStr.indexOf(input.charAt(i++));\n        enc2 = _keyStr.indexOf(input.charAt(i++));\n        enc3 = _keyStr.indexOf(input.charAt(i++));\n        enc4 = _keyStr.indexOf(input.charAt(i++));\n\n        chr1 = (enc1 << 2) | (enc2 >> 4);\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n        chr3 = ((enc3 & 3) << 6) | enc4;\n\n        output[resultIndex++] = chr1;\n\n        if (enc3 !== 64) {\n            output[resultIndex++] = chr2;\n        }\n        if (enc4 !== 64) {\n            output[resultIndex++] = chr3;\n        }\n\n    }\n\n    return output;\n};\n","'use strict';\n\nvar external = require(\"./external\");\nvar DataWorker = require('./stream/DataWorker');\nvar DataLengthProbe = require('./stream/DataLengthProbe');\nvar Crc32Probe = require('./stream/Crc32Probe');\nvar DataLengthProbe = require('./stream/DataLengthProbe');\n\n/**\n * Represent a compressed object, with everything needed to decompress it.\n * @constructor\n * @param {number} compressedSize the size of the data compressed.\n * @param {number} uncompressedSize the size of the data after decompression.\n * @param {number} crc32 the crc32 of the decompressed file.\n * @param {object} compression the type of compression, see lib/compressions.js.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.\n */\nfunction CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {\n    this.compressedSize = compressedSize;\n    this.uncompressedSize = uncompressedSize;\n    this.crc32 = crc32;\n    this.compression = compression;\n    this.compressedContent = data;\n}\n\nCompressedObject.prototype = {\n    /**\n     * Create a worker to get the uncompressed content.\n     * @return {GenericWorker} the worker.\n     */\n    getContentWorker : function () {\n        var worker = new DataWorker(external.Promise.resolve(this.compressedContent))\n        .pipe(this.compression.uncompressWorker())\n        .pipe(new DataLengthProbe(\"data_length\"));\n\n        var that = this;\n        worker.on(\"end\", function () {\n            if(this.streamInfo['data_length'] !== that.uncompressedSize) {\n                throw new Error(\"Bug : uncompressed data size mismatch\");\n            }\n        });\n        return worker;\n    },\n    /**\n     * Create a worker to get the compressed content.\n     * @return {GenericWorker} the worker.\n     */\n    getCompressedWorker : function () {\n        return new DataWorker(external.Promise.resolve(this.compressedContent))\n        .withStreamInfo(\"compressedSize\", this.compressedSize)\n        .withStreamInfo(\"uncompressedSize\", this.uncompressedSize)\n        .withStreamInfo(\"crc32\", this.crc32)\n        .withStreamInfo(\"compression\", this.compression)\n        ;\n    }\n};\n\n/**\n * Chain the given worker with other workers to compress the content with the\n * given compression.\n * @param {GenericWorker} uncompressedWorker the worker to pipe.\n * @param {Object} compression the compression object.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {GenericWorker} the new worker compressing the content.\n */\nCompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {\n    return uncompressedWorker\n    .pipe(new Crc32Probe())\n    .pipe(new DataLengthProbe(\"uncompressedSize\"))\n    .pipe(compression.compressWorker(compressionOptions))\n    .pipe(new DataLengthProbe(\"compressedSize\"))\n    .withStreamInfo(\"compression\", compression);\n};\n\nmodule.exports = CompressedObject;\n","'use strict';\n\nvar GenericWorker = require(\"./stream/GenericWorker\");\n\nexports.STORE = {\n    magic: \"\\x00\\x00\",\n    compressWorker : function (compressionOptions) {\n        return new GenericWorker(\"STORE compression\");\n    },\n    uncompressWorker : function () {\n        return new GenericWorker(\"STORE decompression\");\n    }\n};\nexports.DEFLATE = require('./flate');\n","'use strict';\n\nvar utils = require('./utils');\n\n/**\n * The following functions come from pako, from pako/lib/zlib/crc32.js\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n    var c, table = [];\n\n    for(var n =0; n < 256; n++){\n        c = n;\n        for(var k =0; k < 8; k++){\n            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n        }\n        table[n] = c;\n    }\n\n    return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n    var t = crcTable, end = pos + len;\n\n    crc = crc ^ (-1);\n\n    for (var i = pos; i < end; i++ ) {\n        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n\n    return (crc ^ (-1)); // >>> 0;\n}\n\n// That's all for the pako functions.\n\n/**\n * Compute the crc32 of a string.\n * This is almost the same as the function crc32, but for strings. Using the\n * same function for the two use cases leads to horrible performances.\n * @param {Number} crc the starting value of the crc.\n * @param {String} str the string to use.\n * @param {Number} len the length of the string.\n * @param {Number} pos the starting position for the crc32 computation.\n * @return {Number} the computed crc32.\n */\nfunction crc32str(crc, str, len, pos) {\n    var t = crcTable, end = pos + len;\n\n    crc = crc ^ (-1);\n\n    for (var i = pos; i < end; i++ ) {\n        crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];\n    }\n\n    return (crc ^ (-1)); // >>> 0;\n}\n\nmodule.exports = function crc32wrapper(input, crc) {\n    if (typeof input === \"undefined\" || !input.length) {\n        return 0;\n    }\n\n    var isArray = utils.getTypeOf(input) !== \"string\";\n\n    if(isArray) {\n        return crc32(crc|0, input, input.length, 0);\n    } else {\n        return crc32str(crc|0, input, input.length, 0);\n    }\n};\n","'use strict';\nexports.base64 = false;\nexports.binary = false;\nexports.dir = false;\nexports.createFolders = true;\nexports.date = null;\nexports.compression = null;\nexports.compressionOptions = null;\nexports.comment = null;\nexports.unixPermissions = null;\nexports.dosPermissions = null;\n","/* global Promise */\n'use strict';\n\n// load the global object first:\n// - it should be better integrated in the system (unhandledRejection in node)\n// - the environment may have a custom Promise implementation (see zone.js)\nvar ES6Promise = null;\nif (typeof Promise !== \"undefined\") {\n    ES6Promise = Promise;\n} else {\n    ES6Promise = require(\"lie\");\n}\n\n/**\n * Let the user use/change some implementations.\n */\nmodule.exports = {\n    Promise: ES6Promise\n};\n","'use strict';\nvar USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');\n\nvar pako = require(\"pako\");\nvar utils = require(\"./utils\");\nvar GenericWorker = require(\"./stream/GenericWorker\");\n\nvar ARRAY_TYPE = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\n\nexports.magic = \"\\x08\\x00\";\n\n/**\n * Create a worker that uses pako to inflate/deflate.\n * @constructor\n * @param {String} action the name of the pako function to call : either \"Deflate\" or \"Inflate\".\n * @param {Object} options the options to use when (de)compressing.\n */\nfunction FlateWorker(action, options) {\n    GenericWorker.call(this, \"FlateWorker/\" + action);\n\n    this._pako = null;\n    this._pakoAction = action;\n    this._pakoOptions = options;\n    // the `meta` object from the last chunk received\n    // this allow this worker to pass around metadata\n    this.meta = {};\n}\n\nutils.inherits(FlateWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nFlateWorker.prototype.processChunk = function (chunk) {\n    this.meta = chunk.meta;\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);\n};\n\n/**\n * @see GenericWorker.flush\n */\nFlateWorker.prototype.flush = function () {\n    GenericWorker.prototype.flush.call(this);\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push([], true);\n};\n/**\n * @see GenericWorker.cleanUp\n */\nFlateWorker.prototype.cleanUp = function () {\n    GenericWorker.prototype.cleanUp.call(this);\n    this._pako = null;\n};\n\n/**\n * Create the _pako object.\n * TODO: lazy-loading this object isn't the best solution but it's the\n * quickest. The best solution is to lazy-load the worker list. See also the\n * issue #446.\n */\nFlateWorker.prototype._createPako = function () {\n    this._pako = new pako[this._pakoAction]({\n        raw: true,\n        level: this._pakoOptions.level || -1 // default compression\n    });\n    var self = this;\n    this._pako.onData = function(data) {\n        self.push({\n            data : data,\n            meta : self.meta\n        });\n    };\n};\n\nexports.compressWorker = function (compressionOptions) {\n    return new FlateWorker(\"Deflate\", compressionOptions);\n};\nexports.uncompressWorker = function () {\n    return new FlateWorker(\"Inflate\", {});\n};\n","'use strict';\n\nvar utils = require('../utils');\nvar GenericWorker = require('../stream/GenericWorker');\nvar utf8 = require('../utf8');\nvar crc32 = require('../crc32');\nvar signature = require('../signature');\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nvar decToHex = function(dec, bytes) {\n    var hex = \"\", i;\n    for (i = 0; i < bytes; i++) {\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can't use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n    return (result & 0xFFFF) << 16;\n};\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n\n    // the dir flag is already set for compatibility\n    return (dosPermissions || 0)  & 0x3F;\n};\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {Object} streamInfo the hash with information about the compressed file.\n * @param {Boolean} streamedContent is the content streamed ?\n * @param {Boolean} streamingEnded is the stream finished ?\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {Object} the zip parts.\n */\nvar generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n    var file = streamInfo['file'],\n    compression = streamInfo['compression'],\n    useCustomEncoding = encodeFileName !== utf8.utf8encode,\n    encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n    utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n    comment = file.comment,\n    encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n    utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n    useUTF8ForComment = utfEncodedComment.length !== comment.length,\n    dosTime,\n    dosDate,\n    extraFields = \"\",\n    unicodePathExtraField = \"\",\n    unicodeCommentExtraField = \"\",\n    dir = file.dir,\n    date = file.date;\n\n\n    var dataInfo = {\n        crc32 : 0,\n        compressedSize : 0,\n        uncompressedSize : 0\n    };\n\n    // if the content is streamed, the sizes/crc32 are only available AFTER\n    // the end of the stream.\n    if (!streamedContent || streamingEnded) {\n        dataInfo.crc32 = streamInfo['crc32'];\n        dataInfo.compressedSize = streamInfo['compressedSize'];\n        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];\n    }\n\n    var bitflag = 0;\n    if (streamedContent) {\n        // Bit 3: the sizes/crc32 are set to zero in the local header.\n        // The correct values are put in the data descriptor immediately\n        // following the compressed data.\n        bitflag |= 0x0008;\n    }\n    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n        // Bit 11: Language encoding flag (EFS).\n        bitflag |= 0x0800;\n    }\n\n\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if(platform === \"UNIX\") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else { // DOS or other, fallback to DOS\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n    dosTime = date.getUTCHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getUTCMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getUTCSeconds() / 2;\n\n    dosDate = date.getUTCFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | (date.getUTCMonth() + 1);\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getUTCDate();\n\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField =\n            // Version\n            decToHex(1, 1) +\n            // NameCRC32\n            decToHex(crc32(encodedFileName), 4) +\n            // UnicodeName\n            utfEncodedFileName;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x70\" +\n            // size\n            decToHex(unicodePathExtraField.length, 2) +\n            // content\n            unicodePathExtraField;\n    }\n\n    if(useUTF8ForComment) {\n\n        unicodeCommentExtraField =\n            // Version\n            decToHex(1, 1) +\n            // CommentCRC32\n            decToHex(crc32(encodedComment), 4) +\n            // UnicodeName\n            utfEncodedComment;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x63\" +\n            // size\n            decToHex(unicodeCommentExtraField.length, 2) +\n            // content\n            unicodeCommentExtraField;\n    }\n\n    var header = \"\";\n\n    // version needed to extract\n    header += \"\\x0A\\x00\";\n    // general purpose bit flag\n    header += decToHex(bitflag, 2);\n    // compression method\n    header += compression.magic;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(dataInfo.crc32, 4);\n    // compressed size\n    header += decToHex(dataInfo.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(dataInfo.uncompressedSize, 4);\n    // file name length\n    header += decToHex(encodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n\n\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n\n    var dirRecord = signature.CENTRAL_FILE_HEADER +\n        // version made by (00: DOS)\n        decToHex(versionMadeBy, 2) +\n        // file header (common to file and central directory)\n        header +\n        // file comment length\n        decToHex(encodedComment.length, 2) +\n        // disk number start\n        \"\\x00\\x00\" +\n        // internal file attributes TODO\n        \"\\x00\\x00\" +\n        // external file attributes\n        decToHex(extFileAttr, 4) +\n        // relative offset of local header\n        decToHex(offset, 4) +\n        // file name\n        encodedFileName +\n        // extra field\n        extraFields +\n        // file comment\n        encodedComment;\n\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord\n    };\n};\n\n/**\n * Generate the EOCD record.\n * @param {Number} entriesCount the number of entries in the zip file.\n * @param {Number} centralDirLength the length (in bytes) of the central dir.\n * @param {Number} localDirLength the length (in bytes) of the local dir.\n * @param {String} comment the zip file comment as a binary string.\n * @param {Function} encodeFileName the function to encode the comment.\n * @return {String} the EOCD record.\n */\nvar generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n    var dirEnd = \"\";\n    var encodedComment = utils.transformTo(\"string\", encodeFileName(comment));\n\n    // end of central dir signature\n    dirEnd = signature.CENTRAL_DIRECTORY_END +\n        // number of this disk\n        \"\\x00\\x00\" +\n        // number of the disk with the start of the central directory\n        \"\\x00\\x00\" +\n        // total number of entries in the central directory on this disk\n        decToHex(entriesCount, 2) +\n        // total number of entries in the central directory\n        decToHex(entriesCount, 2) +\n        // size of the central directory   4 bytes\n        decToHex(centralDirLength, 4) +\n        // offset of start of central directory with respect to the starting disk number\n        decToHex(localDirLength, 4) +\n        // .ZIP file comment length\n        decToHex(encodedComment.length, 2) +\n        // .ZIP file comment\n        encodedComment;\n\n    return dirEnd;\n};\n\n/**\n * Generate data descriptors for a file entry.\n * @param {Object} streamInfo the hash generated by a worker, containing information\n * on the file entry.\n * @return {String} the data descriptors.\n */\nvar generateDataDescriptors = function (streamInfo) {\n    var descriptor = \"\";\n    descriptor = signature.DATA_DESCRIPTOR +\n        // crc-32                          4 bytes\n        decToHex(streamInfo['crc32'], 4) +\n        // compressed size                 4 bytes\n        decToHex(streamInfo['compressedSize'], 4) +\n        // uncompressed size               4 bytes\n        decToHex(streamInfo['uncompressedSize'], 4);\n\n    return descriptor;\n};\n\n\n/**\n * A worker to concatenate other workers to create a zip file.\n * @param {Boolean} streamFiles `true` to stream the content of the files,\n * `false` to accumulate it.\n * @param {String} comment the comment to use.\n * @param {String} platform the platform to use, \"UNIX\" or \"DOS\".\n * @param {Function} encodeFileName the function to encode file names and comments.\n */\nfunction ZipFileWorker(streamFiles, comment, platform, encodeFileName) {\n    GenericWorker.call(this, \"ZipFileWorker\");\n    // The number of bytes written so far. This doesn't count accumulated chunks.\n    this.bytesWritten = 0;\n    // The comment of the zip file\n    this.zipComment = comment;\n    // The platform \"generating\" the zip file.\n    this.zipPlatform = platform;\n    // the function to encode file names and comments.\n    this.encodeFileName = encodeFileName;\n    // Should we stream the content of the files ?\n    this.streamFiles = streamFiles;\n    // If `streamFiles` is false, we will need to accumulate the content of the\n    // files to calculate sizes / crc32 (and write them *before* the content).\n    // This boolean indicates if we are accumulating chunks (it will change a lot\n    // during the lifetime of this worker).\n    this.accumulate = false;\n    // The buffer receiving chunks when accumulating content.\n    this.contentBuffer = [];\n    // The list of generated directory records.\n    this.dirRecords = [];\n    // The offset (in bytes) from the beginning of the zip file for the current source.\n    this.currentSourceOffset = 0;\n    // The total number of entries in this zip file.\n    this.entriesCount = 0;\n    // the name of the file currently being added, null when handling the end of the zip file.\n    // Used for the emitted metadata.\n    this.currentFile = null;\n\n\n\n    this._sources = [];\n}\nutils.inherits(ZipFileWorker, GenericWorker);\n\n/**\n * @see GenericWorker.push\n */\nZipFileWorker.prototype.push = function (chunk) {\n\n    var currentFilePercent = chunk.meta.percent || 0;\n    var entriesCount = this.entriesCount;\n    var remainingFiles = this._sources.length;\n\n    if(this.accumulate) {\n        this.contentBuffer.push(chunk);\n    } else {\n        this.bytesWritten += chunk.data.length;\n\n        GenericWorker.prototype.push.call(this, {\n            data : chunk.data,\n            meta : {\n                currentFile : this.currentFile,\n                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100\n            }\n        });\n    }\n};\n\n/**\n * The worker started a new source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the new source.\n */\nZipFileWorker.prototype.openedSource = function (streamInfo) {\n    this.currentSourceOffset = this.bytesWritten;\n    this.currentFile = streamInfo['file'].name;\n\n    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n\n    // don't stream folders (because they don't have any content)\n    if(streamedContent) {\n        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n        this.push({\n            data : record.fileRecord,\n            meta : {percent:0}\n        });\n    } else {\n        // we need to wait for the whole file before pushing anything\n        this.accumulate = true;\n    }\n};\n\n/**\n * The worker finished a source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the finished source.\n */\nZipFileWorker.prototype.closedSource = function (streamInfo) {\n    this.accumulate = false;\n    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n\n    this.dirRecords.push(record.dirRecord);\n    if(streamedContent) {\n        // after the streamed file, we put data descriptors\n        this.push({\n            data : generateDataDescriptors(streamInfo),\n            meta : {percent:100}\n        });\n    } else {\n        // the content wasn't streamed, we need to push everything now\n        // first the file record, then the content\n        this.push({\n            data : record.fileRecord,\n            meta : {percent:0}\n        });\n        while(this.contentBuffer.length) {\n            this.push(this.contentBuffer.shift());\n        }\n    }\n    this.currentFile = null;\n};\n\n/**\n * @see GenericWorker.flush\n */\nZipFileWorker.prototype.flush = function () {\n\n    var localDirLength = this.bytesWritten;\n    for(var i = 0; i < this.dirRecords.length; i++) {\n        this.push({\n            data : this.dirRecords[i],\n            meta : {percent:100}\n        });\n    }\n    var centralDirLength = this.bytesWritten - localDirLength;\n\n    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n\n    this.push({\n        data : dirEnd,\n        meta : {percent:100}\n    });\n};\n\n/**\n * Prepare the next source to be read.\n */\nZipFileWorker.prototype.prepareNextSource = function () {\n    this.previous = this._sources.shift();\n    this.openedSource(this.previous.streamInfo);\n    if (this.isPaused) {\n        this.previous.pause();\n    } else {\n        this.previous.resume();\n    }\n};\n\n/**\n * @see GenericWorker.registerPrevious\n */\nZipFileWorker.prototype.registerPrevious = function (previous) {\n    this._sources.push(previous);\n    var self = this;\n\n    previous.on('data', function (chunk) {\n        self.processChunk(chunk);\n    });\n    previous.on('end', function () {\n        self.closedSource(self.previous.streamInfo);\n        if(self._sources.length) {\n            self.prepareNextSource();\n        } else {\n            self.end();\n        }\n    });\n    previous.on('error', function (e) {\n        self.error(e);\n    });\n    return this;\n};\n\n/**\n * @see GenericWorker.resume\n */\nZipFileWorker.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if (!this.previous && this._sources.length) {\n        this.prepareNextSource();\n        return true;\n    }\n    if (!this.previous && !this._sources.length && !this.generatedError) {\n        this.end();\n        return true;\n    }\n};\n\n/**\n * @see GenericWorker.error\n */\nZipFileWorker.prototype.error = function (e) {\n    var sources = this._sources;\n    if(!GenericWorker.prototype.error.call(this, e)) {\n        return false;\n    }\n    for(var i = 0; i < sources.length; i++) {\n        try {\n            sources[i].error(e);\n        } catch(e) {\n            // the `error` exploded, nothing to do\n        }\n    }\n    return true;\n};\n\n/**\n * @see GenericWorker.lock\n */\nZipFileWorker.prototype.lock = function () {\n    GenericWorker.prototype.lock.call(this);\n    var sources = this._sources;\n    for(var i = 0; i < sources.length; i++) {\n        sources[i].lock();\n    }\n};\n\nmodule.exports = ZipFileWorker;\n","'use strict';\n\nvar compressions = require('../compressions');\nvar ZipFileWorker = require('./ZipFileWorker');\n\n/**\n * Find the compression to use.\n * @param {String} fileCompression the compression defined at the file level, if any.\n * @param {String} zipCompression the compression defined at the load() level.\n * @return {Object} the compression object to use.\n */\nvar getCompression = function (fileCompression, zipCompression) {\n\n    var compressionName = fileCompression || zipCompression;\n    var compression = compressions[compressionName];\n    if (!compression) {\n        throw new Error(compressionName + \" is not a valid compression method !\");\n    }\n    return compression;\n};\n\n/**\n * Create a worker to generate a zip file.\n * @param {JSZip} zip the JSZip instance at the right root level.\n * @param {Object} options to generate the zip file.\n * @param {String} comment the comment to use.\n */\nexports.generateWorker = function (zip, options, comment) {\n\n    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\n    var entriesCount = 0;\n    try {\n\n        zip.forEach(function (relativePath, file) {\n            entriesCount++;\n            var compression = getCompression(file.options.compression, options.compression);\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n            var dir = file.dir, date = file.date;\n\n            file._compressWorker(compression, compressionOptions)\n            .withStreamInfo(\"file\", {\n                name : relativePath,\n                dir : dir,\n                date : date,\n                comment : file.comment || \"\",\n                unixPermissions : file.unixPermissions,\n                dosPermissions : file.dosPermissions\n            })\n            .pipe(zipFileWorker);\n        });\n        zipFileWorker.entriesCount = entriesCount;\n    } catch (e) {\n        zipFileWorker.error(e);\n    }\n\n    return zipFileWorker;\n};\n","'use strict';\n\n/**\n * Representation a of zip file in js\n * @constructor\n */\nfunction JSZip() {\n    // if this constructor isused without`new`, itadds `new` beforeitself:\n    if(!(this instanceof JSZip)) {\n        return new JSZip();\n    }\n\n    if(arguments.length) {\n        throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");\n    }\n\n    // object containing the files :\n    // {\n    //   \"folder/\" : {...},\n    //   \"folder/data.txt\" : {...}\n    // }\n    this.files = {};\n\n    this.comment = null;\n\n    // Where we are in the hierarchy\n    this.root = \"\";\n    this.clone = function() {\n        var newObj = new JSZip();\n        for (var i in this) {\n            if (typeof this[i] !== \"function\") {\n                newObj[i] = this[i];\n            }\n        }\n        return newObj;\n    };\n}\nJSZip.prototype = require('./object');\nJSZip.prototype.loadAsync = require('./load');\nJSZip.support = require('./support');\nJSZip.defaults = require('./defaults');\n\n// TODO find a better way to handle this version,\n// a require('package.json').version doesn't work with webpack, see #327\nJSZip.version = \"3.5.0\";\n\nJSZip.loadAsync = function (content, options) {\n    return new JSZip().loadAsync(content, options);\n};\n\nJSZip.external = require(\"./external\");\nmodule.exports = JSZip;\n","'use strict';\nvar utils = require('./utils');\nvar external = require(\"./external\");\nvar utf8 = require('./utf8');\nvar utils = require('./utils');\nvar ZipEntries = require('./zipEntries');\nvar Crc32Probe = require('./stream/Crc32Probe');\nvar nodejsUtils = require(\"./nodejsUtils\");\n\n/**\n * Check the CRC32 of an entry.\n * @param {ZipEntry} zipEntry the zip entry to check.\n * @return {Promise} the result.\n */\nfunction checkEntryCRC32(zipEntry) {\n    return new external.Promise(function (resolve, reject) {\n        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());\n        worker.on(\"error\", function (e) {\n            reject(e);\n        })\n        .on(\"end\", function () {\n            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {\n                reject(new Error(\"Corrupted zip : CRC32 mismatch\"));\n            } else {\n                resolve();\n            }\n        })\n        .resume();\n    });\n}\n\nmodule.exports = function(data, options) {\n    var zip = this;\n    options = utils.extend(options || {}, {\n        base64: false,\n        checkCRC32: false,\n        optimizedBinaryString: false,\n        createFolders: false,\n        decodeFileName: utf8.utf8decode\n    });\n\n    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        return external.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\"));\n    }\n\n    return utils.prepareContent(\"the loaded zip file\", data, true, options.optimizedBinaryString, options.base64)\n    .then(function(data) {\n        var zipEntries = new ZipEntries(options);\n        zipEntries.load(data);\n        return zipEntries;\n    }).then(function checkCRC32(zipEntries) {\n        var promises = [external.Promise.resolve(zipEntries)];\n        var files = zipEntries.files;\n        if (options.checkCRC32) {\n            for (var i = 0; i < files.length; i++) {\n                promises.push(checkEntryCRC32(files[i]));\n            }\n        }\n        return external.Promise.all(promises);\n    }).then(function addFiles(results) {\n        var zipEntries = results.shift();\n        var files = zipEntries.files;\n        for (var i = 0; i < files.length; i++) {\n            var input = files[i];\n            zip.file(input.fileNameStr, input.decompressed, {\n                binary: true,\n                optimizedBinaryString: true,\n                date: input.date,\n                dir: input.dir,\n                comment : input.fileCommentStr.length ? input.fileCommentStr : null,\n                unixPermissions : input.unixPermissions,\n                dosPermissions : input.dosPermissions,\n                createFolders: options.createFolders\n            });\n        }\n        if (zipEntries.zipComment.length) {\n            zip.comment = zipEntries.zipComment;\n        }\n\n        return zip;\n    });\n};\n","'use strict';\n\nmodule.exports = {\n    /**\n     * True if this is running in Nodejs, will be undefined in a browser.\n     * In a browser, browserify won't include this file and the whole module\n     * will be resolved an empty object.\n     */\n    isNode : typeof Buffer !== \"undefined\",\n    /**\n     * Create a new nodejs Buffer from an existing content.\n     * @param {Object} data the data to pass to the constructor.\n     * @param {String} encoding the encoding to use.\n     * @return {Buffer} a new Buffer.\n     */\n    newBufferFrom: function(data, encoding) {\n        if (Buffer.from && Buffer.from !== Uint8Array.from) {\n            return Buffer.from(data, encoding);\n        } else {\n            if (typeof data === \"number\") {\n                // Safeguard for old Node.js versions. On newer versions,\n                // Buffer.from(number) / Buffer(number, encoding) already throw.\n                throw new Error(\"The \\\"data\\\" argument must not be a number\");\n            }\n            return new Buffer(data, encoding);\n        }\n    },\n    /**\n     * Create a new nodejs Buffer with the specified size.\n     * @param {Integer} size the size of the buffer.\n     * @return {Buffer} a new Buffer.\n     */\n    allocBuffer: function (size) {\n        if (Buffer.alloc) {\n            return Buffer.alloc(size);\n        } else {\n            var buf = new Buffer(size);\n            buf.fill(0);\n            return buf;\n        }\n    },\n    /**\n     * Find out if an object is a Buffer.\n     * @param {Object} b the object to test.\n     * @return {Boolean} true if the object is a Buffer, false otherwise.\n     */\n    isBuffer : function(b){\n        return Buffer.isBuffer(b);\n    },\n\n    isStream : function (obj) {\n        return obj &&\n            typeof obj.on === \"function\" &&\n            typeof obj.pause === \"function\" &&\n            typeof obj.resume === \"function\";\n    }\n};\n","\"use strict\";\n\nvar utils = require('../utils');\nvar GenericWorker = require('../stream/GenericWorker');\n\n/**\n * A worker that use a nodejs stream as source.\n * @constructor\n * @param {String} filename the name of the file entry for this stream.\n * @param {Readable} stream the nodejs stream.\n */\nfunction NodejsStreamInputAdapter(filename, stream) {\n    GenericWorker.call(this, \"Nodejs stream input adapter for \" + filename);\n    this._upstreamEnded = false;\n    this._bindStream(stream);\n}\n\nutils.inherits(NodejsStreamInputAdapter, GenericWorker);\n\n/**\n * Prepare the stream and bind the callbacks on it.\n * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.\n * @param {Stream} stream the nodejs stream to use.\n */\nNodejsStreamInputAdapter.prototype._bindStream = function (stream) {\n    var self = this;\n    this._stream = stream;\n    stream.pause();\n    stream\n    .on(\"data\", function (chunk) {\n        self.push({\n            data: chunk,\n            meta : {\n                percent : 0\n            }\n        });\n    })\n    .on(\"error\", function (e) {\n        if(self.isPaused) {\n            this.generatedError = e;\n        } else {\n            self.error(e);\n        }\n    })\n    .on(\"end\", function () {\n        if(self.isPaused) {\n            self._upstreamEnded = true;\n        } else {\n            self.end();\n        }\n    });\n};\nNodejsStreamInputAdapter.prototype.pause = function () {\n    if(!GenericWorker.prototype.pause.call(this)) {\n        return false;\n    }\n    this._stream.pause();\n    return true;\n};\nNodejsStreamInputAdapter.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if(this._upstreamEnded) {\n        this.end();\n    } else {\n        this._stream.resume();\n    }\n\n    return true;\n};\n\nmodule.exports = NodejsStreamInputAdapter;\n","'use strict';\n\nvar Readable = require('readable-stream').Readable;\n\nvar utils = require('../utils');\nutils.inherits(NodejsStreamOutputAdapter, Readable);\n\n/**\n* A nodejs stream using a worker as source.\n* @see the SourceWrapper in http://nodejs.org/api/stream.html\n* @constructor\n* @param {StreamHelper} helper the helper wrapping the worker\n* @param {Object} options the nodejs stream options\n* @param {Function} updateCb the update callback.\n*/\nfunction NodejsStreamOutputAdapter(helper, options, updateCb) {\n    Readable.call(this, options);\n    this._helper = helper;\n\n    var self = this;\n    helper.on(\"data\", function (data, meta) {\n        if (!self.push(data)) {\n            self._helper.pause();\n        }\n        if(updateCb) {\n            updateCb(meta);\n        }\n    })\n    .on(\"error\", function(e) {\n        self.emit('error', e);\n    })\n    .on(\"end\", function () {\n        self.push(null);\n    });\n}\n\n\nNodejsStreamOutputAdapter.prototype._read = function() {\n    this._helper.resume();\n};\n\nmodule.exports = NodejsStreamOutputAdapter;\n","'use strict';\nvar utf8 = require('./utf8');\nvar utils = require('./utils');\nvar GenericWorker = require('./stream/GenericWorker');\nvar StreamHelper = require('./stream/StreamHelper');\nvar defaults = require('./defaults');\nvar CompressedObject = require('./compressedObject');\nvar ZipObject = require('./zipObject');\nvar generate = require(\"./generate\");\nvar nodejsUtils = require(\"./nodejsUtils\");\nvar NodejsStreamInputAdapter = require(\"./nodejs/NodejsStreamInputAdapter\");\n\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} originalOptions the options of the file\n * @return {Object} the new file.\n */\nvar fileAdd = function(name, data, originalOptions) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data),\n        parent;\n\n\n    /*\n     * Correct options.\n     */\n\n    var o = utils.extend(originalOptions || {}, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) {\n        o.compression = o.compression.toUpperCase();\n    }\n\n    if (typeof o.unixPermissions === \"string\") {\n        o.unixPermissions = parseInt(o.unixPermissions, 8);\n    }\n\n    // UNX_IFDIR  0040000 see zipinfo.c\n    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {\n        o.dir = true;\n    }\n    // Bit 4    Directory\n    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {\n        o.dir = true;\n    }\n\n    if (o.dir) {\n        name = forceTrailingSlash(name);\n    }\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n\n    var isUnicodeString = dataType === \"string\" && o.binary === false && o.base64 === false;\n    if (!originalOptions || typeof originalOptions.binary === \"undefined\") {\n        o.binary = !isUnicodeString;\n    }\n\n\n    var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;\n\n    if (isCompressedEmpty || o.dir || !data || data.length === 0) {\n        o.base64 = false;\n        o.binary = true;\n        data = \"\";\n        o.compression = \"STORE\";\n        dataType = \"string\";\n    }\n\n    /*\n     * Convert content to fit.\n     */\n\n    var zipObjectContent = null;\n    if (data instanceof CompressedObject || data instanceof GenericWorker) {\n        zipObjectContent = data;\n    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        zipObjectContent = new NodejsStreamInputAdapter(name, data);\n    } else {\n        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);\n    }\n\n    var object = new ZipObject(name, zipObjectContent, o);\n    this.files[name] = object;\n    /*\n    TODO: we can't throw an exception because we have async promises\n    (we can have a promise of a Date() for example) but returning a\n    promise is useless because file(name, data) returns the JSZip\n    object for chaining. Should we break that to allow the user\n    to catch the error ?\n\n    return external.Promise.resolve(zipObjectContent)\n    .then(function () {\n        return object;\n    });\n    */\n};\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\nvar parentFolder = function (path) {\n    if (path.slice(-1) === '/') {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf('/');\n    return (lastSlash > 0) ? path.substring(0, lastSlash) : \"\";\n};\n\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\nvar forceTrailingSlash = function(path) {\n    // Check the name ends with a /\n    if (path.slice(-1) !== \"/\") {\n        path += \"/\"; // IE doesn't like substr(-1)\n    }\n    return path;\n};\n\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nvar folderAdd = function(name, createFolders) {\n    createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;\n\n    name = forceTrailingSlash(name);\n\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nfunction isRegExp(object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n}\n\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * @see loadAsync\n     */\n    load: function() {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n\n\n    /**\n     * Call a callback function for each entry at this folder level.\n     * @param {Function} cb the callback function:\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     */\n    forEach: function(cb) {\n        var filename, relativePath, file;\n        for (filename in this.files) {\n            if (!this.files.hasOwnProperty(filename)) {\n                continue;\n            }\n            file = this.files[filename];\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (relativePath && filename.slice(0, this.root.length) === this.root) { // the file is in the current root\n                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...\n            }\n        }\n    },\n\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */\n    filter: function(search) {\n        var result = [];\n        this.forEach(function (relativePath, entry) {\n            if (search(relativePath, entry)) { // the file matches the function\n                result.push(entry);\n            }\n\n        });\n        return result;\n    },\n\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */\n    file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            }\n            else { // text\n                var obj = this.files[this.root + name];\n                if (obj && !obj.dir) {\n                    return obj;\n                } else {\n                    return null;\n                }\n            }\n        }\n        else { // more than one argument : we have data !\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */\n    folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n\n        if (isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */\n    remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) !== \"/\") {\n                name += \"/\";\n            }\n            file = this.files[name];\n        }\n\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for (var i = 0; i < kids.length; i++) {\n                delete this.files[kids[i].name];\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Generate the complete zip file\n     * @param {Object} options the options to generate the zip file :\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n     */\n    generate: function(options) {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n\n    /**\n     * Generate the complete zip file as an internal stream.\n     * @param {Object} options the options to generate the zip file :\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {StreamHelper} the streamed zip file.\n     */\n    generateInternalStream: function(options) {\n      var worker, opts = {};\n      try {\n          opts = utils.extend(options || {}, {\n              streamFiles: false,\n              compression: \"STORE\",\n              compressionOptions : null,\n              type: \"\",\n              platform: \"DOS\",\n              comment: null,\n              mimeType: 'application/zip',\n              encodeFileName: utf8.utf8encode\n          });\n\n          opts.type = opts.type.toLowerCase();\n          opts.compression = opts.compression.toUpperCase();\n\n          // \"binarystring\" is preferred but the internals use \"string\".\n          if(opts.type === \"binarystring\") {\n            opts.type = \"string\";\n          }\n\n          if (!opts.type) {\n            throw new Error(\"No output type specified.\");\n          }\n\n          utils.checkSupport(opts.type);\n\n          // accept nodejs `process.platform`\n          if(\n              opts.platform === 'darwin' ||\n              opts.platform === 'freebsd' ||\n              opts.platform === 'linux' ||\n              opts.platform === 'sunos'\n          ) {\n              opts.platform = \"UNIX\";\n          }\n          if (opts.platform === 'win32') {\n              opts.platform = \"DOS\";\n          }\n\n          var comment = opts.comment || this.comment || \"\";\n          worker = generate.generateWorker(this, opts, comment);\n      } catch (e) {\n        worker = new GenericWorker(\"error\");\n        worker.error(e);\n      }\n      return new StreamHelper(worker, opts.type || \"string\", opts.mimeType);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */\n    generateAsync: function(options, onUpdate) {\n        return this.generateInternalStream(options).accumulate(onUpdate);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */\n    generateNodeStream: function(options, onUpdate) {\n        options = options || {};\n        if (!options.type) {\n            options.type = \"nodebuffer\";\n        }\n        return this.generateInternalStream(options).toNodejsStream(onUpdate);\n    }\n};\nmodule.exports = out;\n","/*\n * This file is used by module bundlers (browserify/webpack/etc) when\n * including a stream implementation. We use \"readable-stream\" to get a\n * consistent behavior between nodejs versions but bundlers often have a shim\n * for \"stream\". Using this shim greatly improve the compatibility and greatly\n * reduce the final size of the bundle (only one stream implementation, not\n * two).\n */\nmodule.exports = require(\"stream\");\n","'use strict';\nvar DataReader = require('./DataReader');\nvar utils = require('../utils');\n\nfunction ArrayReader(data) {\n    DataReader.call(this, data);\n\tfor(var i = 0; i < this.data.length; i++) {\n\t\tdata[i] = data[i] & 0xFF;\n\t}\n}\nutils.inherits(ArrayReader, DataReader);\n/**\n * @see DataReader.byteAt\n */\nArrayReader.prototype.byteAt = function(i) {\n    return this.data[this.zero + i];\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nArrayReader.prototype.lastIndexOfSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3);\n    for (var i = this.length - 4; i >= 0; --i) {\n        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n            return i - this.zero;\n        }\n    }\n\n    return -1;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */\nArrayReader.prototype.readAndCheckSignature = function (sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3),\n        data = this.readData(4);\n    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];\n};\n/**\n * @see DataReader.readData\n */\nArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        return [];\n    }\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = ArrayReader;\n","'use strict';\nvar utils = require('../utils');\n\nfunction DataReader(data) {\n    this.data = data; // type : see implementation\n    this.length = data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */\n    checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specified index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */\n    checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + (newIndex) + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */\n    setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */\n    skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */\n    byteAt: function(i) {\n        // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */\n    readInt: function(size) {\n        var result = 0,\n            i;\n        this.checkOffset(size);\n        for (i = this.index + size - 1; i >= this.index; i--) {\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */\n    readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */\n    readData: function(size) {\n        // see implementations\n    },\n    /**\n     * Find the last occurrence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurrence, -1 if not found.\n     */\n    lastIndexOfSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Read the signature (4 bytes) at the current position and compare it with sig.\n     * @param {string} sig the expected signature\n     * @return {boolean} true if the signature matches, false otherwise.\n     */\n    readAndCheckSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */\n    readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(Date.UTC(\n        ((dostime >> 25) & 0x7f) + 1980, // year\n        ((dostime >> 21) & 0x0f) - 1, // month\n        (dostime >> 16) & 0x1f, // day\n        (dostime >> 11) & 0x1f, // hour\n        (dostime >> 5) & 0x3f, // minute\n        (dostime & 0x1f) << 1)); // second\n    }\n};\nmodule.exports = DataReader;\n","'use strict';\nvar Uint8ArrayReader = require('./Uint8ArrayReader');\nvar utils = require('../utils');\n\nfunction NodeBufferReader(data) {\n    Uint8ArrayReader.call(this, data);\n}\nutils.inherits(NodeBufferReader, Uint8ArrayReader);\n\n/**\n * @see DataReader.readData\n */\nNodeBufferReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = NodeBufferReader;\n","'use strict';\nvar DataReader = require('./DataReader');\nvar utils = require('../utils');\n\nfunction StringReader(data) {\n    DataReader.call(this, data);\n}\nutils.inherits(StringReader, DataReader);\n/**\n * @see DataReader.byteAt\n */\nStringReader.prototype.byteAt = function(i) {\n    return this.data.charCodeAt(this.zero + i);\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nStringReader.prototype.lastIndexOfSignature = function(sig) {\n    return this.data.lastIndexOf(sig) - this.zero;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */\nStringReader.prototype.readAndCheckSignature = function (sig) {\n    var data = this.readData(4);\n    return sig === data;\n};\n/**\n * @see DataReader.readData\n */\nStringReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    // this will work because the constructor applied the \"& 0xff\" mask.\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = StringReader;\n","'use strict';\nvar ArrayReader = require('./ArrayReader');\nvar utils = require('../utils');\n\nfunction Uint8ArrayReader(data) {\n    ArrayReader.call(this, data);\n}\nutils.inherits(Uint8ArrayReader, ArrayReader);\n/**\n * @see DataReader.readData\n */\nUint8ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].\n        return new Uint8Array(0);\n    }\n    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = Uint8ArrayReader;\n","'use strict';\n\nvar utils = require('../utils');\nvar support = require('../support');\nvar ArrayReader = require('./ArrayReader');\nvar StringReader = require('./StringReader');\nvar NodeBufferReader = require('./NodeBufferReader');\nvar Uint8ArrayReader = require('./Uint8ArrayReader');\n\n/**\n * Create a reader adapted to the data.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.\n * @return {DataReader} the data reader.\n */\nmodule.exports = function (data) {\n    var type = utils.getTypeOf(data);\n    utils.checkSupport(type);\n    if (type === \"string\" && !support.uint8array) {\n        return new StringReader(data);\n    }\n    if (type === \"nodebuffer\") {\n        return new NodeBufferReader(data);\n    }\n    if (support.uint8array) {\n        return new Uint8ArrayReader(utils.transformTo(\"uint8array\", data));\n    }\n    return new ArrayReader(utils.transformTo(\"array\", data));\n};\n","'use strict';\nexports.LOCAL_FILE_HEADER = \"PK\\x03\\x04\";\nexports.CENTRAL_FILE_HEADER = \"PK\\x01\\x02\";\nexports.CENTRAL_DIRECTORY_END = \"PK\\x05\\x06\";\nexports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\x06\\x07\";\nexports.ZIP64_CENTRAL_DIRECTORY_END = \"PK\\x06\\x06\";\nexports.DATA_DESCRIPTOR = \"PK\\x07\\x08\";\n","'use strict';\n\nvar GenericWorker = require('./GenericWorker');\nvar utils = require('../utils');\n\n/**\n * A worker which convert chunks to a specified type.\n * @constructor\n * @param {String} destType the destination type.\n */\nfunction ConvertWorker(destType) {\n    GenericWorker.call(this, \"ConvertWorker to \" + destType);\n    this.destType = destType;\n}\nutils.inherits(ConvertWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nConvertWorker.prototype.processChunk = function (chunk) {\n    this.push({\n        data : utils.transformTo(this.destType, chunk.data),\n        meta : chunk.meta\n    });\n};\nmodule.exports = ConvertWorker;\n","'use strict';\n\nvar GenericWorker = require('./GenericWorker');\nvar crc32 = require('../crc32');\nvar utils = require('../utils');\n\n/**\n * A worker which calculate the crc32 of the data flowing through.\n * @constructor\n */\nfunction Crc32Probe() {\n    GenericWorker.call(this, \"Crc32Probe\");\n    this.withStreamInfo(\"crc32\", 0);\n}\nutils.inherits(Crc32Probe, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nCrc32Probe.prototype.processChunk = function (chunk) {\n    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);\n    this.push(chunk);\n};\nmodule.exports = Crc32Probe;\n","'use strict';\n\nvar utils = require('../utils');\nvar GenericWorker = require('./GenericWorker');\n\n/**\n * A worker which calculate the total length of the data flowing through.\n * @constructor\n * @param {String} propName the name used to expose the length\n */\nfunction DataLengthProbe(propName) {\n    GenericWorker.call(this, \"DataLengthProbe for \" + propName);\n    this.propName = propName;\n    this.withStreamInfo(propName, 0);\n}\nutils.inherits(DataLengthProbe, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nDataLengthProbe.prototype.processChunk = function (chunk) {\n    if(chunk) {\n        var length = this.streamInfo[this.propName] || 0;\n        this.streamInfo[this.propName] = length + chunk.data.length;\n    }\n    GenericWorker.prototype.processChunk.call(this, chunk);\n};\nmodule.exports = DataLengthProbe;\n\n","'use strict';\n\nvar utils = require('../utils');\nvar GenericWorker = require('./GenericWorker');\n\n// the size of the generated chunks\n// TODO expose this as a public variable\nvar DEFAULT_BLOCK_SIZE = 16 * 1024;\n\n/**\n * A worker that reads a content and emits chunks.\n * @constructor\n * @param {Promise} dataP the promise of the data to split\n */\nfunction DataWorker(dataP) {\n    GenericWorker.call(this, \"DataWorker\");\n    var self = this;\n    this.dataIsReady = false;\n    this.index = 0;\n    this.max = 0;\n    this.data = null;\n    this.type = \"\";\n\n    this._tickScheduled = false;\n\n    dataP.then(function (data) {\n        self.dataIsReady = true;\n        self.data = data;\n        self.max = data && data.length || 0;\n        self.type = utils.getTypeOf(data);\n        if(!self.isPaused) {\n            self._tickAndRepeat();\n        }\n    }, function (e) {\n        self.error(e);\n    });\n}\n\nutils.inherits(DataWorker, GenericWorker);\n\n/**\n * @see GenericWorker.cleanUp\n */\nDataWorker.prototype.cleanUp = function () {\n    GenericWorker.prototype.cleanUp.call(this);\n    this.data = null;\n};\n\n/**\n * @see GenericWorker.resume\n */\nDataWorker.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if (!this._tickScheduled && this.dataIsReady) {\n        this._tickScheduled = true;\n        utils.delay(this._tickAndRepeat, [], this);\n    }\n    return true;\n};\n\n/**\n * Trigger a tick a schedule an other call to this function.\n */\nDataWorker.prototype._tickAndRepeat = function() {\n    this._tickScheduled = false;\n    if(this.isPaused || this.isFinished) {\n        return;\n    }\n    this._tick();\n    if(!this.isFinished) {\n        utils.delay(this._tickAndRepeat, [], this);\n        this._tickScheduled = true;\n    }\n};\n\n/**\n * Read and push a chunk.\n */\nDataWorker.prototype._tick = function() {\n\n    if(this.isPaused || this.isFinished) {\n        return false;\n    }\n\n    var size = DEFAULT_BLOCK_SIZE;\n    var data = null, nextIndex = Math.min(this.max, this.index + size);\n    if (this.index >= this.max) {\n        // EOF\n        return this.end();\n    } else {\n        switch(this.type) {\n            case \"string\":\n                data = this.data.substring(this.index, nextIndex);\n            break;\n            case \"uint8array\":\n                data = this.data.subarray(this.index, nextIndex);\n            break;\n            case \"array\":\n            case \"nodebuffer\":\n                data = this.data.slice(this.index, nextIndex);\n            break;\n        }\n        this.index = nextIndex;\n        return this.push({\n            data : data,\n            meta : {\n                percent : this.max ? this.index / this.max * 100 : 0\n            }\n        });\n    }\n};\n\nmodule.exports = DataWorker;\n","'use strict';\n\n/**\n * A worker that does nothing but passing chunks to the next one. This is like\n * a nodejs stream but with some differences. On the good side :\n * - it works on IE 6-9 without any issue / polyfill\n * - it weights less than the full dependencies bundled with browserify\n * - it forwards errors (no need to declare an error handler EVERYWHERE)\n *\n * A chunk is an object with 2 attributes : `meta` and `data`. The former is an\n * object containing anything (`percent` for example), see each worker for more\n * details. The latter is the real data (String, Uint8Array, etc).\n *\n * @constructor\n * @param {String} name the name of the stream (mainly used for debugging purposes)\n */\nfunction GenericWorker(name) {\n    // the name of the worker\n    this.name = name || \"default\";\n    // an object containing metadata about the workers chain\n    this.streamInfo = {};\n    // an error which happened when the worker was paused\n    this.generatedError = null;\n    // an object containing metadata to be merged by this worker into the general metadata\n    this.extraStreamInfo = {};\n    // true if the stream is paused (and should not do anything), false otherwise\n    this.isPaused = true;\n    // true if the stream is finished (and should not do anything), false otherwise\n    this.isFinished = false;\n    // true if the stream is locked to prevent further structure updates (pipe), false otherwise\n    this.isLocked = false;\n    // the event listeners\n    this._listeners = {\n        'data':[],\n        'end':[],\n        'error':[]\n    };\n    // the previous worker, if any\n    this.previous = null;\n}\n\nGenericWorker.prototype = {\n    /**\n     * Push a chunk to the next workers.\n     * @param {Object} chunk the chunk to push\n     */\n    push : function (chunk) {\n        this.emit(\"data\", chunk);\n    },\n    /**\n     * End the stream.\n     * @return {Boolean} true if this call ended the worker, false otherwise.\n     */\n    end : function () {\n        if (this.isFinished) {\n            return false;\n        }\n\n        this.flush();\n        try {\n            this.emit(\"end\");\n            this.cleanUp();\n            this.isFinished = true;\n        } catch (e) {\n            this.emit(\"error\", e);\n        }\n        return true;\n    },\n    /**\n     * End the stream with an error.\n     * @param {Error} e the error which caused the premature end.\n     * @return {Boolean} true if this call ended the worker with an error, false otherwise.\n     */\n    error : function (e) {\n        if (this.isFinished) {\n            return false;\n        }\n\n        if(this.isPaused) {\n            this.generatedError = e;\n        } else {\n            this.isFinished = true;\n\n            this.emit(\"error\", e);\n\n            // in the workers chain exploded in the middle of the chain,\n            // the error event will go downward but we also need to notify\n            // workers upward that there has been an error.\n            if(this.previous) {\n                this.previous.error(e);\n            }\n\n            this.cleanUp();\n        }\n        return true;\n    },\n    /**\n     * Add a callback on an event.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Function} listener the function to call when the event is triggered\n     * @return {GenericWorker} the current object for chainability\n     */\n    on : function (name, listener) {\n        this._listeners[name].push(listener);\n        return this;\n    },\n    /**\n     * Clean any references when a worker is ending.\n     */\n    cleanUp : function () {\n        this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n        this._listeners = [];\n    },\n    /**\n     * Trigger an event. This will call registered callback with the provided arg.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Object} arg the argument to call the callback with.\n     */\n    emit : function (name, arg) {\n        if (this._listeners[name]) {\n            for(var i = 0; i < this._listeners[name].length; i++) {\n                this._listeners[name][i].call(this, arg);\n            }\n        }\n    },\n    /**\n     * Chain a worker with an other.\n     * @param {Worker} next the worker receiving events from the current one.\n     * @return {worker} the next worker for chainability\n     */\n    pipe : function (next) {\n        return next.registerPrevious(this);\n    },\n    /**\n     * Same as `pipe` in the other direction.\n     * Using an API with `pipe(next)` is very easy.\n     * Implementing the API with the point of view of the next one registering\n     * a source is easier, see the ZipFileWorker.\n     * @param {Worker} previous the previous worker, sending events to this one\n     * @return {Worker} the current worker for chainability\n     */\n    registerPrevious : function (previous) {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n\n        // sharing the streamInfo...\n        this.streamInfo = previous.streamInfo;\n        // ... and adding our own bits\n        this.mergeStreamInfo();\n        this.previous =  previous;\n        var self = this;\n        previous.on('data', function (chunk) {\n            self.processChunk(chunk);\n        });\n        previous.on('end', function () {\n            self.end();\n        });\n        previous.on('error', function (e) {\n            self.error(e);\n        });\n        return this;\n    },\n    /**\n     * Pause the stream so it doesn't send events anymore.\n     * @return {Boolean} true if this call paused the worker, false otherwise.\n     */\n    pause : function () {\n        if(this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = true;\n\n        if(this.previous) {\n            this.previous.pause();\n        }\n        return true;\n    },\n    /**\n     * Resume a paused stream.\n     * @return {Boolean} true if this call resumed the worker, false otherwise.\n     */\n    resume : function () {\n        if(!this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = false;\n\n        // if true, the worker tried to resume but failed\n        var withError = false;\n        if(this.generatedError) {\n            this.error(this.generatedError);\n            withError = true;\n        }\n        if(this.previous) {\n            this.previous.resume();\n        }\n\n        return !withError;\n    },\n    /**\n     * Flush any remaining bytes as the stream is ending.\n     */\n    flush : function () {},\n    /**\n     * Process a chunk. This is usually the method overridden.\n     * @param {Object} chunk the chunk to process.\n     */\n    processChunk : function(chunk) {\n        this.push(chunk);\n    },\n    /**\n     * Add a key/value to be added in the workers chain streamInfo once activated.\n     * @param {String} key the key to use\n     * @param {Object} value the associated value\n     * @return {Worker} the current worker for chainability\n     */\n    withStreamInfo : function (key, value) {\n        this.extraStreamInfo[key] = value;\n        this.mergeStreamInfo();\n        return this;\n    },\n    /**\n     * Merge this worker's streamInfo into the chain's streamInfo.\n     */\n    mergeStreamInfo : function () {\n        for(var key in this.extraStreamInfo) {\n            if (!this.extraStreamInfo.hasOwnProperty(key)) {\n                continue;\n            }\n            this.streamInfo[key] = this.extraStreamInfo[key];\n        }\n    },\n\n    /**\n     * Lock the stream to prevent further updates on the workers chain.\n     * After calling this method, all calls to pipe will fail.\n     */\n    lock: function () {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n        this.isLocked = true;\n        if (this.previous) {\n            this.previous.lock();\n        }\n    },\n\n    /**\n     *\n     * Pretty print the workers chain.\n     */\n    toString : function () {\n        var me = \"Worker \" + this.name;\n        if (this.previous) {\n            return this.previous + \" -> \" + me;\n        } else {\n            return me;\n        }\n    }\n};\n\nmodule.exports = GenericWorker;\n","'use strict';\n\nvar utils = require('../utils');\nvar ConvertWorker = require('./ConvertWorker');\nvar GenericWorker = require('./GenericWorker');\nvar base64 = require('../base64');\nvar support = require(\"../support\");\nvar external = require(\"../external\");\n\nvar NodejsStreamOutputAdapter = null;\nif (support.nodestream) {\n    try {\n        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');\n    } catch(e) {}\n}\n\n/**\n * Apply the final transformation of the data. If the user wants a Blob for\n * example, it's easier to work with an U8intArray and finally do the\n * ArrayBuffer/Blob conversion.\n * @param {String} type the name of the final type\n * @param {String|Uint8Array|Buffer} content the content to transform\n * @param {String} mimeType the mime type of the content, if applicable.\n * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.\n */\nfunction transformZipOutput(type, content, mimeType) {\n    switch(type) {\n        case \"blob\" :\n            return utils.newBlob(utils.transformTo(\"arraybuffer\", content), mimeType);\n        case \"base64\" :\n            return base64.encode(content);\n        default :\n            return utils.transformTo(type, content);\n    }\n}\n\n/**\n * Concatenate an array of data of the given type.\n * @param {String} type the type of the data in the given array.\n * @param {Array} dataArray the array containing the data chunks to concatenate\n * @return {String|Uint8Array|Buffer} the concatenated data\n * @throws Error if the asked type is unsupported\n */\nfunction concat (type, dataArray) {\n    var i, index = 0, res = null, totalLength = 0;\n    for(i = 0; i < dataArray.length; i++) {\n        totalLength += dataArray[i].length;\n    }\n    switch(type) {\n        case \"string\":\n            return dataArray.join(\"\");\n          case \"array\":\n            return Array.prototype.concat.apply([], dataArray);\n        case \"uint8array\":\n            res = new Uint8Array(totalLength);\n            for(i = 0; i < dataArray.length; i++) {\n                res.set(dataArray[i], index);\n                index += dataArray[i].length;\n            }\n            return res;\n        case \"nodebuffer\":\n            return Buffer.concat(dataArray);\n        default:\n            throw new Error(\"concat : unsupported type '\"  + type + \"'\");\n    }\n}\n\n/**\n * Listen a StreamHelper, accumulate its content and concatenate it into a\n * complete block.\n * @param {StreamHelper} helper the helper to use.\n * @param {Function} updateCallback a callback called on each update. Called\n * with one arg :\n * - the metadata linked to the update received.\n * @return Promise the promise for the accumulation.\n */\nfunction accumulate(helper, updateCallback) {\n    return new external.Promise(function (resolve, reject){\n        var dataArray = [];\n        var chunkType = helper._internalType,\n            resultType = helper._outputType,\n            mimeType = helper._mimeType;\n        helper\n        .on('data', function (data, meta) {\n            dataArray.push(data);\n            if(updateCallback) {\n                updateCallback(meta);\n            }\n        })\n        .on('error', function(err) {\n            dataArray = [];\n            reject(err);\n        })\n        .on('end', function (){\n            try {\n                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n                resolve(result);\n            } catch (e) {\n                reject(e);\n            }\n            dataArray = [];\n        })\n        .resume();\n    });\n}\n\n/**\n * An helper to easily use workers outside of JSZip.\n * @constructor\n * @param {Worker} worker the worker to wrap\n * @param {String} outputType the type of data expected by the use\n * @param {String} mimeType the mime type of the content, if applicable.\n */\nfunction StreamHelper(worker, outputType, mimeType) {\n    var internalType = outputType;\n    switch(outputType) {\n        case \"blob\":\n        case \"arraybuffer\":\n            internalType = \"uint8array\";\n        break;\n        case \"base64\":\n            internalType = \"string\";\n        break;\n    }\n\n    try {\n        // the type used internally\n        this._internalType = internalType;\n        // the type used to output results\n        this._outputType = outputType;\n        // the mime type\n        this._mimeType = mimeType;\n        utils.checkSupport(internalType);\n        this._worker = worker.pipe(new ConvertWorker(internalType));\n        // the last workers can be rewired without issues but we need to\n        // prevent any updates on previous workers.\n        worker.lock();\n    } catch(e) {\n        this._worker = new GenericWorker(\"error\");\n        this._worker.error(e);\n    }\n}\n\nStreamHelper.prototype = {\n    /**\n     * Listen a StreamHelper, accumulate its content and concatenate it into a\n     * complete block.\n     * @param {Function} updateCb the update callback.\n     * @return Promise the promise for the accumulation.\n     */\n    accumulate : function (updateCb) {\n        return accumulate(this, updateCb);\n    },\n    /**\n     * Add a listener on an event triggered on a stream.\n     * @param {String} evt the name of the event\n     * @param {Function} fn the listener\n     * @return {StreamHelper} the current helper.\n     */\n    on : function (evt, fn) {\n        var self = this;\n\n        if(evt === \"data\") {\n            this._worker.on(evt, function (chunk) {\n                fn.call(self, chunk.data, chunk.meta);\n            });\n        } else {\n            this._worker.on(evt, function () {\n                utils.delay(fn, arguments, self);\n            });\n        }\n        return this;\n    },\n    /**\n     * Resume the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */\n    resume : function () {\n        utils.delay(this._worker.resume, [], this._worker);\n        return this;\n    },\n    /**\n     * Pause the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */\n    pause : function () {\n        this._worker.pause();\n        return this;\n    },\n    /**\n     * Return a nodejs stream for this helper.\n     * @param {Function} updateCb the update callback.\n     * @return {NodejsStreamOutputAdapter} the nodejs stream.\n     */\n    toNodejsStream : function (updateCb) {\n        utils.checkSupport(\"nodestream\");\n        if (this._outputType !== \"nodebuffer\") {\n            // an object stream containing blob/arraybuffer/uint8array/string\n            // is strange and I don't know if it would be useful.\n            // I you find this comment and have a good usecase, please open a\n            // bug report !\n            throw new Error(this._outputType + \" is not supported by this method\");\n        }\n\n        return new NodejsStreamOutputAdapter(this, {\n            objectMode : this._outputType !== \"nodebuffer\"\n        }, updateCb);\n    }\n};\n\n\nmodule.exports = StreamHelper;\n","'use strict';\n\nexports.base64 = true;\nexports.array = true;\nexports.string = true;\nexports.arraybuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\nexports.nodebuffer = typeof Buffer !== \"undefined\";\n// contains true if JSZip can read/generate Uint8Array, false otherwise.\nexports.uint8array = typeof Uint8Array !== \"undefined\";\n\nif (typeof ArrayBuffer === \"undefined\") {\n    exports.blob = false;\n}\nelse {\n    var buffer = new ArrayBuffer(0);\n    try {\n        exports.blob = new Blob([buffer], {\n            type: \"application/zip\"\n        }).size === 0;\n    }\n    catch (e) {\n        try {\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            exports.blob = builder.getBlob('application/zip').size === 0;\n        }\n        catch (e) {\n            exports.blob = false;\n        }\n    }\n}\n\ntry {\n    exports.nodestream = !!require('readable-stream').Readable;\n} catch(e) {\n    exports.nodestream = false;\n}\n","'use strict';\n\nvar utils = require('./utils');\nvar support = require('./support');\nvar nodejsUtils = require('./nodejsUtils');\nvar GenericWorker = require('./stream/GenericWorker');\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That's all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodejsUtils.newBufferFrom(str, \"utf-8\");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n    return buf2string(buf);\n};\n\n/**\n * A worker to decode utf8 encoded binary chunks into string chunks.\n * @constructor\n */\nfunction Utf8DecodeWorker() {\n    GenericWorker.call(this, \"utf-8 decode\");\n    // the last bytes if a chunk didn't end with a complete codepoint.\n    this.leftOver = null;\n}\nutils.inherits(Utf8DecodeWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nUtf8DecodeWorker.prototype.processChunk = function (chunk) {\n\n    var data = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", chunk.data);\n\n    // 1st step, re-use what's left of the previous chunk\n    if (this.leftOver && this.leftOver.length) {\n        if(support.uint8array) {\n            var previousData = data;\n            data = new Uint8Array(previousData.length + this.leftOver.length);\n            data.set(this.leftOver, 0);\n            data.set(previousData, this.leftOver.length);\n        } else {\n            data = this.leftOver.concat(data);\n        }\n        this.leftOver = null;\n    }\n\n    var nextBoundary = utf8border(data);\n    var usableData = data;\n    if (nextBoundary !== data.length) {\n        if (support.uint8array) {\n            usableData = data.subarray(0, nextBoundary);\n            this.leftOver = data.subarray(nextBoundary, data.length);\n        } else {\n            usableData = data.slice(0, nextBoundary);\n            this.leftOver = data.slice(nextBoundary, data.length);\n        }\n    }\n\n    this.push({\n        data : exports.utf8decode(usableData),\n        meta : chunk.meta\n    });\n};\n\n/**\n * @see GenericWorker.flush\n */\nUtf8DecodeWorker.prototype.flush = function () {\n    if(this.leftOver && this.leftOver.length) {\n        this.push({\n            data : exports.utf8decode(this.leftOver),\n            meta : {}\n        });\n        this.leftOver = null;\n    }\n};\nexports.Utf8DecodeWorker = Utf8DecodeWorker;\n\n/**\n * A worker to endcode string chunks into utf8 encoded binary chunks.\n * @constructor\n */\nfunction Utf8EncodeWorker() {\n    GenericWorker.call(this, \"utf-8 encode\");\n}\nutils.inherits(Utf8EncodeWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nUtf8EncodeWorker.prototype.processChunk = function (chunk) {\n    this.push({\n        data : exports.utf8encode(chunk.data),\n        meta : chunk.meta\n    });\n};\nexports.Utf8EncodeWorker = Utf8EncodeWorker;\n","'use strict';\n\nvar support = require('./support');\nvar base64 = require('./base64');\nvar nodejsUtils = require('./nodejsUtils');\nvar setImmediate = require('set-immediate-shim');\nvar external = require(\"./external\");\n\n\n/**\n * Convert a string that pass as a \"binary string\": it should represent a byte\n * array but may have > 255 char codes. Be sure to take only the first byte\n * and returns the byte array.\n * @param {String} str the string to transform.\n * @return {Array|Uint8Array} the string in a binary format.\n */\nfunction string2binary(str) {\n    var result = null;\n    if (support.uint8array) {\n      result = new Uint8Array(str.length);\n    } else {\n      result = new Array(str.length);\n    }\n    return stringToArrayLike(str, result);\n}\n\n/**\n * Create a new blob with the given content and the given type.\n * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use\n * an Uint8Array because the stock browser of android 4 won't accept it (it\n * will be silently converted to a string, \"[object Uint8Array]\").\n *\n * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:\n * when a large amount of Array is used to create the Blob, the amount of\n * memory consumed is nearly 100 times the original data amount.\n *\n * @param {String} type the mime type of the blob.\n * @return {Blob} the created blob.\n */\nexports.newBlob = function(part, type) {\n    exports.checkSupport(\"blob\");\n\n    try {\n        // Blob constructor\n        return new Blob([part], {\n            type: type\n        });\n    }\n    catch (e) {\n\n        try {\n            // deprecated, browser only, old way\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(part);\n            return builder.getBlob(type);\n        }\n        catch (e) {\n\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n\n\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n    return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n    for (var i = 0; i < str.length; ++i) {\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n\n/**\n * An helper for the function arrayLikeToString.\n * This contains static information and functions that\n * can be optimized by the browser JIT compiler.\n */\nvar arrayToStringHelper = {\n    /**\n     * Transform an array of int into a string, chunk by chunk.\n     * See the performances notes on arrayLikeToString.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @param {String} type the type of the array.\n     * @param {Integer} chunk the chunk size.\n     * @return {String} the resulting string.\n     * @throws Error if the chunk is too big for the stack.\n     */\n    stringifyByChunk: function(array, type, chunk) {\n        var result = [], k = 0, len = array.length;\n        // shortcut\n        if (len <= chunk) {\n            return String.fromCharCode.apply(null, array);\n        }\n        while (k < len) {\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            }\n            else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        return result.join(\"\");\n    },\n    /**\n     * Call String.fromCharCode on every item in the array.\n     * This is the naive implementation, which generate A LOT of intermediate string.\n     * This should be used when everything else fail.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @return {String} the result.\n     */\n    stringifyByChar: function(array){\n        var resultStr = \"\";\n        for(var i = 0; i < array.length; i++) {\n            resultStr += String.fromCharCode(array[i]);\n        }\n        return resultStr;\n    },\n    applyCanBeUsed : {\n        /**\n         * true if the browser accepts to use String.fromCharCode on Uint8Array\n         */\n        uint8array : (function () {\n            try {\n                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        })(),\n        /**\n         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.\n         */\n        nodebuffer : (function () {\n            try {\n                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        })()\n    }\n};\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    // TODO : we now have workers that split the work. Do we still need that ?\n    var chunk = 65536,\n        type = exports.getTypeOf(array),\n        canUseApply = true;\n    if (type === \"uint8array\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;\n    } else if (type === \"nodebuffer\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;\n    }\n\n    if (canUseApply) {\n        while (chunk > 1) {\n            try {\n                return arrayToStringHelper.stringifyByChunk(array, type, chunk);\n            } catch (e) {\n                chunk = Math.floor(chunk / 2);\n            }\n        }\n    }\n\n    // no apply or chunk error : slow and painful algorithm\n    // default browser on android 4.*\n    return arrayToStringHelper.stringifyByChar(array);\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for (var i = 0; i < arrayFrom.length; i++) {\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));\n    }\n};\n\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return (new Uint8Array(input)).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(new Uint8Array(input));\n    }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this platform\");\n    }\n};\n\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function(str) {\n    var res = '',\n        code, i;\n    for (i = 0; i < (str || \"\").length; i++) {\n        code = str.charCodeAt(i);\n        res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n\n/**\n * Defer the call of a function.\n * @param {Function} callback the function to call asynchronously.\n * @param {Array} args the arguments to give to the callback.\n */\nexports.delay = function(callback, args, self) {\n    setImmediate(function () {\n        callback.apply(self || null, args || []);\n    });\n};\n\n/**\n * Extends a prototype with an other, without calling a constructor with\n * side effects. Inspired by nodejs' `utils.inherits`\n * @param {Function} ctor the constructor to augment\n * @param {Function} superCtor the parent constructor to use\n */\nexports.inherits = function (ctor, superCtor) {\n    var Obj = function() {};\n    Obj.prototype = superCtor.prototype;\n    ctor.prototype = new Obj();\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nexports.extend = function() {\n    var result = {}, i, attr;\n    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers\n        for (attr in arguments[i]) {\n            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Transform arbitrary content into a Promise.\n * @param {String} name a name for the content being processed.\n * @param {Object} inputData the content to process.\n * @param {Boolean} isBinary true if the content is not an unicode string\n * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.\n * @param {Boolean} isBase64 true if the string content is encoded with base64.\n * @return {Promise} a promise in a format usable by JSZip.\n */\nexports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n\n    // if inputData is already a promise, this flatten it.\n    var promise = external.Promise.resolve(inputData).then(function(data) {\n        \n        \n        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);\n\n        if (isBlob && typeof FileReader !== \"undefined\") {\n            return new external.Promise(function (resolve, reject) {\n                var reader = new FileReader();\n\n                reader.onload = function(e) {\n                    resolve(e.target.result);\n                };\n                reader.onerror = function(e) {\n                    reject(e.target.error);\n                };\n                reader.readAsArrayBuffer(data);\n            });\n        } else {\n            return data;\n        }\n    });\n\n    return promise.then(function(data) {\n        var dataType = exports.getTypeOf(data);\n\n        if (!dataType) {\n            return external.Promise.reject(\n                new Error(\"Can't read the data of '\" + name + \"'. Is it \" +\n                          \"in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\")\n            );\n        }\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = exports.transformTo(\"uint8array\", data);\n        } else if (dataType === \"string\") {\n            if (isBase64) {\n                data = base64.decode(data);\n            }\n            else if (isBinary) {\n                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask\n                if (isOptimizedBinaryString !== true) {\n                    // this is a string, not in a base64 format.\n                    // Be sure that this is a correct \"binary string\"\n                    data = string2binary(data);\n                }\n            }\n        }\n        return data;\n    });\n};\n","'use strict';\nvar readerFor = require('./reader/readerFor');\nvar utils = require('./utils');\nvar sig = require('./signature');\nvar ZipEntry = require('./zipEntry');\nvar utf8 = require('./utf8');\nvar support = require('./support');\n//  class ZipEntries {{{\n/**\n * All the entries in the zip file.\n * @constructor\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntries(loadOptions) {\n    this.files = [];\n    this.loadOptions = loadOptions;\n}\nZipEntries.prototype = {\n    /**\n     * Check that the reader is on the specified signature.\n     * @param {string} expectedSignature the expected signature.\n     * @throws {Error} if it is an other signature.\n     */\n    checkSignature: function(expectedSignature) {\n        if (!this.reader.readAndCheckSignature(expectedSignature)) {\n            this.reader.index -= 4;\n            var signature = this.reader.readString(4);\n            throw new Error(\"Corrupted zip or bug: unexpected signature \" + \"(\" + utils.pretty(signature) + \", expected \" + utils.pretty(expectedSignature) + \")\");\n        }\n    },\n    /**\n     * Check if the given signature is at the given index.\n     * @param {number} askedIndex the index to check.\n     * @param {string} expectedSignature the signature to expect.\n     * @return {boolean} true if the signature is here, false otherwise.\n     */\n    isSignature: function(askedIndex, expectedSignature) {\n        var currentIndex = this.reader.index;\n        this.reader.setIndex(askedIndex);\n        var signature = this.reader.readString(4);\n        var result = signature === expectedSignature;\n        this.reader.setIndex(currentIndex);\n        return result;\n    },\n    /**\n     * Read the end of the central directory.\n     */\n    readBlockEndOfCentral: function() {\n        this.diskNumber = this.reader.readInt(2);\n        this.diskWithCentralDirStart = this.reader.readInt(2);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n        this.centralDirRecords = this.reader.readInt(2);\n        this.centralDirSize = this.reader.readInt(4);\n        this.centralDirOffset = this.reader.readInt(4);\n\n        this.zipCommentLength = this.reader.readInt(2);\n        // warning : the encoding depends of the system locale\n        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.\n        // On a windows machine, this field is encoded with the localized windows code page.\n        var zipComment = this.reader.readData(this.zipCommentLength);\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        // To get consistent behavior with the generation part, we will assume that\n        // this is utf8 encoded unless specified otherwise.\n        var decodeContent = utils.transformTo(decodeParamType, zipComment);\n        this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n    },\n    /**\n     * Read the end of the Zip 64 central directory.\n     * Not merged with the method readEndOfCentral :\n     * The end of central can coexist with its Zip64 brother,\n     * I don't want to read the wrong number of bytes !\n     */\n    readBlockZip64EndOfCentral: function() {\n        this.zip64EndOfCentralSize = this.reader.readInt(8);\n        this.reader.skip(4);\n        // this.versionMadeBy = this.reader.readString(2);\n        // this.versionNeeded = this.reader.readInt(2);\n        this.diskNumber = this.reader.readInt(4);\n        this.diskWithCentralDirStart = this.reader.readInt(4);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n        this.centralDirRecords = this.reader.readInt(8);\n        this.centralDirSize = this.reader.readInt(8);\n        this.centralDirOffset = this.reader.readInt(8);\n\n        this.zip64ExtensibleData = {};\n        var extraDataSize = this.zip64EndOfCentralSize - 44,\n            index = 0,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n        while (index < extraDataSize) {\n            extraFieldId = this.reader.readInt(2);\n            extraFieldLength = this.reader.readInt(4);\n            extraFieldValue = this.reader.readData(extraFieldLength);\n            this.zip64ExtensibleData[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Read the end of the Zip 64 central directory locator.\n     */\n    readBlockZip64EndOfCentralLocator: function() {\n        this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n        this.disksCount = this.reader.readInt(4);\n        if (this.disksCount > 1) {\n            throw new Error(\"Multi-volumes zip are not supported\");\n        }\n    },\n    /**\n     * Read the local files, based on the offset read in the central part.\n     */\n    readLocalFiles: function() {\n        var i, file;\n        for (i = 0; i < this.files.length; i++) {\n            file = this.files[i];\n            this.reader.setIndex(file.localHeaderOffset);\n            this.checkSignature(sig.LOCAL_FILE_HEADER);\n            file.readLocalPart(this.reader);\n            file.handleUTF8();\n            file.processAttributes();\n        }\n    },\n    /**\n     * Read the central directory.\n     */\n    readCentralDir: function() {\n        var file;\n\n        this.reader.setIndex(this.centralDirOffset);\n        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {\n            file = new ZipEntry({\n                zip64: this.zip64\n            }, this.loadOptions);\n            file.readCentralPart(this.reader);\n            this.files.push(file);\n        }\n\n        if (this.centralDirRecords !== this.files.length) {\n            if (this.centralDirRecords !== 0 && this.files.length === 0) {\n                // We expected some records but couldn't find ANY.\n                // This is really suspicious, as if something went wrong.\n                throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n            } else {\n                // We found some records but not all.\n                // Something is wrong but we got something for the user: no error here.\n                // console.warn(\"expected\", this.centralDirRecords, \"records in central dir, got\", this.files.length);\n            }\n        }\n    },\n    /**\n     * Read the end of central directory.\n     */\n    readEndOfCentral: function() {\n        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n        if (offset < 0) {\n            // Check if the content is a truncated zip or complete garbage.\n            // A \"LOCAL_FILE_HEADER\" is not required at the beginning (auto\n            // extractible zip for example) but it can give a good hint.\n            // If an ajax request was used without responseType, we will also\n            // get unreadable data.\n            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n\n            if (isGarbage) {\n                throw new Error(\"Can't find end of central directory : is this a zip file ? \" +\n                                \"If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html\");\n            } else {\n                throw new Error(\"Corrupted zip: can't find end of central directory\");\n            }\n\n        }\n        this.reader.setIndex(offset);\n        var endOfCentralDirOffset = offset;\n        this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n        this.readBlockEndOfCentral();\n\n\n        /* extract from the zip spec :\n            4)  If one of the fields in the end of central directory\n                record is too small to hold required data, the field\n                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the\n                ZIP64 format record should be created.\n            5)  The end of central directory record and the\n                Zip64 end of central directory locator record must\n                reside on the same disk when splitting or spanning\n                an archive.\n         */\n        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n            this.zip64 = true;\n\n            /*\n            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from\n            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents\n            all numbers as 64-bit double precision IEEE 754 floating point numbers.\n            So, we have 53bits for integers and bitwise operations treat everything as 32bits.\n            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators\n            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5\n            */\n\n            // should look for a zip64 EOCD locator\n            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            if (offset < 0) {\n                throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n            }\n            this.reader.setIndex(offset);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            this.readBlockZip64EndOfCentralLocator();\n\n            // now the zip64 EOCD record\n            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n                // console.warn(\"ZIP64 end of central directory not where expected.\");\n                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n                    throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n                }\n            }\n            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n            this.readBlockZip64EndOfCentral();\n        }\n\n        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n        if (this.zip64) {\n            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator\n            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;\n        }\n\n        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n\n        if (extraBytes > 0) {\n            // console.warn(extraBytes, \"extra bytes at beginning or within zipfile\");\n            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n                // The offsets seem wrong, but we have something at the specified offset.\n                // So we keep it.\n            } else {\n                // the offset is wrong, update the \"zero\" of the reader\n                // this happens if data has been prepended (crx files for example)\n                this.reader.zero = extraBytes;\n            }\n        } else if (extraBytes < 0) {\n            throw new Error(\"Corrupted zip: missing \" + Math.abs(extraBytes) + \" bytes.\");\n        }\n    },\n    prepareReader: function(data) {\n        this.reader = readerFor(data);\n    },\n    /**\n     * Read a zip file and create ZipEntries.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.\n     */\n    load: function(data) {\n        this.prepareReader(data);\n        this.readEndOfCentral();\n        this.readCentralDir();\n        this.readLocalFiles();\n    }\n};\n// }}} end of ZipEntries\nmodule.exports = ZipEntries;\n","'use strict';\nvar readerFor = require('./reader/readerFor');\nvar utils = require('./utils');\nvar CompressedObject = require('./compressedObject');\nvar crc32fn = require('./crc32');\nvar utf8 = require('./utf8');\nvar compressions = require('./compressions');\nvar support = require('./support');\n\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nvar findCompression = function(compressionMethod) {\n    for (var method in compressions) {\n        if (!compressions.hasOwnProperty(method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntry(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n    /**\n     * say if the file is encrypted.\n     * @return {boolean} true if the file is encrypted, false otherwise.\n     */\n    isEncrypted: function() {\n        // bit 1 is set\n        return (this.bitFlag & 0x0001) === 0x0001;\n    },\n    /**\n     * say if the file has utf-8 filename/comment.\n     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n     */\n    useUTF8: function() {\n        // bit 11 is set\n        return (this.bitFlag & 0x0800) === 0x0800;\n    },\n    /**\n     * Read the local part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readLocalPart: function(reader) {\n        var compression, localExtraFieldsLength;\n\n        // we already know everything from the central dir !\n        // If the central dir data are false, we are doomed.\n        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n        // The less data we get here, the more reliable this should be.\n        // Let's skip the whole header and dash to the data !\n        reader.skip(22);\n        // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n        // Strangely, the filename here is OK.\n        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n        // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n        // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n        // the internet.\n        //\n        // I think I see the logic here : the central directory is used to display\n        // content and the local directory is used to extract the files. Mixing / and \\\n        // may be used to display \\ to windows users and use / when extracting the files.\n        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n        this.fileNameLength = reader.readInt(2);\n        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.\n        this.fileName = reader.readData(this.fileNameLength);\n        reader.skip(localExtraFieldsLength);\n\n        if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n            throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory \" + \"(compressedSize === -1 || uncompressedSize === -1)\");\n        }\n\n        compression = findCompression(this.compressionMethod);\n        if (compression === null) { // no compression found\n            throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + utils.transformTo(\"string\", this.fileName) + \")\");\n        }\n        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n    },\n\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readCentralPart: function(reader) {\n        this.versionMadeBy = reader.readInt(2);\n        reader.skip(2);\n        // this.versionNeeded = reader.readInt(2);\n        this.bitFlag = reader.readInt(2);\n        this.compressionMethod = reader.readString(2);\n        this.date = reader.readDate();\n        this.crc32 = reader.readInt(4);\n        this.compressedSize = reader.readInt(4);\n        this.uncompressedSize = reader.readInt(4);\n        var fileNameLength = reader.readInt(2);\n        this.extraFieldsLength = reader.readInt(2);\n        this.fileCommentLength = reader.readInt(2);\n        this.diskNumberStart = reader.readInt(2);\n        this.internalFileAttributes = reader.readInt(2);\n        this.externalFileAttributes = reader.readInt(4);\n        this.localHeaderOffset = reader.readInt(4);\n\n        if (this.isEncrypted()) {\n            throw new Error(\"Encrypted zip are not supported\");\n        }\n\n        // will be read in the local part, see the comments there\n        reader.skip(fileNameLength);\n        this.readExtraFields(reader);\n        this.parseZIP64ExtraField(reader);\n        this.fileComment = reader.readData(this.fileCommentLength);\n    },\n\n    /**\n     * Parse the external file attributes and get the unix/dos permissions.\n     */\n    processAttributes: function () {\n        this.unixPermissions = null;\n        this.dosPermissions = null;\n        var madeBy = this.versionMadeBy >> 8;\n\n        // Check if we have the DOS directory flag set.\n        // We look for it in the DOS and UNIX permissions\n        // but some unknown platform could set it as a compatibility flag.\n        this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n\n        if(madeBy === MADE_BY_DOS) {\n            // first 6 bits (0 to 5)\n            this.dosPermissions = this.externalFileAttributes & 0x3F;\n        }\n\n        if(madeBy === MADE_BY_UNIX) {\n            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;\n            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n        }\n\n        // fail safe : if the name ends with a / it probably means a folder\n        if (!this.dir && this.fileNameStr.slice(-1) === '/') {\n            this.dir = true;\n        }\n    },\n\n    /**\n     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n     * @param {DataReader} reader the reader to use.\n     */\n    parseZIP64ExtraField: function(reader) {\n\n        if (!this.extraFields[0x0001]) {\n            return;\n        }\n\n        // should be something, preparing the extra reader\n        var extraReader = readerFor(this.extraFields[0x0001].value);\n\n        // I really hope that these 64bits integer can fit in 32 bits integer, because js\n        // won't let us have more.\n        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n            this.uncompressedSize = extraReader.readInt(8);\n        }\n        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n            this.compressedSize = extraReader.readInt(8);\n        }\n        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n            this.localHeaderOffset = extraReader.readInt(8);\n        }\n        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n            this.diskNumberStart = extraReader.readInt(4);\n        }\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readExtraFields: function(reader) {\n        var end = reader.index + this.extraFieldsLength,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n\n        if (!this.extraFields) {\n            this.extraFields = {};\n        }\n\n        while (reader.index + 4 < end) {\n            extraFieldId = reader.readInt(2);\n            extraFieldLength = reader.readInt(2);\n            extraFieldValue = reader.readData(extraFieldLength);\n\n            this.extraFields[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n\n        reader.setIndex(end);\n    },\n    /**\n     * Apply an UTF8 transformation if needed.\n     */\n    handleUTF8: function() {\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        if (this.useUTF8()) {\n            this.fileNameStr = utf8.utf8decode(this.fileName);\n            this.fileCommentStr = utf8.utf8decode(this.fileComment);\n        } else {\n            var upath = this.findExtraFieldUnicodePath();\n            if (upath !== null) {\n                this.fileNameStr = upath;\n            } else {\n                // ASCII text or unsupported code page\n                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);\n                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n            }\n\n            var ucomment = this.findExtraFieldUnicodeComment();\n            if (ucomment !== null) {\n                this.fileCommentStr = ucomment;\n            } else {\n                // ASCII text or unsupported code page\n                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);\n                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n            }\n        }\n    },\n\n    /**\n     * Find the unicode path declared in the extra field, if any.\n     * @return {String} the unicode path, null otherwise.\n     */\n    findExtraFieldUnicodePath: function() {\n        var upathField = this.extraFields[0x7075];\n        if (upathField) {\n            var extraReader = readerFor(upathField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the filename changed, this field is out of date.\n            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return utf8.utf8decode(extraReader.readData(upathField.length - 5));\n        }\n        return null;\n    },\n\n    /**\n     * Find the unicode comment declared in the extra field, if any.\n     * @return {String} the unicode comment, null otherwise.\n     */\n    findExtraFieldUnicodeComment: function() {\n        var ucommentField = this.extraFields[0x6375];\n        if (ucommentField) {\n            var extraReader = readerFor(ucommentField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the comment changed, this field is out of date.\n            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));\n        }\n        return null;\n    }\n};\nmodule.exports = ZipEntry;\n","'use strict';\n\nvar StreamHelper = require('./stream/StreamHelper');\nvar DataWorker = require('./stream/DataWorker');\nvar utf8 = require('./utf8');\nvar CompressedObject = require('./compressedObject');\nvar GenericWorker = require('./stream/GenericWorker');\n\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nvar ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n\n    this._data = data;\n    this._dataBinary = options.binary;\n    // keep only the compression\n    this.options = {\n        compression : options.compression,\n        compressionOptions : options.compressionOptions\n    };\n};\n\nZipObject.prototype = {\n    /**\n     * Create an internal stream for the content of this object.\n     * @param {String} type the type of each chunk.\n     * @return StreamHelper the stream.\n     */\n    internalStream: function (type) {\n        var result = null, outputType = \"string\";\n        try {\n            if (!type) {\n                throw new Error(\"No output type specified.\");\n            }\n            outputType = type.toLowerCase();\n            var askUnicodeString = outputType === \"string\" || outputType === \"text\";\n            if (outputType === \"binarystring\" || outputType === \"text\") {\n                outputType = \"string\";\n            }\n            result = this._decompressWorker();\n\n            var isUnicodeString = !this._dataBinary;\n\n            if (isUnicodeString && !askUnicodeString) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            if (!isUnicodeString && askUnicodeString) {\n                result = result.pipe(new utf8.Utf8DecodeWorker());\n            }\n        } catch (e) {\n            result = new GenericWorker(\"error\");\n            result.error(e);\n        }\n\n        return new StreamHelper(result, outputType, \"\");\n    },\n\n    /**\n     * Prepare the content in the asked type.\n     * @param {String} type the type of the result.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Promise the promise of the result.\n     */\n    async: function (type, onUpdate) {\n        return this.internalStream(type).accumulate(onUpdate);\n    },\n\n    /**\n     * Prepare the content as a nodejs stream.\n     * @param {String} type the type of each chunk.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Stream the stream.\n     */\n    nodeStream: function (type, onUpdate) {\n        return this.internalStream(type || \"nodebuffer\").toNodejsStream(onUpdate);\n    },\n\n    /**\n     * Return a worker for the compressed content.\n     * @private\n     * @param {Object} compression the compression object to use.\n     * @param {Object} compressionOptions the options to use when compressing.\n     * @return Worker the worker.\n     */\n    _compressWorker: function (compression, compressionOptions) {\n        if (\n            this._data instanceof CompressedObject &&\n            this._data.compression.magic === compression.magic\n        ) {\n            return this._data.getCompressedWorker();\n        } else {\n            var result = this._decompressWorker();\n            if(!this._dataBinary) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n        }\n    },\n    /**\n     * Return a worker for the decompressed content.\n     * @private\n     * @return Worker the worker.\n     */\n    _decompressWorker : function () {\n        if (this._data instanceof CompressedObject) {\n            return this._data.getContentWorker();\n        } else if (this._data instanceof GenericWorker) {\n            return this._data;\n        } else {\n            return new DataWorker(this._data);\n        }\n    }\n};\n\nvar removedMethods = [\"asText\", \"asBinary\", \"asNodeBuffer\", \"asUint8Array\", \"asArrayBuffer\"];\nvar removedFn = function () {\n    throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n};\n\nfor(var i = 0; i < removedMethods.length; i++) {\n    ZipObject.prototype[removedMethods[i]] = removedFn;\n}\nmodule.exports = ZipObject;\n","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"finally\"] = function (callback) {\n  if (typeof callback !== 'function') {\n    return this;\n  }\n  var p = this.constructor;\n  return this.then(resolve, reject);\n\n  function resolve(value) {\n    function yes () {\n      return value;\n    }\n    return p.resolve(callback()).then(yes);\n  }\n  function reject(reason) {\n    function no () {\n      throw reason;\n    }\n    return p.resolve(callback()).then(no);\n  }\n};\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n","// Top level file is just a mixin of submodules & constants\n'use strict';\n\nvar assign    = require('./lib/utils/common').assign;\n\nvar deflate   = require('./lib/deflate');\nvar inflate   = require('./lib/inflate');\nvar constants = require('./lib/zlib/constants');\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n","'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n","'use strict';\n\n\nvar zlib_inflate = require('./zlib/inflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar c            = require('./zlib/constants');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\nvar GZheader     = require('./zlib/gzheader');\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n","'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n","// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n","'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n","'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = require('../utils/common');\nvar adler32       = require('./adler32');\nvar crc32         = require('./crc32');\nvar inflate_fast  = require('./inffast');\nvar inflate_table = require('./inftrees');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = require('../utils/common');\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n","'use strict';\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = require('./lib/_stream_duplex.js');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","module.exports = require('events').EventEmitter;\n","module.exports = require('./readable').PassThrough\n","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","module.exports = require('./readable').Transform\n","module.exports = require('./lib/_stream_writable.js');\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","'use strict';\nmodule.exports = typeof setImmediate === 'function' ? setImmediate :\n\tfunction setImmediate() {\n\t\tvar args = [].slice.apply(arguments);\n\t\targs.splice(1, 0, 0);\n\t\tsetTimeout.apply(null, args);\n\t};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","import JSZip from \"jszip\";\r\nimport {IuploadfileList} from \"./ICommon\";\r\nimport {getBinaryContent} from \"./common/method\"\r\n\r\n\r\nexport class HandleZip{\r\n    uploadFile:File; \r\n    workBook:JSZip; \r\n    \r\n    constructor(file?:File){\r\n        // Support nodejs fs to read files\r\n        // if(file instanceof File){\r\n            this.uploadFile = file;\r\n        // }\r\n    }\r\n\r\n    unzipFile(successFunc:(file:IuploadfileList)=>void, errorFunc:(err:Error)=>void):void { \r\n        // var new_zip:JSZip = new JSZip();\r\n        JSZip.loadAsync(this.uploadFile)                                   // 1) read the Blob\r\n        .then(function(zip:any) {\r\n            let fileList:IuploadfileList = <IuploadfileList>{}, lastIndex:number = Object.keys(zip.files).length, index:number=0;\r\n            zip.forEach(function (relativePath:any, zipEntry:any) {  // 2) print entries\r\n                let fileName = zipEntry.name;\r\n                let fileNameArr = fileName.split(\".\");\r\n                let suffix = fileNameArr[fileNameArr.length-1].toLowerCase();\r\n                let fileType = \"string\";\r\n                if(suffix in {\"png\":1, \"jpeg\":1, \"jpg\":1, \"gif\":1,\"bmp\":1,\"tif\":1,\"webp\":1,}){\r\n                    fileType = \"base64\";\r\n                }\r\n                else if(suffix==\"emf\"){\r\n                    fileType = \"arraybuffer\";\r\n                }\r\n                zipEntry.async(fileType).then(function (data:string) {\r\n                    if(fileType==\"base64\"){\r\n                        data = \"data:image/\"+ suffix +\";base64,\" + data;\r\n                    }\r\n                    fileList[zipEntry.name] = data;\r\n                    // console.log(lastIndex, index);\r\n                    if(lastIndex==index+1){\r\n                        successFunc(fileList);\r\n                    }\r\n                    index++;\r\n                });\r\n            });\r\n            \r\n        }, function (e:Error) {\r\n            errorFunc(e);\r\n        });\r\n    }\r\n\r\n    unzipFileByUrl(url:string,successFunc:(file:IuploadfileList)=>void, errorFunc:(err:Error)=>void):void { \r\n        var new_zip:JSZip = new JSZip();\r\n        getBinaryContent(url, function(err:any, data:any) {\r\n            if(err) {\r\n                throw err; // or handle err\r\n            }\r\n        \r\n            JSZip.loadAsync(data).then(function(zip:any) {\r\n                let fileList:IuploadfileList = <IuploadfileList>{}, lastIndex:number = Object.keys(zip.files).length, index:number=0;\r\n                zip.forEach(function (relativePath:any, zipEntry:any) {  // 2) print entries\r\n                    let fileName = zipEntry.name;\r\n                    let fileNameArr = fileName.split(\".\");\r\n                    let suffix = fileNameArr[fileNameArr.length-1].toLowerCase();\r\n                    let fileType = \"string\";\r\n                    if(suffix in {\"png\":1, \"jpeg\":1, \"jpg\":1, \"gif\":1,\"bmp\":1,\"tif\":1,\"webp\":1,}){\r\n                        fileType = \"base64\";\r\n                    }\r\n                    else if(suffix==\"emf\"){\r\n                        fileType = \"arraybuffer\";\r\n                    }\r\n                    zipEntry.async(fileType).then(function (data:any) {\r\n                        if(fileType==\"base64\"){\r\n                            data = \"data:image/\"+ suffix +\";base64,\" + data;\r\n                        }\r\n                        fileList[zipEntry.name] = data;\r\n                        // console.log(lastIndex, index);\r\n                        if(lastIndex==index+1){\r\n                            successFunc(fileList);\r\n                        }\r\n                        index++;\r\n                    });\r\n                });\r\n                \r\n            }, function (e:Error) {\r\n                errorFunc(e);\r\n            });\r\n        });\r\n        \r\n    }\r\n\r\n    newZipFile():void { \r\n        var zip = new JSZip();\r\n        this.workBook =  zip;\r\n    }\r\n\r\n    //title:\"nested/hello.txt\", content:\"Hello Worldasdfasfasdfasfasfasfasfasdfas\"\r\n    addToZipFile(title:string,content:string):void { \r\n        if(this.workBook==null){\r\n            var zip = new JSZip();\r\n            this.workBook =  zip;\r\n        }\r\n        this.workBook.file(title, content);\r\n    }\r\n}","import { ILuckyFile, ILuckyFileInfo,IluckySheet,IluckySheetCelldata,IluckySheetConfig,IluckySheetCelldataValue,IluckySheetCelldataValueMerge,ILuckySheetCellFormat,IluckySheetConfigMerges,IluckySheetConfigMerge,IMapluckySheetborderInfoCellForImp,IluckySheetborderInfoCellValue,IluckySheetborderInfoCellValueStyle,IluckySheetborderInfoCellForImp,IluckySheetRowAndColumnLen,IluckySheetRowAndColumnHidden,IluckySheetSelection,IluckysheetFrozen,IluckySheetChart,IluckySheetPivotTable,IluckysheetConditionFormat,IluckysheetCalcChain,ILuckyInlineString,IluckyImage,IluckyImageBorder,IluckyImageCrop,IluckyImageDefault,IluckyImages, IluckysheetHyperlink, IluckysheetDataVerification} from \"./ILuck\";\r\n\r\n\r\n\r\nexport class LuckyFileBase implements ILuckyFile {\r\n    info:ILuckyFileInfo\r\n    sheets:IluckySheet[]\r\n}\r\n\r\nexport class LuckySheetBase implements IluckySheet{\r\n    name:string\r\n    color:string\r\n    config:IluckySheetConfig\r\n    index:string\r\n    status:string\r\n    order:string\r\n    row:number\r\n    column:number\r\n    luckysheet_select_save:IluckySheetSelection[]\r\n    scrollLeft:number\r\n    scrollTop:number\r\n    zoomRatio:number\r\n    showGridLines:string\r\n    defaultColWidth:number\r\n    defaultRowHeight:number\r\n\r\n    celldata:IluckySheetCelldata[]\r\n    chart:IluckySheetChart[]\r\n\r\n    isPivotTable:boolean\r\n    pivotTable:IluckySheetPivotTable\r\n\r\n    luckysheet_conditionformat_save:IluckysheetConditionFormat[]\r\n    freezen:IluckysheetFrozen\r\n\r\n    calcChain:IluckysheetCalcChain[]\r\n\r\n    images:IluckyImages\r\n    \r\n    dataVerification: IluckysheetDataVerification;\r\n    hyperlink: IluckysheetHyperlink\r\n    hide: number;\r\n    \r\n}\r\n\r\nexport class LuckyFileInfo implements ILuckyFileInfo{\r\n    name:string\r\n    creator:string\r\n    lastmodifiedby:string\r\n    createdTime:string\r\n    modifiedTime:string\r\n    company:string\r\n    appversion:string\r\n}\r\n\r\nexport class LuckySheetCelldataBase implements IluckySheetCelldata{\r\n    r:number\r\n    c:number\r\n    v:IluckySheetCelldataValue | string | null\r\n}\r\n\r\nexport class LuckySheetCelldataValue implements IluckySheetCelldataValue{\r\n    ct: LuckySheetCellFormat | undefined //celltype,Cell value format: text, time, etc. numfmts\r\n    bg: string | undefined//background,#fff000,\tfill\r\n    ff: string | undefined//fontfamily, fonts\r\n    fc: string | undefined//fontcolor fonts\r\n    bl: number | undefined//Bold, fonts\r\n    it: number | undefined//italic, fonts\r\n    fs: number | undefined//font size, fonts\r\n    cl: number | undefined//strike, 0 Regular, 1 strikes, fonts\r\n    un: number | undefined//underline, 0 Regular, 1 underlines, fonts\r\n    vt: number | undefined//Vertical alignment, 0 middle, 1 up, 2 down, alignment\r\n    ht: number | undefined//Horizontal alignment,0 center, 1 left, 2 right, alignment\r\n    mc: IluckySheetCelldataValueMerge | undefined //Merge Cells, mergeCells\r\n    tr: number | undefined //Text rotation,0: 03 Vertical text alignment\r\n    tb: number | undefined //Text wrap,0 truncation, 1 overflow, 2 word wrap, alignment\r\n    v: string | undefined //Original value, v\r\n    m: string | undefined //Display value, v\r\n    f: string | undefined //formula, f\r\n    rt:number | undefined //text rotation angle 0-180 alignment\r\n    qp:number | undefined //quotePrefix, show number as string\r\n}\r\n\r\n\r\nexport class LuckySheetCellFormat implements ILuckySheetCellFormat {\r\n    fa:string\r\n    t:string\r\n    s:LuckyInlineString[] | undefined\r\n}\r\n\r\nexport class LuckyInlineString implements ILuckyInlineString {\r\n    ff:string | undefined //font family\r\n    fc:string | undefined//font color\r\n    fs:number | undefined//font size\r\n    cl:number | undefined//strike\r\n    un:number | undefined//underline\r\n    bl:number | undefined//blod\r\n    it:number | undefined//italic\r\n    va:number | undefined//1sub and 2super and 0none\r\n    v:string | undefined\r\n}\r\n\r\nexport class LuckyConfig implements IluckySheetConfig{\r\n    merge:IluckySheetConfigMerges\r\n    borderInfo:IluckySheetborderInfoCellForImp[]\r\n    // _borderInfo: IMapluckySheetborderInfoCellForImp\r\n    rowlen:IluckySheetRowAndColumnLen\r\n    columnlen:IluckySheetRowAndColumnLen\r\n    rowhidden:IluckySheetRowAndColumnHidden\r\n    colhidden:IluckySheetRowAndColumnHidden\r\n\r\n    customHeight:IluckySheetRowAndColumnHidden\r\n    customWidth:IluckySheetRowAndColumnHidden\r\n}\r\n\r\nexport class LuckySheetborderInfoCellForImp implements IluckySheetborderInfoCellForImp{\r\n    rangeType:string\r\n    // cells:string[]\r\n    value:IluckySheetborderInfoCellValue\r\n}\r\n\r\nexport class LuckySheetborderInfoCellValue implements IluckySheetborderInfoCellValue{\r\n    row_index: number\r\n    col_index: number\r\n    l: IluckySheetborderInfoCellValueStyle\r\n    r: IluckySheetborderInfoCellValueStyle\r\n    t: IluckySheetborderInfoCellValueStyle\r\n    b: IluckySheetborderInfoCellValueStyle\r\n}\r\n\r\nexport class LuckySheetborderInfoCellValueStyle implements IluckySheetborderInfoCellValueStyle{\r\n    \"style\": number\r\n    \"color\": string\r\n}\r\n\r\nexport class LuckySheetConfigMerge implements IluckySheetConfigMerge{\r\n    r: number\r\n    c: number\r\n    rs: number\r\n    cs: number\r\n}\r\n\r\nexport class LuckysheetCalcChain implements IluckysheetCalcChain{\r\n    r:number\r\n    c:number\r\n    index:string | undefined\r\n}\r\n\r\n\r\nexport class LuckyImageBase implements IluckyImage{\r\n    border: IluckyImageBorder\r\n    crop: IluckyImageCrop\r\n    default: IluckyImageDefault\r\n\r\n    fixedLeft: number\r\n    fixedTop: number\r\n    isFixedPos: Boolean\r\n    originHeight: number\r\n    originWidth: number\r\n    src: string\r\n    type: string\r\n}","import { IluckySheetborderInfoCellForImp,IluckySheetCelldataValue,IluckySheetCelldataValueMerge,ILuckySheetCellFormat } from \"./ILuck\";\r\nimport { ReadXml, Element, IStyleCollections,getColor,getlineStringAttr } from \"./ReadXml\";\r\nimport {getXmlAttibute, getColumnWidthPixel, getRowHeightPixel,getcellrange, escapeCharacter, isChinese, isJapanese, isKoera,isContainMultiType} from \"../common/method\";\r\nimport { ST_CellType, indexedColors, OEM_CHARSET,borderTypes,fontFamilys } from \"../common/constant\"\r\nimport { IattributeList, stringToNum } from \"../ICommon\";\r\nimport { LuckySheetborderInfoCellValueStyle,LuckySheetborderInfoCellForImp,LuckySheetborderInfoCellValue,LuckySheetCelldataBase,LuckySheetCelldataValue,LuckySheetCellFormat,LuckyInlineString } from \"./LuckyBase\";\r\n\r\nexport class LuckySheetCelldata extends LuckySheetCelldataBase{\r\n    _borderObject:IluckySheetborderInfoCellForImp\r\n    _fomulaRef:string\r\n    _formulaSi:string\r\n    _formulaType:string\r\n\r\n    private sheetFile:string\r\n    private readXml:ReadXml\r\n    private cell:Element\r\n    private styles:IStyleCollections\r\n    private sharedStrings:Element[]\r\n    private mergeCells:Element[]\r\n\r\n    constructor(cell:Element, styles:IStyleCollections, sharedStrings:Element[], mergeCells:Element[], sheetFile:string, ReadXml:ReadXml){\r\n        //Private\r\n        super();\r\n        this.cell = cell;\r\n        this.sheetFile = sheetFile;\r\n        this.styles = styles;\r\n        this.sharedStrings = sharedStrings;\r\n        this.readXml = ReadXml;\r\n        this.mergeCells = mergeCells;\r\n\r\n        let attrList = cell.attributeList;\r\n        let r = attrList.r, s = attrList.s, t = attrList.t;\r\n        let range = getcellrange(r);\r\n\r\n        this.r = range.row[0];\r\n        this.c = range.column[0];\r\n        this.v = this.generateValue(s, t);\r\n\r\n    }\r\n\r\n    /**\r\n    * @param s Style index ,start 1\r\n    * @param t Cell type, Optional value is ST_CellType, it's found at constat.ts\r\n    */\r\n    private generateValue(s:string, t:string){\r\n        let v = this.cell.getInnerElements(\"v\");\r\n        let f = this.cell.getInnerElements(\"f\");\r\n\r\n        if(v==null){\r\n            v = this.cell.getInnerElements(\"t\");\r\n        }\r\n\r\n        let cellXfs = this.styles[\"cellXfs\"] as Element[];\r\n        let cellStyleXfs = this.styles[\"cellStyleXfs\"] as Element[];\r\n        let cellStyles = this.styles[\"cellStyles\"] as Element[];\r\n        let fonts = this.styles[\"fonts\"] as Element[];\r\n        let fills = this.styles[\"fills\"] as Element[];\r\n        let borders = this.styles[\"borders\"] as Element[];\r\n        let numfmts = this.styles[\"numfmts\"] as IattributeList;\r\n        let clrScheme = this.styles[\"clrScheme\"] as Element[];\r\n\r\n        let sharedStrings = this.sharedStrings;\r\n        let cellValue = new LuckySheetCelldataValue();\r\n\r\n        if(f!=null){\r\n            let formula = f[0], attrList = formula.attributeList;\r\n            let t = attrList.t, ref = attrList.ref, si = attrList.si;\r\n            let formulaValue =f[0].value;\r\n            if(t==\"shared\"){\r\n                this._fomulaRef = ref;\r\n                this._formulaType = t;\r\n                this._formulaSi = si;\r\n            }\r\n            // console.log(ref, t, si);\r\n            if(ref!=null || (formulaValue!=null && formulaValue.length>0)){\r\n                formulaValue = escapeCharacter(formulaValue);\r\n                cellValue.f = \"=\" + formulaValue;\r\n            }\r\n\r\n        }\r\n\r\n        let familyFont = null;\r\n        let quotePrefix;\r\n        if(s!=null){\r\n            let sNum = parseInt(s);\r\n            let cellXf = cellXfs[sNum];\r\n            let xfId = cellXf.attributeList.xfId;\r\n\r\n            let numFmtId,fontId,fillId,borderId;\r\n            let horizontal,vertical, wrapText, textRotation, shrinkToFit, indent,applyProtection;\r\n\r\n            if(xfId!=null){\r\n                let cellStyleXf = cellStyleXfs[parseInt(xfId)];\r\n                let attrList = cellStyleXf.attributeList;\r\n\r\n                let applyNumberFormat = attrList.applyNumberFormat;\r\n                let applyFont = attrList.applyFont;\r\n                let applyFill = attrList.applyFill;\r\n                let applyBorder = attrList.applyBorder;\r\n                let applyAlignment = attrList.applyAlignment;\r\n                // let applyProtection = attrList.applyProtection;\r\n\r\n                applyProtection = attrList.applyProtection;\r\n                quotePrefix = attrList.quotePrefix;\r\n\r\n                if(applyNumberFormat!=\"0\" && attrList.numFmtId!=null){\r\n                    // if(attrList.numFmtId!=\"0\"){\r\n                        numFmtId = attrList.numFmtId;\r\n                    // }\r\n                }\r\n                if(applyFont!=\"0\" && attrList.fontId!=null){\r\n                    fontId = attrList.fontId;\r\n                }\r\n                if(applyFill!=\"0\" && attrList.fillId!=null){\r\n                    fillId = attrList.fillId;\r\n                }\r\n                if(applyBorder!=\"0\" && attrList.borderId!=null){\r\n                    borderId = attrList.borderId;\r\n                }\r\n                if(applyAlignment!=null && applyAlignment!=\"0\"){\r\n                    let alignment = cellStyleXf.getInnerElements(\"alignment\");\r\n                    if(alignment!=null){\r\n                        let attrList = alignment[0].attributeList;\r\n                        if(attrList.horizontal!=null){\r\n                            horizontal = attrList.horizontal;\r\n                        }\r\n                        if(attrList.vertical!=null){\r\n                            vertical = attrList.vertical;\r\n                        }\r\n                        if(attrList.wrapText!=null){\r\n                            wrapText = attrList.wrapText;\r\n                        }\r\n                        if(attrList.textRotation!=null){\r\n                            textRotation = attrList.textRotation;\r\n                        }\r\n                        if(attrList.shrinkToFit!=null){\r\n                            shrinkToFit = attrList.shrinkToFit;\r\n                        }\r\n                        if(attrList.indent!=null){\r\n                            indent = attrList.indent;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            let applyNumberFormat = cellXf.attributeList.applyNumberFormat;\r\n            let applyFont = cellXf.attributeList.applyFont;\r\n            let applyFill = cellXf.attributeList.applyFill;\r\n            let applyBorder = cellXf.attributeList.applyBorder;\r\n            let applyAlignment = cellXf.attributeList.applyAlignment;\r\n\r\n            if(cellXf.attributeList.applyProtection!=null){\r\n                applyProtection = cellXf.attributeList.applyProtection;\r\n            }\r\n\r\n            if(cellXf.attributeList.quotePrefix!=null){\r\n                quotePrefix = cellXf.attributeList.quotePrefix;\r\n            }\r\n\r\n            if(applyNumberFormat!=\"0\" && cellXf.attributeList.numFmtId!=null){\r\n                numFmtId = cellXf.attributeList.numFmtId;\r\n            }\r\n            if(applyFont!=\"0\"){\r\n                fontId = cellXf.attributeList.fontId;\r\n            }\r\n            if(applyFill!=\"0\"){\r\n                fillId = cellXf.attributeList.fillId;\r\n            }\r\n            if(applyBorder!=\"0\"){\r\n                borderId =cellXf.attributeList.borderId;\r\n            }\r\n            if(applyAlignment!=\"0\"){\r\n                let alignment = cellXf.getInnerElements(\"alignment\");\r\n                if(alignment!=null && alignment.length>0){\r\n                    let attrList = alignment[0].attributeList;\r\n                    if(attrList.horizontal!=null){\r\n                        horizontal = attrList.horizontal;\r\n                    }\r\n                    if(attrList.vertical!=null){\r\n                        vertical = attrList.vertical;\r\n                    }\r\n                    if(attrList.wrapText!=null){\r\n                        wrapText = attrList.wrapText;\r\n                    }\r\n                    if(attrList.textRotation!=null){\r\n                        textRotation = attrList.textRotation;\r\n                    }\r\n                    if(attrList.shrinkToFit!=null){\r\n                        shrinkToFit = attrList.shrinkToFit;\r\n                    }\r\n                    if(attrList.indent!=null){\r\n                        indent = attrList.indent;\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n\r\n            if(numFmtId!=undefined){\r\n                let numf = numfmts[parseInt(numFmtId)];\r\n                let cellFormat = new LuckySheetCellFormat();\r\n                cellFormat.fa = escapeCharacter(numf);\r\n                // console.log(numf, numFmtId, this.v);\r\n                cellFormat.t = t || 'd';\r\n                cellValue.ct = cellFormat;\r\n            }\r\n\r\n            if(fillId!=undefined){\r\n                let fillIdNum = parseInt(fillId);\r\n                let fill  = fills[fillIdNum];\r\n                // console.log(cellValue.v);\r\n                let bg = this.getBackgroundByFill(fill, clrScheme);\r\n                if(bg!=null){\r\n                    cellValue.bg = bg;\r\n                }\r\n            }\r\n\r\n\r\n            if(fontId!=undefined){\r\n                let fontIdNum = parseInt(fontId);\r\n                let font = fonts[fontIdNum];\r\n                if(font!=null){\r\n                    let sz = font.getInnerElements(\"sz\");//font size\r\n                    let colors = font.getInnerElements(\"color\");//font color\r\n                    let family = font.getInnerElements(\"name\");//font family\r\n                    let familyOverrides = font.getInnerElements(\"family\");//font family will be overrided by name\r\n                    let charset = font.getInnerElements(\"charset\");//font charset\r\n                    let bolds = font.getInnerElements(\"b\");//font bold\r\n                    let italics = font.getInnerElements(\"i\");//font italic\r\n                    let strikes = font.getInnerElements(\"strike\");//font italic\r\n                    let underlines = font.getInnerElements(\"u\");//font italic\r\n\r\n                    if(sz!=null && sz.length>0){\r\n                        let fs = sz[0].attributeList.val;\r\n                        if(fs!=null){\r\n                            cellValue.fs = parseInt(fs);\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(colors!=null && colors.length>0){\r\n                        let color = colors[0];\r\n                        let fc = getColor(color, this.styles, \"t\");\r\n                        if(fc!=null){\r\n                            cellValue.fc = fc;\r\n                        }\r\n                    }\r\n\r\n\r\n                    if(familyOverrides!=null && familyOverrides.length>0){\r\n                        let val = familyOverrides[0].attributeList.val;\r\n                        if(val!=null){\r\n                            familyFont = fontFamilys[val];\r\n                        }\r\n                    }\r\n\r\n                    if(family!=null && family.length>0){\r\n                        let val = family[0].attributeList.val;\r\n                        if(val!=null){\r\n                            cellValue.ff = val;\r\n                        }\r\n                    }\r\n\r\n\r\n                    if(bolds!=null && bolds.length>0){\r\n                        let bold = bolds[0].attributeList.val;\r\n                        if(bold==\"0\"){\r\n                            cellValue.bl =  0;\r\n                        }\r\n                        else{\r\n                            cellValue.bl =  1;\r\n                        }\r\n                    }\r\n\r\n                    if(italics!=null && italics.length>0){\r\n                        let italic = italics[0].attributeList.val;\r\n                        if(italic==\"0\"){\r\n                            cellValue.it =  0;\r\n                        }\r\n                        else{\r\n                            cellValue.it =  1;\r\n                        }\r\n                    }\r\n\r\n                    if(strikes!=null && strikes.length>0){\r\n                        let strike = strikes[0].attributeList.val;\r\n                        if(strike==\"0\"){\r\n                            cellValue.cl =  0;\r\n                        }\r\n                        else{\r\n                            cellValue.cl =  1;\r\n                        }\r\n                    }\r\n\r\n                    if(underlines!=null&&underlines.length>0){\r\nletunderline=underlines[0].attributeList.val;\r\nif(underline==\"single\"){\r\ncellValue.un=1;\r\n}\r\nelseif(underline==\"double\"){\r\ncellValue.un=2;\r\n}\r\nelseif(underline==\"singleAccounting\"){\r\ncellValue.un=3;\r\n}\r\nelseif(underline==\"doubleAccounting\"){\r\ncellValue.un=4;\r\n}\r\nelse{\r\ncellValue.un=0;\r\n}\r\n}\r\n                }\r\n            }\r\n\r\n            // vt: number | undefined//Vertical alignment, 0 middle, 1 up, 2 down, alignment\r\n            // ht: number | undefined//Horizontal alignment,0 center, 1 left, 2 right, alignment\r\n            // tr: number | undefined //Text rotation,0: 01: 45 2: -453 Vertical text4: 90 5: -90, alignment\r\n            // tb: number | undefined //Text wrap,0 truncation, 1 overflow, 2 word wrap, alignment\r\n\r\n            if(horizontal!=undefined){//Horizontal alignment\r\n                if(horizontal==\"center\"){\r\n                    cellValue.ht = 0;\r\n                }\r\n                else if(horizontal==\"centerContinuous\"){\r\n                    cellValue.ht = 0;//luckysheet unsupport\r\n                }\r\n                else if(horizontal==\"left\"){\r\n                    cellValue.ht = 1;\r\n                }\r\n                else if(horizontal==\"right\"){\r\n                    cellValue.ht = 2;\r\n                }\r\n                else if(horizontal==\"distributed\"){\r\n                    cellValue.ht = 0;//luckysheet unsupport\r\n                }\r\n                else if(horizontal==\"fill\"){\r\n                    cellValue.ht = 1;//luckysheet unsupport\r\n                }\r\n                else if(horizontal==\"general\"){\r\n                    cellValue.ht = 1;//luckysheet unsupport\r\n                }\r\n                else if(horizontal==\"justify\"){\r\n                    cellValue.ht = 0;//luckysheet unsupport\r\n                }\r\n                else{\r\n                    cellValue.ht = 1;\r\n                }\r\n            }\r\n\r\n            if(vertical!=undefined){//Vertical alignment\r\n                if(vertical==\"bottom\"){\r\n                    cellValue.vt = 2;\r\n                }\r\n                else if(vertical==\"center\"){\r\n                    cellValue.vt = 0;\r\n                }\r\n                else if(vertical==\"distributed\"){\r\n                    cellValue.vt = 0;//luckysheet unsupport\r\n                }\r\n                else if(vertical==\"justify\"){\r\n                    cellValue.vt = 0;//luckysheet unsupport\r\n                }\r\n                else if(vertical==\"top\"){\r\n                    cellValue.vt = 1;\r\n                }\r\n                else{\r\n                    cellValue.vt = 1;\r\n                }\r\n            }\r\n            else {\r\n                //sometimes bottom style is lost after setting it in excel\r\n                //when vertical is undefined set it to 2.\r\n                cellValue.vt = 2;\r\n            }\r\n\r\n            if(wrapText!=undefined){\r\n                if(wrapText==\"1\"){\r\n                    cellValue.tb = 2;\r\n                }\r\n                else{\r\n                    cellValue.tb = 1;\r\n                }\r\n            }\r\n            else{\r\n                cellValue.tb = 1;\r\n            }\r\n\r\n            if(textRotation!=undefined){\r\n                // tr: number | undefined //Text rotation,0: 01: 45 2: -453 Vertical text4: 90 5: -90, alignment\r\n                if(textRotation==\"255\"){\r\n                    cellValue.tr = 3;\r\n                }\r\n                // else if(textRotation==\"45\"){\r\n                //     cellValue.tr = 1;\r\n                // }\r\n                // else if(textRotation==\"90\"){\r\n                //     cellValue.tr = 4;\r\n                // }\r\n                // else if(textRotation==\"135\"){\r\n                //     cellValue.tr = 2;\r\n                // }\r\n                // else if(textRotation==\"180\"){\r\n                //     cellValue.tr = 5;\r\n                // }\r\n                else{\r\n                    cellValue.tr = 0;\r\n                    cellValue.rt =  parseInt(textRotation);\r\n                }\r\n\r\n\r\n            }\r\n\r\n            if(shrinkToFit!=undefined){//luckysheet unsupport\r\n\r\n            }\r\n\r\n            if(indent!=undefined){//luckysheet unsupport\r\n\r\n            }\r\n\r\n            if(borderId!=undefined){\r\n                let borderIdNum = parseInt(borderId);\r\n                let border = borders[borderIdNum];\r\n                // this._borderId = borderIdNum;\r\n\r\n                let borderObject = new LuckySheetborderInfoCellForImp();\r\n                borderObject.rangeType = \"cell\";\r\n                // borderObject.cells = [];\r\n                let borderCellValue = new LuckySheetborderInfoCellValue();\r\n\r\n                borderCellValue.row_index = this.r;\r\n                borderCellValue.col_index = this.c;\r\n\r\n                let lefts = border.getInnerElements(\"left\");\r\n                let rights = border.getInnerElements(\"right\");\r\n                let tops = border.getInnerElements(\"top\");\r\n                let bottoms = border.getInnerElements(\"bottom\");\r\n                let diagonals = border.getInnerElements(\"diagonal\");\r\n\r\n                let starts = border.getInnerElements(\"start\");\r\n                let ends = border.getInnerElements(\"end\");\r\n\r\n                let left = this.getBorderInfo(lefts);\r\n                let right = this.getBorderInfo(rights);\r\n                let top = this.getBorderInfo(tops);\r\n                let bottom = this.getBorderInfo(bottoms);\r\n                let diagonal = this.getBorderInfo(diagonals);\r\n\r\n                let start = this.getBorderInfo(starts);\r\n                let end = this.getBorderInfo(ends);\r\n\r\n                let isAdd = false;\r\n\r\n                if(start!=null && start.color!=null){\r\n                    borderCellValue.l = start;\r\n                    isAdd = true;\r\n                }\r\n\r\n                if(end!=null && end.color!=null){\r\n                    borderCellValue.r = end;\r\n                    isAdd = true;\r\n                }\r\n\r\n                if(left!=null && left.color!=null){\r\n                    borderCellValue.l = left;\r\n                    isAdd = true;\r\n                }\r\n\r\n                if(right!=null && right.color!=null){\r\n                    borderCellValue.r = right;\r\n                    isAdd = true;\r\n                }\r\n\r\n                if(top!=null && top.color!=null){\r\n                    borderCellValue.t = top;\r\n                    isAdd = true;\r\n                }\r\n\r\n                if(bottom!=null && bottom.color!=null){\r\n                    borderCellValue.b = bottom;\r\n                    isAdd = true;\r\n                }\r\n\r\n                if(isAdd){\r\n                    borderObject.value = borderCellValue;\r\n                    // this.config._borderInfo[borderId] = borderObject;\r\n                    this._borderObject = borderObject;\r\n                }\r\n            }\r\n\r\n        }\r\n        else{\r\n            cellValue.tb = 1;\r\n        }\r\n\r\n        if(v!=null){\r\n            let value =v[0].value;\r\n\r\n            if(/&#\\d+;/.test(value)){\r\n                value = this.htmlDecode(value);\r\n            }\r\n\r\n            if(t==ST_CellType[\"SharedString\"]){\r\n                let siIndex = parseInt(v[0].value);\r\n                let sharedSI = sharedStrings[siIndex];\r\n\r\n                let rFlag = sharedSI.getInnerElements(\"r\");\r\n                if(rFlag==null){\r\n                    let tFlag = sharedSI.getInnerElements(\"t\");\r\n                    if(tFlag!=null){\r\n                        let text = \"\";\r\n                        tFlag.forEach((t)=>{\r\n                            text += t.value;\r\n                        });\r\n\r\n                        text = escapeCharacter(text);\r\n\r\n                        //isContainMultiType(text) &&\r\n                        if(familyFont==\"Roman\" && text.length>0){\r\n                            let textArray = text.split(\"\");\r\n                            let preWordType:string = null, wordText=\"\", preWholef:string=null;\r\n                            let wholef = \"Times New Roman\";\r\n                            if(cellValue.ff!=null){\r\n                                wholef = cellValue.ff;\r\n                            }\r\n\r\n                            let cellFormat = cellValue.ct;\r\n                            if(cellFormat==null){\r\n                                cellFormat = new LuckySheetCellFormat();\r\n                            }\r\n\r\n                            if(cellFormat.s==null){\r\n                                cellFormat.s = [];\r\n                            }\r\n\r\n                            for(let i=0;i<textArray.length;i++){\r\n                                let w = textArray[i];\r\n                                let type:string = null, ff=wholef;\r\n\r\n                                if(isChinese(w)){\r\n                                    type = \"c\";\r\n                                    ff=\"\";\r\n                                }\r\n                                else if(isJapanese(w)){\r\n                                    type = \"j\";\r\n                                    ff=\"Yu Gothic\";\r\n                                }\r\n                                else if(isKoera(w)){\r\n                                    type = \"k\";\r\n                                    ff=\"Malgun Gothic\";\r\n                                }\r\n                                else{\r\n                                    type = \"e\";\r\n                                }\r\n\r\n                                if((type!=preWordType && preWordType!=null) || i==textArray.length-1){\r\n                                    let InlineString = new LuckyInlineString();\r\n\r\n                                    InlineString.ff = preWholef;\r\n\r\n                                    if(cellValue.fc!=null){\r\n                                        InlineString.fc = cellValue.fc;\r\n                                    }\r\n\r\n                                    if(cellValue.fs!=null){\r\n                                        InlineString.fs = cellValue.fs;\r\n                                    }\r\n\r\n                                    if(cellValue.cl!=null){\r\n                                        InlineString.cl = cellValue.cl;\r\n                                    }\r\n\r\n                                    if(cellValue.un!=null){\r\n                                        InlineString.un = cellValue.un;\r\n                                    }\r\n\r\n                                    if(cellValue.bl!=null){\r\n                                        InlineString.bl = cellValue.bl;\r\n                                    }\r\n\r\n                                    if(cellValue.it!=null){\r\n                                        InlineString.it = cellValue.it;\r\n                                    }\r\n\r\n                                    if(i==textArray.length-1){\r\n                                        if(type==preWordType){\r\n                                            InlineString.ff = ff;\r\n                                            InlineString.v = wordText + w;\r\n                                        }\r\n                                        else{\r\n                                            InlineString.ff = preWholef;\r\n                                            InlineString.v = wordText;\r\n                                            cellFormat.s.push(InlineString);\r\n\r\n                                            let InlineStringLast = new LuckyInlineString();\r\n                                            InlineStringLast.ff = ff;\r\n                                            InlineStringLast.v = w;\r\n                                            if(cellValue.fc!=null){\r\n                                                InlineStringLast.fc = cellValue.fc;\r\n                                            }\r\n\r\n                                            if(cellValue.fs!=null){\r\n                                                InlineStringLast.fs = cellValue.fs;\r\n                                            }\r\n\r\n                                            if(cellValue.cl!=null){\r\n                                                InlineStringLast.cl = cellValue.cl;\r\n                                            }\r\n\r\n                                            if(cellValue.un!=null){\r\n                                                InlineStringLast.un = cellValue.un;\r\n                                            }\r\n\r\n                                            if(cellValue.bl!=null){\r\n                                                InlineStringLast.bl = cellValue.bl;\r\n                                            }\r\n\r\n                                            if(cellValue.it!=null){\r\n                                                InlineStringLast.it = cellValue.it;\r\n                                            }\r\n                                            cellFormat.s.push(InlineStringLast);\r\n\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    else{\r\n                                        InlineString.v = wordText;\r\n                                    }\r\n\r\n\r\n                                    cellFormat.s.push(InlineString);\r\n\r\n                                    wordText = w;\r\n                                }\r\n                                else{\r\n                                    wordText += w;\r\n                                }\r\n\r\n\r\n                                preWordType = type;\r\n                                preWholef = ff;\r\n                            }\r\n\r\n                            cellFormat.t = \"inlineStr\";\r\n                            // cellFormat.s = [InlineString];\r\n                            cellValue.ct = cellFormat;\r\n                            // console.log(cellValue);\r\n                        }\r\n                        else{\r\n\r\n\r\n                            text = this.replaceSpecialWrap(text);\r\n\r\n                            if(text.indexOf(\"\\r\\n\")>-1 || text.indexOf(\"\\n\")>-1){\r\n                                let InlineString = new LuckyInlineString();\r\n                                InlineString.v = text;\r\n                                let cellFormat = cellValue.ct;\r\n                                if(cellFormat==null){\r\n                                    cellFormat = new LuckySheetCellFormat();\r\n                                }\r\n\r\n                                if(cellValue.ff!=null){\r\n                                    InlineString.ff = cellValue.ff;\r\n                                }\r\n\r\n                                if(cellValue.fc!=null){\r\n                                    InlineString.fc = cellValue.fc;\r\n                                }\r\n\r\n                                if(cellValue.fs!=null){\r\n                                    InlineString.fs = cellValue.fs;\r\n                                }\r\n\r\n                                if(cellValue.cl!=null){\r\n                                    InlineString.cl = cellValue.cl;\r\n                                }\r\n\r\n                                if(cellValue.un!=null){\r\n                                    InlineString.un = cellValue.un;\r\n                                }\r\n\r\n                                if(cellValue.bl!=null){\r\n                                    InlineString.bl = cellValue.bl;\r\n                                }\r\n\r\n                                if(cellValue.it!=null){\r\n                                    InlineString.it = cellValue.it;\r\n                                }\r\n\r\n                                cellFormat.t = \"inlineStr\";\r\n                                cellFormat.s = [InlineString];\r\n                                cellValue.ct = cellFormat;\r\n                            }\r\n                            else{\r\n                                cellValue.v = text;\r\n                                quotePrefix = \"1\";\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n                else{\r\n                    let styles:LuckyInlineString[] = [];\r\n                    rFlag.forEach((r)=>{\r\n                        let tFlag = r.getInnerElements(\"t\");\r\n                        let rPr = r.getInnerElements(\"rPr\");\r\n\r\n                        let InlineString = new LuckyInlineString();\r\n\r\n                        if(tFlag!=null && tFlag.length>0){\r\n                            let text = tFlag[0].value;\r\n                            text = this.replaceSpecialWrap(text);\r\n                            text = escapeCharacter(text);\r\n                            InlineString.v = text;\r\n                        }\r\n\r\n                        if(rPr!=null && rPr.length>0){\r\n                            let frpr = rPr[0];\r\n                            let sz = getlineStringAttr(frpr,\"sz\"), rFont=getlineStringAttr(frpr,\"rFont\"), family=getlineStringAttr(frpr,\"family\"), charset=getlineStringAttr(frpr,\"charset\"), scheme=getlineStringAttr(frpr,\"scheme\"), b=getlineStringAttr(frpr,\"b\"), i=getlineStringAttr(frpr,\"i\"), u=getlineStringAttr(frpr,\"u\"), strike=getlineStringAttr(frpr,\"strike\"), vertAlign=getlineStringAttr(frpr,\"vertAlign\"), color;\r\n\r\n\r\n                            let cEle = frpr.getInnerElements(\"color\");\r\n                            if(cEle!=null && cEle.length>0){\r\n                                color = getColor(cEle[0],this.styles, \"t\");\r\n                            }\r\n\r\n\r\n                            let ff;\r\n                            // if(family!=null){\r\n                            //     ff = fontFamilys[family];\r\n                            // }\r\n                            if(rFont!=null){\r\n                                ff = rFont;\r\n                            }\r\n                            if(ff!=null){\r\n                                InlineString.ff = ff;\r\n                            }\r\n                            else if(cellValue.ff!=null){\r\n                                InlineString.ff = cellValue.ff;\r\n                            }\r\n\r\n                            if(color!=null){\r\n                                InlineString.fc = color;\r\n                            }\r\n                            else if(cellValue.fc!=null){\r\n                                InlineString.fc = cellValue.fc;\r\n                            }\r\n\r\n                            if(sz!=null){\r\n                                InlineString.fs = parseInt(sz);\r\n                            }\r\n                            else if(cellValue.fs!=null){\r\n                                InlineString.fs = cellValue.fs;\r\n                            }\r\n\r\n                            if(strike!=null){\r\n                                InlineString.cl = parseInt(strike);\r\n                            }\r\n                            else if(cellValue.cl!=null){\r\n                                InlineString.cl = cellValue.cl;\r\n                            }\r\n\r\n                            if(u!=null){\r\n                                InlineString.un = parseInt(u);\r\n                            }\r\n                            else if(cellValue.un!=null){\r\n                                InlineString.un = cellValue.un;\r\n                            }\r\n\r\n                            if(b!=null){\r\n                                InlineString.bl = parseInt(b);\r\n                            }\r\n                            else if(cellValue.bl!=null){\r\n                                InlineString.bl = cellValue.bl;\r\n                            }\r\n\r\n                            if(i!=null){\r\n                                InlineString.it = parseInt(i);\r\n                            }\r\n                            else if(cellValue.it!=null){\r\n                                InlineString.it = cellValue.it;\r\n                            }\r\n\r\n                            if(vertAlign!=null){\r\n                                InlineString.va = parseInt(vertAlign);\r\n                            }\r\n\r\n\r\n                            // ff:string | undefined //font family\r\n                            // fc:string | undefined//font color\r\n                            // fs:number | undefined//font size\r\n                            // cl:number | undefined//strike\r\n                            // un:number | undefined//underline\r\n                            // bl:number | undefined//blod\r\n                            // it:number | undefined//italic\r\n                            // v:string | undefined\r\n                        }\r\n                        else{\r\n                            if(InlineString.ff==null && cellValue.ff!=null){\r\n                                InlineString.ff = cellValue.ff;\r\n                            }\r\n\r\n                            if(InlineString.fc==null && cellValue.fc!=null){\r\n                                InlineString.fc = cellValue.fc;\r\n                            }\r\n\r\n                            if(InlineString.fs==null && cellValue.fs!=null){\r\n                                InlineString.fs = cellValue.fs;\r\n                            }\r\n\r\n                            if(InlineString.cl==null && cellValue.cl!=null){\r\n                                InlineString.cl = cellValue.cl;\r\n                            }\r\n\r\n                            if(InlineString.un==null && cellValue.un!=null){\r\n                                InlineString.un = cellValue.un;\r\n                            }\r\n\r\n                            if(InlineString.bl==null && cellValue.bl!=null){\r\n                                InlineString.bl = cellValue.bl;\r\n                            }\r\n\r\n                            if(InlineString.it==null && cellValue.it!=null){\r\n                                InlineString.it = cellValue.it;\r\n                            }\r\n                        }\r\n\r\n\r\n                        styles.push(InlineString);\r\n                    });\r\n\r\n                    let cellFormat = cellValue.ct;\r\n                    if(cellFormat==null){\r\n                        cellFormat = new LuckySheetCellFormat();\r\n                    }\r\n                    cellFormat.t = \"inlineStr\";\r\n                    cellFormat.s = styles;\r\n                    cellValue.ct = cellFormat;\r\n                }\r\n            }\r\n            // to be confirmed\r\n            else if(t==ST_CellType[\"InlineString\"] && v!=null){\r\n                cellValue.v = \"'\"+ value;\r\n            }\r\n            else {\r\n                value = escapeCharacter(value);\r\n                cellValue.v = value;\r\n            }\r\n        }\r\n\r\n        if(quotePrefix!=null){\r\n            cellValue.qp = parseInt(quotePrefix);\r\n        }\r\n\r\n        return cellValue;\r\n\r\n    }\r\n\r\n    private replaceSpecialWrap(text:string):string{\r\n        text = text.replace(/_x000D_/g, \"\").replace(/&#13;&#10;/g, \"\\r\\n\").replace(/&#13;/g, \"\\r\").replace(/&#10;/g, \"\\n\");\r\n        return text;\r\n    }\r\n\r\n\r\n    private getBackgroundByFill(fill:Element, clrScheme:Element[]):string|null{\r\n        let patternFills = fill.getInnerElements(\"patternFill\");\r\n        if(patternFills!=null){\r\n            let patternFill = patternFills[0];\r\n            let fgColors = patternFill.getInnerElements(\"fgColor\");\r\n            let bgColors = patternFill.getInnerElements(\"bgColor\");\r\n            let fg, bg;\r\n            if(fgColors!=null){\r\n                let fgColor = fgColors[0];\r\n                fg = getColor(fgColor, this.styles);\r\n            }\r\n\r\n            if(bgColors!=null){\r\n                let bgColor = bgColors[0];\r\n                bg = getColor(bgColor, this.styles);\r\n            }\r\n            // console.log(fgColors,bgColors,clrScheme);\r\n            if(fg!=null){\r\n                return fg;\r\n            }\r\n            else if(bg!=null){\r\n                return bg;\r\n            }\r\n        }\r\n        else{\r\n            let gradientfills = fill.getInnerElements(\"gradientFill\");\r\n            if(gradientfills!=null){\r\n                //graient color fill handler\r\n\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    private getBorderInfo(borders:Element[]):LuckySheetborderInfoCellValueStyle{\r\n        if(borders==null){\r\n            return null;\r\n        }\r\n\r\n        let border = borders[0], attrList = border.attributeList;\r\n        let clrScheme = this.styles[\"clrScheme\"] as Element[];\r\n        let style:string = attrList.style;\r\n        if(style==null || style==\"none\"){\r\n            return null;\r\n        }\r\n\r\n        let colors = border.getInnerElements(\"color\");\r\n        let colorRet = \"#000000\";\r\n        if(colors!=null){\r\n            let color = colors[0];\r\n            colorRet = getColor(color, this.styles, \"b\");\r\n            if(colorRet==null){\r\n                colorRet = \"#000000\";\r\n            }\r\n        }\r\n\r\n        let ret = new LuckySheetborderInfoCellValueStyle();\r\n        ret.style = borderTypes[style];\r\n        ret.color = colorRet;\r\n\r\n        return ret;\r\n    }\r\n\r\n    private htmlDecode (str:string):string {\r\n        return str.replace(/&#(x)?([^&]{1,5});/g,function($,$1,$2) {\r\n            return String.fromCharCode(parseInt($2 , $1 ? 16:10));\r\n        });\r\n    };\r\n\r\n}\r\n\r\n","import { ILuckyFile,IluckySheetRowAndColumnHidden,IluckySheetRowAndColumnLen} from \"./ILuck\";\r\nimport { LuckySheet} from \"./LuckySheet\";\r\nimport {IuploadfileList, IattributeList} from \"../ICommon\";\r\nimport {workBookFile, coreFile, appFile, stylesFile, sharedStringsFile,numFmtDefault,theme1File,calcChainFile,workbookRels, numFmtDefaultMap} from \"../common/constant\";\r\nimport { ReadXml,IStyleCollections,Element } from \"./ReadXml\";\r\nimport {getXmlAttibute} from \"../common/method\";\r\nimport { LuckyFileBase,LuckyFileInfo,LuckySheetBase,LuckySheetCelldataBase,LuckySheetCelldataValue,LuckySheetCellFormat } from \"./LuckyBase\";\r\nimport {ImageList} from \"./LuckyImage\";\r\n\r\nexport class LuckyFile extends LuckyFileBase {\r\n\r\n    private files:IuploadfileList\r\n    private sheetNameList:IattributeList\r\n    private readXml:ReadXml\r\n    private fileName:string\r\n    private styles:IStyleCollections\r\n    private sharedStrings:Element[]\r\n    private calcChain:Element[]\r\n    private imageList:ImageList\r\n\r\n    constructor(files:IuploadfileList, fileName:string) {\r\n        super();\r\n        this.files = files;\r\n        this.fileName = fileName;\r\n        this.readXml = new ReadXml(files);\r\n        this.getSheetNameList();\r\n\r\n        this.sharedStrings = this.readXml.getElementsByTagName(\"sst/si\", sharedStringsFile);\r\n        this.calcChain = this.readXml.getElementsByTagName(\"calcChain/c\", calcChainFile);\r\n        this.styles = {};\r\n        this.styles[\"cellXfs\"] =  this.readXml.getElementsByTagName(\"cellXfs/xf\", stylesFile);\r\n        this.styles[\"cellStyleXfs\"] =  this.readXml.getElementsByTagName(\"cellStyleXfs/xf\", stylesFile);\r\n        this.styles[\"cellStyles\"] =  this.readXml.getElementsByTagName(\"cellStyles/cellStyle\", stylesFile);\r\n        this.styles[\"fonts\"] =  this.readXml.getElementsByTagName(\"fonts/font\", stylesFile);\r\n        this.styles[\"fills\"] =  this.readXml.getElementsByTagName(\"fills/fill\", stylesFile);\r\n        this.styles[\"borders\"] =  this.readXml.getElementsByTagName(\"borders/border\", stylesFile);\r\n        this.styles[\"clrScheme\"] =  this.readXml.getElementsByTagName(\"a:clrScheme/a:dk1|a:lt1|a:dk2|a:lt2|a:accent1|a:accent2|a:accent3|a:accent4|a:accent5|a:accent6|a:hlink|a:folHlink\", theme1File);\r\n        this.styles[\"indexedColors\"] =  this.readXml.getElementsByTagName(\"colors/indexedColors/rgbColor\", stylesFile);\r\n        this.styles[\"mruColors\"] =  this.readXml.getElementsByTagName(\"colors/mruColors/color\", stylesFile);\r\n\r\n        this.imageList = new ImageList(files);\r\n\r\n        let numfmts =  this.readXml.getElementsByTagName(\"numFmt/numFmt\", stylesFile);\r\n        let numFmtDefaultC = JSON.parse(JSON.stringify(numFmtDefault));\r\n        for(let i=0;i<numfmts.length;i++){\r\n            let attrList = numfmts[i].attributeList;\r\n            let numfmtid = getXmlAttibute(attrList, \"numFmtId\", \"49\");\r\n            let formatcode = getXmlAttibute(attrList, \"formatCode\", \"@\");\r\n            // console.log(numfmtid, formatcode);\r\n            if(!(numfmtid in numFmtDefault)){\r\n                numFmtDefaultC[numfmtid] = numFmtDefaultMap[formatcode] || formatcode;\r\n            }\r\n        }\r\n\r\n        // console.log(JSON.stringify(numFmtDefaultC), numfmts);\r\n        this.styles[\"numfmts\"] =  numFmtDefaultC;\r\n    }\r\n\r\n    /**\r\n    * @return All sheet name of workbook\r\n    */\r\n    private getSheetNameList(){\r\n        let workbookRelList = this.readXml.getElementsByTagName(\"Relationships/Relationship\", workbookRels);\r\n        if(workbookRelList==null){\r\n            return;\r\n        }\r\n\r\n        let regex = new RegExp(\"worksheets/[^/]*?.xml\");\r\n        let sheetNames:IattributeList = {};\r\n        for(let i=0;i<workbookRelList.length;i++){\r\n            let rel = workbookRelList[i], attrList = rel.attributeList;\r\n            let id = attrList[\"Id\"], target = attrList[\"Target\"];\r\n            if(regex.test(target)){\r\n                if(target.indexOf('/xl') === 0){\r\n                    sheetNames[id] =   target.substr(1);\r\n                }else{\r\n                    sheetNames[id] =   \"xl/\" + target;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        this.sheetNameList = sheetNames;\r\n    }\r\n\r\n    /**\r\n    * @param sheetName WorkSheet'name\r\n    * @return sheet file name and path in zip\r\n    */\r\n   private getSheetFileBysheetId(sheetId:string){\r\n        // for(let i=0;i<this.sheetNameList.length;i++){\r\n        //     let sheetFileName = this.sheetNameList[i];\r\n        //     if(sheetFileName.indexOf(\"sheet\"+sheetId)>-1){\r\n        //         return sheetFileName;\r\n        //     }\r\n        // }\r\n        return this.sheetNameList[sheetId];\r\n    }\r\n\r\n    /**\r\n    * @return workBook information\r\n    */\r\n    getWorkBookInfo(){\r\n        let Company = this.readXml.getElementsByTagName(\"Company\", appFile);\r\n        let AppVersion = this.readXml.getElementsByTagName(\"AppVersion\", appFile);\r\n        let creator = this.readXml.getElementsByTagName(\"dc:creator\", coreFile);\r\n        let lastModifiedBy = this.readXml.getElementsByTagName(\"cp:lastModifiedBy\", coreFile);\r\n        let created = this.readXml.getElementsByTagName(\"dcterms:created\", coreFile);\r\n        let modified = this.readXml.getElementsByTagName(\"dcterms:modified\", coreFile);\r\n        this.info = new LuckyFileInfo();\r\n        this.info.name = this.fileName;\r\n        this.info.creator = creator.length>0?creator[0].value:\"\";\r\n        this.info.lastmodifiedby = lastModifiedBy.length>0?lastModifiedBy[0].value:\"\";\r\n        this.info.createdTime = created.length>0?created[0].value:\"\";\r\n        this.info.modifiedTime = modified.length>0?modified[0].value:\"\";\r\n        this.info.company = Company.length>0?Company[0].value:\"\";\r\n        this.info.appversion = AppVersion.length>0?AppVersion[0].value:\"\";\r\n    }\r\n\r\n    /**\r\n    * @return All sheet , include whole information\r\n    */\r\n    getSheetsFull(isInitialCell:boolean=true){\r\n        let sheets = this.readXml.getElementsByTagName(\"sheets/sheet\", workBookFile);\r\n        let sheetList:IattributeList = {};\r\n        for(let key in sheets){\r\n            let sheet = sheets[key];\r\n            sheetList[sheet.attributeList.name] = sheet.attributeList[\"sheetId\"];\r\n        }\r\n        this.sheets = [];\r\n        let order = 0;\r\n        for(let key in sheets){\r\n            let sheet = sheets[key];\r\n            let sheetName = sheet.attributeList.name;\r\n            let sheetId = sheet.attributeList[\"sheetId\"];\r\n            let rid = sheet.attributeList[\"r:id\"];\r\n            let sheetFile = this.getSheetFileBysheetId(rid);\r\n            let hide = sheet.attributeList.state === \"hidden\" ? 1 : 0;\r\n\r\n            let drawing = this.readXml.getElementsByTagName(\"worksheet/drawing\", sheetFile), drawingFile, drawingRelsFile;\r\n            if(drawing!=null && drawing.length>0){\r\n                let attrList = drawing[0].attributeList;\r\n                let rid = getXmlAttibute(attrList, \"r:id\", null);\r\n                if(rid!=null){\r\n                    drawingFile = this.getDrawingFile(rid, sheetFile);\r\n                    drawingRelsFile = this.getDrawingRelsFile(drawingFile);\r\n                }\r\n            }\r\n\r\n            if(sheetFile!=null){\r\n                let sheet = new LuckySheet(sheetName, sheetId, order, isInitialCell,\r\n                    {\r\n                        sheetFile:sheetFile,\r\n                        readXml:this.readXml,\r\n                        sheetList:sheetList,\r\n                        styles:this.styles,\r\n                        sharedStrings:this.sharedStrings,\r\n                        calcChain:this.calcChain,\r\n                        imageList:this.imageList,\r\n                        drawingFile:drawingFile,\r\n                        drawingRelsFile: drawingRelsFile,\r\n                        hide: hide,\r\n                    }\r\n                )\r\n                this.columnWidthSet = [];\r\n                this.rowHeightSet = [];\r\n\r\n                this.imagePositionCaculation(sheet);\r\n\r\n                this.sheets.push(sheet);\r\n                order++;\r\n            }\r\n        }\r\n    }\r\n\r\n    private columnWidthSet:number[] = [];\r\n    private rowHeightSet:number[] = [];\r\n\r\n    private extendArray(index:number, sets:number[],def:number, hidden:IluckySheetRowAndColumnHidden, lens:IluckySheetRowAndColumnLen){\r\n        if(index<sets.length){\r\n            return;\r\n        }\r\n\r\n        let startIndex = sets.length, endIndex = index;\r\n        let allGap = 0;\r\n        if(startIndex>0){\r\n            allGap = sets[startIndex-1];\r\n        }\r\n        // else{\r\n        //     sets.push(0);\r\n        // }\r\n        for(let i=startIndex;i<=endIndex;i++){\r\n            let gap = def, istring  = i.toString();\r\n            if(istring in hidden){\r\n                gap = 0;\r\n            }\r\n            else if(istring in lens){\r\n                gap = lens[istring];\r\n            }\r\n\r\n            allGap += Math.round(gap + 1);\r\n\r\n            sets.push(allGap);\r\n        }\r\n    }\r\n\r\n    private imagePositionCaculation(sheet:LuckySheet){\r\n        let images = sheet.images, defaultColWidth = sheet.defaultColWidth, defaultRowHeight = sheet.defaultRowHeight;\r\n        let colhidden = {};\r\n        if(sheet.config.colhidden){\r\n            colhidden = sheet.config.colhidden;\r\n        }\r\n\r\n        let columnlen = {};\r\n        if(sheet.config.columnlen){\r\n            columnlen = sheet.config.columnlen;\r\n        }\r\n\r\n        let rowhidden = {};\r\n        if(sheet.config.rowhidden){\r\n            rowhidden = sheet.config.rowhidden;\r\n        }\r\n\r\n        let rowlen = {};\r\n        if(sheet.config.rowlen){\r\n            rowlen = sheet.config.rowlen;\r\n        }\r\n\r\n        for(let key in images){\r\n            let imageObject:any = images[key];//Image, luckyImage\r\n            let fromCol = imageObject.fromCol;\r\n            let fromColOff = imageObject.fromColOff;\r\n            let fromRow = imageObject.fromRow;\r\n            let fromRowOff = imageObject.fromRowOff;\r\n\r\n            let toCol = imageObject.toCol;\r\n            let toColOff = imageObject.toColOff;\r\n            let toRow = imageObject.toRow;\r\n            let toRowOff = imageObject.toRowOff;\r\n\r\n            let x_n =0,y_n = 0;\r\n            let cx_n = 0, cy_n = 0;\r\n\r\n            if(fromCol>=this.columnWidthSet.length){\r\n                this.extendArray(fromCol, this.columnWidthSet, defaultColWidth, colhidden, columnlen);\r\n            }\r\n            if(fromCol==0){\r\n                x_n = 0;\r\n            }\r\n            else{\r\n                x_n = this.columnWidthSet[fromCol-1];\r\n            }\r\n            x_n = x_n + fromColOff;\r\n\r\n            if(fromRow>=this.rowHeightSet.length){\r\n                this.extendArray(fromRow, this.rowHeightSet, defaultRowHeight, rowhidden, rowlen);\r\n            }\r\n            if(fromRow==0){\r\n                y_n = 0;\r\n            }\r\n            else{\r\n                y_n = this.rowHeightSet[fromRow-1];\r\n            }\r\n            y_n = y_n + fromRowOff;\r\n\r\n\r\n            if(toCol>=this.columnWidthSet.length){\r\n                this.extendArray(toCol, this.columnWidthSet, defaultColWidth, colhidden, columnlen);\r\n            }\r\n            if(toCol==0){\r\n                cx_n = 0;\r\n            }\r\n            else{\r\n                cx_n = this.columnWidthSet[toCol-1];\r\n            }\r\n            cx_n = cx_n + toColOff- x_n;\r\n\r\n            if(toRow>=this.rowHeightSet.length){\r\n                this.extendArray(toRow, this.rowHeightSet, defaultRowHeight, rowhidden, rowlen);\r\n            }\r\n            if(toRow==0){\r\n                cy_n = 0;\r\n            }\r\n            else{\r\n                cy_n = this.rowHeightSet[toRow-1];\r\n            }\r\n\r\n            cy_n = cy_n + toRowOff - y_n;\r\n\r\n            // console.log(defaultColWidth, colhidden , columnlen);\r\n            // console.log(fromCol, this.columnWidthSet[fromCol] , fromColOff);\r\n            // console.log(toCol, this.columnWidthSet[toCol] , toColOff, JSON.stringify(this.columnWidthSet));\r\n\r\n            imageObject.originWidth = cx_n;\r\n            imageObject.originHeight = cy_n;\r\n\r\n            imageObject.crop.height = cy_n;\r\n            imageObject.crop.width = cx_n;\r\n\r\n            imageObject.default.height = cy_n;\r\n            imageObject.default.left = x_n;\r\n            imageObject.default.top = y_n;\r\n            imageObject.default.width = cx_n;\r\n        }\r\n\r\n        //console.log(this.columnWidthSet, this.rowHeightSet);\r\n    }\r\n\r\n    /**\r\n    * @return drawing file string\r\n    */\r\n   private getDrawingFile(rid:string, sheetFile:string):string{\r\n        let sheetRelsPath = \"xl/worksheets/_rels/\";\r\n        let sheetFileArr = sheetFile.split(\"/\");\r\n        let sheetRelsName = sheetFileArr[sheetFileArr.length-1];\r\n\r\n        let sheetRelsFile = sheetRelsPath + sheetRelsName + \".rels\";\r\n\r\n        let drawing = this.readXml.getElementsByTagName(\"Relationships/Relationship\", sheetRelsFile);\r\n        if(drawing.length>0){\r\n            for(let i=0;i<drawing.length;i++){\r\n                let relationship = drawing[i];\r\n                let attrList = relationship.attributeList;\r\n                let relationshipId = getXmlAttibute(attrList, \"Id\", null);\r\n                if(relationshipId==rid){\r\n                    let target = getXmlAttibute(attrList, \"Target\", null);\r\n                    if(target!=null){\r\n                        return target.replace(/\\.\\.\\//g, \"\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n    private getDrawingRelsFile(drawingFile:string):string{\r\n        let drawingRelsPath = \"xl/drawings/_rels/\";\r\n        let drawingFileArr = drawingFile.split(\"/\");\r\n        let drawingRelsName = drawingFileArr[drawingFileArr.length-1];\r\n\r\n        let drawingRelsFile = drawingRelsPath + drawingRelsName + \".rels\";\r\n\r\n        return drawingRelsFile;\r\n    }\r\n\r\n    /**\r\n    * @return All sheet base information widthout cell and config\r\n    */\r\n    getSheetsWithoutCell(){\r\n        this.getSheetsFull(false);\r\n    }\r\n\r\n    /**\r\n    * @return LuckySheet file json\r\n    */\r\n    Parse():string{\r\n        // let xml = this.readXml;\r\n        // for(let key in this.sheetNameList){\r\n        //     let sheetName=this.sheetNameList[key];\r\n        //     let sheetColumns = xml.getElementsByTagName(\"row/c/f\", sheetName);\r\n        //     console.log(sheetColumns);\r\n        // }\r\n        // return \"\";\r\n\r\n        this.getWorkBookInfo();\r\n        this.getSheetsFull();\r\n\r\n        // for(let i=0;i<this.sheets.length;i++){\r\n        //     let sheet = this.sheets[i];\r\n        //     let _borderInfo = sheet.config._borderInfo;\r\n        //     if(_borderInfo==null){\r\n        //         continue;\r\n        //     }\r\n        //     let _borderInfoKeys = Object.keys(_borderInfo);\r\n        //     _borderInfoKeys.sort();\r\n        //     for(let a=0;a<_borderInfoKeys.length;a++){\r\n        //         let key = parseInt(_borderInfoKeys[a]);\r\n        //         let b = _borderInfo[key];\r\n        //         if(b.cells.length==0){\r\n        //             continue;\r\n        //         }\r\n        //         if(sheet.config.borderInfo==null){\r\n        //             sheet.config.borderInfo = [];\r\n        //         }\r\n        //         sheet.config.borderInfo.push(b);\r\n        //     }\r\n        // }\r\n\r\n        return this.toJsonString(this);\r\n    }\r\n\r\n    private toJsonString(file:ILuckyFile):string{\r\n        let LuckyOutPutFile = new LuckyFileBase();\r\n        LuckyOutPutFile.info = file.info;\r\n        LuckyOutPutFile.sheets = [];\r\n\r\n        file.sheets.forEach((sheet)=>{\r\n            let sheetout = new LuckySheetBase();\r\n            //let attrName = [\"name\",\"color\",\"config\",\"index\",\"status\",\"order\",\"row\",\"column\",\"luckysheet_select_save\",\"scrollLeft\",\"scrollTop\",\"zoomRatio\",\"showGridLines\",\"defaultColWidth\",\"defaultRowHeight\",\"celldata\",\"chart\",\"isPivotTable\",\"pivotTable\",\"luckysheet_conditionformat_save\",\"freezen\",\"calcChain\"];\r\n\r\n            if(sheet.name!=null){\r\n                sheetout.name = sheet.name;\r\n            }\r\n\r\n            if(sheet.color!=null){\r\n                sheetout.color = sheet.color;\r\n            }\r\n\r\n            if(sheet.config!=null){\r\n                sheetout.config = sheet.config;\r\n                // if(sheetout.config._borderInfo!=null){\r\n                //     delete sheetout.config._borderInfo;\r\n                // }\r\n            }\r\n\r\n            if(sheet.index!=null){\r\n                sheetout.index = sheet.index;\r\n            }\r\n\r\n            if(sheet.status!=null){\r\n                sheetout.status = sheet.status;\r\n            }\r\n\r\n            if(sheet.order!=null){\r\n                sheetout.order = sheet.order;\r\n            }\r\n\r\n            if(sheet.row!=null){\r\n                sheetout.row = sheet.row;\r\n            }\r\n\r\n            if(sheet.column!=null){\r\n                sheetout.column = sheet.column;\r\n            }\r\n\r\n            if(sheet.luckysheet_select_save!=null){\r\n                sheetout.luckysheet_select_save = sheet.luckysheet_select_save;\r\n            }\r\n\r\n            if(sheet.scrollLeft!=null){\r\n                sheetout.scrollLeft = sheet.scrollLeft;\r\n            }\r\n\r\n            if(sheet.scrollTop!=null){\r\n                sheetout.scrollTop = sheet.scrollTop;\r\n            }\r\n\r\n            if(sheet.zoomRatio!=null){\r\n                sheetout.zoomRatio = sheet.zoomRatio;\r\n            }\r\n\r\n            if(sheet.showGridLines!=null){\r\n                sheetout.showGridLines = sheet.showGridLines;\r\n            }\r\n\r\n            if(sheet.defaultColWidth!=null){\r\n                sheetout.defaultColWidth = sheet.defaultColWidth;\r\n            }\r\n\r\n            if(sheet.defaultRowHeight!=null){\r\n                sheetout.defaultRowHeight = sheet.defaultRowHeight;\r\n            }\r\n\r\n            if(sheet.celldata!=null){\r\n                // sheetout.celldata = sheet.celldata;\r\n                sheetout.celldata = [];\r\n                sheet.celldata.forEach((cell)=>{\r\n                    let cellout = new LuckySheetCelldataBase();\r\n                    cellout.r = cell.r;\r\n                    cellout.c = cell.c;\r\n                    cellout.v = cell.v;\r\n                    sheetout.celldata.push(cellout);\r\n                });\r\n            }\r\n\r\n            if(sheet.chart!=null){\r\n                sheetout.chart = sheet.chart;\r\n            }\r\n\r\n            if(sheet.isPivotTable!=null){\r\n                sheetout.isPivotTable = sheet.isPivotTable;\r\n            }\r\n\r\n            if(sheet.pivotTable!=null){\r\n                sheetout.pivotTable = sheet.pivotTable;\r\n            }\r\n\r\n            if(sheet.luckysheet_conditionformat_save!=null){\r\n                sheetout.luckysheet_conditionformat_save = sheet.luckysheet_conditionformat_save;\r\n            }\r\n\r\n            if(sheet.freezen!=null){\r\n                sheetout.freezen = sheet.freezen;\r\n            }\r\n\r\n            if(sheet.calcChain!=null){\r\n                sheetout.calcChain = sheet.calcChain;\r\n            }\r\n\r\n            if(sheet.images!=null){\r\n                sheetout.images = sheet.images;\r\n            }\r\n          \r\n            if (sheet.dataVerification != null){\r\n              sheetout.dataVerification = sheet.dataVerification;\r\n            }\r\n          \r\n            if (sheet.hyperlink != null){\r\n                sheetout.hyperlink = sheet.hyperlink;\r\n            }\r\n          \r\n            if (sheet.hide != null) {\r\n              sheetout.hide = sheet.hide;\r\n            }\r\n            \r\n            LuckyOutPutFile.sheets.push(sheetout);\r\n        });\r\n\r\n        return JSON.stringify(LuckyOutPutFile);\r\n    }\r\n\r\n\r\n}\r\n","import { IluckyImage } from \"./ILuck\";\r\nimport {LuckySheetCelldata} from \"./LuckyCell\";\r\nimport { IuploadfileList, IattributeList } from \"../ICommon\";\r\nimport {getXmlAttibute, getColumnWidthPixel, fromulaRef,getRowHeightPixel,getcellrange} from \"../common/method\";\r\nimport {borderTypes} from \"../common/constant\";\r\nimport { ReadXml, IStyleCollections, Element,getColor } from \"./ReadXml\";\r\nimport { LuckyImageBase } from \"./LuckyBase\";\r\nimport { UDOC,FromEMF,ToContext2D  } from \"../common/emf\";\r\n\r\n\r\nexport class ImageList {\r\n    private images:IattributeList\r\n    constructor(files:IuploadfileList) {\r\n        if(files==null){\r\n            return;\r\n        }\r\n        this.images = {};\r\n        for(let fileKey in files){\r\n            // let reg = new RegExp(\"xl/media/image1.png\", \"g\");\r\n            if(fileKey.indexOf(\"xl/media/\")>-1){\r\n                let fileNameArr = fileKey.split(\".\");\r\n                let suffix = fileNameArr[fileNameArr.length-1].toLowerCase();\r\n                if(suffix in {\"png\":1, \"jpeg\":1, \"jpg\":1, \"gif\":1,\"bmp\":1,\"tif\":1,\"webp\":1,\"emf\":1}){\r\n                    if(suffix==\"emf\"){\r\n                        var pNum  = 0;  // number of the page, that you want to render\r\n                        var scale = 1;  // the scale of the document\r\n                        var wrt = new ToContext2D(pNum, scale);\r\n                        var inp, out, stt;\r\n                        FromEMF.K = [];\r\n                        inp = FromEMF.C;   out = FromEMF.K;   stt=4;\r\n                        for(var p in inp) out[inp[p]] = p.slice(stt);\r\n                        FromEMF.Parse(files[fileKey], wrt);\r\n                        this.images[fileKey] = wrt.canvas.toDataURL(\"image/png\");\r\n                    }\r\n                    else{\r\n                        this.images[fileKey] = files[fileKey];\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    getImageByName(pathName:string):Image{\r\n        if(pathName in this.images){\r\n            let base64 = this.images[pathName];\r\n            return new Image(pathName, base64);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n\r\nclass Image extends LuckyImageBase {\r\n\r\n    fromCol:number\r\n    fromColOff:number\r\n    fromRow:number\r\n    fromRowOff:number\r\n\r\n    toCol:number\r\n    toColOff:number\r\n    toRow:number\r\n    toRowOff:number\r\n\r\n    constructor(pathName:string, base64:string) {\r\n        super();\r\n        this.src = base64;\r\n    }\r\n\r\n    setDefault(){\r\n\r\n    }\r\n}","import { IluckyImageBorder,IluckyImageCrop,IluckyImageDefault,IluckyImages,IluckySheetCelldata,IluckySheetCelldataValue,IMapluckySheetborderInfoCellForImp,IluckySheetborderInfoCellValue,IluckySheetborderInfoCellValueStyle,IFormulaSI,IluckySheetRowAndColumnLen,IluckySheetRowAndColumnHidden,IluckySheetSelection,IcellOtherInfo,IformulaList,IformulaListItem, IluckysheetHyperlink, IluckysheetHyperlinkType, IluckysheetDataVerification} from \"./ILuck\";\r\nimport {LuckySheetCelldata} from \"./LuckyCell\";\r\nimport { IattributeList } from \"../ICommon\";\r\nimport {getXmlAttibute, getColumnWidthPixel, fromulaRef,getRowHeightPixel,getcellrange,generateRandomIndex,getPxByEMUs, getMultiSequenceToNum, getTransR1C1ToSequence, getPeelOffX14, getMultiFormulaValue} from \"../common/method\";\r\nimport {borderTypes, COMMON_TYPE2, DATA_VERIFICATION_MAP, DATA_VERIFICATION_TYPE2_MAP, worksheetFilePath} from \"../common/constant\";\r\nimport { ReadXml, IStyleCollections, Element,getColor } from \"./ReadXml\";\r\nimport { LuckyFileBase,LuckySheetBase,LuckyConfig,LuckySheetborderInfoCellForImp,LuckySheetborderInfoCellValue,LuckysheetCalcChain,LuckySheetConfigMerge } from \"./LuckyBase\";\r\nimport {ImageList} from \"./LuckyImage\";\r\nimport dayjs from \"dayjs\";\r\n\r\nexport class LuckySheet extends LuckySheetBase {\r\n\r\n    private readXml:ReadXml\r\n    private sheetFile:string\r\n    private isInitialCell:boolean\r\n    private styles:IStyleCollections\r\n    private sharedStrings:Element[]\r\n    private mergeCells:Element[]\r\n    private calcChainEles:Element[]\r\n    private sheetList:IattributeList\r\n\r\n    private imageList:ImageList\r\n\r\n    private formulaRefList:IFormulaSI\r\n\r\n    constructor(sheetName:string, sheetId:string, sheetOrder:number,isInitialCell:boolean=false, allFileOption:any){\r\n        //Private\r\n        super();\r\n        this.isInitialCell = isInitialCell;\r\n\r\n        this.readXml = allFileOption.readXml;\r\n        this.sheetFile = allFileOption.sheetFile;\r\n        this.styles = allFileOption.styles;\r\n        this.sharedStrings = allFileOption.sharedStrings;\r\n        this.calcChainEles = allFileOption.calcChain;\r\n        this.sheetList = allFileOption.sheetList;\r\n        this.imageList = allFileOption.imageList;\r\n        this.hide = allFileOption.hide;\r\n\r\n        //Output\r\n        this.name = sheetName;\r\n        this.index = sheetId;\r\n        this.order = sheetOrder.toString();\r\n        this.config = new LuckyConfig();\r\n        this.celldata = [];\r\n        this.mergeCells = this.readXml.getElementsByTagName(\"mergeCells/mergeCell\", this.sheetFile);\r\n        let clrScheme = this.styles[\"clrScheme\"] as Element[];\r\n        let sheetView = this.readXml.getElementsByTagName(\"sheetViews/sheetView\", this.sheetFile);\r\n        let showGridLines = \"1\", tabSelected=\"0\", zoomScale = \"100\", activeCell = \"A1\";\r\n        if(sheetView.length>0){\r\n            let attrList = sheetView[0].attributeList;\r\n            showGridLines = getXmlAttibute(attrList, \"showGridLines\", \"1\");\r\n            tabSelected = getXmlAttibute(attrList, \"tabSelected\", \"0\");\r\n            zoomScale = getXmlAttibute(attrList, \"zoomScale\", \"100\");\r\n            // let colorId = getXmlAttibute(attrList, \"colorId\", \"0\");\r\n            let selections = sheetView[0].getInnerElements(\"selection\");\r\n            if(selections!=null && selections.length>0){\r\n                activeCell = getXmlAttibute(selections[0].attributeList, \"activeCell\", \"A1\");\r\n                let range:IluckySheetSelection = getcellrange(activeCell, this.sheetList, sheetId);\r\n                this.luckysheet_select_save = [];\r\n                this.luckysheet_select_save.push(range);\r\n            }\r\n        }\r\n        this.showGridLines = showGridLines;\r\n        this.status = tabSelected;\r\n        this.zoomRatio = parseInt(zoomScale)/100;\r\n\r\n        let tabColors = this.readXml.getElementsByTagName(\"sheetPr/tabColor\", this.sheetFile);\r\n        if(tabColors!=null && tabColors.length>0){\r\n            let tabColor = tabColors[0], attrList = tabColor.attributeList;\r\n            // if(attrList.rgb!=null){\r\n                let tc = getColor(tabColor, this.styles, \"b\");\r\n                this.color = tc;\r\n            // }\r\n        }\r\n\r\n        let sheetFormatPr = this.readXml.getElementsByTagName(\"sheetFormatPr\", this.sheetFile);\r\n        let defaultColWidth, defaultRowHeight;\r\n        if(sheetFormatPr.length>0){\r\n            let attrList = sheetFormatPr[0].attributeList;\r\n            defaultColWidth = getXmlAttibute(attrList, \"defaultColWidth\", \"9.21\");\r\n            defaultRowHeight = getXmlAttibute(attrList, \"defaultRowHeight\", \"19\");\r\n        }\r\n\r\n        this.defaultColWidth = getColumnWidthPixel(parseFloat(defaultColWidth));\r\n        this.defaultRowHeight = getRowHeightPixel(parseFloat(defaultRowHeight));\r\n\r\n\r\n        this.generateConfigColumnLenAndHidden();\r\n        let cellOtherInfo:IcellOtherInfo =  this.generateConfigRowLenAndHiddenAddCell();\r\n        \r\n        if(this.calcChain==null){\r\n            this.calcChain = [];\r\n        }\r\n\r\n        let formulaListExist:IformulaList={};\r\n        for(let c=0;c<this.calcChainEles.length;c++){\r\n            let calcChainEle = this.calcChainEles[c], attrList = calcChainEle.attributeList;\r\n            if(attrList.i!=sheetId){\r\n                continue;\r\n            }\r\n\r\n            let r = attrList.r , i = attrList.i, l = attrList.l, s = attrList.s, a = attrList.a, t = attrList.t;\r\n\r\n            let range = getcellrange(r);\r\n            let chain = new LuckysheetCalcChain();\r\n            chain.r = range.row[0];\r\n            chain.c = range.column[0];\r\n            chain.index = this.index;\r\n            this.calcChain.push(chain);\r\n            formulaListExist[\"r\"+r+\"c\"+c] = null;\r\n        }\r\n        \r\n\r\n        if(this.formulaRefList!=null){\r\n            for(let key in this.formulaRefList){\r\n                let funclist = this.formulaRefList[key];\r\n                let mainFunc = funclist[\"mainRef\"], mainCellValue = mainFunc.cellValue;\r\n                let formulaTxt = mainFunc.fv;\r\n                let mainR = mainCellValue.r, mainC = mainCellValue.c;\r\n                // let refRange = getcellrange(ref);\r\n                for(let name in funclist){\r\n                    if(name == \"mainRef\"){\r\n                        continue;\r\n                    }\r\n\r\n                    let funcValue = funclist[name], cellValue = funcValue.cellValue;\r\n                    if(cellValue==null){\r\n                        continue;\r\n                    }\r\n                    let r = cellValue.r, c = cellValue.c;\r\n\r\n                    let func = formulaTxt;\r\n                    let offsetRow = r - mainR, offsetCol = c - mainC;\r\n\r\n                    \r\n                    if(offsetRow > 0){\r\n                        func = \"=\" + fromulaRef.functionCopy(func, \"down\", offsetRow);\r\n                    }\r\n                    else if(offsetRow < 0){\r\n                        func = \"=\" + fromulaRef.functionCopy(func, \"up\", Math.abs(offsetRow));\r\n                    }\r\n\r\n                    if(offsetCol > 0){\r\n                        func = \"=\" + fromulaRef.functionCopy(func, \"right\", offsetCol);\r\n                    }\r\n                    else if(offsetCol < 0){\r\n                        func = \"=\" + fromulaRef.functionCopy(func, \"left\", Math.abs(offsetCol));\r\n                    }\r\n\r\n                    // console.log(offsetRow, offsetCol, func);\r\n\r\n                    (cellValue.v as IluckySheetCelldataValue ).f = func;\r\n                    \r\n                    //\r\n                    let chain = new LuckysheetCalcChain();\r\n                    chain.r = cellValue.r;\r\n                    chain.c = cellValue.c;\r\n                    chain.index = this.index;\r\n                    this.calcChain.push(chain);\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        //There may be formulas that do not appear in calcChain\r\n        for(let key in cellOtherInfo.formulaList){\r\n            if(!(key in formulaListExist)){\r\n                let formulaListItem = cellOtherInfo.formulaList[key];\r\n                let chain = new LuckysheetCalcChain();\r\n                chain.r = formulaListItem.r;\r\n                chain.c = formulaListItem.c;\r\n                chain.index = this.index;\r\n                this.calcChain.push(chain);\r\n            }\r\n        }\r\n      \r\n        // dataVerification config\r\n        this.dataVerification = this.generateConfigDataValidations();\r\n\r\n        // hyperlink config\r\n        this.hyperlink = this.generateConfigHyperlinks();\r\n      \r\n        // sheet hide\r\n        this.hide = this.hide;\r\n\r\n        if(this.mergeCells!=null){\r\n            for(let i=0;i<this.mergeCells.length;i++){\r\n                let merge = this.mergeCells[i], attrList = merge.attributeList;\r\n                let ref = attrList.ref;\r\n                if(ref==null){\r\n                    continue;\r\n                }\r\n                let range = getcellrange(ref, this.sheetList, sheetId);\r\n                let mergeValue = new LuckySheetConfigMerge();\r\n                mergeValue.r = range.row[0];\r\n                mergeValue.c = range.column[0];\r\n                mergeValue.rs = range.row[1]-range.row[0]+1;\r\n                mergeValue.cs = range.column[1]-range.column[0]+1;\r\n                if(this.config.merge==null){\r\n                    this.config.merge = {};\r\n                }\r\n                this.config.merge[range.row[0] + \"_\" + range.column[0]] = mergeValue;\r\n            }\r\n        }\r\n\r\n        let drawingFile = allFileOption.drawingFile, drawingRelsFile = allFileOption.drawingRelsFile;\r\n        if(drawingFile!=null && drawingRelsFile!=null){\r\n            let twoCellAnchors = this.readXml.getElementsByTagName(\"xdr:twoCellAnchor\", drawingFile);\r\n\r\n            if(twoCellAnchors!=null && twoCellAnchors.length>0){\r\n                for(let i=0;i<twoCellAnchors.length;i++){\r\n                    let twoCellAnchor = twoCellAnchors[i];\r\n                    let editAs = getXmlAttibute(twoCellAnchor.attributeList, \"editAs\", \"twoCell\");\r\n\r\n                    let xdrFroms = twoCellAnchor.getInnerElements(\"xdr:from\"), xdrTos = twoCellAnchor.getInnerElements(\"xdr:to\");\r\n\r\n                    let xdr_blipfills = twoCellAnchor.getInnerElements(\"a:blip\");\r\n                    if(xdrFroms!=null && xdr_blipfills!=null && xdrFroms.length>0 && xdr_blipfills.length>0){\r\n                        let xdrFrom = xdrFroms[0], xdrTo = xdrTos[0],xdr_blipfill = xdr_blipfills[0];\r\n                        \r\n                        let rembed = getXmlAttibute(xdr_blipfill.attributeList, \"r:embed\", null);\r\n\r\n                        let imageObject = this.getBase64ByRid(rembed, drawingRelsFile);\r\n                        if (!imageObject) {\r\n                            return;\r\n                        }\r\n\r\n\r\n                        // let aoff = xdr_xfrm.getInnerElements(\"a:off\"), aext = xdr_xfrm.getInnerElements(\"a:ext\");\r\n\r\n                        \r\n\r\n                        // if(aoff!=null && aext!=null && aoff.length>0 && aext.length>0){\r\n                        //     let aoffAttribute = aoff[0].attributeList, aextAttribute = aext[0].attributeList;\r\n                        //     let x = getXmlAttibute(aoffAttribute, \"x\", null);\r\n                        //     let y = getXmlAttibute(aoffAttribute, \"y\", null);\r\n\r\n                        //     let cx = getXmlAttibute(aextAttribute, \"cx\", null);\r\n                        //     let cy = getXmlAttibute(aextAttribute, \"cy\", null);\r\n\r\n                        //     if(x!=null && y!=null && cx!=null && cy!=null && imageObject !=null){\r\n                        // let x_n = getPxByEMUs(parseInt(x), \"c\"),y_n = getPxByEMUs(parseInt(y));\r\n                        // let cx_n = getPxByEMUs(parseInt(cx), \"c\"),cy_n = getPxByEMUs(parseInt(cy));\r\n\r\n                        let x_n =0,y_n = 0;\r\n                        let cx_n = 0, cy_n = 0;\r\n\r\n                        imageObject.fromCol = this.getXdrValue(xdrFrom.getInnerElements(\"xdr:col\"));\r\n                        imageObject.fromColOff = getPxByEMUs(this.getXdrValue(xdrFrom.getInnerElements(\"xdr:colOff\")));\r\n                        imageObject.fromRow= this.getXdrValue(xdrFrom.getInnerElements(\"xdr:row\"));\r\n                        imageObject.fromRowOff = getPxByEMUs(this.getXdrValue(xdrFrom.getInnerElements(\"xdr:rowOff\")));\r\n\r\n                        imageObject.toCol = this.getXdrValue(xdrTo.getInnerElements(\"xdr:col\"));\r\n                        imageObject.toColOff = getPxByEMUs(this.getXdrValue(xdrTo.getInnerElements(\"xdr:colOff\")));\r\n                        imageObject.toRow = this.getXdrValue(xdrTo.getInnerElements(\"xdr:row\"));\r\n                        imageObject.toRowOff = getPxByEMUs(this.getXdrValue(xdrTo.getInnerElements(\"xdr:rowOff\")));\r\n\r\n                        imageObject.originWidth = cx_n;\r\n                        imageObject.originHeight = cy_n;\r\n                        \r\n                        if(editAs==\"absolute\"){\r\n                            imageObject.type = \"3\";\r\n                        }\r\n                        else if(editAs==\"oneCell\"){\r\n                            imageObject.type = \"2\";\r\n                        }\r\n                        else{\r\n                            imageObject.type = \"1\";\r\n                        }\r\n\r\n                        imageObject.isFixedPos = false;\r\n                        imageObject.fixedLeft = 0;\r\n                        imageObject.fixedTop = 0;\r\n\r\n                        let imageBorder:IluckyImageBorder = {\r\n                            color: \"#000\",\r\n                            radius: 0,\r\n                            style: \"solid\",\r\n                            width: 0\r\n                        }\r\n                        imageObject.border = imageBorder;\r\n\r\n                        let imageCrop:IluckyImageCrop = {\r\n                            height: cy_n,\r\n                            offsetLeft: 0,\r\n                            offsetTop: 0,\r\n                            width: cx_n\r\n                        }\r\n                        imageObject.crop = imageCrop;\r\n\r\n                        let imageDefault:IluckyImageDefault = {\r\n                            height: cy_n,\r\n                            left: x_n,\r\n                            top: y_n,\r\n                            width: cx_n\r\n                        }\r\n                        imageObject.default = imageDefault;\r\n\r\n                        if(this.images==null){\r\n                            this.images = {};\r\n                        }\r\n                        this.images[generateRandomIndex(\"image\")] = imageObject;\r\n                        //     }\r\n                        // }\r\n                    }\r\n                }\r\n            }\r\n            \r\n        } \r\n    }\r\n\r\n    private getXdrValue(ele:Element[]):number{\r\n        if(ele==null || ele.length==0){\r\n            return null;\r\n        }\r\n\r\n        return parseInt(ele[0].value);\r\n    }\r\n\r\n    private getBase64ByRid(rid:string, drawingRelsFile:string){\r\n        let Relationships = this.readXml.getElementsByTagName(\"Relationships/Relationship\", drawingRelsFile);\r\n\r\n        if(Relationships!=null && Relationships.length>0){\r\n            for(let i=0;i<Relationships.length;i++){\r\n                let Relationship = Relationships[i];\r\n                let attrList = Relationship.attributeList;\r\n                let Id = getXmlAttibute(attrList, \"Id\", null);\r\n                let src = getXmlAttibute(attrList, \"Target\", null);\r\n                if(Id == rid){\r\n                    src = src.replace(/\\.\\.\\//g, \"\");\r\n                    src = \"xl/\" + src;\r\n                    let imgage = this.imageList.getImageByName(src);\r\n                    return imgage;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n    * @desc This will convert cols/col to luckysheet config of column'width\r\n    */\r\n    private generateConfigColumnLenAndHidden(){\r\n        let cols = this.readXml.getElementsByTagName(\"cols/col\", this.sheetFile);\r\n        for(let i=0;i<cols.length;i++){\r\n            let col = cols[i], attrList = col.attributeList;\r\n            let min = getXmlAttibute(attrList, \"min\", null);\r\n            let max = getXmlAttibute(attrList, \"max\", null);\r\n            let width = getXmlAttibute(attrList, \"width\", null);\r\n            let hidden = getXmlAttibute(attrList, \"hidden\", null);\r\n            let customWidth = getXmlAttibute(attrList, \"customWidth\", null);\r\n\r\n\r\n            if(min==null || max==null){\r\n                continue;\r\n            }\r\n\r\n            let minNum = parseInt(min)-1, maxNum=parseInt(max)-1, widthNum=parseFloat(width);\r\n            \r\n            for(let m=minNum;m<=maxNum;m++){\r\n                if(width!=null){\r\n                    if(this.config.columnlen==null){\r\n                        this.config.columnlen = {};\r\n                    }\r\n                    this.config.columnlen[m] = getColumnWidthPixel(widthNum);\r\n                }\r\n\r\n                if(hidden==\"1\"){\r\n                    if(this.config.colhidden==null){\r\n                        this.config.colhidden = {};\r\n                    }\r\n                    this.config.colhidden[m] = 0;\r\n\r\n                    if(this.config.columnlen){\r\n                        delete this.config.columnlen[m];\r\n                    }\r\n                    \r\n                }\r\n\r\n                if(customWidth!=null){\r\n                    if(this.config.customWidth==null){\r\n                        this.config.customWidth = {};\r\n                    }\r\n                    this.config.customWidth[m] = 1;\r\n                }\r\n            } \r\n        }\r\n    }\r\n\r\n    /**\r\n    * @desc This will convert cols/col to luckysheet config of column'width\r\n    */\r\n    private generateConfigRowLenAndHiddenAddCell():IcellOtherInfo{\r\n        let rows = this.readXml.getElementsByTagName(\"sheetData/row\", this.sheetFile);\r\n        let cellOtherInfo:IcellOtherInfo = {};\r\n        let formulaList:IformulaList = {};\r\n        cellOtherInfo.formulaList = formulaList;\r\n        for(let i=0;i<rows.length;i++){\r\n            let row = rows[i], attrList = row.attributeList;\r\n            let rowNo = getXmlAttibute(attrList, \"r\", null);\r\n            let height = getXmlAttibute(attrList, \"ht\", null);\r\n            let hidden = getXmlAttibute(attrList, \"hidden\", null);\r\n            let customHeight = getXmlAttibute(attrList, \"customHeight\", null);\r\n\r\n            if(rowNo==null){\r\n                continue;\r\n            }\r\n\r\n            let rowNoNum = parseInt(rowNo) - 1;\r\n            if(height!=null){\r\n                let heightNum = parseFloat(height);\r\n                if(this.config.rowlen==null){\r\n                    this.config.rowlen = {};\r\n                }\r\n                this.config.rowlen[rowNoNum] = getRowHeightPixel(heightNum);\r\n            }\r\n\r\n            if(hidden==\"1\"){\r\n                if(this.config.rowhidden==null){\r\n                    this.config.rowhidden = {};\r\n                }\r\n                this.config.rowhidden[rowNoNum] = 0;\r\n                \r\n                if(this.config.rowlen){\r\n                    delete this.config.rowlen[rowNoNum];\r\n                }\r\n                \r\n            }\r\n\r\n            if(customHeight!=null){\r\n                if(this.config.customHeight==null){\r\n                    this.config.customHeight = {};\r\n                }\r\n                this.config.customHeight[rowNoNum] = 1;\r\n            }\r\n\r\n\r\n            if(this.isInitialCell){\r\n                let cells = row.getInnerElements(\"c\");\r\n                for(let key in cells){\r\n                    let cell = cells[key];\r\n                    let cellValue = new LuckySheetCelldata(cell, this.styles, this.sharedStrings, this.mergeCells,this.sheetFile, this.readXml);\r\n                    if(cellValue._borderObject!=null){\r\n                        if(this.config.borderInfo==null){\r\n                            this.config.borderInfo = [];\r\n                        }\r\n                        this.config.borderInfo.push(cellValue._borderObject);\r\n                        delete cellValue._borderObject;\r\n                    }\r\n                    \r\n                    // let borderId = cellValue._borderId;\r\n                    // if(borderId!=null){\r\n                    //     let borders = this.styles[\"borders\"] as Element[];\r\n                    //     if(this.config._borderInfo==null){\r\n                    //         this.config._borderInfo = {};\r\n                    //     }\r\n                    //     if( borderId in this.config._borderInfo){\r\n                    //         this.config._borderInfo[borderId].cells.push(cellValue.r + \"_\" + cellValue.c);\r\n                    //     }\r\n                    //     else{\r\n                    //         let border = borders[borderId];\r\n                    //         let borderObject = new LuckySheetborderInfoCellForImp();\r\n                    //         borderObject.rangeType = \"cellGroup\";\r\n                    //         borderObject.cells = [];\r\n                    //         let borderCellValue = new LuckySheetborderInfoCellValue();\r\n                            \r\n                    //         let lefts = border.getInnerElements(\"left\");\r\n                    //         let rights = border.getInnerElements(\"right\");\r\n                    //         let tops = border.getInnerElements(\"top\");\r\n                    //         let bottoms = border.getInnerElements(\"bottom\");\r\n                    //         let diagonals = border.getInnerElements(\"diagonal\");\r\n\r\n                    //         let left = this.getBorderInfo(lefts);\r\n                    //         let right = this.getBorderInfo(rights);\r\n                    //         let top = this.getBorderInfo(tops);\r\n                    //         let bottom = this.getBorderInfo(bottoms);\r\n                    //         let diagonal = this.getBorderInfo(diagonals);\r\n\r\n                    //         let isAdd = false;\r\n                    //         if(left!=null && left.color!=null){\r\n                    //             borderCellValue.l = left;\r\n                    //             isAdd = true;\r\n                    //         }\r\n\r\n                    //         if(right!=null && right.color!=null){\r\n                    //             borderCellValue.r = right;\r\n                    //             isAdd = true;\r\n                    //         }\r\n\r\n                    //         if(top!=null && top.color!=null){\r\n                    //             borderCellValue.t = top;\r\n                    //             isAdd = true;\r\n                    //         }\r\n\r\n                    //         if(bottom!=null && bottom.color!=null){\r\n                    //             borderCellValue.b = bottom;\r\n                    //             isAdd = true;\r\n                    //         }\r\n\r\n                    //         if(isAdd){\r\n                    //             borderObject.value = borderCellValue;\r\n                    //             this.config._borderInfo[borderId] = borderObject;\r\n                    //         }\r\n\r\n                    //     }\r\n                    // }\r\n                    if(cellValue._formulaType==\"shared\"){\r\n                        if(this.formulaRefList==null){\r\n                            this.formulaRefList = {};\r\n                        }\r\n\r\n                        if(this.formulaRefList[cellValue._formulaSi]==null){\r\n                            this.formulaRefList[cellValue._formulaSi] = {}\r\n                        }\r\n\r\n                        let fv;\r\n                        if(cellValue.v!=null){\r\n                            fv = (cellValue.v as IluckySheetCelldataValue).f;\r\n                        }\r\n\r\n                        let refValue = {\r\n                            t:cellValue._formulaType,\r\n                            ref:cellValue._fomulaRef,\r\n                            si:cellValue._formulaSi,\r\n                            fv:fv,\r\n                            cellValue:cellValue\r\n                        }\r\n\r\n                        if(cellValue._fomulaRef!=null){\r\n                            this.formulaRefList[cellValue._formulaSi][\"mainRef\"] = refValue;\r\n                        }\r\n                        else{\r\n                            this.formulaRefList[cellValue._formulaSi][cellValue.r+\"_\"+cellValue.c] = refValue;\r\n                        }\r\n\r\n                        // console.log(refValue, this.formulaRefList);\r\n                    }\r\n\r\n                    //There may be formulas that do not appear in calcChain\r\n                    if(cellValue.v!=null && (cellValue.v as IluckySheetCelldataValue).f!=null){\r\n                        let formulaCell:IformulaListItem = {\r\n                            r:cellValue.r,\r\n                            c:cellValue.c\r\n                        }\r\n                        cellOtherInfo.formulaList[\"r\"+cellValue.r+\"c\"+cellValue.c] = formulaCell;\r\n                    }\r\n\r\n                    this.celldata.push(cellValue);\r\n                }\r\n                \r\n            }\r\n        }\r\n\r\n        return cellOtherInfo;\r\n    }\r\n  \r\n    /**\r\n     * luckysheet config of dataValidations\r\n     * \r\n     * @returns {IluckysheetDataVerification} - dataValidations config\r\n     */\r\n    private generateConfigDataValidations(): IluckysheetDataVerification {\r\n      \r\n      let rows = this.readXml.getElementsByTagName(\r\n        \"dataValidations/dataValidation\",\r\n        this.sheetFile\r\n      );\r\n      let extLst =\r\n        this.readXml.getElementsByTagName(\r\n          \"extLst/ext/x14:dataValidations/x14:dataValidation\",\r\n          this.sheetFile\r\n        ) || [];\r\n      \r\n      rows = rows.concat(extLst);\r\n  \r\n      let dataVerification: IluckysheetDataVerification = {};\r\n  \r\n      for (let i = 0; i < rows.length; i++) {\r\n        let row = rows[i];\r\n        let attrList = row.attributeList;\r\n        let formulaValue = row.value;\r\n  \r\n        let type = getXmlAttibute(attrList, \"type\", null);\r\n        if(!type) {\r\n            continue;\r\n        }\r\n        let operator = \"\",\r\n            sqref = \"\",\r\n            sqrefIndexArr: string[] = [],\r\n            valueArr: string[] = [];\r\n        let _prohibitInput =\r\n          getXmlAttibute(attrList, \"allowBlank\", null) !== \"1\" ? false : true;\r\n        \r\n        // x14 processing\r\n        const formulaReg = new RegExp(/<x14:formula1>|<xm:sqref>/g)\r\n        if (formulaReg.test(formulaValue) && extLst?.length >= 0) {\r\n          operator = getXmlAttibute(attrList, \"operator\", null);\r\n          const peelOffData = getPeelOffX14(formulaValue);\r\n          sqref = peelOffData?.sqref;\r\n          sqrefIndexArr = getMultiSequenceToNum(sqref);\r\n          valueArr = getMultiFormulaValue(peelOffData?.formula);\r\n        } else {\r\n          operator = getXmlAttibute(attrList, \"operator\", null);\r\n          sqref = getXmlAttibute(attrList, \"sqref\", null);\r\n          sqrefIndexArr = getMultiSequenceToNum(sqref);\r\n          valueArr = getMultiFormulaValue(formulaValue);\r\n        }\r\n\r\n        let _type = DATA_VERIFICATION_MAP[type];\r\n        let _type2 = null;\r\n        let _value1: string | number = valueArr?.length >= 1 ? valueArr[0] : \"\";\r\n        let _value2: string | number = valueArr?.length === 2 ? valueArr[1] : \"\";\r\n        let _hint = getXmlAttibute(attrList, \"prompt\", null);\r\n        let _hintShow = _hint ? true : false\r\n  \r\n        const matchType = COMMON_TYPE2.includes(_type) ? \"common\" : _type;\r\n        _type2 = operator\r\n          ? DATA_VERIFICATION_TYPE2_MAP[matchType][operator]\r\n          : \"bw\";\r\n        \r\n        // mobile phone number processing\r\n        if (\r\n          _type === \"text_content\" &&\r\n          (_value1?.includes(\"LEN\") || _value1?.includes(\"len\")) &&\r\n          _value1?.includes(\"=11\")\r\n        ) {\r\n          _type = \"validity\";\r\n          _type2 = \"phone\";\r\n        }\r\n\r\n        // date processing\r\n        if (_type === \"date\") {\r\n          const D1900 = new Date(1899, 11, 30, 0, 0, 0);\r\n          _value1 = dayjs(D1900)\r\n            .clone()\r\n            .add(Number(_value1), \"day\")\r\n            .format(\"YYYY-MM-DD\");\r\n          _value2 = dayjs(D1900)\r\n            .clone()\r\n            .add(Number(_value2), \"day\")\r\n            .format(\"YYYY-MM-DD\");\r\n        }\r\n        \r\n        // checkbox and dropdown processing\r\n        if (_type === \"checkbox\" || _type === \"dropdown\") {\r\n          _type2 = null;\r\n        }\r\n        \r\n        // dynamically add dataVerifications\r\n        for (const ref of sqrefIndexArr) {\r\n          dataVerification[ref] = {\r\n            type: _type,\r\n            type2: _type2,\r\n            value1: _value1,\r\n            value2: _value2,\r\n            checked: false,\r\n            remote: false,\r\n            prohibitInput: _prohibitInput,\r\n            hintShow: _hintShow,\r\n            hintText: _hint\r\n          };\r\n        }\r\n      }\r\n  \r\n      return dataVerification;\r\n    }\r\n  \r\n    /**\r\n     * luckysheet config of hyperlink\r\n     * \r\n     * @returns {IluckysheetHyperlink} - hyperlink config\r\n     */\r\n    private generateConfigHyperlinks(): IluckysheetHyperlink {\r\n      let rows = this.readXml.getElementsByTagName(\r\n        \"hyperlinks/hyperlink\",\r\n        this.sheetFile\r\n      );\r\n      let hyperlink: IluckysheetHyperlink = {};\r\n      for (let i = 0; i < rows.length; i++) {\r\n        let row = rows[i];\r\n        let attrList = row.attributeList;\r\n        let ref = getXmlAttibute(attrList, \"ref\", null),\r\n            refArr = getMultiSequenceToNum(ref),\r\n            _display = getXmlAttibute(attrList, \"display\", null),\r\n            _address = getXmlAttibute(attrList, \"location\", null),\r\n            _tooltip = getXmlAttibute(attrList, \"tooltip\", null);\r\n        let _type: IluckysheetHyperlinkType = _address ? \"internal\" : \"external\";\r\n  \r\n        // external hyperlink\r\n        if (!_address) {\r\n          let rid = attrList[\"r:id\"];\r\n          let sheetFile = this.sheetFile;\r\n          let relationshipList = this.readXml.getElementsByTagName(\r\n            \"Relationships/Relationship\",\r\n            `xl/worksheets/_rels/${sheetFile.replace(worksheetFilePath, \"\")}.rels`\r\n          );\r\n  \r\n          const findRid = relationshipList?.find(\r\n            (e) => e.attributeList[\"Id\"] === rid\r\n          );\r\n\r\n          if (findRid) {\r\n            _address = findRid.attributeList[\"Target\"];\r\n            _type = findRid.attributeList[\r\n              \"TargetMode\"\r\n            ]?.toLocaleLowerCase() as IluckysheetHyperlinkType;\r\n          }\r\n        }\r\n\r\n        // match R1C1\r\n        const addressReg = new RegExp(/^.*!R([\\d$])+C([\\d$])*$/g)\r\n        if (addressReg.test(_address)) {\r\n          _address = getTransR1C1ToSequence(_address);\r\n        }\r\n        \r\n        // dynamically add hyperlinks\r\n        for (const ref of refArr) {\r\n          hyperlink[ref] = {\r\n            linkAddress: _address,\r\n            linkTooltip: _tooltip || \"\",\r\n            linkType: _type,\r\n            display: _display || \"\",\r\n          };\r\n        }\r\n      }\r\n      \r\n      return hyperlink;\r\n    }\r\n\r\n    // private getBorderInfo(borders:Element[]):LuckySheetborderInfoCellValueStyle{\r\n    //     if(borders==null){\r\n    //         return null;\r\n    //     }\r\n\r\n    //     let border = borders[0], attrList = border.attributeList;\r\n    //     let clrScheme = this.styles[\"clrScheme\"] as Element[];\r\n    //     let style:string = attrList.style;\r\n    //     if(style==null || style==\"none\"){\r\n    //         return null;\r\n    //     }\r\n\r\n    //     let colors = border.getInnerElements(\"color\");\r\n    //     let colorRet = \"#000000\";\r\n    //     if(colors!=null){\r\n    //         let color = colors[0];\r\n    //         colorRet = getColor(color, clrScheme);\r\n    //     }\r\n\r\n    //     let ret = new LuckySheetborderInfoCellValueStyle();\r\n    //     ret.style = borderTypes[style];\r\n    //     ret.color = colorRet;\r\n\r\n    //     return ret;\r\n    // }\r\n}\r\n","import {IuploadfileList, IattributeList, stringToNum} from \"../ICommon\";\r\nimport {indexedColors}  from \"../common/constant\";\r\nimport {LightenDarkenColor}  from \"../common/method\";\r\n\r\n\r\nclass xmloperation {\r\n    /**\r\n    * @param tag Search xml tag name , div,title etc.\r\n    * @param file Xml string\r\n    * @return Xml element string \r\n    */\r\n    protected getElementsByOneTag(tag:string, file:string):string[]{\r\n        //<a:[^/>: ]+?>.*?</a:[^/>: ]+?>\r\n        let readTagReg;\r\n        if(tag.indexOf(\"|\")>-1){\r\n            let tags = tag.split(\"|\"), tagsRegTxt=\"\";\r\n            for(let i=0;i<tags.length;i++){\r\n                let t = tags[i];\r\n                tagsRegTxt += \"|<\"+ t +\" [^>]+?[^/]>[\\\\s\\\\S]*?</\"+ t +\">|<\"+ t +\" [^>]+?/>|<\"+ t +\">[\\\\s\\\\S]*?</\"+ t +\">|<\"+ t +\"/>\";\r\n            }\r\n            tagsRegTxt = tagsRegTxt.substr(1, tagsRegTxt.length);\r\n            readTagReg = new RegExp(tagsRegTxt, \"g\");\r\n        }\r\n        else{\r\n            readTagReg = new RegExp(\"<\"+ tag +\" [^>]+?[^/]>[\\\\s\\\\S]*?</\"+ tag +\">|<\"+ tag +\" [^>]+?/>|<\"+ tag +\">[\\\\s\\\\S]*?</\"+ tag +\">|<\"+ tag +\"/>\", \"g\");\r\n        }\r\n        \r\n        let ret = file.match(readTagReg);\r\n        if(ret==null){\r\n            return [];\r\n        }\r\n        else{\r\n            return ret;\r\n        }\r\n    }\r\n}\r\n\r\nexport class ReadXml extends xmloperation{\r\n    originFile:IuploadfileList\r\n    constructor(files:IuploadfileList){\r\n        super();\r\n        this.originFile = files;\r\n    }\r\n    /**\r\n    * @param path Search xml tag group , div,title etc.\r\n    * @param fileName One of uploadfileList, uploadfileList is file group, {key:value}\r\n    * @return Xml element calss\r\n    */\r\n    getElementsByTagName(path:string, fileName:string): Element[]{\r\n        \r\n        let file = this.getFileByName(fileName);\r\n        let pathArr = path.split(\"/\"), ret:string[] | string;\r\n        for(let key in pathArr){\r\n            let path = pathArr[key];\r\n            if(ret==undefined){\r\n                ret = this.getElementsByOneTag(path,file);\r\n            }\r\n            else{\r\n                if(ret instanceof Array){\r\n                    let items:string[]=[];\r\n                    for(let key in ret){\r\n                        let item = ret[key];\r\n                        items = items.concat(this.getElementsByOneTag(path,item));\r\n                    }\r\n                    ret = items;\r\n                }\r\n                else{\r\n                    ret = this.getElementsByOneTag(path,ret);\r\n                }\r\n            }\r\n        }\r\n\r\n        let elements:Element[] = [];\r\n\r\n        for(let i=0;i<ret.length;i++){\r\n            let ele = new Element(ret[i]);\r\n            elements.push(ele);\r\n        }\r\n\r\n        return elements;\r\n    }\r\n\r\n    /**\r\n    * @param name One of uploadfileList's name, search for file by this parameter\r\n    * @retrun Select a file from uploadfileList\r\n    */\r\n    private getFileByName(name:string):string{\r\n        for(let fileKey in this.originFile){\r\n            if(fileKey.indexOf(name)>-1){\r\n                return this.originFile[fileKey];\r\n            }\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    \r\n}\r\n\r\nexport class Element extends xmloperation {\r\n    elementString:string\r\n    attributeList:IattributeList\r\n    value:string\r\n    container:string\r\n    constructor(str:string){\r\n        super();\r\n        this.elementString = str;\r\n        this.setValue();\r\n        const readAttrReg = new RegExp('[a-zA-Z0-9_:]*?=\".*?\"', \"g\");\r\n        let attrList = this.container.match(readAttrReg);\r\n        this.attributeList = {};\r\n        if(attrList!=null){\r\n            for(let key in attrList){\r\n                let attrFull = attrList[key];\r\n                // let al= attrFull.split(\"=\");\r\n                if(attrFull.length==0){\r\n                    continue;\r\n                }\r\n                let attrKey = attrFull.substr(0, attrFull.indexOf('='));\r\n                let attrValue = attrFull.substr(attrFull.indexOf('=') + 1);\r\n                if(attrKey==null || attrValue==null ||attrKey.length==0 || attrValue.length==0){\r\n                    continue;\r\n                }\r\n                this.attributeList[attrKey] = attrValue.substr(1, attrValue.length-2);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @param name Get attribute by key in element\r\n    * @return Single attribute\r\n    */\r\n    get(name:string):string|number|boolean{\r\n        return this.attributeList[name];\r\n    }\r\n\r\n    /**\r\n    * @param tag Get elements by tag in elementString\r\n    * @return Element group\r\n    */\r\n    getInnerElements(tag:string):Element[]{\r\n        let ret = this.getElementsByOneTag(tag,this.elementString);\r\n        let elements:Element[] = [];\r\n\r\n        for(let i=0;i<ret.length;i++){\r\n            let ele = new Element(ret[i]);\r\n            elements.push(ele);\r\n        }\r\n\r\n        if(elements.length==0){\r\n            return null;\r\n        }\r\n        return elements;\r\n    }\r\n\r\n    /**\r\n    * @desc get xml dom value and container, <container>value</container>\r\n    */\r\n    private setValue(){\r\n        let str = this.elementString;\r\n        if(str.substr(str.length-2, 2)==\"/>\"){\r\n            this.value = \"\";\r\n            this.container = str;\r\n        }\r\n        else{\r\n            let firstTag = this.getFirstTag();\r\n            const firstTagReg = new RegExp(\"(<\"+ firstTag +\" [^>]+?[^/]>)([\\\\s\\\\S]*?)</\"+ firstTag +\">|(<\"+ firstTag +\">)([\\\\s\\\\S]*?)</\"+ firstTag +\">\", \"g\");\r\n            let result = firstTagReg.exec(str);\r\n            if (result != null) {\r\n                if(result[1]!=null){\r\n                    this.container = result[1];\r\n                    this.value = result[2];\r\n                }\r\n                else{\r\n                    this.container = result[3];\r\n                    this.value = result[4];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @desc get xml dom first tag, <a><b></b></a>, get a\r\n    */\r\n    private getFirstTag(){\r\n        let str = this.elementString;\r\n        let firstTag = str.substr(0, str.indexOf(' '));\r\n        if(firstTag==\"\" || firstTag.indexOf(\">\")>-1){\r\n            firstTag = str.substr(0, str.indexOf('>'));\r\n        }\r\n        firstTag = firstTag.substr(1,firstTag.length);\r\n        return firstTag;\r\n    }\r\n}\r\n\r\n\r\nexport interface IStyleCollections {\r\n    [index:string]:Element[] | IattributeList\r\n}\r\n\r\nfunction combineIndexedColor(indexedColorsInner:Element[], indexedColors:IattributeList):IattributeList{\r\n    let ret:IattributeList = {};\r\n    if(indexedColorsInner==null || indexedColorsInner.length==0){\r\n        return indexedColors;\r\n    }\r\n    for(let key in indexedColors){\r\n        let value = indexedColors[key], kn = parseInt(key);\r\n        let inner = indexedColorsInner[kn];\r\n        if(inner==null){\r\n            ret[key] = value;\r\n        }\r\n        else{\r\n            let rgb = inner.attributeList.rgb;\r\n            ret[key] = rgb;\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\n//clrScheme:Element[]\r\nexport function getColor(color:Element, styles:IStyleCollections , type:string=\"g\"){\r\n    let attrList = color.attributeList;\r\n    let clrScheme = styles[\"clrScheme\"] as Element[];\r\n    let indexedColorsInner = styles[\"indexedColors\"] as Element[];\r\n    let mruColorsInner = styles[\"mruColors\"];\r\n    let indexedColorsList = combineIndexedColor(indexedColorsInner, indexedColors);\r\n    let indexed = attrList.indexed, rgb = attrList.rgb, theme = attrList.theme, tint = attrList.tint;\r\n    let bg;\r\n    if(indexed!=null){\r\n        let indexedNum = parseInt(indexed);\r\n        bg = indexedColorsList[indexedNum];\r\n        if(bg!=null){\r\n            bg = bg.substring(bg.length-6, bg.length);\r\n            bg = \"#\"+bg;\r\n        }\r\n    }\r\n    else if(rgb!=null){\r\n        rgb = rgb.substring(rgb.length-6, rgb.length);\r\n        bg = \"#\"+rgb;\r\n    }\r\n    else if(theme!=null){\r\n        let themeNum = parseInt(theme);\r\n        if(themeNum==0){\r\n            themeNum = 1;\r\n        }\r\n        else if(themeNum==1){\r\n            themeNum = 0;\r\n        }\r\n        else if(themeNum==2){\r\n            themeNum = 3;\r\n        }\r\n        else if(themeNum==3){\r\n            themeNum = 2;\r\n        }\r\n        let clrSchemeElement = clrScheme[themeNum];\r\n        if(clrSchemeElement!=null){\r\n            let clrs = clrSchemeElement.getInnerElements(\"a:sysClr|a:srgbClr\");\r\n            if(clrs!=null){\r\n                let clr = clrs[0];\r\n                let clrAttrList = clr.attributeList;\r\n                // console.log(clr.container, );\r\n                if(clr.container.indexOf(\"sysClr\")>-1){\r\n                    // if(type==\"g\" && clrAttrList.val==\"windowText\"){\r\n                    //     bg = null;\r\n                    // }\r\n                    // else if((type==\"t\" || type==\"b\") && clrAttrList.val==\"window\"){\r\n                    //     bg = null;\r\n                    // }                    \r\n                    // else \r\n                    if(clrAttrList.lastClr!=null){\r\n                        bg = \"#\" + clrAttrList.lastClr;\r\n                    }\r\n                    else if(clrAttrList.val!=null){\r\n                        bg = \"#\" + clrAttrList.val;\r\n                    }\r\n\r\n                }\r\n                else if(clr.container.indexOf(\"srgbClr\")>-1){\r\n                    // console.log(clrAttrList.val);\r\n                    bg = \"#\" + clrAttrList.val;\r\n                }\r\n            }\r\n        }\r\n        \r\n    }\r\n    \r\n    if(tint!=null){\r\n        let tintNum = parseFloat(tint);\r\n        if(bg!=null){\r\n            bg = LightenDarkenColor(bg, tintNum);\r\n        }\r\n    }\r\n\r\n    return bg;\r\n}\r\n\r\n\r\n/** \r\n * @dom xml attribute object\r\n * @attr attribute name\r\n * @d if attribute is null, return default value \r\n * @return attribute value\r\n*/\r\nexport function getlineStringAttr(frpr:Element, attr:string):string{\r\n    let attrEle = frpr.getInnerElements(attr), value;\r\n\r\n    if(attrEle!=null && attrEle.length>0){\r\n        if(attr==\"b\" || attr==\"i\" || attr==\"strike\"){\r\n            value = \"1\";\r\n        }\r\n        else if(attr==\"u\"){\r\n            let v = attrEle[0].attributeList.val;\r\n            if(v==\"double\"){\r\n                value=\"2\";\r\n            }\r\n            elseif(v==\"singleAccounting\"){\r\n                value=\"3\";\r\n            }\r\n            elseif(v==\"doubleAccounting\"){\r\n                value=\"4\";\r\n            }\r\n            else{\r\n                value = \"1\";\r\n            }\r\n        }\r\n        else if(attr==\"vertAlign\"){\r\n            let v = attrEle[0].attributeList.val;\r\n            if(v==\"subscript\"){\r\n                value = \"1\";\r\n            }\r\n            else if(v==\"superscript\"){\r\n                value = \"2\";\r\n            }\r\n        }\r\n        else{\r\n            value = attrEle[0].attributeList.val;\r\n        }\r\n        \r\n    }\r\n\r\n    return value;\r\n}","import {stringToNum, IattributeList, numTostring, IDataVerificationMap, IDataVerificationType2Map} from \"../ICommon\";\r\n\r\nexport const columeHeader_word:string[] = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\r\n\r\nexport const columeHeader_word_index:stringToNum = { 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7, 'I': 8, 'J': 9, 'K': 10, 'L': 11, 'M': 12, 'N': 13, 'O': 14, 'P': 15, 'Q': 16, 'R': 17, 'S': 18, 'T': 19, 'U': 20, 'V': 21, 'W': 22, 'X': 23, 'Y': 24, 'Z': 25 };\r\n\r\nexport const coreFile = \"docProps/core.xml\";\r\nexport const appFile = \"docProps/app.xml\";\r\nexport const contentTypesFile = \"[Content_Types].xml\";\r\nexport const workBookFile = \"xl/workbook.xml\";\r\nexport const calcChainFile = \"xl/calcChain.xml\";\r\nexport const stylesFile = \"xl/styles.xml\";\r\nexport const sharedStringsFile = \"xl/sharedStrings.xml\";\r\nexport const worksheetFilePath = \"xl/worksheets/\";\r\nexport const theme1File = \"xl/theme/theme1.xml\";\r\nexport const workbookRels= \"xl/_rels/workbook.xml.rels\";\r\n\r\n\r\n\r\n\r\n//Excel Built-In cell type\r\nexport const ST_CellType:IattributeList ={\r\n    \"Boolean\":\"b\",\r\n    \"Date\":\"d\",\r\n    \"Error\":\"e\",\r\n    \"InlineString\":\"inlineStr\",\r\n    \"Number\":\"n\",\r\n    \"SharedString\":\"s\",\r\n    \"String\":\"str\",\r\n}\r\n\r\n//Excel Built-In cell style\r\nexport const BuiltInCellStyles:IattributeList = {\r\n    \"0\":\"Normal\",\r\n\r\n}\r\n\r\n\r\nexport let numFmtDefault:IattributeList = {\r\n    \"0\":'General',\r\n    \"1\": '0',\r\n    \"2\": '0.00',\r\n    \"3\": '#,##0',\r\n    \"4\": '#,##0.00',\r\n    \"9\":'0%',\r\n    \"10\": '0.00%',\r\n    \"11\": '0.00E+00',\r\n    \"12\": '# ?/?',\r\n    \"13\": '# ??/??',\r\n    \"14\": 'm/d/yy',\r\n    \"15\": 'd-mmm-yy',\r\n    \"16\": 'd-mmm',\r\n    \"17\": 'mmm-yy',\r\n    \"18\": 'h:mm AM/PM',\r\n    \"19\": 'h:mm:ss AM/PM',\r\n    \"20\": 'h:mm',\r\n    \"21\": 'h:mm:ss',\r\n    \"22\": 'm/d/yy h:mm',\r\n    \"37\": '#,##0 ;(#,##0)',\r\n    \"38\": '#,##0 ;[Red](#,##0)',\r\n    \"39\": '#,##0.00;(#,##0.00)',\r\n    \"40\": '#,##0.00;[Red](#,##0.00)',\r\n    \"45\": 'mm:ss',\r\n    \"46\": '[h]:mm:ss',\r\n    \"47\": 'mmss.0',\r\n    \"48\": '##0.0E+0',\r\n    \"49\": '@'\r\n}\r\n\r\nexport const indexedColors:IattributeList = {\r\n    \"0\":'00000000',\r\n    \"1\":'00FFFFFF',\r\n    \"2\":'00FF0000',\r\n    \"3\":'0000FF00',\r\n    \"4\":'000000FF',\r\n    \"5\":'00FFFF00',\r\n    \"6\":'00FF00FF',\r\n    \"7\":'0000FFFF',\r\n    \"8\":'00000000',\r\n    \"9\":'00FFFFFF',\r\n    \"10\":'00FF0000',\r\n    \"11\":'0000FF00',\r\n    \"12\":'000000FF',\r\n    \"13\":'00FFFF00',\r\n    \"14\":'00FF00FF',\r\n    \"15\":'0000FFFF',\r\n    \"16\":'00800000',\r\n    \"17\":'00008000',\r\n    \"18\":'00000080',\r\n    \"19\":'00808000',\r\n    \"20\":'00800080',\r\n    \"21\":'00008080',\r\n    \"22\":'00C0C0C0',\r\n    \"23\":'00808080',\r\n    \"24\":'009999FF',\r\n    \"25\":'00993366',\r\n    \"26\":'00FFFFCC',\r\n    \"27\":'00CCFFFF',\r\n    \"28\":'00660066',\r\n    \"29\":'00FF8080',\r\n    \"30\":'000066CC',\r\n    \"31\":'00CCCCFF',\r\n    \"32\":'00000080',\r\n    \"33\":'00FF00FF',\r\n    \"34\":'00FFFF00',\r\n    \"35\":'0000FFFF',\r\n    \"36\":'00800080',\r\n    \"37\":'00800000',\r\n    \"38\":'00008080',\r\n    \"39\":'000000FF',\r\n    \"40\":'0000CCFF',\r\n    \"41\":'00CCFFFF',\r\n    \"42\":'00CCFFCC',\r\n    \"43\":'00FFFF99',\r\n    \"44\":'0099CCFF',\r\n    \"45\":'00FF99CC',\r\n    \"46\":'00CC99FF',\r\n    \"47\":'00FFCC99',\r\n    \"48\":'003366FF',\r\n    \"49\":'0033CCCC',\r\n    \"50\":'0099CC00',\r\n    \"51\":'00FFCC00',\r\n    \"52\":'00FF9900',\r\n    \"53\":'00FF6600',\r\n    \"54\":'00666699',\r\n    \"55\":'00969696',\r\n    \"56\":'00003366',\r\n    \"57\":'00339966',\r\n    \"58\":'00003300',\r\n    \"59\":'00333300',\r\n    \"60\":'00993300',\r\n    \"61\":'00993366',\r\n    \"62\":'00333399',\r\n    \"63\":'00333333',\r\n    \"64\":null,//system Foreground n/a\r\n    \"65\":null,//system Background n/a\r\n}\r\n\r\nexport const OEM_CHARSET:IattributeList = {\r\n    \"0\": \"ANSI_CHARSET\",\r\n    \"1\": \"DEFAULT_CHARSET\",\r\n    \"2\": \"SYMBOL_CHARSET\",\r\n    \"77\": \"MAC_CHARSET\",\r\n    \"128\": \"SHIFTJIS_CHARSET\",\r\n    \"129\": \"HANGUL_CHARSET\",\r\n    \"130\": \"JOHAB_CHARSET\",\r\n    \"134\": \"GB2312_CHARSET\",\r\n    \"136\": \"CHINESEBIG5_CHARSET\",\r\n    \"161\": \"GREEK_CHARSET\",\r\n    \"162\": \"TURKISH_CHARSET\",\r\n    \"163\": \"VIETNAMESE_CHARSET\",\r\n    \"177\": \"HEBREW_CHARSET\",\r\n    \"178\": \"ARABIC_CHARSET\",\r\n    \"186\": \"BALTIC_CHARSET\",\r\n    \"204\": \"RUSSIAN_CHARSET\",\r\n    \"222\": \"THAI_CHARSET\",\r\n    \"238\": \"EASTEUROPE_CHARSET\",\r\n    \"255\": \"OEM_CHARSET\",\r\n}\r\n\r\n\r\nexport const borderTypes:stringToNum = {\r\n    \"none\":0,\r\n    \"thin\":1, \r\n    \"hair\":2, \r\n    \"dotted\":3, \r\n    \"dashed\":4, \r\n    \"dashDot\":5, \r\n    \"dashDotDot\":6, \r\n    \"double\":7, \r\n    \"medium\":8, \r\n    \"mediumDashed\":9, \r\n    \"mediumDashDot\":10, \r\n    \"mediumDashDotDot\":11, \r\n    \"slantDashDot\":12, \r\n    \"thick\":13\r\n}\r\n\r\n\r\nexport let numFmtDefaultMap: IattributeList = {\r\n    \"yyyy/m/d;@\": \"yyyy/MM/dd\",\r\n    \"yyyy&quot;&quot;m&quot;&quot;d&quot;&quot;;@\":\r\n      \"yyyy&quot;&quot;MM&quot;&quot;dd&quot;&quot;\",\r\n    \"[$-409]yyyy/m/d\\\\ h:mm\\\\ AM/PM;@\": \"yyyy/MM/dd hh:mm AM/PM\",\r\n};\r\n\r\nexport const fontFamilys:IattributeList = {\r\n    \"0\":\"defualt\",\r\n    \"1\":\"Roman\",\r\n    \"2\":\"Swiss\",\r\n    \"3\":\"Modern\",\r\n    \"4\":\"Script\",\r\n    \"5\":\"Decorative\"\r\n}\r\n\r\nexport const DATA_VERIFICATION_MAP: IDataVerificationMap = {\r\n    list: \"dropdown\",\r\n    whole: \"number_integer\",\r\n    decimal: \"number_decimal\",\r\n    custom: \"text_content\",\r\n    textLength: \"text_length\",\r\n    date: \"date\",\r\n    \"unknown1\": \"number\", // no match yet\r\n    \"unknown2\": \"checkbox\", // no match yet\r\n    \"unknown3\": \"validity\", // no match yet\r\n};\r\n\r\nexport const COMMON_TYPE2: string[] = [\r\n    \"number\",\r\n    \"number_integer\",\r\n    \"number_decimal\",\r\n    \"text_length\",\r\n];\r\n\r\nexport const DATA_VERIFICATION_TYPE2_MAP: IDataVerificationType2Map = {\r\n    common: {\r\n      between: \"bw\",\r\n      notBetween: \"nb\",\r\n      equal: \"eq\",\r\n      notEqualTo: \"ne\",\r\n      moreThanThe: \"gt\",\r\n      lessThan: \"lt\",\r\n      greaterOrEqualTo: \"gte\",\r\n      lessThanOrEqualTo: \"lte\",\r\n    },\r\n    text_content: {\r\n      include: \"include\",\r\n      exclude: \"exclude\",\r\n      equal: \"equal\",\r\n    },\r\n    date: {\r\n      between: \"bw\",\r\n      notBetween: \"nb\",\r\n      equal: \"eq\",\r\n      notEqualTo: \"ne\",\r\n      earlierThan: \"bf\",\r\n      noEarlierThan: \"nbf\",\r\n      laterThan: \"af\",\r\n      noLaterThan: \"naf\",\r\n    },\r\n    validity: {\r\n      card: \"card\",\r\n      phone: \"phone\",\r\n    },\r\n};\r\n","export let UDOC:any = {};\r\n\t\r\n\tUDOC.G = {\r\n\t\tconcat : function(p:any,r:any) {\r\n\t\t\tfor(var i=0; i<r.cmds.length; i++) p.cmds.push(r.cmds[i]);\r\n\t\t\tfor(var i=0; i<r.crds.length; i++) p.crds.push(r.crds[i]);\r\n\t\t},\r\n\t\tgetBB  : function(ps:any) {\r\n\t\t\tvar x0=1e99, y0=1e99, x1=-x0, y1=-y0;\r\n\t\t\tfor(var i=0; i<ps.length; i+=2) {  var x=ps[i],y=ps[i+1];  if(x<x0)x0=x; else if(x>x1)x1=x;  if(y<y0)y0=y;  else if(y>y1)y1=y;  }\r\n\t\t\treturn [x0,y0,x1,y1];\r\n\t\t},\r\n\t\trectToPath: function(r:any) {  return  {cmds:[\"M\",\"L\",\"L\",\"L\",\"Z\"],crds:[r[0],r[1],r[2],r[1], r[2],r[3],r[0],r[3]]};  },\r\n\t\t// a inside b\r\n\t\tinsideBox: function(a:any,b:any) {  return b[0]<=a[0] && b[1]<=a[1] && a[2]<=b[2] && a[3]<=b[3];   },\r\n\t\tisBox : function(p:any, bb:any) {\r\n\t\t\tvar sameCrd8 = function(pcrd:any, crds:any) {\r\n\t\t\t\tfor(var o=0; o<8; o+=2) {  var eq = true;  for(var j=0; j<8; j++) if(Math.abs(crds[j]-pcrd[(j+o)&7])>=2) {  eq = false;  break;  }    if(eq) return true;  }\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t\tif(p.cmds.length>10) return false;\r\n\t\t\tvar cmds=p.cmds.join(\"\"), crds=p.crds;\r\n\t\t\tvar sameRect = false;\r\n\t\t\tif((cmds==\"MLLLZ\"  && crds.length== 8) \r\n\t\t\t ||(cmds==\"MLLLLZ\" && crds.length==10) ) {\r\n\t\t\t\tif(crds.length==10) crds=crds.slice(0,8);\r\n\t\t\t\tvar x0=bb[0],y0=bb[1],x1=bb[2],y1=bb[3];\r\n\t\t\t\tif(!sameRect) sameRect = sameCrd8(crds, [x0,y0,x1,y0,x1,y1,x0,y1]);\r\n\t\t\t\tif(!sameRect) sameRect = sameCrd8(crds, [x0,y1,x1,y1,x1,y0,x0,y0]);\r\n\t\t\t}\r\n\t\t\treturn sameRect;\r\n\t\t},\r\n\t\tboxArea: function(a:any) {  var w=a[2]-a[0], h=a[3]-a[1];  return w*h;  },\r\n\t\tnewPath: function(gst:any    ) {  gst.pth = {cmds:[], crds:[]};  },\r\n\t\tmoveTo : function(gst:any,x:any,y:any) {  var p=UDOC.M.multPoint(gst.ctm,[x,y]);  //if(gst.cpos[0]==p[0] && gst.cpos[1]==p[1]) return;\r\n\t\t\t\t\t\t\t\t\t\tgst.pth.cmds.push(\"M\");  gst.pth.crds.push(p[0],p[1]);  gst.cpos = p;  },\r\n\t\tlineTo : function(gst:any,x:any,y:any) {  var p=UDOC.M.multPoint(gst.ctm,[x,y]);  if(gst.cpos[0]==p[0] && gst.cpos[1]==p[1]) return;\r\n\t\t\t\t\t\t\t\t\t\tgst.pth.cmds.push(\"L\");  gst.pth.crds.push(p[0],p[1]);  gst.cpos = p;  },\r\n\t\tcurveTo: function(gst:any,x1:any,y1:any,x2:any,y2:any,x3:any,y3:any) {   var p;  \r\n\t\t\tp=UDOC.M.multPoint(gst.ctm,[x1,y1]);  x1=p[0];  y1=p[1];\r\n\t\t\tp=UDOC.M.multPoint(gst.ctm,[x2,y2]);  x2=p[0];  y2=p[1];\r\n\t\t\tp=UDOC.M.multPoint(gst.ctm,[x3,y3]);  x3=p[0];  y3=p[1];  gst.cpos = p;\r\n\t\t\tgst.pth.cmds.push(\"C\");  \r\n\t\t\tgst.pth.crds.push(x1,y1,x2,y2,x3,y3);  \r\n\t\t},\r\n\t\tclosePath: function(gst:any  ) {  gst.pth.cmds.push(\"Z\");  },\r\n\t\tarc : function(gst:any,x:any,y:any,r:any,a0:any,a1:any, neg:any) {\r\n\t\t\t\r\n\t\t\t// circle from a0 counter-clock-wise to a1\r\n\t\t\tif(neg) while(a1>a0) a1-=2*Math.PI;\r\n\t\t\telse    while(a1<a0) a1+=2*Math.PI;\r\n\t\t\tvar th = (a1-a0)/4;\r\n\t\t\t\r\n\t\t\tvar x0 = Math.cos(th/2), y0 = -Math.sin(th/2);\r\n\t\t\tvar x1 = (4-x0)/3, y1 = y0==0 ? y0 : (1-x0)*(3-x0)/(3*y0);\r\n\t\t\tvar x2 = x1, y2 = -y1;\r\n\t\t\tvar x3 = x0, y3 = -y0;\r\n\t\t\t\r\n\t\t\tvar p0 = [x0,y0], p1 = [x1,y1], p2 = [x2,y2], p3 = [x3,y3];\r\n\t\t\t\r\n\t\t\tvar pth = {cmds:[(gst.pth.cmds.length==0)?\"M\":\"L\",\"C\",\"C\",\"C\",\"C\"], crds:[x0,y0,x1,y1,x2,y2,x3,y3]};\r\n\t\t\t\r\n\t\t\tvar rot = [1,0,0,1,0,0];  UDOC.M.rotate(rot,-th);\r\n\t\t\t\r\n\t\t\tfor(var i=0; i<3; i++) {\r\n\t\t\t\tp1 = UDOC.M.multPoint(rot,p1);  p2 = UDOC.M.multPoint(rot,p2);  p3 = UDOC.M.multPoint(rot,p3);\r\n\t\t\t\tpth.crds.push(p1[0],p1[1],p2[0],p2[1],p3[0],p3[1]);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar sc = [r,0,0,r,x,y];  \r\n\t\t\tUDOC.M.rotate(rot, -a0+th/2);  UDOC.M.concat(rot, sc);  UDOC.M.multArray(rot, pth.crds);\r\n\t\t\tUDOC.M.multArray(gst.ctm, pth.crds);\r\n\t\t\t\r\n\t\t\tUDOC.G.concat(gst.pth, pth);\r\n\t\t\tvar y:any=pth.crds.pop();  x=pth.crds.pop();\r\n\t\t\tgst.cpos = [x,y];\r\n\t\t},\r\n\t\ttoPoly : function(p:any) {\r\n\t\t\tif(p.cmds[0]!=\"M\" || p.cmds[p.cmds.length-1]!=\"Z\") return null;\r\n\t\t\tfor(var i=1; i<p.cmds.length-1; i++) if(p.cmds[i]!=\"L\") return null;\r\n\t\t\tvar out = [], cl = p.crds.length;\r\n\t\t\tif(p.crds[0]==p.crds[cl-2] && p.crds[1]==p.crds[cl-1]) cl-=2;\r\n\t\t\tfor(var i=0; i<cl; i+=2) out.push([p.crds[i],p.crds[i+1]]);\r\n\t\t\tif(UDOC.G.polyArea(p.crds)<0) out.reverse();\r\n\t\t\treturn out;\r\n\t\t},\r\n\t\tfromPoly : function(p:any) {\r\n\t\t\tvar o:any = {cmds:[],crds:[]};\r\n\t\t\tfor(var i=0; i<p.length; i++) { o.crds.push(p[i][0], p[i][1]);  o.cmds.push(i==0?\"M\":\"L\");  }\r\n\t\t\to.cmds.push(\"Z\");\r\n\t\t\treturn o;\r\n\t\t},\r\n\t\tpolyArea : function(p:any) {\r\n\t\t\tif(p.length <6) return 0;\r\n\t\t\tvar l = p.length - 2;\r\n\t\t\tvar sum = (p[0]-p[l]) * (p[l+1]+p[1]);\r\n\t\t\tfor(var i=0; i<l; i+=2)\r\n\t\t\t\tsum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);\r\n\t\t\treturn - sum * 0.5;\r\n\t\t},\r\n\t\tpolyClip : function(p0:any, p1:any) {  // p0 clipped by p1\r\n            var cp1:any, cp2:any, s:any, e:any;\r\n            var inside = function (p:any) {\r\n                return (cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0]);\r\n            };\r\n            var isc = function () {\r\n                var dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ],\r\n                    dp = [ s[0] - e[0], s[1] - e[1] ],\r\n                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\r\n                    n2 = s[0] * e[1] - s[1] * e[0], \r\n                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\r\n                return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3];\r\n            };\r\n            var out = p0;\r\n            cp1 = p1[p1.length-1];\r\n            for (let j in p1) {\r\n                var cp2 = p1[j];\r\n                var inp = out;\r\n                out = [];\r\n                s = inp[inp.length - 1]; //last on the input list\r\n                for (let i in inp) {\r\n                    var e = inp[i];\r\n                    if (inside(e)) {\r\n                        if (!inside(s)) {\r\n                            out.push(isc());\r\n                        }\r\n                        out.push(e);\r\n                    }\r\n                    else if (inside(s)) {\r\n                        out.push(isc());\r\n                    }\r\n                    s = e;\r\n                }\r\n                cp1 = cp2;\r\n            }\r\n            return out\r\n        }\r\n\t}\r\n\tUDOC.M = {\r\n\t\tgetScale : function(m:any) {  return Math.sqrt(Math.abs(m[0]*m[3]-m[1]*m[2]));  },\r\n\t\ttranslate: function(m:any,x:any,y:any) {  UDOC.M.concat(m, [1,0,0,1,x,y]);  },\r\n\t\trotate   : function(m:any,a:any  ) {  UDOC.M.concat(m, [Math.cos(a), -Math.sin(a), Math.sin(a), Math.cos(a),0,0]);  },\r\n\t\tscale    : function(m:any,x:any,y:any) {  UDOC.M.concat(m, [x,0,0,y,0,0]);  },\r\n\t\tconcat   : function(m:any,w:any  ) {  \r\n\t\t\tvar a=m[0],b=m[1],c=m[2],d=m[3],tx=m[4],ty=m[5];\r\n\t\t\tm[0] = (a *w[0])+(b *w[2]);       m[1] = (a *w[1])+(b *w[3]);\r\n\t\t\tm[2] = (c *w[0])+(d *w[2]);       m[3] = (c *w[1])+(d *w[3]);\r\n\t\t\tm[4] = (tx*w[0])+(ty*w[2])+w[4];  m[5] = (tx*w[1])+(ty*w[3])+w[5]; \r\n\t\t},\r\n\t\tinvert   : function(m:any    ) {  \r\n\t\t\tvar a=m[0],b=m[1],c=m[2],d=m[3],tx=m[4],ty=m[5], adbc=a*d-b*c;\r\n\t\t\tm[0] = d/adbc;  m[1] = -b/adbc;  m[2] =-c/adbc;  m[3] =  a/adbc;\r\n\t\t\tm[4] = (c*ty - d*tx)/adbc;  m[5] = (b*tx - a*ty)/adbc;\r\n\t\t},\r\n\t\tmultPoint: function(m:any, p:any ) {  var x=p[0],y=p[1];  return [x*m[0]+y*m[2]+m[4],   x*m[1]+y*m[3]+m[5]];  },\r\n\t\tmultArray: function(m:any, a:any ) {  for(var i=0; i<a.length; i+=2) {  var x=a[i],y=a[i+1];  a[i]=x*m[0]+y*m[2]+m[4];  a[i+1]=x*m[1]+y*m[3]+m[5];  }  }\r\n\t}\r\n\tUDOC.C = {\r\n\t\tsrgbGamma : function(x:any) {  return x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1.0 / 2.4) - 0.055;  },\r\n\t\tcmykToRgb : function(clr:any) { \r\n\t\t\tvar c=clr[0], m=clr[1], y=clr[2], k=clr[3];\r\n\t\t\t// return [1-Math.min(1,c+k), 1-Math.min(1, m+k), 1-Math.min(1,y+k)];\r\n\t\t\tvar r = 255\r\n\t\t\t+ c * (-4.387332384609988  * c + 54.48615194189176  * m +  18.82290502165302  * y + 212.25662451639585 * k +  -285.2331026137004) \r\n\t\t\t+ m * ( 1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) \r\n\t\t\t+ y * (-2.5217340131683033 * y - 21.248923337353073 * k +  17.5119270841813) \r\n\t\t\t+ k * (-21.86122147463605  * k - 189.48180835922747);\r\n\t\t\tvar g = 255\r\n\t\t\t+ c * (8.841041422036149   * c + 60.118027045597366 * m +  6.871425592049007  * y + 31.159100130055922 * k +  -79.2970844816548) \r\n\t\t\t+ m * (-15.310361306967817 * m + 17.575251261109482 * y +  131.35250912493976 * k - 190.9453302588951) \r\n\t\t\t+ y * (4.444339102852739   * y + 9.8632861493405    * k -  24.86741582555878) \r\n\t\t\t+ k * (-20.737325471181034 * k - 187.80453709719578);\r\n\t\t\tvar b = 255\r\n\t\t\t+ c * (0.8842522430003296  * c + 8.078677503112928  * m +  30.89978309703729  * y - 0.23883238689178934 * k + -14.183576799673286) \r\n\t\t\t+ m * (10.49593273432072   * m + 63.02378494754052  * y +  50.606957656360734 * k - 112.23884253719248) \r\n\t\t\t+ y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505)\r\n\t\t\t+ k * (-22.33816807309886  * k - 180.12613974708367);\r\n\r\n\t\t\treturn [Math.max(0, Math.min(1, r/255)), Math.max(0, Math.min(1, g/255)), Math.max(0, Math.min(1, b/255))];\r\n\t\t\t//var iK = 1-c[3];  \r\n\t\t\t//return [(1-c[0])*iK, (1-c[1])*iK, (1-c[2])*iK];  \r\n\t\t},\r\n\t\tlabToRgb  : function(lab:any) {\r\n\t\t\tvar k = 903.3, e = 0.008856, L = lab[0], a = lab[1], b = lab[2];\r\n\t\t\tvar fy = (L+16)/116, fy3 = fy*fy*fy;\r\n\t\t\tvar fz = fy - b/200, fz3 = fz*fz*fz;\r\n\t\t\tvar fx = a/500 + fy, fx3 = fx*fx*fx;\r\n\t\t\tvar zr = fz3>e ? fz3 : (116*fz-16)/k;\r\n\t\t\tvar yr = fy3>e ? fy3 : (116*fy-16)/k;\r\n\t\t\tvar xr = fx3>e ? fx3 : (116*fx-16)/k;\r\n\t\t\t\t\r\n\t\t\tvar X = xr*96.72, Y = yr*100, Z = zr*81.427, xyz = [X/100,Y/100,Z/100];\r\n\t\t\tvar x2s = [3.1338561, -1.6168667, -0.4906146, -0.9787684,  1.9161415,  0.0334540, 0.0719453, -0.2289914,  1.4052427];\r\n\t\t\t\r\n\t\t\tvar rgb = [ x2s[0]*xyz[0] + x2s[1]*xyz[1] + x2s[2]*xyz[2],\r\n\t\t\t\t\t\tx2s[3]*xyz[0] + x2s[4]*xyz[1] + x2s[5]*xyz[2],\r\n\t\t\t\t\t\tx2s[6]*xyz[0] + x2s[7]*xyz[1] + x2s[8]*xyz[2]  ];\r\n\t\t\tfor(var i=0; i<3; i++) rgb[i] = Math.max(0, Math.min(1, UDOC.C.srgbGamma(rgb[i])));\r\n\t\t\treturn rgb;\r\n\t\t}\r\n\t}\r\n\t\r\n\tUDOC.getState = function(crds:any):any {\r\n\t\treturn {\r\n\t\t\tfont : UDOC.getFont(),\r\n\t\t\tdd: {flat:1},  // device-dependent\r\n\t\t\tspace :\"/DeviceGray\",\r\n\t\t\t// fill\r\n\t\t\tca: 1,\r\n\t\t\tcolr  : [0,0,0],\r\n\t\t\tsspace:\"/DeviceGray\",\r\n\t\t\t// stroke\r\n\t\t\tCA: 1,\r\n\t\t\tCOLR : [0,0,0],\r\n\t\t\tbmode: \"/Normal\",\r\n\t\t\tSA:false, OPM:0, AIS:false, OP:false, op:false, SMask:\"/None\",\r\n\t\t\tlwidth : 1,\r\n\t\t\tlcap: 0,\r\n\t\t\tljoin: 0,\r\n\t\t\tmlimit: 10,\r\n\t\t\tSM : 0.1,\r\n\t\t\tdoff: 0,\r\n\t\t\tdash: [],\r\n\t\t\tctm : [1,0,0,1,0,0],\r\n\t\t\tcpos: [0,0],\r\n\t\t\tpth : {cmds:[],crds:[]}, \r\n\t\t\tcpth: crds ? UDOC.G.rectToPath(crds) : null  // clipping path\r\n\t\t};\r\n\t}\r\n\t\r\n\tUDOC.getFont = function() {\r\n\t\treturn {\r\n\t\t\tTc: 0, // character spacing\r\n\t\t\tTw: 0, // word spacing\r\n\t\t\tTh:100, // horizontal scale\r\n\t\t\tTl: 0, // leading\r\n\t\t\tTf:\"Helvetica-Bold\", \r\n\t\t\tTfs:1, // font size\r\n\t\t\tTmode:0, // rendering mode\r\n\t\t\tTrise:0, // rise\r\n\t\t\tTk: 0,  // knockout\r\n\t\t\tTal:0,  // align, 0: left, 1: right, 2: center\r\n\t\t\tTun:0,  // 0: no, 1: underline\r\n\t\t\t\r\n\t\t\tTm :[1,0,0,1,0,0],\r\n\t\t\tTlm:[1,0,0,1,0,0],\r\n\t\t\tTrm:[1,0,0,1,0,0]\r\n\t\t};\r\n\t}\r\n\r\n\r\nexport let FromEMF:any = function()\r\n{\r\n}\r\n\r\nFromEMF.Parse = function(buff:any, genv:any)\r\n{\r\n    buff = new Uint8Array(buff);  var off=0;\r\n    //console.log(buff.slice(0,32));\r\n    var prms:any = {fill:false, strk:false, bb:[0,0,1,1], wbb:[0,0,1,1], fnt:{nam:\"Arial\",hgh:25,und:false,orn:0}, tclr:[0,0,0], talg:0}, gst, tab = [], sts=[];\r\n    \r\n    var rI = FromEMF.B.readShort, rU = FromEMF.B.readUshort, rI32 = FromEMF.B.readInt, rU32 = FromEMF.B.readUint, rF32 = FromEMF.B.readFloat;\t\r\n    \r\n    var opn=0;\r\n    while(true) {\r\n        var fnc = rU32(buff, off);  off+=4;\r\n        var fnm = FromEMF.K[fnc]; \r\n        var siz = rU32(buff, off);  off+=4;\r\n        \r\n        //if(gst && isNaN(gst.ctm[0])) throw \"e\";\r\n        //console.log(fnc,fnm,siz);\r\n        \r\n        var loff = off;\r\n        \r\n        //if(opn++==253) break;\r\n        var obj:any = null, oid = 0;\r\n        //console.log(fnm, siz);\r\n        \r\n        if(false) {}\r\n        else if(fnm==\"EOF\") {  break;  }\r\n        else if(fnm==\"HEADER\") {\r\n            prms.bb = FromEMF._readBox(buff,loff);   loff+=16;  //console.log(fnm, prms.bb);\r\n            genv.StartPage(prms.bb[0],prms.bb[1],prms.bb[2],prms.bb[3]);\r\n            gst = UDOC.getState(prms.bb);\t\r\n        }\r\n        else if(fnm==\"SAVEDC\") sts.push(JSON.stringify(gst), JSON.stringify(prms));\r\n        else if(fnm==\"RESTOREDC\") {\r\n            var dif = rI32(buff, loff);  loff+=4;\r\n            while(dif<-1) {  sts.pop();  sts.pop();  }\r\n            prms = JSON.parse(sts.pop());  gst = JSON.parse(sts.pop());\r\n        }\r\n        else if(fnm==\"SELECTCLIPPATH\") {  gst.cpth = JSON.parse(JSON.stringify(gst.pth));  }\r\n        else if([\"SETMAPMODE\",\"SETPOLYFILLMODE\",\"SETBKMODE\"/*,\"SETVIEWPORTEXTEX\"*/,\"SETICMMODE\",\"SETROP2\",\"EXTSELECTCLIPRGN\"].indexOf(fnm)!=-1) {}\r\n        //else if(fnm==\"INTERSECTCLIPRECT\") {  var r=prms.crct=FromEMF._readBox(buff, loff);  /*var y0=r[1],y1=r[3]; if(y0>y1){r[1]=y1; r[3]=y0;}*/ console.log(prms.crct);  }\r\n        else if(fnm==\"SETMITERLIMIT\") gst.mlimit = rU32(buff, loff);\r\n        else if(fnm==\"SETTEXTCOLOR\") prms.tclr = [buff[loff]/255, buff[loff+1]/255, buff[loff+2]/255]; \r\n        else if(fnm==\"SETTEXTALIGN\") prms.talg = rU32(buff, loff);\r\n        else if(fnm==\"SETVIEWPORTEXTEX\" || fnm==\"SETVIEWPORTORGEX\") {\r\n            if(prms.vbb==null) prms.vbb=[];\r\n            var coff = fnm==\"SETVIEWPORTORGEX\" ? 0 : 2;\r\n            prms.vbb[coff  ] = rI32(buff, loff);  loff+=4;\r\n            prms.vbb[coff+1] = rI32(buff, loff);  loff+=4;\r\n            //console.log(prms.vbb);\r\n            if(fnm==\"SETVIEWPORTEXTEX\") FromEMF._updateCtm(prms, gst);\r\n        }\r\n        else if(fnm==\"SETWINDOWEXTEX\" || fnm==\"SETWINDOWORGEX\") {\r\n            var coff = fnm==\"SETWINDOWORGEX\" ? 0 : 2;\r\n            prms.wbb[coff  ] = rI32(buff, loff);  loff+=4;\r\n            prms.wbb[coff+1] = rI32(buff, loff);  loff+=4;\r\n            if(fnm==\"SETWINDOWEXTEX\") FromEMF._updateCtm(prms, gst);\r\n        }\r\n        //else if(fnm==\"SETMETARGN\") {}\r\n        else if(fnm==\"COMMENT\") {  var ds = rU32(buff, loff);  loff+=4;  }\r\n        \r\n        else if(fnm==\"SELECTOBJECT\") {\r\n            var ind = rU32(buff, loff);  loff+=4;\r\n            //console.log(ind.toString(16), tab, tab[ind]);\r\n            if     (ind==0x80000000) {  prms.fill=true ;  gst.colr=[1,1,1];  } // white brush\r\n            else if(ind==0x80000005) {  prms.fill=false;  } // null brush\r\n            else if(ind==0x80000007) {  prms.strk=true ;  prms.lwidth=1;  gst.COLR=[0,0,0];  } // black pen\r\n            else if(ind==0x80000008) {  prms.strk=false;  } // null  pen\r\n            else if(ind==0x8000000d) {} // system font\r\n            else if(ind==0x8000000e) {}  // device default font\r\n            else {\r\n                var co:any = tab[ind];  //console.log(ind, co);\r\n                if(co.t==\"b\") {\r\n                    prms.fill=co.stl!=1;\r\n                    if     (co.stl==0) {}\r\n                    else if(co.stl==1) {}\r\n                    else throw co.stl+\" e\";\r\n                    gst.colr=co.clr;\r\n                }\r\n                else if(co.t==\"p\") {\r\n                    prms.strk=co.stl!=5;\r\n                    gst.lwidth = co.wid;\r\n                    gst.COLR=co.clr;\r\n                }\r\n                else if(co.t==\"f\") {\r\n                    prms.fnt = co;\r\n                    gst.font.Tf = co.nam;\r\n                    gst.font.Tfs = Math.abs(co.hgh);\r\n                    gst.font.Tun = co.und;\r\n                }\r\n                else throw \"e\";\r\n            }\r\n        }\r\n        else if(fnm==\"DELETEOBJECT\") {\r\n            var ind = rU32(buff, loff);  loff+=4;\r\n            if(tab[ind]!=null) tab[ind]=null;\r\n            else throw \"e\";\r\n        }\r\n        else if(fnm==\"CREATEBRUSHINDIRECT\") {\r\n            oid = rU32(buff, loff);  loff+=4;\r\n            obj = {t:\"b\"};\r\n            obj.stl = rU32(buff, loff);  loff+=4;\r\n            obj.clr = [buff[loff]/255, buff[loff+1]/255, buff[loff+2]/255];  loff+=4;\r\n            obj.htc = rU32(buff, loff);  loff+=4;\r\n            //console.log(oid, obj);\r\n        }\r\n        else if(fnm==\"CREATEPEN\" || fnm==\"EXTCREATEPEN\") {\r\n            oid = rU32(buff, loff);  loff+=4;\r\n            obj = {t:\"p\"};\r\n            if(fnm==\"EXTCREATEPEN\") {\r\n                loff+=16;\r\n                obj.stl = rU32(buff, loff);  loff+=4;\r\n                obj.wid = rU32(buff, loff);  loff+=4;\r\n                //obj.stl = rU32(buff, loff);  \r\n                loff+=4;\r\n            } else {\r\n                obj.stl = rU32(buff, loff);  loff+=4;\r\n                obj.wid = rU32(buff, loff);  loff+=4;  loff+=4;\r\n            }\r\n            obj.clr = [buff[loff]/255, buff[loff+1]/255, buff[loff+2]/255];  loff+=4;\r\n        }\r\n        else if(fnm==\"EXTCREATEFONTINDIRECTW\") {\r\n            oid = rU32(buff, loff);  loff+=4;\r\n            obj = {t:\"f\", nam:\"\"};\r\n            obj.hgh = rI32(buff, loff);  loff += 4;\r\n            loff += 4*2;\r\n            obj.orn = rI32(buff, loff)/10;  loff+=4;\r\n            var wgh = rU32(buff, loff);  loff+=4;  //console.log(fnm, obj.orn, wgh);\r\n            //console.log(rU32(buff,loff), rU32(buff,loff+4), buff.slice(loff,loff+8));\r\n            obj.und = buff[loff+1];  obj.stk = buff[loff+2];  loff += 4*2;\r\n            while(rU(buff,loff)!=0) {  obj.nam+=String.fromCharCode(rU(buff,loff));  loff+=2;  }\r\n            if(wgh>500) obj.nam+=\"-Bold\";\r\n            //console.log(wgh, obj.nam);\r\n        }\r\n        else if(fnm==\"EXTTEXTOUTW\") {\r\n            //console.log(buff.slice(loff-8, loff-8+siz));\r\n            loff+=16;\r\n            var mod = rU32(buff, loff);  loff+=4;  //console.log(mod);\r\n            var scx = rF32(buff, loff);  loff+=4;\r\n            var scy = rF32(buff, loff);  loff+=4;\r\n            var rfx = rI32(buff, loff);  loff+=4;\r\n            var rfy = rI32(buff, loff);  loff+=4;\r\n            //console.log(mod, scx, scy,rfx,rfy);\r\n            \r\n            gst.font.Tm = [1,0,0,-1,0,0];\r\n            UDOC.M.rotate(gst.font.Tm, prms.fnt.orn*Math.PI/180);\r\n            UDOC.M.translate(gst.font.Tm, rfx, rfy);\r\n            \r\n            var alg = prms.talg;  //console.log(alg.toString(2));\r\n            if     ((alg&6)==6) gst.font.Tal = 2;\r\n            else if((alg&7)==0) gst.font.Tal = 0;\r\n            else throw alg+\" e\";\r\n            if((alg&24)==24) {}  // baseline\r\n            else if((alg&24)==0) UDOC.M.translate(gst.font.Tm, 0, gst.font.Tfs);\r\n            else throw \"e\";\r\n            \r\n            \r\n            var crs = rU32(buff, loff);  loff+=4;\r\n            var ofs = rU32(buff, loff);  loff+=4;\r\n            var ops = rU32(buff, loff);  loff+=4;  //if(ops!=0) throw \"e\";\r\n            //console.log(ofs,ops,crs);\r\n            loff+=16;\r\n            var ofD = rU32(buff, loff);  loff+=4;  //console.log(ops, ofD, loff, ofs+off-8);\r\n            ofs += off-8;  //console.log(crs, ops);\r\n            var str = \"\";\r\n            for(var i=0; i<crs; i++) {  var cc=rU(buff,ofs+i*2);  str+=String.fromCharCode(cc);  };\r\n            var oclr = gst.colr;  gst.colr = prms.tclr;\r\n            //console.log(str, gst.colr, gst.font.Tm);\r\n            //var otfs = gst.font.Tfs;  gst.font.Tfs *= 1/gst.ctm[0];\r\n            genv.PutText(gst, str, str.length*gst.font.Tfs*0.5);  gst.colr=oclr;\r\n            //gst.font.Tfs = otfs;\r\n            //console.log(rfx, rfy, scx, ops, rcX, rcY, rcW, rcH, offDx, str);\r\n        }\r\n        else if(fnm==\"BEGINPATH\") {  UDOC.G.newPath(gst);  }\r\n        else if(fnm==\"ENDPATH\"  ) {    }\r\n        else if(fnm==\"CLOSEFIGURE\") UDOC.G.closePath(gst);\r\n        else if(fnm==\"MOVETOEX\" ) {  UDOC.G.moveTo(gst, rI32(buff,loff), rI32(buff,loff+4));  }\r\n        else if(fnm==\"LINETO\"   ) {  \r\n            if(gst.pth.cmds.length==0) {  var im=gst.ctm.slice(0);  UDOC.M.invert(im);  var p = UDOC.M.multPoint(im, gst.cpos);  UDOC.G.moveTo(gst, p[0], p[1]);  }  \r\n            UDOC.G.lineTo(gst, rI32(buff,loff), rI32(buff,loff+4));  }\r\n        else if(fnm==\"POLYGON\" || fnm==\"POLYGON16\" || fnm==\"POLYLINE\" || fnm==\"POLYLINE16\" || fnm==\"POLYLINETO\" || fnm==\"POLYLINETO16\") {\r\n            loff+=16;\r\n            var ndf = fnm.startsWith(\"POLYGON\"), isTo = fnm.indexOf(\"TO\")!=-1;\r\n            var cnt = rU32(buff, loff);  loff+=4;\r\n            if(!isTo) UDOC.G.newPath(gst);\r\n            loff = FromEMF._drawPoly(buff,loff,cnt,gst, fnm.endsWith(\"16\")?2:4,  ndf, isTo);\r\n            if(!isTo) FromEMF._draw(genv,gst,prms, ndf);\r\n            //console.log(prms, gst.lwidth);\r\n            //console.log(JSON.parse(JSON.stringify(gst.pth)));\r\n        }\r\n        else if(fnm==\"POLYPOLYGON16\") {\r\n            loff+=16;\r\n            var ndf = fnm.startsWith(\"POLYPOLYGON\"), isTo = fnm.indexOf(\"TO\")!=-1;\r\n            var nop = rU32(buff, loff);  loff+=4;  loff+=4;\r\n            var pi = loff;  loff+= nop*4;\r\n            \r\n            if(!isTo) UDOC.G.newPath(gst);\r\n            for(var i=0; i<nop; i++) {\r\n                var ppp = rU(buff, pi+i*4);\r\n                loff = FromEMF._drawPoly(buff,loff,ppp,gst, fnm.endsWith(\"16\")?2:4, ndf, isTo);\r\n            }\r\n            if(!isTo) FromEMF._draw(genv,gst,prms, ndf);\r\n        }\r\n        else if(fnm==\"POLYBEZIER\" || fnm==\"POLYBEZIER16\" || fnm==\"POLYBEZIERTO\" || fnm==\"POLYBEZIERTO16\") {\r\n            loff+=16;\r\n            var is16 = fnm.endsWith(\"16\"), rC = is16?rI:rI32, nl = is16?2:4;\r\n            var cnt = rU32(buff, loff);  loff+=4;\r\n            if(fnm.indexOf(\"TO\")==-1) {\r\n                UDOC.G.moveTo(gst, rC(buff,loff), rC(buff,loff+nl));  loff+=2*nl;  cnt--;\r\n            }\r\n            while(cnt>0) {\r\n                UDOC.G.curveTo(gst, rC(buff,loff), rC(buff,loff+nl), rC(buff,loff+2*nl), rC(buff,loff+3*nl), rC(buff,loff+4*nl), rC(buff,loff+5*nl) );\r\n                loff+=6*nl;\r\n                cnt-=3;\r\n            }\r\n            //console.log(JSON.parse(JSON.stringify(gst.pth)));\r\n        }\r\n        else if(fnm==\"RECTANGLE\" || fnm==\"ELLIPSE\") {\r\n            UDOC.G.newPath(gst);\r\n            var bx = FromEMF._readBox(buff, loff);\r\n            if(fnm==\"RECTANGLE\") {\r\n                UDOC.G.moveTo(gst, bx[0],bx[1]);\r\n                UDOC.G.lineTo(gst, bx[2],bx[1]);\r\n                UDOC.G.lineTo(gst, bx[2],bx[3]);\r\n                UDOC.G.lineTo(gst, bx[0],bx[3]);\r\n            }\r\n            else {\r\n                var x = (bx[0]+bx[2])/2, y = (bx[1]+bx[3])/2;\r\n                UDOC.G.arc(gst,x,y,(bx[2]-bx[0])/2,0,2*Math.PI, false);\r\n            }\r\n            UDOC.G.closePath(gst);\r\n            FromEMF._draw(genv,gst,prms, true);\r\n            //console.log(prms, gst.lwidth);\r\n        }\r\n        else if(fnm==\"FILLPATH\"  ) genv.Fill(gst, false);\r\n        else if(fnm==\"STROKEPATH\") genv.Stroke(gst);\r\n        else if(fnm==\"STROKEANDFILLPATH\") {  genv.Fill(gst, false);  genv.Stroke(gst);  }\r\n        else if(fnm==\"SETWORLDTRANSFORM\" || fnm==\"MODIFYWORLDTRANSFORM\") {\r\n            var mat = [];\r\n            for(var i=0; i<6; i++) mat.push(rF32(buff,loff+i*4));  loff+=24;\r\n            //console.log(fnm, gst.ctm.slice(0), mat);\r\n            if(fnm==\"SETWORLDTRANSFORM\") gst.ctm=mat;\r\n            else {\r\n                var mod = rU32(buff,loff);  loff+=4;\r\n                if(mod==2) {  var om=gst.ctm;  gst.ctm=mat;  UDOC.M.concat(gst.ctm, om);  }\r\n                else throw \"e\";\r\n            }\r\n        }\r\n        else if(fnm==\"SETSTRETCHBLTMODE\") {  var sm = rU32(buff, loff);  loff+=4;  }\r\n        else if(fnm==\"STRETCHDIBITS\") {\r\n            var bx = FromEMF._readBox(buff, loff);  loff+=16;\r\n            var xD = rI32(buff, loff);  loff+=4;\r\n            var yD = rI32(buff, loff);  loff+=4;\r\n            var xS = rI32(buff, loff);  loff+=4;\r\n            var yS = rI32(buff, loff);  loff+=4;\r\n            var wS = rI32(buff, loff);  loff+=4;\r\n            var hS = rI32(buff, loff);  loff+=4;\r\n            var ofH = rU32(buff, loff)+off-8;  loff+=4;\r\n            var szH = rU32(buff, loff);  loff+=4;\r\n            var ofB = rU32(buff, loff)+off-8;  loff+=4;\r\n            var szB = rU32(buff, loff);  loff+=4;\r\n            var usg = rU32(buff, loff);  loff+=4;  if(usg!=0) throw \"e\";\r\n            var bop = rU32(buff, loff);  loff+=4;\r\n            var wD = rI32(buff, loff);  loff+=4;\r\n            var hD = rI32(buff, loff);  loff+=4;  //console.log(bop, wD, hD);\r\n            \r\n            //console.log(ofH, szH, ofB, szB, ofH+40);\r\n            //console.log(bx, xD,yD,wD,hD);\r\n            //console.log(xS,yS,wS,hS);\r\n            //console.log(ofH,szH,ofB,szB,usg,bop);\r\n            \r\n            var hl = rU32(buff, ofH);  ofH+=4;\r\n            var w  = rU32(buff, ofH);  ofH+=4;\r\n            var h  = rU32(buff, ofH);  ofH+=4;  if(w!=wS || h!=hS) throw \"e\";\r\n            var ps = rU  (buff, ofH);  ofH+=2;\r\n            var bc = rU  (buff, ofH);  ofH+=2;  if(bc!=8 && bc!=24 && bc!=32) throw bc+\" e\";\r\n            var cpr= rU32(buff, ofH);  ofH+=4;  if(cpr!=0) throw cpr+\" e\";\r\n            var sz = rU32(buff, ofH);  ofH+=4;\r\n            var xpm= rU32(buff, ofH);  ofH+=4;\r\n            var ypm= rU32(buff, ofH);  ofH+=4;\r\n            var cu = rU32(buff, ofH);  ofH+=4;\r\n            var ci = rU32(buff, ofH);  ofH+=4;  //console.log(hl, w, h, ps, bc, cpr, sz, xpm, ypm, cu, ci);\r\n            \r\n            //console.log(hl,w,h,\",\",xS,yS,wS,hS,\",\",xD,yD,wD,hD,\",\",xpm,ypm);\r\n            \r\n            var rl = Math.floor(((w * ps * bc + 31) & ~31) / 8);\r\n            var img = new Uint8Array(w*h*4);\r\n            if(bc==8) {\r\n                for(var y=0; y<h; y++) \r\n                    for(var x=0; x<w; x++) {\r\n                        var qi = (y*w+x)<<2, ind:any = buff[ofB+(h-1-y)*rl+x]<<2;\r\n                        img[qi  ] = buff[ofH+ind+2];\r\n                        img[qi+1] = buff[ofH+ind+1];\r\n                        img[qi+2] = buff[ofH+ind+0];\r\n                        img[qi+3] = 255;\r\n                    }\r\n            }\r\n            if(bc==24) {\r\n                for(var y=0; y<h; y++) \r\n                    for(var x=0; x<w; x++) {\r\n                        var qi = (y*w+x)<<2, ti=ofB+(h-1-y)*rl+x*3;\r\n                        img[qi  ] = buff[ti+2];\r\n                        img[qi+1] = buff[ti+1];\r\n                        img[qi+2] = buff[ti+0];\r\n                        img[qi+3] = 255;\r\n                    }\r\n            }\r\n            if(bc==32) {\r\n                for(var y=0; y<h; y++) \r\n                    for(var x=0; x<w; x++) {\r\n                        var qi = (y*w+x)<<2, ti=ofB+(h-1-y)*rl+x*4;\r\n                        img[qi  ] = buff[ti+2];\r\n                        img[qi+1] = buff[ti+1];\r\n                        img[qi+2] = buff[ti+0];\r\n                        img[qi+3] = buff[ti+3];\r\n                    }\r\n            }\r\n            \r\n            var ctm = gst.ctm.slice(0);\r\n            gst.ctm = [1,0,0,1,0,0];\r\n            UDOC.M.scale(gst.ctm, wD, -hD);\r\n            UDOC.M.translate(gst.ctm, xD, yD+hD);\r\n            UDOC.M.concat(gst.ctm, ctm);\r\n            genv.PutImage(gst, img, w, h);\r\n            gst.ctm = ctm;\r\n        }\r\n        else {\r\n            console.log(fnm, siz);\r\n        }\r\n        \r\n        if(obj!=null) tab[oid]=obj;\r\n        \r\n        off+=siz-8;\r\n    }\r\n    //genv.Stroke(gst);\r\n    genv.ShowPage();  genv.Done();\r\n}\r\nFromEMF._readBox = function(buff:any, off:any) {  var b=[];  for(var i=0; i<4; i++) b[i] = FromEMF.B.readInt(buff,off+i*4);  return b;  }\t\r\n\r\nFromEMF._updateCtm = function(prms:any, gst:any) {\r\n    var mat = [1,0,0,1,0,0];\r\n    var wbb = prms.wbb, bb = prms.bb, vbb=(prms.vbb && prms.vbb.length==4) ? prms.vbb:prms.bb;\r\n    \r\n    //var y0 = bb[1], y1 = bb[3];  bb[1]=Math.min(y0,y1);  bb[3]=Math.max(y0,y1);\r\n    \r\n    UDOC.M.translate(mat, -wbb[0],-wbb[1]);\r\n    UDOC.M.scale(mat, 1/wbb[2], 1/wbb[3]);\r\n    \r\n    UDOC.M.scale(mat, vbb[2], vbb[3]);\r\n    //UDOC.M.scale(mat, vbb[2]/(bb[2]-bb[0]), vbb[3]/(bb[3]-bb[1]));\r\n    \r\n    //UDOC.M.scale(mat, bb[2]-bb[0],bb[3]-bb[1]);\r\n    \r\n    gst.ctm = mat;\r\n}\r\nFromEMF._draw = function(genv:any, gst:any, prms:any, needFill:any) {\r\n    if(prms.fill && needFill     ) genv.Fill  (gst, false);\r\n    if(prms.strk && gst.lwidth!=0) genv.Stroke(gst);\r\n}\r\nFromEMF._drawPoly = function(buff:any, off:any, ppp:any, gst:any, nl:any, clos:any, justLine:any) {\r\n    var rS = nl==2 ? FromEMF.B.readShort : FromEMF.B.readInt;\r\n    for(var j=0; j<ppp; j++) {\r\n        var px = rS(buff, off);  off+=nl;  \r\n        var py = rS(buff, off);  off+=nl;\r\n        if(j==0 && !justLine) UDOC.G.moveTo(gst,px,py);  else UDOC.G.lineTo(gst,px,py);\r\n    }\r\n    if(clos) UDOC.G.closePath(gst);\r\n    return off;\r\n}\r\n\r\nFromEMF.B = {\r\n    uint8 : new Uint8Array(4),\r\n    readShort  : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  return FromEMF.B.int16 [0];  },\r\n    readUshort : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  return FromEMF.B.uint16[0];  },\r\n    readInt    : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  u8[2]=buff[p+2];  u8[3]=buff[p+3];  return FromEMF.B.int32 [0];  },\r\n    readUint   : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  u8[2]=buff[p+2];  u8[3]=buff[p+3];  return FromEMF.B.uint32[0];  },\r\n    readFloat  : function(buff:any,p:any):any  {  var u8=FromEMF.B.uint8;  u8[0]=buff[p];  u8[1]=buff[p+1];  u8[2]=buff[p+2];  u8[3]=buff[p+3];  return FromEMF.B.flot32[0];  },\r\n    readASCII  : function(buff:any,p:any,l:any):any {  var s = \"\";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    }\r\n}\r\nFromEMF.B.int16  = new Int16Array (FromEMF.B.uint8.buffer);\r\nFromEMF.B.uint16 = new Uint16Array(FromEMF.B.uint8.buffer);\r\nFromEMF.B.int32  = new Int32Array (FromEMF.B.uint8.buffer);\r\nFromEMF.B.uint32 = new Uint32Array(FromEMF.B.uint8.buffer);\r\nFromEMF.B.flot32 = new Float32Array(FromEMF.B.uint8.buffer);\r\n\r\n\r\nFromEMF.C = {\r\n    EMR_HEADER : 0x00000001,\r\n    EMR_POLYBEZIER : 0x00000002,\r\n    EMR_POLYGON : 0x00000003,\r\n    EMR_POLYLINE : 0x00000004,\r\n    EMR_POLYBEZIERTO : 0x00000005,\r\n    EMR_POLYLINETO : 0x00000006,\r\n    EMR_POLYPOLYLINE : 0x00000007,\r\n    EMR_POLYPOLYGON : 0x00000008,\r\n    EMR_SETWINDOWEXTEX : 0x00000009,\r\n    EMR_SETWINDOWORGEX : 0x0000000A,\r\n    EMR_SETVIEWPORTEXTEX : 0x0000000B,\r\n    EMR_SETVIEWPORTORGEX : 0x0000000C,\r\n    EMR_SETBRUSHORGEX : 0x0000000D,\r\n    EMR_EOF : 0x0000000E,\r\n    EMR_SETPIXELV : 0x0000000F,\r\n    EMR_SETMAPPERFLAGS : 0x00000010,\r\n    EMR_SETMAPMODE : 0x00000011,\r\n    EMR_SETBKMODE : 0x00000012,\r\n    EMR_SETPOLYFILLMODE : 0x00000013,\r\n    EMR_SETROP2 : 0x00000014,\r\n    EMR_SETSTRETCHBLTMODE : 0x00000015,\r\n    EMR_SETTEXTALIGN : 0x00000016,\r\n    EMR_SETCOLORADJUSTMENT : 0x00000017,\r\n    EMR_SETTEXTCOLOR : 0x00000018,\r\n    EMR_SETBKCOLOR : 0x00000019,\r\n    EMR_OFFSETCLIPRGN : 0x0000001A,\r\n    EMR_MOVETOEX : 0x0000001B,\r\n    EMR_SETMETARGN : 0x0000001C,\r\n    EMR_EXCLUDECLIPRECT : 0x0000001D,\r\n    EMR_INTERSECTCLIPRECT : 0x0000001E,\r\n    EMR_SCALEVIEWPORTEXTEX : 0x0000001F,\r\n    EMR_SCALEWINDOWEXTEX : 0x00000020,\r\n    EMR_SAVEDC : 0x00000021,\r\n    EMR_RESTOREDC : 0x00000022,\r\n    EMR_SETWORLDTRANSFORM : 0x00000023,\r\n    EMR_MODIFYWORLDTRANSFORM : 0x00000024,\r\n    EMR_SELECTOBJECT : 0x00000025,\r\n    EMR_CREATEPEN : 0x00000026,\r\n    EMR_CREATEBRUSHINDIRECT : 0x00000027,\r\n    EMR_DELETEOBJECT : 0x00000028,\r\n    EMR_ANGLEARC : 0x00000029,\r\n    EMR_ELLIPSE : 0x0000002A,\r\n    EMR_RECTANGLE : 0x0000002B,\r\n    EMR_ROUNDRECT : 0x0000002C,\r\n    EMR_ARC : 0x0000002D,\r\n    EMR_CHORD : 0x0000002E,\r\n    EMR_PIE : 0x0000002F,\r\n    EMR_SELECTPALETTE : 0x00000030,\r\n    EMR_CREATEPALETTE : 0x00000031,\r\n    EMR_SETPALETTEENTRIES : 0x00000032,\r\n    EMR_RESIZEPALETTE : 0x00000033,\r\n    EMR_REALIZEPALETTE : 0x00000034,\r\n    EMR_EXTFLOODFILL : 0x00000035,\r\n    EMR_LINETO : 0x00000036,\r\n    EMR_ARCTO : 0x00000037,\r\n    EMR_POLYDRAW : 0x00000038,\r\n    EMR_SETARCDIRECTION : 0x00000039,\r\n    EMR_SETMITERLIMIT : 0x0000003A,\r\n    EMR_BEGINPATH : 0x0000003B,\r\n    EMR_ENDPATH : 0x0000003C,\r\n    EMR_CLOSEFIGURE : 0x0000003D,\r\n    EMR_FILLPATH : 0x0000003E,\r\n    EMR_STROKEANDFILLPATH : 0x0000003F,\r\n    EMR_STROKEPATH : 0x00000040,\r\n    EMR_FLATTENPATH : 0x00000041,\r\n    EMR_WIDENPATH : 0x00000042,\r\n    EMR_SELECTCLIPPATH : 0x00000043,\r\n    EMR_ABORTPATH : 0x00000044,\r\n    EMR_COMMENT : 0x00000046,\r\n    EMR_FILLRGN : 0x00000047,\r\n    EMR_FRAMERGN : 0x00000048,\r\n    EMR_INVERTRGN : 0x00000049,\r\n    EMR_PAINTRGN : 0x0000004A,\r\n    EMR_EXTSELECTCLIPRGN : 0x0000004B,\r\n    EMR_BITBLT : 0x0000004C,\r\n    EMR_STRETCHBLT : 0x0000004D,\r\n    EMR_MASKBLT : 0x0000004E,\r\n    EMR_PLGBLT : 0x0000004F,\r\n    EMR_SETDIBITSTODEVICE : 0x00000050,\r\n    EMR_STRETCHDIBITS : 0x00000051,\r\n    EMR_EXTCREATEFONTINDIRECTW : 0x00000052,\r\n    EMR_EXTTEXTOUTA : 0x00000053,\r\n    EMR_EXTTEXTOUTW : 0x00000054,\r\n    EMR_POLYBEZIER16 : 0x00000055,\r\n    EMR_POLYGON16 : 0x00000056,\r\n    EMR_POLYLINE16 : 0x00000057,\r\n    EMR_POLYBEZIERTO16 : 0x00000058,\r\n    EMR_POLYLINETO16 : 0x00000059,\r\n    EMR_POLYPOLYLINE16 : 0x0000005A,\r\n    EMR_POLYPOLYGON16 : 0x0000005B,\r\n    EMR_POLYDRAW16 : 0x0000005C,\r\n    EMR_CREATEMONOBRUSH : 0x0000005D,\r\n    EMR_CREATEDIBPATTERNBRUSHPT : 0x0000005E,\r\n    EMR_EXTCREATEPEN : 0x0000005F,\r\n    EMR_POLYTEXTOUTA : 0x00000060,\r\n    EMR_POLYTEXTOUTW : 0x00000061,\r\n    EMR_SETICMMODE : 0x00000062,\r\n    EMR_CREATECOLORSPACE : 0x00000063,\r\n    EMR_SETCOLORSPACE : 0x00000064,\r\n    EMR_DELETECOLORSPACE : 0x00000065,\r\n    EMR_GLSRECORD : 0x00000066,\r\n    EMR_GLSBOUNDEDRECORD : 0x00000067,\r\n    EMR_PIXELFORMAT : 0x00000068,\r\n    EMR_DRAWESCAPE : 0x00000069,\r\n    EMR_EXTESCAPE : 0x0000006A,\r\n    EMR_SMALLTEXTOUT : 0x0000006C,\r\n    EMR_FORCEUFIMAPPING : 0x0000006D,\r\n    EMR_NAMEDESCAPE : 0x0000006E,\r\n    EMR_COLORCORRECTPALETTE : 0x0000006F,\r\n    EMR_SETICMPROFILEA : 0x00000070,\r\n    EMR_SETICMPROFILEW : 0x00000071,\r\n    EMR_ALPHABLEND : 0x00000072,\r\n    EMR_SETLAYOUT : 0x00000073,\r\n    EMR_TRANSPARENTBLT : 0x00000074,\r\n    EMR_GRADIENTFILL : 0x00000076,\r\n    EMR_SETLINKEDUFIS : 0x00000077,\r\n    EMR_SETTEXTJUSTIFICATION : 0x00000078,\r\n    EMR_COLORMATCHTOTARGETW : 0x00000079,\r\n    EMR_CREATECOLORSPACEW : 0x0000007A\r\n};\r\nFromEMF.K = [];\r\n\r\n// (function() {\r\n//     var inp, out, stt;\r\n//     inp = FromEMF.C;   out = FromEMF.K;   stt=4;\r\n//     for(var p in inp) out[inp[p]] = p.slice(stt);\r\n// }  )();\r\n\r\n\r\n\r\nexport let ToContext2D:any = function (needPage:any, scale:any)\r\n{\r\n    this.canvas = document.createElement(\"canvas\");\r\n    this.ctx = this.canvas.getContext(\"2d\");\r\n    this.bb = null;\r\n    this.currPage = 0;\r\n    this.needPage = needPage;\r\n    this.scale = scale;\r\n}\r\nToContext2D.prototype.StartPage = function(x:any,y:any,w:any,h:any) {\r\n    if(this.currPage!=this.needPage) return;\r\n    this.bb = [x,y,w,h];\r\n    var scl = this.scale, dpr = window.devicePixelRatio;\r\n    var cnv = this.canvas, ctx = this.ctx;\r\n    cnv.width = Math.round(w*scl);  cnv.height = Math.round(h*scl);\r\n    ctx.translate(0,h*scl);  ctx.scale(scl,-scl);\r\n    cnv.setAttribute(\"style\", \"border:1px solid; width:\"+(cnv.width/dpr)+\"px; height:\"+(cnv.height/dpr)+\"px\");\r\n}\r\nToContext2D.prototype.Fill = function(gst:any, evenOdd:any) {\r\n    if(this.currPage!=this.needPage) return;\r\n    var ctx = this.ctx;\r\n    ctx.beginPath();\r\n    this._setStyle(gst, ctx);\r\n    this._draw(gst.pth, ctx);\r\n    ctx.fill();\r\n}\r\nToContext2D.prototype.Stroke = function(gst:any) {\r\n    if(this.currPage!=this.needPage) return;\r\n    var ctx = this.ctx;\r\n    ctx.beginPath();\r\n    this._setStyle(gst, ctx);\r\n    this._draw(gst.pth, ctx);\r\n    ctx.stroke();\r\n}\r\nToContext2D.prototype.PutText = function(gst:any, str:any, stw:any) {\r\n    if(this.currPage!=this.needPage) return;\r\n    var scl = this._scale(gst.ctm);\r\n    var ctx = this.ctx;\r\n    this._setStyle(gst, ctx);\r\n    ctx.save();\r\n    var m = [1,0,0,-1,0,0];  this._concat(m, gst.font.Tm);  this._concat(m, gst.ctm);\r\n    //console.log(str, m, gst);  throw \"e\";\r\n    ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5]);\r\n    ctx.fillText(str,0,0);\r\n    ctx.restore();\r\n}\r\nToContext2D.prototype.PutImage = function(gst:any, buff:any, w:any, h:any, msk:any) {\r\n    if(this.currPage!=this.needPage) return;\r\n    var ctx = this.ctx;\r\n    \r\n    if(buff.length==w*h*4) {\r\n        buff = buff.slice(0);\r\n        if(msk && msk.length==w*h*4) for(var i=0; i<buff.length; i+=4) buff[i+3] = msk[i+1];\r\n        \r\n        var cnv = document.createElement(\"canvas\"), cctx = cnv.getContext(\"2d\");\r\n        cnv.width = w;  cnv.height = h;\r\n        var imgd = cctx.createImageData(w,h);\r\n        for(var i=0; i<buff.length; i++) imgd.data[i]=buff[i];\r\n        cctx.putImageData(imgd,0,0);\r\n        \r\n        ctx.save();\r\n        var m = [1,0,0,1,0,0];  this._concat(m, [1/w,0,0,-1/h,0,1]);  this._concat(m, gst.ctm);\r\n        ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5]);\r\n        ctx.drawImage(cnv,0,0);\r\n        ctx.restore();\r\n    }\r\n}\r\nToContext2D.prototype.ShowPage = function() {  this.currPage++;  }\r\nToContext2D.prototype.Done = function() {}\r\n\r\n\r\nfunction _flt(n:any)  {  return \"\"+parseFloat(n.toFixed(2));  }\r\n\r\nToContext2D.prototype._setStyle = function(gst:any, ctx:any) {\r\n    var scl = this._scale(gst.ctm);\r\n    ctx.fillStyle = this._getFill(gst.colr, gst.ca, ctx);\r\n    ctx.strokeStyle=this._getFill(gst.COLR, gst.CA, ctx);\r\n    \r\n    ctx.lineCap = [\"butt\",\"round\",\"square\"][gst.lcap];\r\n    ctx.lineJoin= [\"miter\",\"round\",\"bevel\"][gst.ljoin];\r\n    ctx.lineWidth=gst.lwidth*scl;\r\n    var dsh = gst.dash.slice(0);  for(var i=0; i<dsh.length; i++) dsh[i] = _flt(dsh[i]*scl);\r\n    ctx.setLineDash(dsh); \r\n    ctx.miterLimit = gst.mlimit*scl;\r\n    \r\n    var fn = gst.font.Tf, ln = fn.toLowerCase();\r\n    var p0 = ln.indexOf(\"bold\")!=-1 ? \"bold \" : \"\";\r\n    var p1 = (ln.indexOf(\"italic\")!=-1 || ln.indexOf(\"oblique\")!=-1) ? \"italic \" : \"\";\r\n    ctx.font = p0+p1 + gst.font.Tfs+\"px \\\"\"+fn+\"\\\"\";\r\n}\r\nToContext2D.prototype._getFill = function(colr:any, ca:any, ctx:any)\r\n{\r\n    if(colr.typ==null) return this._colr(colr,ca);\r\n    else {\r\n        var grd = colr, crd = grd.crds, mat = grd.mat, scl=this._scale(mat), gf;\r\n        if     (grd.typ==\"lin\") {\r\n            var p0 = this._multPoint(mat,crd.slice(0,2)), p1 = this._multPoint(mat,crd.slice(2));\r\n            gf=ctx.createLinearGradient(p0[0],p0[1],p1[0],p1[1]);\r\n        }\r\n        else if(grd.typ==\"rad\") {\r\n            var p0 = this._multPoint(mat,crd.slice(0,2)), p1 = this._multPoint(mat,crd.slice(3));\r\n            gf=ctx.createRadialGradient(p0[0],p0[1],crd[2]*scl,p1[0],p1[1],crd[5]*scl);\r\n        }\r\n        for(var i=0; i<grd.grad.length; i++)  gf.addColorStop(grd.grad[i][0],this._colr(grd.grad[i][1], ca));\r\n        return gf;\r\n    }\r\n}\r\nToContext2D.prototype._colr  = function(c:any,a:any) {  return \"rgba(\"+Math.round(c[0]*255)+\",\"+Math.round(c[1]*255)+\",\"+Math.round(c[2]*255)+\",\"+a+\")\";  };\r\nToContext2D.prototype._scale = function(m:any)  {  return Math.sqrt(Math.abs(m[0]*m[3]-m[1]*m[2]));  };\r\nToContext2D.prototype._concat= function(m:any,w:any  ) {  \r\n        var a=m[0],b=m[1],c=m[2],d=m[3],tx=m[4],ty=m[5];\r\n        m[0] = (a *w[0])+(b *w[2]);       m[1] = (a *w[1])+(b *w[3]);\r\n        m[2] = (c *w[0])+(d *w[2]);       m[3] = (c *w[1])+(d *w[3]);\r\n        m[4] = (tx*w[0])+(ty*w[2])+w[4];  m[5] = (tx*w[1])+(ty*w[3])+w[5]; \r\n}\r\nToContext2D.prototype._multPoint= function(m:any, p:any) {  var x=p[0],y=p[1];  return [x*m[0]+y*m[2]+m[4],   x*m[1]+y*m[3]+m[5]];  },\r\nToContext2D.prototype._draw  = function(path:any, ctx:any)\r\n{\r\n    var c = 0, crds = path.crds;\r\n    for(var j=0; j<path.cmds.length; j++) {\r\n        var cmd = path.cmds[j];\r\n        if     (cmd==\"M\") {  ctx.moveTo(crds[c], crds[c+1]);  c+=2;  }\r\n        else if(cmd==\"L\") {  ctx.lineTo(crds[c], crds[c+1]);  c+=2;  }\r\n        else if(cmd==\"C\") {  ctx.bezierCurveTo(crds[c], crds[c+1], crds[c+2], crds[c+3], crds[c+4], crds[c+5]);  c+=6;  }\r\n        else if(cmd==\"Q\") {  ctx.quadraticCurveTo(crds[c], crds[c+1], crds[c+2], crds[c+3]);  c+=4;  }\r\n        else if(cmd==\"Z\") {  ctx.closePath();  }\r\n    }\r\n}\r\n","import { columeHeader_word, columeHeader_word_index } from \"./constant\";\r\nimport { IluckySheetSelection } from \"../ToLuckySheet/ILuck\";\r\nimport { IattributeList, stringToNum} from \"../ICommon\";\r\n\r\n\r\nexport function getRangetxt(range:IluckySheetSelection, sheettxt:string) {\r\n\r\n    let row0 = range[\"row\"][0], row1 = range[\"row\"][1];\r\n    let column0 = range[\"column\"][0], column1 = range[\"column\"][1];\r\n\r\n    if (row0 == null && row1 == null) {\r\n        return sheettxt + chatatABC(column0) + \":\" + chatatABC(column1);\r\n    }\r\n    else if (column0 == null && column1 == null) {\r\n        return sheettxt + (row0 + 1) + \":\" + (row1 + 1);\r\n    }\r\n    else {\r\n        if (column0 == column1 && row0 == row1) {\r\n            return sheettxt + chatatABC(column0) + (row0 + 1);\r\n        }\r\n        else {\r\n            return sheettxt + chatatABC(column0) + (row0 + 1) + \":\" + chatatABC(column1) + (row1 + 1);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport function getcellrange (txt:string, sheets:IattributeList={}, sheetId:string=\"1\") {\r\n    let val = txt.split(\"!\");\r\n\r\n    let sheettxt = \"\",\r\n        rangetxt = \"\",\r\n        sheetIndex = -1;\r\n\r\n    if (val.length > 1) {\r\n        sheettxt = val[0];\r\n        rangetxt = val[1];\r\n        \r\n        let si = sheets[sheettxt];\r\n        if(si==null){\r\n            sheetIndex = parseInt(sheetId);\r\n        }\r\n        else{\r\n            sheetIndex = parseInt(si);\r\n        }\r\n    } \r\n    else {\r\n        sheetIndex = parseInt(sheetId);\r\n        rangetxt = val[0];\r\n    }\r\n    \r\n    if (rangetxt.indexOf(\":\") == -1) {\r\n        let row = parseInt(rangetxt.replace(/[^0-9]/g, \"\")) - 1;\r\n        let col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, \"\"));\r\n\r\n        if (!isNaN(row) && !isNaN(col)) {\r\n            return {\r\n                \"row\": [row, row],\r\n                \"column\": [col, col],\r\n                \"sheetIndex\": sheetIndex\r\n            };\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    } \r\n    else {\r\n        let rangetxtArray:string[] = rangetxt.split(\":\");\r\n        let row = [],col = [];\r\n        row[0] = parseInt(rangetxtArray[0].replace(/[^0-9]/g, \"\")) - 1;\r\n        row[1] = parseInt(rangetxtArray[1].replace(/[^0-9]/g, \"\")) - 1;\r\n        // if (isNaN(row[0])) {\r\n        //     row[0] = 0;\r\n        // }\r\n        // if (isNaN(row[1])) {\r\n        //     row[1] = sheetdata.length - 1;\r\n        // }\r\n        if (row[0] > row[1]) {\r\n            return null;\r\n        }\r\n        col[0] = ABCatNum(rangetxtArray[0].replace(/[^A-Za-z]/g, \"\"));\r\n        col[1] = ABCatNum(rangetxtArray[1].replace(/[^A-Za-z]/g, \"\"));\r\n        // if (isNaN(col[0])) {\r\n        //     col[0] = 0;\r\n        // }\r\n        // if (isNaN(col[1])) {\r\n        //     col[1] = sheetdata[0].length - 1;\r\n        // }\r\n        if (col[0] > col[1]) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            \"row\": row,\r\n            \"column\": col,\r\n            \"sheetIndex\": sheetIndex\r\n        };\r\n    }\r\n}\r\n\r\n//  \r\nfunction ABCatNum(abc:string) {\r\n    abc = abc.toUpperCase();\r\n\r\n    let abc_len = abc.length;\r\n    if (abc_len == 0) {\r\n        return NaN;\r\n    }\r\n\r\n    let abc_array = abc.split(\"\");\r\n    let wordlen = columeHeader_word.length;\r\n    let ret = 0;\r\n\r\n    for (let i = abc_len - 1; i >= 0; i--) {\r\n        if (i == abc_len - 1) {\r\n            ret += columeHeader_word_index[abc_array[i]];\r\n        }\r\n        else {\r\n            ret += Math.pow(wordlen, abc_len - i - 1) * (columeHeader_word_index[abc_array[i]] + 1);\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\n//  \r\nfunction chatatABC(index:number) {\r\n    let wordlen = columeHeader_word.length;\r\n\r\n    if (index < wordlen) {\r\n        return columeHeader_word[index];\r\n    }\r\n    else {\r\n        let last = 0, pre = 0, ret = \"\";\r\n        let i = 1, n = 0;\r\n\r\n        while (index >= (wordlen / (wordlen - 1)) * (Math.pow(wordlen, i++) - 1)) {\r\n            n = i;\r\n        }\r\n\r\n        let index_ab = index - (wordlen / (wordlen - 1)) * (Math.pow(wordlen, n - 1) - 1);//970\r\n        last = index_ab + 1;\r\n\r\n        for (let x = n; x > 0; x--) {\r\n            let last1 = last, x1 = x;//-702=268, 3\r\n\r\n            if (x == 1) {\r\n                last1 = last1 % wordlen;\r\n\r\n                if (last1 == 0) {\r\n                    last1 = 26;\r\n                }\r\n\r\n                return ret + columeHeader_word[last1 - 1];\r\n            }\r\n\r\n            last1 = Math.ceil(last1 / Math.pow(wordlen, x - 1));\r\n            //last1 = last1 % wordlen;\r\n            ret += columeHeader_word[last1 - 1];\r\n\r\n            if (x > 1) {\r\n                last = last - (last1 - 1) * wordlen;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** \r\n * @return ratio, default 0.75 1in = 2.54cm = 25.4mm = 72pt = 6pc,  pt = 1/72 In, px = 1/dpi In\r\n*/\r\nexport function getptToPxRatioByDPI():number{\r\n    return 72/96;\r\n}\r\n\r\n/** \r\n * @emus EMUs, Excel drawing unit\r\n * @return pixel\r\n*/\r\nexport function getPxByEMUs(emus:number){\r\n    if(emus==null){\r\n        return 0;\r\n    }\r\n    let inch = emus/914400;\r\n    let pt = inch*72;\r\n    let px = pt / getptToPxRatioByDPI();\r\n    return px;\r\n}\r\n\r\n/** \r\n * @dom xml attribute object\r\n * @attr attribute name\r\n * @d if attribute is null, return default value \r\n * @return attribute value\r\n*/\r\nexport function getXmlAttibute(dom:IattributeList, attr:string, d:string){\r\n    let value = dom[attr];\r\n    value = value==null?d:value;\r\n    return value;\r\n}\r\n\r\n/** \r\n * @columnWidth Excel column width\r\n * @return pixel column width\r\n*/\r\nexport function getColumnWidthPixel(columnWidth:number){\r\n    let pix = Math.round((columnWidth-0.83) * 8 + 5);\r\n    return pix;\r\n}\r\n\r\n/** \r\n * @rowHeight Excel row height\r\n * @return pixel row height\r\n*/\r\nexport function getRowHeightPixel(rowHeight:number){\r\n    let pix = Math.round(rowHeight/getptToPxRatioByDPI());\r\n    return pix;\r\n}\r\n\r\nexport function LightenDarkenColor(sixColor:string, tint:number){\r\n    let hex:string = sixColor.substring(sixColor.length-6,sixColor.length);\r\n    let rgbArray:number[] = hexToRgbArray(\"#\"+hex);\r\n    let hslArray = rgbToHsl(rgbArray[0], rgbArray[1],rgbArray[2]);\r\n    if(tint>0){\r\n        hslArray[2] = hslArray[2] * (1.0-tint) + tint;\r\n    }\r\n    else if(tint<0){\r\n        hslArray[2] = hslArray[2] * (1.0 + tint)\r\n    }\r\n    else{\r\n        return \"#\"+hex;\r\n    }\r\n\r\n    let newRgbArray = hslToRgb(hslArray[0],hslArray[1],hslArray[2]);\r\n\r\n    return rgbToHex(\"RGB(\" + newRgbArray.join(\",\") + \")\");\r\n}\r\n\r\n\r\nfunction rgbToHex(rgb:string){\r\n    //\r\n    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;\r\n    // rgb\r\n    if (/^(rgb|RGB)/.test(rgb)) {\r\n        var aColor = rgb.replace(/(?:\\(|\\)|rgb|RGB)*/g, \"\").split(\",\");\r\n        var strHex = \"#\";\r\n        for (var i=0; i<aColor.length; i++) {\r\n            var hex = Number(aColor[i]).toString(16);\r\n            if (hex.length < 2) {\r\n                hex = '0' + hex;    \r\n            }\r\n            strHex += hex;\r\n        }\r\n        if (strHex.length !== 7) {\r\n            strHex = rgb;    \r\n        }\r\n        return strHex;\r\n    } else if (reg.test(rgb)) {\r\n        var aNum = rgb.replace(/#/,\"\").split(\"\");\r\n        if (aNum.length === 6) {\r\n            return rgb;    \r\n        } else if(aNum.length === 3) {\r\n            var numHex = \"#\";\r\n            for (var i=0; i<aNum.length; i+=1) {\r\n                numHex += (aNum[i] + aNum[i]);\r\n            }\r\n            return numHex;\r\n        }\r\n    }\r\n    return rgb;\r\n}\r\n\r\nfunction hexToRgb(hex:string){\r\n    var sColor = hex.toLowerCase();\r\n    //\r\n    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;\r\n    // 16\r\n    if (sColor && reg.test(sColor)) {\r\n        if (sColor.length === 4) {\r\n            var sColorNew = \"#\";\r\n            for (var i=1; i<4; i+=1) {\r\n                sColorNew += sColor.slice(i, i+1).concat(sColor.slice(i, i+1));    \r\n            }\r\n            sColor = sColorNew;\r\n        }\r\n        //\r\n        var sColorChange = [];\r\n        for (var i=1; i<7; i+=2) {\r\n            sColorChange.push(parseInt(\"0x\"+sColor.slice(i, i+2)));    \r\n        }\r\n        return \"RGB(\" + sColorChange.join(\",\") + \")\";\r\n    }\r\n    return sColor;\r\n}\r\n\r\nfunction hexToRgbArray(hex:string){\r\n    var sColor = hex.toLowerCase();\r\n    //\r\n    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;\r\n    // 16\r\n    if (sColor && reg.test(sColor)) {\r\n        if (sColor.length === 4) {\r\n            var sColorNew = \"#\";\r\n            for (var i=1; i<4; i+=1) {\r\n                sColorNew += sColor.slice(i, i+1).concat(sColor.slice(i, i+1));    \r\n            }\r\n            sColor = sColorNew;\r\n        }\r\n        //\r\n        var sColorChange:number[] = [];\r\n        for (var i=1; i<7; i+=2) {\r\n            sColorChange.push(parseInt(\"0x\"+sColor.slice(i, i+2)));    \r\n        }\r\n        return  sColorChange;\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * HSLRGB. \r\n *  http://en.wikipedia.org/wiki/HSL_color_space.\r\n * h, s,  l  [0, 1] \r\n *  r, g,  b  [0, 255]\r\n *\r\n * @param   Number  h       \r\n * @param   Number  s       \r\n * @param   Number  l       \r\n * @return  Array           RGB\r\n */\r\nfunction hslToRgb(h:number, s:number, l:number) {\r\n    var r, g, b;\r\n\r\n    if(s == 0) {\r\n        r = g = b = l; // achromatic\r\n    } else {\r\n        var hue2rgb = function hue2rgb(p:number, q:number, t:number) {\r\n            if(t < 0) t += 1;\r\n            if(t > 1) t -= 1;\r\n            if(t < 1/6) return p + (q - p) * 6 * t;\r\n            if(t < 1/2) return q;\r\n            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\r\n            return p;\r\n        }\r\n\r\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n        var p = 2 * l - q;\r\n        r = hue2rgb(p, q, h + 1/3);\r\n        g = hue2rgb(p, q, h);\r\n        b = hue2rgb(p, q, h - 1/3);\r\n    }\r\n\r\n    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\r\n}\r\n\r\n\r\n/**\r\n * RGB  HSL.\r\n *  http://en.wikipedia.org/wiki/HSL_color_space.\r\n * r, g,  b  [0, 255] \r\n *  h, s,  l  [0, 1] \r\n *\r\n * @param   Number  r       \r\n * @param   Number  g       \r\n * @param   Number  b       \r\n * @return  Array           HSL\r\n */\r\nfunction rgbToHsl(r:number, g:number, b:number) {\r\n    r /= 255, g /= 255, b /= 255;\r\n    var max = Math.max(r, g, b), min = Math.min(r, g, b);\r\n    var h, s, l = (max + min) / 2;\r\n\r\n    if (max == min){ \r\n        h = s = 0; // achromatic\r\n    } else {\r\n        var d = max - min;\r\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n        switch(max) {\r\n            case r: h = (g - b) / d + (g < b ? 6 : 0); break;\r\n            case g: h = (b - r) / d + 2; break;\r\n            case b: h = (r - g) / d + 4; break;\r\n        }\r\n        h /= 6;\r\n    }\r\n\r\n    return [h, s, l];\r\n}\r\n \r\nexport function generateRandomIndex(prefix:string):string {\r\n    if(prefix == null){\r\n        prefix = \"Sheet\";\r\n    }\r\n\r\n    let userAgent = window.navigator.userAgent.replace(/[^a-zA-Z0-9]/g, \"\").split(\"\");\r\n\r\n    let mid = \"\";\r\n\r\n    for(let i = 0; i < 5; i++){\r\n        mid += userAgent[Math.round(Math.random() * (userAgent.length - 1))];\r\n    }\r\n\r\n    let time = new Date().getTime();\r\n\r\n    return prefix + \"_\" + mid + \"_\" + time;\r\n}\r\n\r\n\r\nexport function escapeCharacter(str:string){\r\n    if(str==null || str.length==0){\r\n        return str;\r\n    }\r\n\r\n    return str.replace(/&amp;/g, \"&\").replace(/&quot;/g, '\"').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&nbsp;/g, ' ').replace(/&apos;/g, \"'\").replace(/&iexcl;/g, \"\").replace(/&cent;/g, \"\").replace(/&pound;/g, \"\").replace(/&curren;/g, \"\").replace(/&yen;/g, \"\").replace(/&brvbar;/g, \"\").replace(/&sect;/g, \"\").replace(/&uml;/g, \"\").replace(/&copy;/g, \"\").replace(/&ordf;/g, \"\").replace(/&laquo;/g, \"\").replace(/&not;/g, \"\").replace(/&shy;/g, \"\").replace(/&reg;/g, \"\").replace(/&macr;/g, \"\").replace(/&deg;/g, \"\").replace(/&plusmn;/g, \"\").replace(/&sup2;/g, \"\").replace(/&sup3;/g, \"\").replace(/&acute;/g, \"\").replace(/&micro;/g, \"\").replace(/&para;/g, \"\").replace(/&middot;/g, \"\").replace(/&cedil;/g, \"\").replace(/&sup1;/g, \"\").replace(/&ordm;/g, \"\").replace(/&raquo;/g, \"\").replace(/&frac14;/g, \"\").replace(/&frac12;/g, \"\").replace(/&frac34;/g, \"\").replace(/&iquest;/g, \"\").replace(/&times;/g, \"\").replace(/&divide;/g, \"\").replace(/&Agrave;/g, \"\").replace(/&Aacute;/g, \"\").replace(/&Acirc;/g, \"\").replace(/&Atilde;/g, \"\").replace(/&Auml;/g, \"\").replace(/&Aring;/g, \"\").replace(/&AElig;/g, \"\").replace(/&Ccedil;/g, \"\").replace(/&Egrave;/g, \"\").replace(/&Eacute;/g, \"\").replace(/&Ecirc;/g, \"\").replace(/&Euml;/g, \"\").replace(/&Igrave;/g, \"\").replace(/&Iacute;/g, \"\").replace(/&Icirc;/g, \"\").replace(/&Iuml;/g, \"\").replace(/&ETH;/g, \"\").replace(/&Ntilde;/g, \"\").replace(/&Ograve;/g, \"\").replace(/&Oacute;/g, \"\").replace(/&Ocirc;/g, \"\").replace(/&Otilde;/g, \"\").replace(/&Ouml;/g, \"\").replace(/&Oslash;/g, \"\").replace(/&Ugrave;/g, \"\").replace(/&Uacute;/g, \"\").replace(/&Ucirc;/g, \"\").replace(/&Uuml;/g, \"\").replace(/&Yacute;/g, \"\").replace(/&THORN;/g, \"\").replace(/&szlig;/g, \"\").replace(/&agrave;/g, \"\").replace(/&aacute;/g, \"\").replace(/&acirc;/g, \"\").replace(/&atilde;/g, \"\").replace(/&auml;/g, \"\").replace(/&aring;/g, \"\").replace(/&aelig;/g, \"\").replace(/&ccedil;/g, \"\").replace(/&egrave;/g, \"\").replace(/&eacute;/g, \"\").replace(/&ecirc;/g, \"\").replace(/&euml;/g, \"\").replace(/&igrave;/g, \"\").replace(/&iacute;/g, \"\").replace(/&icirc;/g, \"\").replace(/&iuml;/g, \"\").replace(/&eth;/g, \"\").replace(/&ntilde;/g, \"\").replace(/&ograve;/g, \"\").replace(/&oacute;/g, \"\").replace(/&ocirc;/g, \"\").replace(/&otilde;/g, \"\").replace(/&ouml;/g, \"\").replace(/&oslash;/g, \"\").replace(/&ugrave;/g, \"\").replace(/&uacute;/g, \"\").replace(/&ucirc;/g, \"\").replace(/&uuml;/g, \"\").replace(/&yacute;/g, \"\").replace(/&thorn;/g, \"\").replace(/&yuml;/g, \"\");\r\n\r\n}\r\n\r\n\r\nexport class fromulaRef {\r\n\r\n    static operator = '==|!=|<>|<=|>=|=|+|-|>|<|/|*|%|&|^'\r\n    static error = {\r\n        v: \"#VALUE!\",    //\r\n        n: \"#NAME?\",     //\r\n        na: \"#N/A\",      //\r\n        r: \"#REF!\",      //\r\n        d: \"#DIV/0!\",    //0\r\n        nm: \"#NUM!\",     //\r\n        nl: \"#NULL!\",    //\r\n        sp: \"#SPILL!\"    //\r\n    }\r\n\r\n    static operatorjson:stringToNum = null\r\n\r\n    static trim(str:string) {  \r\n        if(str == null){  \r\n            str = \"\";  \r\n        }  \r\n        return str.replace(/(^\\s*)|(\\s*$)/g, \"\");  \r\n    }\r\n\r\n    static functionCopy(txt:string, mode:string, step:number) {\r\n        let _this = this;\r\n\r\n        if (_this.operatorjson == null) {\r\n            let arr = _this.operator.split(\"|\"),\r\n                op:stringToNum = {};\r\n\r\n            for (let i = 0; i < arr.length; i++) {\r\n                op[arr[i].toString()] = 1;\r\n            }\r\n\r\n            _this.operatorjson = op;\r\n        }\r\n\r\n        if (mode == null) {\r\n            mode = \"down\";\r\n        }\r\n\r\n        if (step == null) {\r\n            step = 1;\r\n        }\r\n\r\n        if (txt.substr(0, 1) == \"=\") {\r\n            txt = txt.substr(1);\r\n        }\r\n\r\n        let funcstack = txt.split(\"\");\r\n        let i = 0,\r\n            str = \"\",\r\n            function_str = \"\",\r\n            ispassby = true;\r\n        \r\n        let matchConfig = {\r\n            \"bracket\": 0,\r\n            \"comma\": 0,\r\n            \"squote\": 0,\r\n            \"dquote\": 0\r\n        };\r\n\r\n        while (i < funcstack.length) {\r\n            let s = funcstack[i];\r\n\r\n            if (s == \"(\" && matchConfig.dquote == 0) {\r\n                matchConfig.bracket += 1;\r\n\r\n                if (str.length > 0) {\r\n                    function_str += str + \"(\";\r\n                } \r\n                else {\r\n                    function_str += \"(\";\r\n                }\r\n\r\n                str = \"\";\r\n            } \r\n            else if (s == \")\" && matchConfig.dquote == 0) {\r\n                matchConfig.bracket -= 1;\r\n                function_str += _this.functionCopy(str, mode, step) + \")\";\r\n                str = \"\";\r\n            }\r\n            else if (s == '\"' && matchConfig.squote == 0) {\r\n                if (matchConfig.dquote > 0) {\r\n                    function_str += str + '\"';\r\n                    matchConfig.dquote -= 1;\r\n                    str = \"\";\r\n                } \r\n                else {\r\n                    matchConfig.dquote += 1;\r\n                    str += '\"';\r\n                }\r\n            } \r\n            else if (s == ',' && matchConfig.dquote == 0) {\r\n                function_str += _this.functionCopy(str, mode, step) + ',';\r\n                str = \"\";\r\n            } \r\n            else if (s == '&' && matchConfig.dquote == 0) {\r\n                if (str.length > 0) {\r\n                    function_str += _this.functionCopy(str, mode, step) + \"&\";\r\n                    str = \"\";\r\n                } \r\n                else {\r\n                    function_str += \"&\";\r\n                }\r\n            } \r\n            else if (s in _this.operatorjson && matchConfig.dquote == 0) {\r\n                let s_next = \"\";\r\n\r\n                if ((i + 1) < funcstack.length) {\r\n                    s_next = funcstack[i + 1];\r\n                }\r\n\r\n                let p = i - 1, \r\n                    s_pre = null;\r\n\r\n                if(p >= 0){\r\n                    do {\r\n                        s_pre = funcstack[p--];\r\n                    }\r\n                    while (p>=0 && s_pre ==\" \")\r\n                }\r\n\r\n                if ((s + s_next) in _this.operatorjson) {\r\n                    if (str.length > 0) {\r\n                        function_str += _this.functionCopy(str, mode, step) + s + s_next;\r\n                        str = \"\";\r\n                    } \r\n                    else {\r\n                        function_str += s + s_next;\r\n                    }\r\n\r\n                    i++;\r\n                }\r\n                else if(!(/[^0-9]/.test(s_next)) && s==\"-\" && (s_pre==\"(\" || s_pre == null || s_pre == \",\" || s_pre == \" \" || s_pre in _this.operatorjson ) ){\r\n                    str += s;\r\n                }\r\n                else {\r\n                    if (str.length > 0) {\r\n                        function_str += _this.functionCopy(str, mode, step) + s;\r\n                        str = \"\";\r\n                    } \r\n                    else {\r\n                        function_str += s;\r\n                    }\r\n                }\r\n            } \r\n            else {\r\n                str += s;\r\n            }\r\n\r\n            if (i == funcstack.length - 1) {\r\n                if (_this.iscelldata(_this.trim(str))) {\r\n                    if (mode == \"down\") {\r\n                        function_str += _this.downparam(_this.trim(str), step);\r\n                    } \r\n                    else if (mode == \"up\") {\r\n                        function_str += _this.upparam(_this.trim(str), step);\r\n                    } \r\n                    else if (mode == \"left\") {\r\n                        function_str += _this.leftparam(_this.trim(str), step);\r\n                    } \r\n                    else if (mode == \"right\") {\r\n                        function_str += _this.rightparam(_this.trim(str), step);\r\n                    }\r\n                } \r\n                else {\r\n                    function_str += _this.trim(str);\r\n                }\r\n            }\r\n            \r\n            i++;\r\n        }\r\n\r\n        return function_str;\r\n    }\r\n\r\n\r\n    static downparam(txt:string, step:number) {\r\n        return this.updateparam(\"d\", txt, step);\r\n    }\r\n\r\n    static upparam(txt:string, step:number) {\r\n        return this.updateparam(\"u\", txt, step);\r\n    }\r\n\r\n    static leftparam(txt:string, step:number) {\r\n        return this.updateparam(\"l\", txt, step);\r\n    }\r\n\r\n    static rightparam (txt:string, step:number) {\r\n        return this.updateparam(\"r\", txt, step);\r\n    }\r\n\r\n\r\n    static updateparam (orient:string, txt:string, step:number) {\r\n        let _this = this;\r\n        let val = txt.split(\"!\"),\r\n            rangetxt, prefix = \"\";\r\n        \r\n        if (val.length > 1) {\r\n            rangetxt = val[1];\r\n            prefix = val[0] + \"!\";\r\n        } \r\n        else {\r\n            rangetxt = val[0];\r\n        }\r\n\r\n        if (rangetxt.indexOf(\":\") == -1) {\r\n            let row = parseInt(rangetxt.replace(/[^0-9]/g, \"\"));\r\n            let col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, \"\"));\r\n            let freezonFuc = _this.isfreezonFuc(rangetxt);\r\n            let $row = freezonFuc[0] ? \"$\" : \"\",\r\n                $col = freezonFuc[1] ? \"$\" : \"\";\r\n            \r\n            if (orient == \"u\" && !freezonFuc[0]) {\r\n                row -= step;\r\n            } \r\n            else if (orient == \"r\" && !freezonFuc[1]) {\r\n                col += step;\r\n            } \r\n            else if (orient == \"l\" && !freezonFuc[1]) {\r\n                col -= step;\r\n            } \r\n            else if (!freezonFuc[0]) {\r\n                row += step;\r\n            }\r\n\r\n            if(row < 0 || col < 0){\r\n                return _this.error.r;\r\n            }\r\n            \r\n            if (!isNaN(row) && !isNaN(col)) {\r\n                return prefix + $col + chatatABC(col) + $row + (row);\r\n            } \r\n            else if (!isNaN(row)) {\r\n                return prefix + $row + (row);\r\n            } \r\n            else if (!isNaN(col)) {\r\n                return prefix + $col + chatatABC(col);\r\n            } \r\n            else {\r\n                return txt;\r\n            }\r\n        } \r\n        else {\r\n            rangetxt = rangetxt.split(\":\");\r\n            let row = [],\r\n                col = [];\r\n\r\n            row[0] = parseInt(rangetxt[0].replace(/[^0-9]/g, \"\"));\r\n            row[1] = parseInt(rangetxt[1].replace(/[^0-9]/g, \"\"));\r\n            if (row[0] > row[1]) {\r\n                return txt;\r\n            }\r\n            \r\n            col[0] = ABCatNum(rangetxt[0].replace(/[^A-Za-z]/g, \"\"));\r\n            col[1] = ABCatNum(rangetxt[1].replace(/[^A-Za-z]/g, \"\"));\r\n            if (col[0] > col[1]) {\r\n                return txt;\r\n            }\r\n\r\n            let freezonFuc0 = _this.isfreezonFuc(rangetxt[0]);\r\n            let freezonFuc1 = _this.isfreezonFuc(rangetxt[1]);\r\n            let $row0 = freezonFuc0[0] ? \"$\" : \"\",\r\n                $col0 = freezonFuc0[1] ? \"$\" : \"\";\r\n            let $row1 = freezonFuc1[0] ? \"$\" : \"\",\r\n                $col1 = freezonFuc1[1] ? \"$\" : \"\";\r\n            \r\n            if (orient == \"u\") {\r\n                if (!freezonFuc0[0]) {\r\n                    row[0] -= step;\r\n                }\r\n\r\n                if (!freezonFuc1[0]) {\r\n                    row[1] -= step;\r\n                }\r\n            } \r\n            else if (orient == \"r\") {\r\n                if (!freezonFuc0[1]) {\r\n                    col[0] += step;\r\n                }\r\n\r\n                if (!freezonFuc1[1]) {\r\n                    col[1] += step;\r\n                }\r\n            } \r\n            else if (orient == \"l\") {\r\n                if (!freezonFuc0[1]) {\r\n                    col[0] -= step;\r\n                }\r\n\r\n                if (!freezonFuc1[1]) {\r\n                    col[1] -= step;\r\n                }\r\n            } \r\n            else {\r\n                if (!freezonFuc0[0]) {\r\n                    row[0] += step;\r\n                }\r\n\r\n                if (!freezonFuc1[0]) {\r\n                    row[1] += step;\r\n                }\r\n            }\r\n\r\n            if(row[0] < 0 || col[0] < 0){\r\n                return _this.error.r;\r\n            }\r\n\r\n            if (isNaN(col[0]) && isNaN(col[1])) {\r\n                return prefix + $row0 + (row[0]) + \":\" + $row1 + (row[1]);\r\n            } \r\n            else if (isNaN(row[0]) && isNaN(row[1])) {\r\n                return prefix + $col0 + chatatABC(col[0]) + \":\" + $col1 + chatatABC(col[1]);\r\n            } \r\n            else {\r\n                return prefix + $col0 + chatatABC(col[0]) + $row0 + (row[0]) + \":\" + $col1 + chatatABC(col[1]) + $row1 + (row[1]);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    static iscelldata(txt:string) { //\r\n        let val = txt.split(\"!\"),\r\n            rangetxt;\r\n\r\n        if (val.length > 1) {\r\n            rangetxt = val[1];\r\n        } \r\n        else {\r\n            rangetxt = val[0];\r\n        }\r\n\r\n        let reg_cell = /^(([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+))$/g; //+ A1:B3\r\n        let reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+))))$/g; //+ A1:B3A:A\r\n        \r\n        if (rangetxt.indexOf(\":\") == -1) {\r\n            let row = parseInt(rangetxt.replace(/[^0-9]/g, \"\")) - 1;\r\n            let col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, \"\"));\r\n            \r\n            if (!isNaN(row) && !isNaN(col) && rangetxt.toString().match(reg_cell)) {\r\n                return true;\r\n            } \r\n            else if (!isNaN(row)) {\r\n                return false;\r\n            } \r\n            else if (!isNaN(col)) {\r\n                return false;\r\n            } \r\n            else {\r\n                return false;\r\n            }\r\n        } \r\n        else {\r\n            reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+)))|((([0-9]+)|([$][0-9]+s))))$/g;\r\n\r\n            rangetxt = rangetxt.split(\":\");\r\n\r\n            let row = [],col = [];\r\n            row[0] = parseInt(rangetxt[0].replace(/[^0-9]/g, \"\")) - 1;\r\n            row[1] = parseInt(rangetxt[1].replace(/[^0-9]/g, \"\")) - 1;\r\n            if (row[0] > row[1]) {\r\n                return false;\r\n            }\r\n\r\n            col[0] = ABCatNum(rangetxt[0].replace(/[^A-Za-z]/g, \"\"));\r\n            col[1] = ABCatNum(rangetxt[1].replace(/[^A-Za-z]/g, \"\"));\r\n            if (col[0] > col[1]) {\r\n                return false;\r\n            }\r\n\r\n            if(rangetxt[0].toString().match(reg_cellRange) && rangetxt[1].toString().match(reg_cellRange)){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    static isfreezonFuc(txt:string) {\r\n        let row = txt.replace(/[^0-9]/g, \"\");\r\n        let col = txt.replace(/[^A-Za-z]/g, \"\");\r\n        let row$ = txt.substr(txt.indexOf(row) - 1, 1);\r\n        let col$ = txt.substr(txt.indexOf(col) - 1, 1);\r\n        let ret = [false, false];\r\n\r\n        if (row$ == \"$\") {\r\n            ret[0] = true;\r\n        }\r\n        if (col$ == \"$\") {\r\n            ret[1] = true;\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nexport function isChinese(temp:string):boolean\r\n{ \r\n    var re = /[^\\u4e00-\\u9fa5]/; \r\n    var reg = /[\\u3002|\\uff1f|\\uff01|\\uff0c|\\u3001|\\uff1b|\\uff1a|\\u201c|\\u201d|\\u2018|\\u2019|\\uff08|\\uff09|\\u300a|\\u300b|\\u3008|\\u3009|\\u3010|\\u3011|\\u300e|\\u300f|\\u300c|\\u300d|\\ufe43|\\ufe44|\\u3014|\\u3015|\\u2026|\\u2014|\\uff5e|\\ufe4f|\\uffe5]/;\r\n    if(reg.test(temp)) return true; \r\n    if(re.test(temp)) return false; \r\n\treturn true; \r\n}\r\n \r\nexport function isJapanese(temp:string):boolean\r\n{ \r\n\tvar re = /[^\\u0800-\\u4e00]/; \r\n\tif(re.test(temp)) return false; \r\n\treturn true; \r\n}\r\n \r\nexport function isKoera(chr:any):boolean {\r\n\t\r\n\tif(((chr > 0x3130 && chr < 0x318F) || \r\n\t    (chr >= 0xAC00 && chr <= 0xD7A3))) \r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nexport function isContainMultiType(str:string):boolean {\r\n\t\r\n    let isUnicode = false;\r\n    if(escape(str).indexOf(\"%u\")>-1){\r\n        isUnicode = true;\r\n    }\r\n\r\n    let isNot = false;\r\n    let reg = /[0-9a-z]/gi; \r\n    if(reg.test(str)){\r\n        isNot = true;\r\n    }\r\n\r\n    let reEnSign = /[\\x00-\\xff]+/g;\r\n    if(reEnSign.test(str)){\r\n        isNot = true;\r\n    }\r\n\r\n    if(isUnicode && isNot){\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport function getBinaryContent (path:any, options:any) {\r\n    let promise, resolve:any, reject:any;\r\n    let callback:any;\r\n\r\n    if (!options) {\r\n        options = {};\r\n    }\r\n\r\n    // taken from jQuery\r\n    let createStandardXHR = function () {\r\n        try {\r\n            return new window.XMLHttpRequest();\r\n        } catch( e ) {}\r\n    }\r\n\r\n    let createActiveXHR = function () {\r\n        try {\r\n            return new window.ActiveXObject(\"Microsoft.XMLHTTP\");\r\n        } catch( e ) {}\r\n    }\r\n\r\n    // Create the request object\r\n    var createXHR = (typeof window !== \"undefined\" && window.ActiveXObject) ?\r\n        /* Microsoft failed to properly\r\n        * implement the XMLHttpRequest in IE7 (can't request local files),\r\n        * so we use the ActiveXObject when it is available\r\n        * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\r\n        * we need a fallback.\r\n        */\r\n        function() {\r\n        return createStandardXHR() || createActiveXHR();\r\n    } :\r\n        // For all other browsers, use the standard XMLHttpRequest object\r\n        createStandardXHR;\r\n\r\n    // backward compatible callback\r\n    if (typeof options === \"function\") {\r\n        callback = options;\r\n        options = {};\r\n    } else if (typeof options.callback === 'function') {\r\n        // callback inside options object\r\n        callback = options.callback;\r\n    }\r\n\r\n    resolve = function (data:any) { callback(null, data); };\r\n    reject = function (err:any) { callback(err, null); };\r\n\r\n    try {\r\n        var xhr = createXHR();\r\n\r\n        xhr.open('GET', path, true);\r\n\r\n        // recent browsers\r\n        if (\"responseType\" in xhr) {\r\n            xhr.responseType = \"arraybuffer\";\r\n        }\r\n\r\n        // older browser\r\n        if(xhr.overrideMimeType) {\r\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\r\n        }\r\n\r\n        xhr.onreadystatechange = function (event:Event) {\r\n            // use `xhr` and not `this`... thanks IE\r\n            if (xhr.readyState === 4) {\r\n                if (xhr.status === 200 || xhr.status === 0) {\r\n                    try {\r\n                        resolve(function (xhr:XMLHttpRequest) {\r\n                            // for xhr.responseText, the 0xFF mask is applied by JSZip\r\n                            return xhr.response || xhr.responseText;\r\n                        }(xhr));\r\n                    } catch(err) {\r\n                        reject(new Error(err));\r\n                    }\r\n                } else {\r\n                    reject(new Error(\"Ajax error for \" + path + \" : \" + this.status + \" \" + this.statusText));\r\n                }\r\n            }\r\n        };\r\n\r\n        if(options.progress) {\r\n            xhr.onprogress = function(e:any) {\r\n                options.progress({\r\n                    path: path,\r\n                    originalEvent: e,\r\n                    percent: e.loaded / e.total * 100,\r\n                    loaded: e.loaded,\r\n                    total: e.total\r\n                });\r\n            };\r\n        }\r\n\r\n        xhr.send();\r\n\r\n    } catch (e) {\r\n        reject(new Error(e), null);\r\n    }\r\n\r\n    // returns a promise or undefined depending on whether a callback was\r\n    // provided\r\n    return promise;\r\n}\r\n\r\n/**\r\n * multi sequence conversion\r\n * example:\r\n *  1E14 -> 13_4\r\n *  2E14 J14 O14 T14 Y14 AD14 AI14 AN14 AS14 AX14 ->\r\n *     ['13_4', '13_9','13_14', '13_19', '13_24', '13_3', '13_8',  '13_13', '13_18', '13_23']\r\n *  3E46:E47 -> ['45_4',  '46_4']\r\n *\r\n * @param {string} sqref - before sequence\r\n * @returns {string[]}\r\n */\r\nexport function getMultiSequenceToNum(sqref: string): string[] {\r\n  if (!sqref || sqref?.length <= 0) return [];\r\n  sqref = sqref.toUpperCase();\r\n  let sqrefRawArr = sqref.split(\" \");\r\n  let sqrefArr = sqrefRawArr.filter((e) => e && e.trim());\r\n  let sqrefLastArr = getSqrefRawArrFormat(sqrefArr);\r\n\r\n  let resArr: string[] = [];\r\n  for (let i = 0; i < sqrefLastArr.length; i++) {\r\n    let _res = getSingleSequenceToNum(sqrefLastArr[i]);\r\n    if (_res) resArr.push(_res);\r\n  }\r\n  return resArr;\r\n}\r\n\r\n/**\r\n * get region sequence\r\n * example:\r\n *  1[A1:C2'] -> ['A1', 'A2', 'B1', 'B2', 'C1', 'C2']\r\n *\r\n * @param {string[]} arr - formats arr\r\n * @returns {string[]} - after arr\r\n */\r\nexport function getRegionSequence(arr: string[]): string[] {\r\n  let formatArr: string[] = [];\r\n  \r\n  const regEn = new RegExp(/[A-Z]+|[0-9]+/g);\r\n  const startArr = arr[0]?.match(regEn);\r\n  const lastArr = arr[1]?.match(regEn);\r\n  const columnMax = Math.max(...[ABCatNum(startArr[0]), ABCatNum(lastArr[0])]);\r\n  const columnMin = Math.min(...[ABCatNum(startArr[0]), ABCatNum(lastArr[0])]);\r\n  const rowMax = Math.max(...[parseInt(startArr[1]), parseInt(lastArr[1])]);\r\n  const rowMin = Math.min(...[parseInt(startArr[1]), parseInt(lastArr[1])]);\r\n  \r\n  for (let i = columnMin; i <= columnMax; i++) {\r\n    for (let j = rowMin; j <= rowMax; j++) {\r\n      formatArr.push(`${chatatABC(i)}${j}`);\r\n    }\r\n  }\r\n\r\n  return formatArr;\r\n}\r\n\r\n/**\r\n * unified processing of conversion formats\r\n * example:\r\n *  1['E38', 'A1:C2'] -> ['E38', 'A1', 'A2', 'B1', 'B2', 'C1', 'C2']\r\n *\r\n * @param {string[]} arr - formats arr\r\n * @returns {string[]} - after arr\r\n */\r\nexport function getSqrefRawArrFormat(arr: string[]): string[] {\r\n  arr?.map((el) => {\r\n    if (el.includes(\":\")) {\r\n      let tempArr: string[] = el.split(\":\");\r\n      if (tempArr?.length === 2) {\r\n        arr = arr.concat(getRegionSequence(tempArr));\r\n        arr.splice(arr.indexOf(el), 1);\r\n      }\r\n    }\r\n  });\r\n\r\n  const resultArr = arr.filter(\r\n    (value, index, array) => array.indexOf(value) === index\r\n  );\r\n\r\n  return resultArr;\r\n}\r\n\r\n/**\r\n * single sequence to number\r\n * example:\r\n *  1A1 -> 0_0\r\n *  2ES14 -> 13_4\r\n *\r\n * @param {string} sqref - before sequence\r\n * @returns {string} - after sequence\r\n */\r\nexport function getSingleSequenceToNum(sqref: string): string {\r\n  let sqrefArray = sqref.match(/[A-Z]+|[0-9]+/g);\r\n  let sqrefLen = sqrefArray.length;\r\n  let regEn = new RegExp(\"^[A-Z]+$\");\r\n  let ret = \"\";\r\n  for (let i = sqrefLen - 1; i >= 0; i--) {\r\n    let cur = sqrefArray[i];\r\n    if (regEn.test(cur)) {\r\n      ret += ABCatNum(cur) + \"_\";\r\n    } else {\r\n      ret += parseInt(cur) - 1 + \"_\";\r\n    }\r\n  }\r\n  return ret.substring(0, ret.length - 1);\r\n}\r\n\r\n/**\r\n * R1C1 to Sequence\r\n * example: sheet2!R1C1 => sheet!A1\r\n *\r\n * @param {string} value - R1C1 value\r\n * @returns\r\n */\r\nexport function getTransR1C1ToSequence(value: string): string {\r\n  if (!value && value?.length <= 0) return \"\";\r\n\r\n  const len = value.length;\r\n  const index = value.lastIndexOf(\"!\");\r\n  const valueArr = [value.slice(0, index), value.slice(index + 1, len)];\r\n  const repStr = valueArr[1] || \"\";\r\n  const indexR = repStr.indexOf(\"R\");\r\n  const indexC = repStr.indexOf(\"C\");\r\n  \r\n  const row = Number(repStr.slice(indexR + 1, indexC));\r\n  const column = chatatABC(Number(repStr.slice(indexC + 1, repStr?.length)) - 1);\r\n\r\n  return `${valueArr[0]}!${column}${row}`;\r\n}\r\n\r\n/**\r\n * strip x14 format data\r\n *\r\n * @param {string} value\r\n * @returns {Object} - { formula, sqref }\r\n */\r\nexport function getPeelOffX14(value: string): {  [key: string]: any} {\r\n  if (!value || value?.length <= 0) return {};\r\n\r\n  // formula\r\n  const formulaReg = new RegExp(\"</x14:formula[^]>\", \"g\");\r\n  const lastIndex = value.match(formulaReg)?.length;\r\n  const lastValue = `</x14:formula${lastIndex}>`;\r\n  const lastValueEnd = value.indexOf(lastValue);\r\n  let formulaValue = value.substring(0, lastValueEnd + lastValue.length);\r\n  formulaValue = formulaValue\r\n    .replace(/<xm:f>/g, \"\")\r\n    .replace(/<\\/xm:f>/g, \"\")\r\n    .replace(/x14:/g, \"\")\r\n    .replace(/\\/x14:/g, \"\");\r\n  const formula = formulaValue;\r\n  \r\n  // sqref\r\n  const xmSqrefLen = \"<xm:sqref>\".length;\r\n  const sqrefStart = value.indexOf(\"<xm:sqref>\");\r\n  const sqrefEnd = value.indexOf(\"</xm:sqref>\");\r\n  const sqref = value.substring(sqrefStart + xmSqrefLen, sqrefEnd);\r\n\r\n  return {\r\n    formula,\r\n    sqref,\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * get the value in the formula\r\n *\r\n * @param {string} value - extracted value\r\n * @returns {string[]}\r\n */\r\nexport function getMultiFormulaValue(value: string): string[] {\r\n  if (!value || value?.length <= 0) return [];\r\n  \r\n  const lenReg = new RegExp(\"formula\", \"g\");\r\n  const len = (value.match(lenReg)?.length || 0) / 2;\r\n  \r\n  if (len === 0) return [];\r\n  \r\n  let retArr: any = [];\r\n  for (let i = 1; i <= len; i++) {\r\n    const startLen = `<formula${i}>`?.length;\r\n    const start = value.indexOf(`<formula${i}>`);\r\n    const end = value.indexOf(`</formula${i}>`);\r\n    const _value = value.substring(start + startLen, end);\r\n    retArr.push(escapeCharacter(_value.replace(/&quot;|^\\\"|\\\"$/g, \"\")));\r\n  }\r\n  return retArr;\r\n}","import { LuckyFile } from \"./ToLuckySheet/LuckyFile\";\r\n// import {SecurityDoor,Car} from './content';\r\n\r\nimport {HandleZip} from './HandleZip';\r\n\r\nimport {IuploadfileList} from \"./ICommon\";\r\nimport { fstat } from \"fs\";\r\n\r\n// //demo\r\n// function demoHandler(){\r\n//     let upload = document.getElementById(\"Luckyexcel-demo-file\");\r\n//     let selectADemo = document.getElementById(\"Luckyexcel-select-demo\");\r\n//     let downlodDemo = document.getElementById(\"Luckyexcel-downlod-file\");\r\n//     let mask = document.getElementById(\"lucky-mask-demo\");\r\n//     if(upload){\r\n        \r\n//         window.onload = () => {\r\n            \r\n//             upload.addEventListener(\"change\", function(evt){\r\n//                 var files:FileList = (evt.target as any).files;\r\n//                 if(files==null || files.length==0){\r\n//                     alert(\"No files wait for import\");\r\n//                     return;\r\n//                 }\r\n\r\n//                 let name = files[0].name;\r\n//                 let suffixArr = name.split(\".\"), suffix = suffixArr[suffixArr.length-1];\r\n//                 if(suffix!=\"xlsx\"){\r\n//                     alert(\"Currently only supports the import of xlsx files\");\r\n//                     return;\r\n//                 }\r\n//                 LuckyExcel.transformExcelToLucky(files[0], function(exportJson:any, luckysheetfile:string){\r\n                    \r\n//                     if(exportJson.sheets==null || exportJson.sheets.length==0){\r\n//                         alert(\"Failed to read the content of the excel file, currently does not support xls files!\");\r\n//                         return;\r\n//                     }\r\n//                     console.log(exportJson, luckysheetfile);\r\n//                     window.luckysheet.destroy();\r\n                    \r\n//                     window.luckysheet.create({\r\n//                         container: 'luckysheet', //luckysheet is the container id\r\n//                         showinfobar:false,\r\n//                         data:exportJson.sheets,\r\n//                         title:exportJson.info.name,\r\n//                         userInfo:exportJson.info.name.creator\r\n//                     });\r\n//                 });\r\n//             });\r\n\r\n//             selectADemo.addEventListener(\"change\", function(evt){\r\n//                 var obj:any = selectADemo;\r\n//                 var index = obj.selectedIndex;\r\n//                 var value = obj.options[index].value;\r\n//                 var name = obj.options[index].innerHTML;\r\n//                 if(value==\"\"){\r\n//                     return;\r\n//                 }\r\n//                 mask.style.display = \"flex\";\r\n//                 LuckyExcel.transformExcelToLuckyByUrl(value, name, function(exportJson:any, luckysheetfile:string){\r\n                    \r\n//                     if(exportJson.sheets==null || exportJson.sheets.length==0){\r\n//                         alert(\"Failed to read the content of the excel file, currently does not support xls files!\");\r\n//                         return;\r\n//                     }\r\n//                     console.log(exportJson, luckysheetfile);\r\n//                     mask.style.display = \"none\";\r\n//                     window.luckysheet.destroy();\r\n                    \r\n//                     window.luckysheet.create({\r\n//                         container: 'luckysheet', //luckysheet is the container id\r\n//                         showinfobar:false,\r\n//                         data:exportJson.sheets,\r\n//                         title:exportJson.info.name,\r\n//                         userInfo:exportJson.info.name.creator\r\n//                     });\r\n//                 });\r\n//             });\r\n\r\n//             downlodDemo.addEventListener(\"click\", function(evt){\r\n//                 var obj:any = selectADemo;\r\n//                 var index = obj.selectedIndex;\r\n//                 var value = obj.options[index].value;\r\n\r\n//                 if(value.length==0){\r\n//                     alert(\"Please select a demo file\");\r\n//                     return;\r\n//                 }\r\n\r\n//                 var elemIF:any = document.getElementById(\"Lucky-download-frame\");\r\n//                 if(elemIF==null){\r\n//                     elemIF = document.createElement(\"iframe\");\r\n//                     elemIF.style.display = \"none\";\r\n//                     elemIF.id = \"Lucky-download-frame\";\r\n//                     document.body.appendChild(elemIF);\r\n//                 }\r\n//                 elemIF.src = value;\r\n\r\n//                 // elemIF.parentNode.removeChild(elemIF);\r\n//             });\r\n//         }\r\n//     }\r\n// }\r\n// demoHandler();\r\n\r\n// api\r\nexport class LuckyExcel{\r\n    static transformExcelToLucky(excelFile: File,\r\n        callback?: (files: IuploadfileList, fs?: string) => void,\r\n        errorHandler?: (err: Error) => void) {\r\n        let handleZip:HandleZip = new HandleZip(excelFile);\r\n        \r\n        handleZip.unzipFile(function (files: IuploadfileList) {\r\n            let luckyFile = new LuckyFile(files, excelFile.name);\r\n            let luckysheetfile = luckyFile.Parse();\r\n            let exportJson = JSON.parse(luckysheetfile);\r\n            if (callback != undefined) {\r\n                callback(exportJson, luckysheetfile);\r\n            }\r\n        },\r\n        function(err:Error){\r\n            if (errorHandler) {\r\n                errorHandler(err);\r\n              } else {\r\n                console.error(err);\r\n              }\r\n        });\r\n    }\r\n\r\n    static transformExcelToLuckyByUrl(\r\n        url: string,\r\n        name: string,\r\n        callBack?: (files: IuploadfileList, fs?: string) => void,\r\n        errorHandler?: (err: Error) => void) {\r\n        let handleZip:HandleZip = new HandleZip();\r\n        handleZip.unzipFileByUrl(url, function(files:IuploadfileList){\r\n            let luckyFile = new LuckyFile(files, name);\r\n            let luckysheetfile = luckyFile.Parse();\r\n            let exportJson = JSON.parse(luckysheetfile);\r\n            if(callBack != undefined){\r\n                callBack(exportJson, luckysheetfile);\r\n            }\r\n        },\r\n        function(err:Error){\r\n            if (errorHandler) {\r\n                errorHandler(err);\r\n              } else {\r\n                console.error(err);\r\n              }\r\n        });\r\n    }\r\n\r\n    static transformLuckyToExcel(\r\n        LuckyFile: any,\r\n        callBack?: (files: string) => void ,\r\n        errorHandler?: (err: Error) => void){ }\r\n}","import {LuckyExcel} from \"./main\"\r\n// export Node module\r\nexport = LuckyExcel;"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RheWpzL2RheWpzLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW1tZWRpYXRlL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvY29tcHJlc3NlZE9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvY29tcHJlc3Npb25zLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jcmMzMi5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvZGVmYXVsdHMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2V4dGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9mbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvZ2VuZXJhdGUvWmlwRmlsZVdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvZ2VuZXJhdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9sb2FkLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9ub2RlanNVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGFibGUtc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9BcnJheVJlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL0RhdGFSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9Ob2RlQnVmZmVyUmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvU3RyaW5nUmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvVWludDhBcnJheVJlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL3JlYWRlckZvci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc2lnbmF0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vQ29udmVydFdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0NyYzMyUHJvYmUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhV29ya2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vR2VuZXJpY1dvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL1N0cmVhbUhlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3VwcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvdXRmOC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcEVudHJpZXMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcEVudHJ5LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbGllL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZXQtaW1tZWRpYXRlLXNoaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsInNyYy9IYW5kbGVaaXAudHMiLCJzcmMvVG9MdWNreVNoZWV0L0x1Y2t5QmFzZS50cyIsInNyYy9Ub0x1Y2t5U2hlZXQvTHVja3lDZWxsLnRzIiwic3JjL1RvTHVja3lTaGVldC9MdWNreUZpbGUudHMiLCJzcmMvVG9MdWNreVNoZWV0L0x1Y2t5SW1hZ2UudHMiLCJzcmMvVG9MdWNreVNoZWV0L0x1Y2t5U2hlZXQudHMiLCJzcmMvVG9MdWNreVNoZWV0L1JlYWRYbWwudHMiLCJzcmMvY29tbW9uL2NvbnN0YW50LnRzIiwic3JjL2NvbW1vbi9lbWYudHMiLCJzcmMvY29tbW9uL21ldGhvZC50cyIsInNyYy9tYWluLnRzIiwic3JjL21haW4udW1kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzd2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0dBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGhEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25FQSxJQUFBLE9BQUEsR0FBQSxlQUFBLENBQUEsT0FBQSxDQUFBLE9BQUEsQ0FBQSxDQUFBOztBQUVBLElBQUEsUUFBQSxHQUFBLE9BQUEsQ0FBQSxpQkFBQSxDQUFBOztBQUdBLElBQUEsU0FBQTtBQUFBO0FBQUEsWUFBQTtBQUlJLFdBQUEsU0FBQSxDQUFZLElBQVosRUFBc0I7QUFDbEI7QUFDQTtBQUNJLFNBQUssVUFBTCxHQUFrQixJ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LElBQUksV0FBQSxDQUFBLFNBQUosRUFBMUI7QUFDQSxJQUFBLFNBQVMsQ0FBQyxjQUFWLENBQXlCLEdBQXpCLEVBQThCLFVBQVMsS0FBVCxFQUE4QjtBQUN4RCxVQUFJLFNBQVMsR0FBRyxJQUFJLFdBQUEsQ0FBQSxTQUFKLENBQWMsS0FBZCxFQUFxQixJQUFyQixDQUFoQjtBQUNBLFVBQUksY0FBYyxHQUFHLFNBQVMsQ0FBQyxLQUFWLEVBQXJCO0FBQ0EsVUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxjQUFYLENBQWpCOztBQUNBLFVBQUcsUUFBUSxJQUFJLFNBQWYsRUFBeUI7QUFDckIsUUFBQSxRQUFRLENBQUMsVUFBRCxFQUFhLGNBQWIsQ0FBUjtBQUNIO0FBQ0osS0FQRCxFQVFBLFVBQVMsR0FBVCxFQUFrQjtBQUNkLFVBQUksWUFBSixFQUFrQjtBQUNkLFFBQUEsWUFBWSxDQUFDLEdBQUQsQ0FBWjtBQUNELE9BRkgsTUFFUztBQUNMLFFBQUEsT0FBTyxDQUFDLEtBQVIsQ0FBYyxHQUFkO0FBQ0Q7QUFDTixLQWREO0FBZUgsR0FyQk07O0FBdUJBLEVBQUEsVUFBQSxDQUFBLHFCQUFBLEdBQVAsVUFDSSxTQURKLEVBRUksUUFGSixFQUdJLFlBSEosRUFHdUMsQ0FBSSxDQUhwQzs7QUFJWCxTQUFBLFVBQUE7QUFBQyxDQWxERCxFQUFBOztBQUFhLE9BQUEsQ0FBQSxVQUFBLEdBQUEsVUFBQTs7Ozs7QUMxR2IsSUFBQSxNQUFBLEdBQUEsT0FBQSxDQUFBLFFBQUEsQ0FBQTs7QUFFQSxNQUFBLENBQUEsT0FBQSxHQUFTLE1BQUEsQ0FBQSxVQUFUIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqcz1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9MWUzLGU9NmU0LG49MzZlNSxyPVwibWlsbGlzZWNvbmRcIixpPVwic2Vjb25kXCIscz1cIm1pbnV0ZVwiLHU9XCJob3VyXCIsYT1cImRheVwiLG89XCJ3ZWVrXCIsZj1cIm1vbnRoXCIsaD1cInF1YXJ0ZXJcIixjPVwieWVhclwiLGQ9XCJkYXRlXCIsJD1cIkludmFsaWQgRGF0ZVwiLGw9L14oXFxkezR9KVstL10/KFxcZHsxLDJ9KT9bLS9dPyhcXGR7MCwyfSlbVHRcXHNdKihcXGR7MSwyfSk/Oj8oXFxkezEsMn0pPzo/KFxcZHsxLDJ9KT9bLjpdPyhcXGQrKT8kLyx5PS9cXFsoW15cXF1dKyldfFl7MSw0fXxNezEsNH18RHsxLDJ9fGR7MSw0fXxIezEsMn18aHsxLDJ9fGF8QXxtezEsMn18c3sxLDJ9fFp7MSwyfXxTU1MvZyxNPXtuYW1lOlwiZW5cIix3ZWVrZGF5czpcIlN1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5XCIuc3BsaXQoXCJfXCIpLG1vbnRoczpcIkphbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXJcIi5zcGxpdChcIl9cIil9LG09ZnVuY3Rpb24odCxlLG4pe3ZhciByPVN0cmluZyh0KTtyZXR1cm4hcnx8ci5sZW5ndGg+PWU/dDpcIlwiK0FycmF5KGUrMS1yLmxlbmd0aCkuam9pbihuKSt0fSxnPXtzOm0sejpmdW5jdGlvbih0KXt2YXIgZT0tdC51dGNPZmZzZXQoKSxuPU1hdGguYWJzKGUpLHI9TWF0aC5mbG9vcihuLzYwKSxpPW4lNjA7cmV0dXJuKGU8PTA/XCIrXCI6XCItXCIpK20ociwyLFwiMFwiKStcIjpcIittKGksMixcIjBcIil9LG06ZnVuY3Rpb24gdChlLG4pe2lmKGUuZGF0ZSgpPG4uZGF0ZSgpKXJldHVybi10KG4sZSk7dmFyIHI9MTIqKG4ueWVhcigpLWUueWVhcigpKSsobi5tb250aCgpLWUubW9udGgoKSksaT1lLmNsb25lKCkuYWRkKHIsZikscz1uLWk8MCx1PWUuY2xvbmUoKS5hZGQocisocz8tMToxKSxmKTtyZXR1cm4rKC0ocisobi1pKS8ocz9pLXU6dS1pKSl8fDApfSxhOmZ1bmN0aW9uKHQpe3JldHVybiB0PDA/TWF0aC5jZWlsKHQpfHwwOk1hdGguZmxvb3IodCl9LHA6ZnVuY3Rpb24odCl7cmV0dXJue006Zix5OmMsdzpvLGQ6YSxEOmQsaDp1LG06cyxzOmksbXM6cixROmh9W3RdfHxTdHJpbmcodHx8XCJcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9zJC8sXCJcIil9LHU6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXR9fSxEPVwiZW5cIix2PXt9O3ZbRF09TTt2YXIgcD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIF99LFM9ZnVuY3Rpb24odCxlLG4pe3ZhciByO2lmKCF0KXJldHVybiBEO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXZbdF0mJihyPXQpLGUmJih2W3RdPWUscj10KTtlbHNle3ZhciBpPXQubmFtZTt2W2ldPXQscj1pfXJldHVybiFuJiZyJiYoRD1yKSxyfHwhbiYmRH0sdz1mdW5jdGlvbih0LGUpe2lmKHAodCkpcmV0dXJuIHQuY2xvbmUoKTt2YXIgbj1cIm9iamVjdFwiPT10eXBlb2YgZT9lOnt9O3JldHVybiBuLmRhdGU9dCxuLmFyZ3M9YXJndW1lbnRzLG5ldyBfKG4pfSxPPWc7Ty5sPVMsTy5pPXAsTy53PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHcodCx7bG9jYWxlOmUuJEwsdXRjOmUuJHUseDplLiR4LCRvZmZzZXQ6ZS4kb2Zmc2V0fSl9O3ZhciBfPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gTSh0KXt0aGlzLiRMPVModC5sb2NhbGUsbnVsbCwhMCksdGhpcy5wYXJzZSh0KX12YXIgbT1NLnByb3RvdHlwZTtyZXR1cm4gbS5wYXJzZT1mdW5jdGlvbih0KXt0aGlzLiRkPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZGF0ZSxuPXQudXRjO2lmKG51bGw9PT1lKXJldHVybiBuZXcgRGF0ZShOYU4pO2lmKE8udShlKSlyZXR1cm4gbmV3IERhdGU7aWYoZSBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIG5ldyBEYXRlKGUpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiYhL1okL2kudGVzdChlKSl7dmFyIHI9ZS5tYXRjaChsKTtpZihyKXt2YXIgaT1yWzJdLTF8fDAscz0ocls3XXx8XCIwXCIpLnN1YnN0cmluZygwLDMpO3JldHVybiBuP25ldyBEYXRlKERhdGUuVVRDKHJbMV0saSxyWzNdfHwxLHJbNF18fDAscls1XXx8MCxyWzZdfHwwLHMpKTpuZXcgRGF0ZShyWzFdLGksclszXXx8MSxyWzRdfHwwLHJbNV18fDAscls2XXx8MCxzKX19cmV0dXJuIG5ldyBEYXRlKGUpfSh0KSx0aGlzLiR4PXQueHx8e30sdGhpcy5pbml0KCl9LG0uaW5pdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuJGQ7dGhpcy4keT10LmdldEZ1bGxZZWFyKCksdGhpcy4kTT10LmdldE1vbnRoKCksdGhpcy4kRD10LmdldERhdGUoKSx0aGlzLiRXPXQuZ2V0RGF5KCksdGhpcy4kSD10LmdldEhvdXJzKCksdGhpcy4kbT10LmdldE1pbnV0ZXMoKSx0aGlzLiRzPXQuZ2V0U2Vjb25kcygpLHRoaXMuJG1zPXQuZ2V0TWlsbGlzZWNvbmRzKCl9LG0uJHV0aWxzPWZ1bmN0aW9uKCl7cmV0dXJuIE99LG0uaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiEodGhpcy4kZC50b1N0cmluZygpPT09JCl9LG0uaXNTYW1lPWZ1bmN0aW9uKHQsZSl7dmFyIG49dyh0KTtyZXR1cm4gdGhpcy5zdGFydE9mKGUpPD1uJiZuPD10aGlzLmVuZE9mKGUpfSxtLmlzQWZ0ZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdyh0KTx0aGlzLnN0YXJ0T2YoZSl9LG0uaXNCZWZvcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmRPZihlKTx3KHQpfSxtLiRnPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTy51KHQpP3RoaXNbZV06dGhpcy5zZXQobix0KX0sbS51bml4PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkvMWUzKX0sbS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQuZ2V0VGltZSgpfSxtLnN0YXJ0T2Y9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLHI9ISFPLnUoZSl8fGUsaD1PLnAodCksJD1mdW5jdGlvbih0LGUpe3ZhciBpPU8udyhuLiR1P0RhdGUuVVRDKG4uJHksZSx0KTpuZXcgRGF0ZShuLiR5LGUsdCksbik7cmV0dXJuIHI/aTppLmVuZE9mKGEpfSxsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE8udyhuLnRvRGF0ZSgpW3RdLmFwcGx5KG4udG9EYXRlKFwic1wiKSwocj9bMCwwLDAsMF06WzIzLDU5LDU5LDk5OV0pLnNsaWNlKGUpKSxuKX0seT10aGlzLiRXLE09dGhpcy4kTSxtPXRoaXMuJEQsZz1cInNldFwiKyh0aGlzLiR1P1wiVVRDXCI6XCJcIik7c3dpdGNoKGgpe2Nhc2UgYzpyZXR1cm4gcj8kKDEsMCk6JCgzMSwxMSk7Y2FzZSBmOnJldHVybiByPyQoMSxNKTokKDAsTSsxKTtjYXNlIG86dmFyIEQ9dGhpcy4kbG9jYWxlKCkud2Vla1N0YXJ0fHwwLHY9KHk8RD95Kzc6eSktRDtyZXR1cm4gJChyP20tdjptKyg2LXYpLE0pO2Nhc2UgYTpjYXNlIGQ6cmV0dXJuIGwoZytcIkhvdXJzXCIsMCk7Y2FzZSB1OnJldHVybiBsKGcrXCJNaW51dGVzXCIsMSk7Y2FzZSBzOnJldHVybiBsKGcrXCJTZWNvbmRzXCIsMik7Y2FzZSBpOnJldHVybiBsKGcrXCJNaWxsaXNlY29uZHNcIiwzKTtkZWZhdWx0OnJldHVybiB0aGlzLmNsb25lKCl9fSxtLmVuZE9mPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXJ0T2YodCwhMSl9LG0uJHNldD1mdW5jdGlvbih0LGUpe3ZhciBuLG89Ty5wKHQpLGg9XCJzZXRcIisodGhpcy4kdT9cIlVUQ1wiOlwiXCIpLCQ9KG49e30sblthXT1oK1wiRGF0ZVwiLG5bZF09aCtcIkRhdGVcIixuW2ZdPWgrXCJNb250aFwiLG5bY109aCtcIkZ1bGxZZWFyXCIsblt1XT1oK1wiSG91cnNcIixuW3NdPWgrXCJNaW51dGVzXCIsbltpXT1oK1wiU2Vjb25kc1wiLG5bcl09aCtcIk1pbGxpc2Vjb25kc1wiLG4pW29dLGw9bz09PWE/dGhpcy4kRCsoZS10aGlzLiRXKTplO2lmKG89PT1mfHxvPT09Yyl7dmFyIHk9dGhpcy5jbG9uZSgpLnNldChkLDEpO3kuJGRbJF0obCkseS5pbml0KCksdGhpcy4kZD15LnNldChkLE1hdGgubWluKHRoaXMuJEQseS5kYXlzSW5Nb250aCgpKSkuJGR9ZWxzZSAkJiZ0aGlzLiRkWyRdKGwpO3JldHVybiB0aGlzLmluaXQoKSx0aGlzfSxtLnNldD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNsb25lKCkuJHNldCh0LGUpfSxtLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpc1tPLnAodCldKCl9LG0uYWRkPWZ1bmN0aW9uKHIsaCl7dmFyIGQsJD10aGlzO3I9TnVtYmVyKHIpO3ZhciBsPU8ucChoKSx5PWZ1bmN0aW9uKHQpe3ZhciBlPXcoJCk7cmV0dXJuIE8udyhlLmRhdGUoZS5kYXRlKCkrTWF0aC5yb3VuZCh0KnIpKSwkKX07aWYobD09PWYpcmV0dXJuIHRoaXMuc2V0KGYsdGhpcy4kTStyKTtpZihsPT09YylyZXR1cm4gdGhpcy5zZXQoYyx0aGlzLiR5K3IpO2lmKGw9PT1hKXJldHVybiB5KDEpO2lmKGw9PT1vKXJldHVybiB5KDcpO3ZhciBNPShkPXt9LGRbc109ZSxkW3VdPW4sZFtpXT10LGQpW2xdfHwxLG09dGhpcy4kZC5nZXRUaW1lKCkrcipNO3JldHVybiBPLncobSx0aGlzKX0sbS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFkZCgtMSp0LGUpfSxtLmZvcm1hdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy4kbG9jYWxlKCk7aWYoIXRoaXMuaXNWYWxpZCgpKXJldHVybiBuLmludmFsaWREYXRlfHwkO3ZhciByPXR8fFwiWVlZWS1NTS1ERFRISDptbTpzc1pcIixpPU8ueih0aGlzKSxzPXRoaXMuJEgsdT10aGlzLiRtLGE9dGhpcy4kTSxvPW4ud2Vla2RheXMsZj1uLm1vbnRocyxoPWZ1bmN0aW9uKHQsbixpLHMpe3JldHVybiB0JiYodFtuXXx8dChlLHIpKXx8aVtuXS5zdWJzdHIoMCxzKX0sYz1mdW5jdGlvbih0KXtyZXR1cm4gTy5zKHMlMTJ8fDEyLHQsXCIwXCIpfSxkPW4ubWVyaWRpZW18fGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10PDEyP1wiQU1cIjpcIlBNXCI7cmV0dXJuIG4/ci50b0xvd2VyQ2FzZSgpOnJ9LGw9e1lZOlN0cmluZyh0aGlzLiR5KS5zbGljZSgtMiksWVlZWTp0aGlzLiR5LE06YSsxLE1NOk8ucyhhKzEsMixcIjBcIiksTU1NOmgobi5tb250aHNTaG9ydCxhLGYsMyksTU1NTTpoKGYsYSksRDp0aGlzLiRELEREOk8ucyh0aGlzLiRELDIsXCIwXCIpLGQ6U3RyaW5nKHRoaXMuJFcpLGRkOmgobi53ZWVrZGF5c01pbix0aGlzLiRXLG8sMiksZGRkOmgobi53ZWVrZGF5c1Nob3J0LHRoaXMuJFcsbywzKSxkZGRkOm9bdGhpcy4kV10sSDpTdHJpbmcocyksSEg6Ty5zKHMsMixcIjBcIiksaDpjKDEpLGhoOmMoMiksYTpkKHMsdSwhMCksQTpkKHMsdSwhMSksbTpTdHJpbmcodSksbW06Ty5zKHUsMixcIjBcIiksczpTdHJpbmcodGhpcy4kcyksc3M6Ty5zKHRoaXMuJHMsMixcIjBcIiksU1NTOk8ucyh0aGlzLiRtcywzLFwiMFwiKSxaOml9O3JldHVybiByLnJlcGxhY2UoeSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8bFt0XXx8aS5yZXBsYWNlKFwiOlwiLFwiXCIpfSkpfSxtLnV0Y09mZnNldD1mdW5jdGlvbigpe3JldHVybiAxNSotTWF0aC5yb3VuZCh0aGlzLiRkLmdldFRpbWV6b25lT2Zmc2V0KCkvMTUpfSxtLmRpZmY9ZnVuY3Rpb24ocixkLCQpe3ZhciBsLHk9Ty5wKGQpLE09dyhyKSxtPShNLnV0Y09mZnNldCgpLXRoaXMudXRjT2Zmc2V0KCkpKmUsZz10aGlzLU0sRD1PLm0odGhpcyxNKTtyZXR1cm4gRD0obD17fSxsW2NdPUQvMTIsbFtmXT1ELGxbaF09RC8zLGxbb109KGctbSkvNjA0OGU1LGxbYV09KGctbSkvODY0ZTUsbFt1XT1nL24sbFtzXT1nL2UsbFtpXT1nL3QsbClbeV18fGcsJD9EOk8uYShEKX0sbS5kYXlzSW5Nb250aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuZE9mKGYpLiREfSxtLiRsb2NhbGU9ZnVuY3Rpb24oKXtyZXR1cm4gdlt0aGlzLiRMXX0sbS5sb2NhbGU9ZnVuY3Rpb24odCxlKXtpZighdClyZXR1cm4gdGhpcy4kTDt2YXIgbj10aGlzLmNsb25lKCkscj1TKHQsZSwhMCk7cmV0dXJuIHImJihuLiRMPXIpLG59LG0uY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gTy53KHRoaXMuJGQsdGhpcyl9LG0udG9EYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKX0sbS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1ZhbGlkKCk/dGhpcy50b0lTT1N0cmluZygpOm51bGx9LG0udG9JU09TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b0lTT1N0cmluZygpfSxtLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQudG9VVENTdHJpbmcoKX0sTX0oKSxiPV8ucHJvdG90eXBlO3JldHVybiB3LnByb3RvdHlwZT1iLFtbXCIkbXNcIixyXSxbXCIkc1wiLGldLFtcIiRtXCIsc10sW1wiJEhcIix1XSxbXCIkV1wiLGFdLFtcIiRNXCIsZl0sW1wiJHlcIixjXSxbXCIkRFwiLGRdXS5mb3JFYWNoKChmdW5jdGlvbih0KXtiW3RbMV1dPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLiRnKGUsdFswXSx0WzFdKX19KSksdy5leHRlbmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC4kaXx8KHQoZSxfLHcpLHQuJGk9ITApLHd9LHcubG9jYWxlPVMsdy5pc0RheWpzPXAsdy51bml4PWZ1bmN0aW9uKHQpe3JldHVybiB3KDFlMyp0KX0sdy5lbj12W0RdLHcuTHM9dix3LnA9e30sd30pKTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE11dGF0aW9uID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbnZhciBzY2hlZHVsZURyYWluO1xuXG57XG4gIGlmIChNdXRhdGlvbikge1xuICAgIHZhciBjYWxsZWQgPSAwO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbihuZXh0VGljayk7XG4gICAgdmFyIGVsZW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBlbGVtZW50LmRhdGEgPSAoY2FsbGVkID0gKytjYWxsZWQgJSAyKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCFnbG9iYWwuc2V0SW1tZWRpYXRlICYmIHR5cGVvZiBnbG9iYWwuTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGNoYW5uZWwgPSBuZXcgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKCk7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBuZXh0VGljaztcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCdkb2N1bWVudCcgaW4gZ2xvYmFsICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgIHZhciBzY3JpcHRFbCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dFRpY2soKTtcblxuICAgICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICBzY3JpcHRFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdEVsKTtcbiAgICAgICAgc2NyaXB0RWwgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2ssIDApO1xuICAgIH07XG4gIH1cbn1cblxudmFyIGRyYWluaW5nO1xudmFyIHF1ZXVlID0gW107XG4vL25hbWVkIG5leHRUaWNrIGZvciBsZXNzIGNvbmZ1c2luZyBzdGFjayB0cmFjZXNcbmZ1bmN0aW9uIG5leHRUaWNrKCkge1xuICBkcmFpbmluZyA9IHRydWU7XG4gIHZhciBpLCBvbGRRdWV1ZTtcbiAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGxlbikge1xuICAgIG9sZFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcbiAgICBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgb2xkUXVldWVbaV0oKTtcbiAgICB9XG4gICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICB9XG4gIGRyYWluaW5nID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW1tZWRpYXRlO1xuZnVuY3Rpb24gaW1tZWRpYXRlKHRhc2spIHtcbiAgaWYgKHF1ZXVlLnB1c2godGFzaykgPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgc2NoZWR1bGVEcmFpbigpO1xuICB9XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbi8vIHByaXZhdGUgcHJvcGVydHlcbnZhciBfa2V5U3RyID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuXG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGVuY29kaW5nXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzLCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgIHZhciBpID0gMCwgbGVuID0gaW5wdXQubGVuZ3RoLCByZW1haW5pbmdCeXRlcyA9IGxlbjtcblxuICAgIHZhciBpc0FycmF5ID0gdXRpbHMuZ2V0VHlwZU9mKGlucHV0KSAhPT0gXCJzdHJpbmdcIjtcbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZW1haW5pbmdCeXRlcyA9IGxlbiAtIGk7XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgY2hyMiA9IGkgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrKykgOiAwO1xuICAgICAgICAgICAgY2hyMyA9IGkgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrKykgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICAgICAgY2hyMyA9IGkgPCBsZW4gPyBpbnB1dFtpKytdIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuYzEgPSBjaHIxID4+IDI7XG4gICAgICAgIGVuYzIgPSAoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpO1xuICAgICAgICBlbmMzID0gcmVtYWluaW5nQnl0ZXMgPiAxID8gKCgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpKSA6IDY0O1xuICAgICAgICBlbmM0ID0gcmVtYWluaW5nQnl0ZXMgPiAyID8gKGNocjMgJiA2MykgOiA2NDtcblxuICAgICAgICBvdXRwdXQucHVzaChfa2V5U3RyLmNoYXJBdChlbmMxKSArIF9rZXlTdHIuY2hhckF0KGVuYzIpICsgX2tleVN0ci5jaGFyQXQoZW5jMykgKyBfa2V5U3RyLmNoYXJBdChlbmM0KSk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59O1xuXG4vLyBwdWJsaWMgbWV0aG9kIGZvciBkZWNvZGluZ1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICAgIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgIHZhciBpID0gMCwgcmVzdWx0SW5kZXggPSAwO1xuXG4gICAgdmFyIGRhdGFVcmxQcmVmaXggPSBcImRhdGE6XCI7XG5cbiAgICBpZiAoaW5wdXQuc3Vic3RyKDAsIGRhdGFVcmxQcmVmaXgubGVuZ3RoKSA9PT0gZGF0YVVybFByZWZpeCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgY29tbW9uIGVycm9yOiBwZW9wbGUgZ2l2ZSBhIGRhdGEgdXJsXG4gICAgICAgIC8vIChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1IuLi4pIHdpdGggYSB7YmFzZTY0OiB0cnVlfSBhbmRcbiAgICAgICAgLy8gd29uZGVycyB3aHkgdGhpbmdzIGRvbid0IHdvcmsuXG4gICAgICAgIC8vIFdlIGNhbiBkZXRlY3QgdGhhdCB0aGUgc3RyaW5nIGlucHV0IGxvb2tzIGxpa2UgYSBkYXRhIHVybCBidXQgd2VcbiAgICAgICAgLy8gKmNhbid0KiBiZSBzdXJlIGl0IGlzIG9uZTogcmVtb3ZpbmcgZXZlcnl0aGluZyB1cCB0byB0aGUgY29tbWEgd291bGRcbiAgICAgICAgLy8gYmUgdG9vIGRhbmdlcm91cy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgaW5wdXQsIGl0IGxvb2tzIGxpa2UgYSBkYXRhIHVybC5cIik7XG4gICAgfVxuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgXCJcIik7XG5cbiAgICB2YXIgdG90YWxMZW5ndGggPSBpbnB1dC5sZW5ndGggKiAzIC8gNDtcbiAgICBpZihpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMSkgPT09IF9rZXlTdHIuY2hhckF0KDY0KSkge1xuICAgICAgICB0b3RhbExlbmd0aC0tO1xuICAgIH1cbiAgICBpZihpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMikgPT09IF9rZXlTdHIuY2hhckF0KDY0KSkge1xuICAgICAgICB0b3RhbExlbmd0aC0tO1xuICAgIH1cbiAgICBpZiAodG90YWxMZW5ndGggJSAxICE9PSAwKSB7XG4gICAgICAgIC8vIHRvdGFsTGVuZ3RoIGlzIG5vdCBhbiBpbnRlZ2VyLCB0aGUgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGEgdmFsaWRcbiAgICAgICAgLy8gYmFzZTY0IGNvbnRlbnQuIFRoYXQgY2FuIGhhcHBlbiBpZjpcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgaXMgbm90IGEgYmFzZTY0IGNvbnRlbnRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgaXMgKmFsbW9zdCogYSBiYXNlNjQgY29udGVudCwgd2l0aCBhIGV4dHJhIGNoYXJzIGF0IHRoZVxuICAgICAgICAvLyAgIGJlZ2lubmluZyBvciBhdCB0aGUgZW5kXG4gICAgICAgIC8vIC0gdGhlIGlucHV0IHVzZXMgYSBiYXNlNjQgdmFyaWFudCAoYmFzZTY0dXJsIGZvciBleGFtcGxlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgYmFkIGNvbnRlbnQgbGVuZ3RoLlwiKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dDtcbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IG5ldyBBcnJheSh0b3RhbExlbmd0aHwwKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuXG4gICAgICAgIGVuYzEgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMyID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMyA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzQgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuXG4gICAgICAgIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xuICAgICAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgICAgIGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQ7XG5cbiAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMTtcblxuICAgICAgICBpZiAoZW5jMyAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYzQgIT09IDY0KSB7XG4gICAgICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIzO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG52YXIgRGF0YVdvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFXb3JrZXInKTtcbnZhciBEYXRhTGVuZ3RoUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmUnKTtcbnZhciBDcmMzMlByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vQ3JjMzJQcm9iZScpO1xudmFyIERhdGFMZW5ndGhQcm9iZSA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZScpO1xuXG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbXByZXNzZWQgb2JqZWN0LCB3aXRoIGV2ZXJ5dGhpbmcgbmVlZGVkIHRvIGRlY29tcHJlc3MgaXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb21wcmVzc2VkU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSBjb21wcmVzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IHVuY29tcHJlc3NlZFNpemUgdGhlIHNpemUgb2YgdGhlIGRhdGEgYWZ0ZXIgZGVjb21wcmVzc2lvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjcmMzMiB0aGUgY3JjMzIgb2YgdGhlIGRlY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXByZXNzaW9uIHRoZSB0eXBlIG9mIGNvbXByZXNzaW9uLCBzZWUgbGliL2NvbXByZXNzaW9ucy5qcy5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBjb21wcmVzc2VkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIENvbXByZXNzZWRPYmplY3QoY29tcHJlc3NlZFNpemUsIHVuY29tcHJlc3NlZFNpemUsIGNyYzMyLCBjb21wcmVzc2lvbiwgZGF0YSkge1xuICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSBjb21wcmVzc2VkU2l6ZTtcbiAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSB1bmNvbXByZXNzZWRTaXplO1xuICAgIHRoaXMuY3JjMzIgPSBjcmMzMjtcbiAgICB0aGlzLmNvbXByZXNzaW9uID0gY29tcHJlc3Npb247XG4gICAgdGhpcy5jb21wcmVzc2VkQ29udGVudCA9IGRhdGE7XG59XG5cbkNvbXByZXNzZWRPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdvcmtlciB0byBnZXQgdGhlIHVuY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29udGVudFdvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgLnBpcGUodGhpcy5jb21wcmVzc2lvbi51bmNvbXByZXNzV29ya2VyKCkpXG4gICAgICAgIC5waXBlKG5ldyBEYXRhTGVuZ3RoUHJvYmUoXCJkYXRhX2xlbmd0aFwiKSk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB3b3JrZXIub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYodGhpcy5zdHJlYW1JbmZvWydkYXRhX2xlbmd0aCddICE9PSB0aGF0LnVuY29tcHJlc3NlZFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgOiB1bmNvbXByZXNzZWQgZGF0YSBzaXplIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdvcmtlciB0byBnZXQgdGhlIGNvbXByZXNzZWQgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIGdldENvbXByZXNzZWRXb3JrZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVdvcmtlcihleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUodGhpcy5jb21wcmVzc2VkQ29udGVudCkpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzZWRTaXplXCIsIHRoaXMuY29tcHJlc3NlZFNpemUpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcInVuY29tcHJlc3NlZFNpemVcIiwgdGhpcy51bmNvbXByZXNzZWRTaXplKVxuICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCB0aGlzLmNyYzMyKVxuICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2lvblwiLCB0aGlzLmNvbXByZXNzaW9uKVxuICAgICAgICA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGFpbiB0aGUgZ2l2ZW4gd29ya2VyIHdpdGggb3RoZXIgd29ya2VycyB0byBjb21wcmVzcyB0aGUgY29udGVudCB3aXRoIHRoZVxuICogZ2l2ZW4gY29tcHJlc3Npb24uXG4gKiBAcGFyYW0ge0dlbmVyaWNXb3JrZXJ9IHVuY29tcHJlc3NlZFdvcmtlciB0aGUgd29ya2VyIHRvIHBpcGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gY29tcHJlc3NpbmcuXG4gKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgbmV3IHdvcmtlciBjb21wcmVzc2luZyB0aGUgY29udGVudC5cbiAqL1xuQ29tcHJlc3NlZE9iamVjdC5jcmVhdGVXb3JrZXJGcm9tID0gZnVuY3Rpb24gKHVuY29tcHJlc3NlZFdvcmtlciwgY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgIHJldHVybiB1bmNvbXByZXNzZWRXb3JrZXJcbiAgICAucGlwZShuZXcgQ3JjMzJQcm9iZSgpKVxuICAgIC5waXBlKG5ldyBEYXRhTGVuZ3RoUHJvYmUoXCJ1bmNvbXByZXNzZWRTaXplXCIpKVxuICAgIC5waXBlKGNvbXByZXNzaW9uLmNvbXByZXNzV29ya2VyKGNvbXByZXNzaW9uT3B0aW9ucykpXG4gICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcImNvbXByZXNzZWRTaXplXCIpKVxuICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzaW9uXCIsIGNvbXByZXNzaW9uKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcHJlc3NlZE9iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxuZXhwb3J0cy5TVE9SRSA9IHtcbiAgICBtYWdpYzogXCJcXHgwMFxceDAwXCIsXG4gICAgY29tcHJlc3NXb3JrZXIgOiBmdW5jdGlvbiAoY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY1dvcmtlcihcIlNUT1JFIGNvbXByZXNzaW9uXCIpO1xuICAgIH0sXG4gICAgdW5jb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljV29ya2VyKFwiU1RPUkUgZGVjb21wcmVzc2lvblwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5ERUZMQVRFID0gcmVxdWlyZSgnLi9mbGF0ZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgY29tZSBmcm9tIHBha28sIGZyb20gcGFrby9saWIvemxpYi9jcmMzMi5qc1xuICogcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLCBzZWUgcGFrbyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28vXG4gKi9cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgICB2YXIgYywgdGFibGUgPSBbXTtcblxuICAgIGZvcih2YXIgbiA9MDsgbiA8IDI1NjsgbisrKXtcbiAgICAgICAgYyA9IG47XG4gICAgICAgIGZvcih2YXIgayA9MDsgayA8IDg7IGsrKyl7XG4gICAgICAgICAgICBjID0gKChjJjEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZVtuXSA9IGM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuO1xuXG4gICAgY3JjID0gY3JjIF4gKC0xKTtcblxuICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gICAgfVxuXG4gICAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cbi8vIFRoYXQncyBhbGwgZm9yIHRoZSBwYWtvIGZ1bmN0aW9ucy5cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBjcmMzMiBvZiBhIHN0cmluZy5cbiAqIFRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIHRoZSBmdW5jdGlvbiBjcmMzMiwgYnV0IGZvciBzdHJpbmdzLiBVc2luZyB0aGVcbiAqIHNhbWUgZnVuY3Rpb24gZm9yIHRoZSB0d28gdXNlIGNhc2VzIGxlYWRzIHRvIGhvcnJpYmxlIHBlcmZvcm1hbmNlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjcmMgdGhlIHN0YXJ0aW5nIHZhbHVlIG9mIHRoZSBjcmMuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdXNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbiB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gcG9zIHRoZSBzdGFydGluZyBwb3NpdGlvbiBmb3IgdGhlIGNyYzMyIGNvbXB1dGF0aW9uLlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgY29tcHV0ZWQgY3JjMzIuXG4gKi9cbmZ1bmN0aW9uIGNyYzMyc3RyKGNyYywgc3RyLCBsZW4sIHBvcykge1xuICAgIHZhciB0ID0gY3JjVGFibGUsIGVuZCA9IHBvcyArIGxlbjtcblxuICAgIGNyYyA9IGNyYyBeICgtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKysgKSB7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gc3RyLmNoYXJDb2RlQXQoaSkpICYgMHhGRl07XG4gICAgfVxuXG4gICAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JjMzJ3cmFwcGVyKGlucHV0LCBjcmMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGlzQXJyYXkgPSB1dGlscy5nZXRUeXBlT2YoaW5wdXQpICE9PSBcInN0cmluZ1wiO1xuXG4gICAgaWYoaXNBcnJheSkge1xuICAgICAgICByZXR1cm4gY3JjMzIoY3JjfDAsIGlucHV0LCBpbnB1dC5sZW5ndGgsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmMzMnN0cihjcmN8MCwgaW5wdXQsIGlucHV0Lmxlbmd0aCwgMCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmV4cG9ydHMuYmFzZTY0ID0gZmFsc2U7XG5leHBvcnRzLmJpbmFyeSA9IGZhbHNlO1xuZXhwb3J0cy5kaXIgPSBmYWxzZTtcbmV4cG9ydHMuY3JlYXRlRm9sZGVycyA9IHRydWU7XG5leHBvcnRzLmRhdGUgPSBudWxsO1xuZXhwb3J0cy5jb21wcmVzc2lvbiA9IG51bGw7XG5leHBvcnRzLmNvbXByZXNzaW9uT3B0aW9ucyA9IG51bGw7XG5leHBvcnRzLmNvbW1lbnQgPSBudWxsO1xuZXhwb3J0cy51bml4UGVybWlzc2lvbnMgPSBudWxsO1xuZXhwb3J0cy5kb3NQZXJtaXNzaW9ucyA9IG51bGw7XG4iLCIvKiBnbG9iYWwgUHJvbWlzZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBsb2FkIHRoZSBnbG9iYWwgb2JqZWN0IGZpcnN0OlxuLy8gLSBpdCBzaG91bGQgYmUgYmV0dGVyIGludGVncmF0ZWQgaW4gdGhlIHN5c3RlbSAodW5oYW5kbGVkUmVqZWN0aW9uIGluIG5vZGUpXG4vLyAtIHRoZSBlbnZpcm9ubWVudCBtYXkgaGF2ZSBhIGN1c3RvbSBQcm9taXNlIGltcGxlbWVudGF0aW9uIChzZWUgem9uZS5qcylcbnZhciBFUzZQcm9taXNlID0gbnVsbDtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIEVTNlByb21pc2UgPSBQcm9taXNlO1xufSBlbHNlIHtcbiAgICBFUzZQcm9taXNlID0gcmVxdWlyZShcImxpZVwiKTtcbn1cblxuLyoqXG4gKiBMZXQgdGhlIHVzZXIgdXNlL2NoYW5nZSBzb21lIGltcGxlbWVudGF0aW9ucy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUHJvbWlzZTogRVM2UHJvbWlzZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBVU0VfVFlQRURBUlJBWSA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJiAodHlwZW9mIFVpbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBwYWtvID0gcmVxdWlyZShcInBha29cIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG5cbnZhciBBUlJBWV9UWVBFID0gVVNFX1RZUEVEQVJSQVkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcblxuZXhwb3J0cy5tYWdpYyA9IFwiXFx4MDhcXHgwMFwiO1xuXG4vKipcbiAqIENyZWF0ZSBhIHdvcmtlciB0aGF0IHVzZXMgcGFrbyB0byBpbmZsYXRlL2RlZmxhdGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gdGhlIG5hbWUgb2YgdGhlIHBha28gZnVuY3Rpb24gdG8gY2FsbCA6IGVpdGhlciBcIkRlZmxhdGVcIiBvciBcIkluZmxhdGVcIi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIChkZSljb21wcmVzc2luZy5cbiAqL1xuZnVuY3Rpb24gRmxhdGVXb3JrZXIoYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiRmxhdGVXb3JrZXIvXCIgKyBhY3Rpb24pO1xuXG4gICAgdGhpcy5fcGFrbyA9IG51bGw7XG4gICAgdGhpcy5fcGFrb0FjdGlvbiA9IGFjdGlvbjtcbiAgICB0aGlzLl9wYWtvT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gdGhlIGBtZXRhYCBvYmplY3QgZnJvbSB0aGUgbGFzdCBjaHVuayByZWNlaXZlZFxuICAgIC8vIHRoaXMgYWxsb3cgdGhpcyB3b3JrZXIgdG8gcGFzcyBhcm91bmQgbWV0YWRhdGFcbiAgICB0aGlzLm1ldGEgPSB7fTtcbn1cblxudXRpbHMuaW5oZXJpdHMoRmxhdGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMubWV0YSA9IGNodW5rLm1ldGE7XG4gICAgaWYgKHRoaXMuX3Bha28gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUGFrbygpO1xuICAgIH1cbiAgICB0aGlzLl9wYWtvLnB1c2godXRpbHMudHJhbnNmb3JtVG8oQVJSQVlfVFlQRSwgY2h1bmsuZGF0YSksIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5mbHVzaC5jYWxsKHRoaXMpO1xuICAgIGlmICh0aGlzLl9wYWtvID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBha28oKTtcbiAgICB9XG4gICAgdGhpcy5fcGFrby5wdXNoKFtdLCB0cnVlKTtcbn07XG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5jbGVhblVwXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9wYWtvID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBfcGFrbyBvYmplY3QuXG4gKiBUT0RPOiBsYXp5LWxvYWRpbmcgdGhpcyBvYmplY3QgaXNuJ3QgdGhlIGJlc3Qgc29sdXRpb24gYnV0IGl0J3MgdGhlXG4gKiBxdWlja2VzdC4gVGhlIGJlc3Qgc29sdXRpb24gaXMgdG8gbGF6eS1sb2FkIHRoZSB3b3JrZXIgbGlzdC4gU2VlIGFsc28gdGhlXG4gKiBpc3N1ZSAjNDQ2LlxuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUuX2NyZWF0ZVBha28gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGFrbyA9IG5ldyBwYWtvW3RoaXMuX3Bha29BY3Rpb25dKHtcbiAgICAgICAgcmF3OiB0cnVlLFxuICAgICAgICBsZXZlbDogdGhpcy5fcGFrb09wdGlvbnMubGV2ZWwgfHwgLTEgLy8gZGVmYXVsdCBjb21wcmVzc2lvblxuICAgIH0pO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9wYWtvLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgc2VsZi5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBkYXRhLFxuICAgICAgICAgICAgbWV0YSA6IHNlbGYubWV0YVxuICAgICAgICB9KTtcbiAgICB9O1xufTtcblxuZXhwb3J0cy5jb21wcmVzc1dvcmtlciA9IGZ1bmN0aW9uIChjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRlV29ya2VyKFwiRGVmbGF0ZVwiLCBjb21wcmVzc2lvbk9wdGlvbnMpO1xufTtcbmV4cG9ydHMudW5jb21wcmVzc1dvcmtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRlV29ya2VyKFwiSW5mbGF0ZVwiLCB7fSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCcuLi91dGY4Jyk7XG52YXIgY3JjMzIgPSByZXF1aXJlKCcuLi9jcmMzMicpO1xudmFyIHNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL3NpZ25hdHVyZScpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBpbnRlZ2VyIGludG8gYSBzdHJpbmcgaW4gaGV4YWRlY2ltYWwuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRlYyB0aGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZXMgdGhlIG51bWJlciBvZiBieXRlcyB0byBnZW5lcmF0ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSByZXN1bHQuXG4gKi9cbnZhciBkZWNUb0hleCA9IGZ1bmN0aW9uKGRlYywgYnl0ZXMpIHtcbiAgICB2YXIgaGV4ID0gXCJcIiwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykge1xuICAgICAgICBoZXggKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkZWMgJiAweGZmKTtcbiAgICAgICAgZGVjID0gZGVjID4+PiA4O1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgVU5JWCBwYXJ0IG9mIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gdW5peFBlcm1pc3Npb25zIHRoZSB1bml4IHBlcm1pc3Npb25zIG9yIG51bGwuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzRGlyIHRydWUgaWYgdGhlIGVudHJ5IGlzIGEgZGlyZWN0b3J5LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGEgMzIgYml0IGludGVnZXIuXG4gKlxuICogYWRhcHRlZCBmcm9tIGh0dHA6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xNDcwNS90aGUtemlwLWZvcm1hdHMtZXh0ZXJuYWwtZmlsZS1hdHRyaWJ1dGUgOlxuICpcbiAqIFRUVFRzc3Ryd3hyd3hyd3gwMDAwMDAwMDAwQURWU0hSXG4gKiBeXl5eX19fX19fX19fX19fX19fX19fX19fX19fX19fXyBmaWxlIHR5cGUsIHNlZSB6aXBpbmZvLmMgKFVOWF8qKVxuICogICAgIF5eXl9fX19fX19fX19fX19fX19fX19fX19fX18gc2V0dWlkLCBzZXRnaWQsIHN0aWNreVxuICogICAgICAgIF5eXl5eXl5eXl9fX19fX19fX19fX19fX18gcGVybWlzc2lvbnNcbiAqICAgICAgICAgICAgICAgICBeXl5eXl5eXl5eX19fX19fIG5vdCB1c2VkID9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eIERPUyBhdHRyaWJ1dGUgYml0cyA6IEFyY2hpdmUsIERpcmVjdG9yeSwgVm9sdW1lIGxhYmVsLCBTeXN0ZW0gZmlsZSwgSGlkZGVuLCBSZWFkIG9ubHlcbiAqL1xudmFyIGdlbmVyYXRlVW5peEV4dGVybmFsRmlsZUF0dHIgPSBmdW5jdGlvbiAodW5peFBlcm1pc3Npb25zLCBpc0Rpcikge1xuXG4gICAgdmFyIHJlc3VsdCA9IHVuaXhQZXJtaXNzaW9ucztcbiAgICBpZiAoIXVuaXhQZXJtaXNzaW9ucykge1xuICAgICAgICAvLyBJIGNhbid0IHVzZSBvY3RhbCB2YWx1ZXMgaW4gc3RyaWN0IG1vZGUsIGhlbmNlIHRoZSBoZXhhLlxuICAgICAgICAvLyAgMDQwNzc1ID0+IDB4NDFmZFxuICAgICAgICAvLyAwMTAwNjY0ID0+IDB4ODFiNFxuICAgICAgICByZXN1bHQgPSBpc0RpciA/IDB4NDFmZCA6IDB4ODFiNDtcbiAgICB9XG4gICAgcmV0dXJuIChyZXN1bHQgJiAweEZGRkYpIDw8IDE2O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgRE9TIHBhcnQgb2YgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkb3NQZXJtaXNzaW9ucyB0aGUgZG9zIHBlcm1pc3Npb25zIG9yIG51bGwuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzRGlyIHRydWUgaWYgdGhlIGVudHJ5IGlzIGEgZGlyZWN0b3J5LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGEgMzIgYml0IGludGVnZXIuXG4gKlxuICogQml0IDAgICAgIFJlYWQtT25seVxuICogQml0IDEgICAgIEhpZGRlblxuICogQml0IDIgICAgIFN5c3RlbVxuICogQml0IDMgICAgIFZvbHVtZSBMYWJlbFxuICogQml0IDQgICAgIERpcmVjdG9yeVxuICogQml0IDUgICAgIEFyY2hpdmVcbiAqL1xudmFyIGdlbmVyYXRlRG9zRXh0ZXJuYWxGaWxlQXR0ciA9IGZ1bmN0aW9uIChkb3NQZXJtaXNzaW9ucywgaXNEaXIpIHtcblxuICAgIC8vIHRoZSBkaXIgZmxhZyBpcyBhbHJlYWR5IHNldCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIHJldHVybiAoZG9zUGVybWlzc2lvbnMgfHwgMCkgICYgMHgzRjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIHZhcmlvdXMgcGFydHMgdXNlZCBpbiB0aGUgY29uc3RydWN0aW9uIG9mIHRoZSBmaW5hbCB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBoYXNoIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbXByZXNzZWQgZmlsZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtZWRDb250ZW50IGlzIHRoZSBjb250ZW50IHN0cmVhbWVkID9cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtaW5nRW5kZWQgaXMgdGhlIHN0cmVhbSBmaW5pc2hlZCA/XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHRoZSBjdXJyZW50IG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhdGZvcm0gbGV0J3MgcHJldGVuZCB3ZSBhcmUgdGhpcyBwbGF0Zm9ybSAoY2hhbmdlIHBsYXRmb3JtIGRlcGVuZGVudHMgZmllbGRzKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgZmlsZSBuYW1lIC8gY29tbWVudC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHppcCBwYXJ0cy5cbiAqL1xudmFyIGdlbmVyYXRlWmlwUGFydHMgPSBmdW5jdGlvbihzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHN0cmVhbWluZ0VuZGVkLCBvZmZzZXQsIHBsYXRmb3JtLCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIHZhciBmaWxlID0gc3RyZWFtSW5mb1snZmlsZSddLFxuICAgIGNvbXByZXNzaW9uID0gc3RyZWFtSW5mb1snY29tcHJlc3Npb24nXSxcbiAgICB1c2VDdXN0b21FbmNvZGluZyA9IGVuY29kZUZpbGVOYW1lICE9PSB1dGY4LnV0ZjhlbmNvZGUsXG4gICAgZW5jb2RlZEZpbGVOYW1lID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoZmlsZS5uYW1lKSksXG4gICAgdXRmRW5jb2RlZEZpbGVOYW1lID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdXRmOC51dGY4ZW5jb2RlKGZpbGUubmFtZSkpLFxuICAgIGNvbW1lbnQgPSBmaWxlLmNvbW1lbnQsXG4gICAgZW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShjb21tZW50KSksXG4gICAgdXRmRW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoY29tbWVudCkpLFxuICAgIHVzZVVURjhGb3JGaWxlTmFtZSA9IHV0ZkVuY29kZWRGaWxlTmFtZS5sZW5ndGggIT09IGZpbGUubmFtZS5sZW5ndGgsXG4gICAgdXNlVVRGOEZvckNvbW1lbnQgPSB1dGZFbmNvZGVkQ29tbWVudC5sZW5ndGggIT09IGNvbW1lbnQubGVuZ3RoLFxuICAgIGRvc1RpbWUsXG4gICAgZG9zRGF0ZSxcbiAgICBleHRyYUZpZWxkcyA9IFwiXCIsXG4gICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkID0gXCJcIixcbiAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQgPSBcIlwiLFxuICAgIGRpciA9IGZpbGUuZGlyLFxuICAgIGRhdGUgPSBmaWxlLmRhdGU7XG5cblxuICAgIHZhciBkYXRhSW5mbyA9IHtcbiAgICAgICAgY3JjMzIgOiAwLFxuICAgICAgICBjb21wcmVzc2VkU2l6ZSA6IDAsXG4gICAgICAgIHVuY29tcHJlc3NlZFNpemUgOiAwXG4gICAgfTtcblxuICAgIC8vIGlmIHRoZSBjb250ZW50IGlzIHN0cmVhbWVkLCB0aGUgc2l6ZXMvY3JjMzIgYXJlIG9ubHkgYXZhaWxhYmxlIEFGVEVSXG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgc3RyZWFtLlxuICAgIGlmICghc3RyZWFtZWRDb250ZW50IHx8IHN0cmVhbWluZ0VuZGVkKSB7XG4gICAgICAgIGRhdGFJbmZvLmNyYzMyID0gc3RyZWFtSW5mb1snY3JjMzInXTtcbiAgICAgICAgZGF0YUluZm8uY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvWydjb21wcmVzc2VkU2l6ZSddO1xuICAgICAgICBkYXRhSW5mby51bmNvbXByZXNzZWRTaXplID0gc3RyZWFtSW5mb1sndW5jb21wcmVzc2VkU2l6ZSddO1xuICAgIH1cblxuICAgIHZhciBiaXRmbGFnID0gMDtcbiAgICBpZiAoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIC8vIEJpdCAzOiB0aGUgc2l6ZXMvY3JjMzIgYXJlIHNldCB0byB6ZXJvIGluIHRoZSBsb2NhbCBoZWFkZXIuXG4gICAgICAgIC8vIFRoZSBjb3JyZWN0IHZhbHVlcyBhcmUgcHV0IGluIHRoZSBkYXRhIGRlc2NyaXB0b3IgaW1tZWRpYXRlbHlcbiAgICAgICAgLy8gZm9sbG93aW5nIHRoZSBjb21wcmVzc2VkIGRhdGEuXG4gICAgICAgIGJpdGZsYWcgfD0gMHgwMDA4O1xuICAgIH1cbiAgICBpZiAoIXVzZUN1c3RvbUVuY29kaW5nICYmICh1c2VVVEY4Rm9yRmlsZU5hbWUgfHwgdXNlVVRGOEZvckNvbW1lbnQpKSB7XG4gICAgICAgIC8vIEJpdCAxMTogTGFuZ3VhZ2UgZW5jb2RpbmcgZmxhZyAoRUZTKS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDA4MDA7XG4gICAgfVxuXG5cbiAgICB2YXIgZXh0RmlsZUF0dHIgPSAwO1xuICAgIHZhciB2ZXJzaW9uTWFkZUJ5ID0gMDtcbiAgICBpZiAoZGlyKSB7XG4gICAgICAgIC8vIGRvcyBvciB1bml4LCB3ZSBzZXQgdGhlIGRvcyBkaXIgZmxhZ1xuICAgICAgICBleHRGaWxlQXR0ciB8PSAweDAwMDEwO1xuICAgIH1cbiAgICBpZihwbGF0Zm9ybSA9PT0gXCJVTklYXCIpIHtcbiAgICAgICAgdmVyc2lvbk1hZGVCeSA9IDB4MDMxRTsgLy8gVU5JWCwgdmVyc2lvbiAzLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0cihmaWxlLnVuaXhQZXJtaXNzaW9ucywgZGlyKTtcbiAgICB9IGVsc2UgeyAvLyBET1Mgb3Igb3RoZXIsIGZhbGxiYWNrIHRvIERPU1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMDE0OyAvLyBET1MsIHZlcnNpb24gMi4wXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IGdlbmVyYXRlRG9zRXh0ZXJuYWxGaWxlQXR0cihmaWxlLmRvc1Blcm1pc3Npb25zLCBkaXIpO1xuICAgIH1cblxuICAgIC8vIGRhdGVcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNTIvMTMuaHRtbFxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC82NS8xNi5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY2LzE2Lmh0bWxcblxuICAgIGRvc1RpbWUgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNjtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIDw8IDU7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgfCBkYXRlLmdldFVUQ1NlY29uZHMoKSAvIDI7XG5cbiAgICBkb3NEYXRlID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpIC0gMTk4MDtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSA8PCA0O1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIHwgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDU7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCBkYXRlLmdldFVUQ0RhdGUoKTtcblxuICAgIGlmICh1c2VVVEY4Rm9yRmlsZU5hbWUpIHtcbiAgICAgICAgLy8gc2V0IHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuIHVuemlwIG5lZWRzIGF0IGxlYXN0IG9uZSBleHRyYVxuICAgICAgICAvLyBmaWVsZCB0byBjb3JyZWN0bHkgaGFuZGxlIHVuaWNvZGUgcGF0aCwgc28gdXNpbmcgdGhlIHBhdGggaXMgYXMgZ29vZFxuICAgICAgICAvLyBhcyBhbnkgb3RoZXIgaW5mb3JtYXRpb24uIFRoaXMgY291bGQgaW1wcm92ZSB0aGUgc2l0dWF0aW9uIHdpdGhcbiAgICAgICAgLy8gb3RoZXIgYXJjaGl2ZSBtYW5hZ2VycyB0b28uXG4gICAgICAgIC8vIFRoaXMgZmllbGQgaXMgdXN1YWxseSB1c2VkIHdpdGhvdXQgdGhlIHV0ZjggZmxhZywgd2l0aCBhIG5vblxuICAgICAgICAvLyB1bmljb2RlIHBhdGggaW4gdGhlIGhlYWRlciAod2lucmFyLCB3aW56aXApLiBUaGlzIGhlbHBzIChhIGJpdClcbiAgICAgICAgLy8gd2l0aCB0aGUgbWVzc3kgV2luZG93cycgZGVmYXVsdCBjb21wcmVzc2VkIGZvbGRlcnMgZmVhdHVyZSBidXRcbiAgICAgICAgLy8gYnJlYWtzIG9uIHA3emlwIHdoaWNoIGRvZXNuJ3Qgc2VlayB0aGUgdW5pY29kZSBwYXRoIGV4dHJhIGZpZWxkLlxuICAgICAgICAvLyBTbyBmb3Igbm93LCBVVEYtOCBldmVyeXdoZXJlICFcbiAgICAgICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkID1cbiAgICAgICAgICAgIC8vIFZlcnNpb25cbiAgICAgICAgICAgIGRlY1RvSGV4KDEsIDEpICtcbiAgICAgICAgICAgIC8vIE5hbWVDUkMzMlxuICAgICAgICAgICAgZGVjVG9IZXgoY3JjMzIoZW5jb2RlZEZpbGVOYW1lKSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRGaWxlTmFtZTtcblxuICAgICAgICBleHRyYUZpZWxkcyArPVxuICAgICAgICAgICAgLy8gSW5mby1aSVAgVW5pY29kZSBQYXRoIEV4dHJhIEZpZWxkXG4gICAgICAgICAgICBcIlxceDc1XFx4NzBcIiArXG4gICAgICAgICAgICAvLyBzaXplXG4gICAgICAgICAgICBkZWNUb0hleCh1bmljb2RlUGF0aEV4dHJhRmllbGQubGVuZ3RoLCAyKSArXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQ7XG4gICAgfVxuXG4gICAgaWYodXNlVVRGOEZvckNvbW1lbnQpIHtcblxuICAgICAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gQ29tbWVudENSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkQ29tbWVudCksIDQpICtcbiAgICAgICAgICAgIC8vIFVuaWNvZGVOYW1lXG4gICAgICAgICAgICB1dGZFbmNvZGVkQ29tbWVudDtcblxuICAgICAgICBleHRyYUZpZWxkcyArPVxuICAgICAgICAgICAgLy8gSW5mby1aSVAgVW5pY29kZSBQYXRoIEV4dHJhIEZpZWxkXG4gICAgICAgICAgICBcIlxceDc1XFx4NjNcIiArXG4gICAgICAgICAgICAvLyBzaXplXG4gICAgICAgICAgICBkZWNUb0hleCh1bmljb2RlQ29tbWVudEV4dHJhRmllbGQubGVuZ3RoLCAyKSArXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQ7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlciA9IFwiXCI7XG5cbiAgICAvLyB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0XG4gICAgaGVhZGVyICs9IFwiXFx4MEFcXHgwMFwiO1xuICAgIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICAgIGhlYWRlciArPSBkZWNUb0hleChiaXRmbGFnLCAyKTtcbiAgICAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgICBoZWFkZXIgKz0gY29tcHJlc3Npb24ubWFnaWM7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSB0aW1lXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc1RpbWUsIDIpO1xuICAgIC8vIGxhc3QgbW9kIGZpbGUgZGF0ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkb3NEYXRlLCAyKTtcbiAgICAvLyBjcmMtMzJcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZGF0YUluZm8uY3JjMzIsIDQpO1xuICAgIC8vIGNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSwgNCk7XG4gICAgLy8gdW5jb21wcmVzc2VkIHNpemVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZGF0YUluZm8udW5jb21wcmVzc2VkU2l6ZSwgNCk7XG4gICAgLy8gZmlsZSBuYW1lIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChlbmNvZGVkRmlsZU5hbWUubGVuZ3RoLCAyKTtcbiAgICAvLyBleHRyYSBmaWVsZCBsZW5ndGhcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZXh0cmFGaWVsZHMubGVuZ3RoLCAyKTtcblxuXG4gICAgdmFyIGZpbGVSZWNvcmQgPSBzaWduYXR1cmUuTE9DQUxfRklMRV9IRUFERVIgKyBoZWFkZXIgKyBlbmNvZGVkRmlsZU5hbWUgKyBleHRyYUZpZWxkcztcblxuICAgIHZhciBkaXJSZWNvcmQgPSBzaWduYXR1cmUuQ0VOVFJBTF9GSUxFX0hFQURFUiArXG4gICAgICAgIC8vIHZlcnNpb24gbWFkZSBieSAoMDA6IERPUylcbiAgICAgICAgZGVjVG9IZXgodmVyc2lvbk1hZGVCeSwgMikgK1xuICAgICAgICAvLyBmaWxlIGhlYWRlciAoY29tbW9uIHRvIGZpbGUgYW5kIGNlbnRyYWwgZGlyZWN0b3J5KVxuICAgICAgICBoZWFkZXIgK1xuICAgICAgICAvLyBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyBkaXNrIG51bWJlciBzdGFydFxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIGludGVybmFsIGZpbGUgYXR0cmlidXRlcyBUT0RPXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG4gICAgICAgIGRlY1RvSGV4KGV4dEZpbGVBdHRyLCA0KSArXG4gICAgICAgIC8vIHJlbGF0aXZlIG9mZnNldCBvZiBsb2NhbCBoZWFkZXJcbiAgICAgICAgZGVjVG9IZXgob2Zmc2V0LCA0KSArXG4gICAgICAgIC8vIGZpbGUgbmFtZVxuICAgICAgICBlbmNvZGVkRmlsZU5hbWUgK1xuICAgICAgICAvLyBleHRyYSBmaWVsZFxuICAgICAgICBleHRyYUZpZWxkcyArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVSZWNvcmQ6IGZpbGVSZWNvcmQsXG4gICAgICAgIGRpclJlY29yZDogZGlyUmVjb3JkXG4gICAgfTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIEVPQ0QgcmVjb3JkLlxuICogQHBhcmFtIHtOdW1iZXJ9IGVudHJpZXNDb3VudCB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHppcCBmaWxlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNlbnRyYWxEaXJMZW5ndGggdGhlIGxlbmd0aCAoaW4gYnl0ZXMpIG9mIHRoZSBjZW50cmFsIGRpci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGxvY2FsIGRpci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSB6aXAgZmlsZSBjb21tZW50IGFzIGEgYmluYXJ5IHN0cmluZy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZUZpbGVOYW1lIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgdGhlIGNvbW1lbnQuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBFT0NEIHJlY29yZC5cbiAqL1xudmFyIGdlbmVyYXRlQ2VudHJhbERpcmVjdG9yeUVuZCA9IGZ1bmN0aW9uIChlbnRyaWVzQ291bnQsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCBjb21tZW50LCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIHZhciBkaXJFbmQgPSBcIlwiO1xuICAgIHZhciBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKTtcblxuICAgIC8vIGVuZCBvZiBjZW50cmFsIGRpciBzaWduYXR1cmVcbiAgICBkaXJFbmQgPSBzaWduYXR1cmUuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoaXMgZGlza1xuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIG51bWJlciBvZiB0aGUgZGlzayB3aXRoIHRoZSBzdGFydCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3Rvcnkgb24gdGhpcyBkaXNrXG4gICAgICAgIGRlY1RvSGV4KGVudHJpZXNDb3VudCwgMikgK1xuICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHNpemUgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5ICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChjZW50cmFsRGlyTGVuZ3RoLCA0KSArXG4gICAgICAgIC8vIG9mZnNldCBvZiBzdGFydCBvZiBjZW50cmFsIGRpcmVjdG9yeSB3aXRoIHJlc3BlY3QgdG8gdGhlIHN0YXJ0aW5nIGRpc2sgbnVtYmVyXG4gICAgICAgIGRlY1RvSGV4KGxvY2FsRGlyTGVuZ3RoLCA0KSArXG4gICAgICAgIC8vIC5aSVAgZmlsZSBjb21tZW50IGxlbmd0aFxuICAgICAgICBkZWNUb0hleChlbmNvZGVkQ29tbWVudC5sZW5ndGgsIDIpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnRcbiAgICAgICAgZW5jb2RlZENvbW1lbnQ7XG5cbiAgICByZXR1cm4gZGlyRW5kO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBkYXRhIGRlc2NyaXB0b3JzIGZvciBhIGZpbGUgZW50cnkuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgaGFzaCBnZW5lcmF0ZWQgYnkgYSB3b3JrZXIsIGNvbnRhaW5pbmcgaW5mb3JtYXRpb25cbiAqIG9uIHRoZSBmaWxlIGVudHJ5LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZGF0YSBkZXNjcmlwdG9ycy5cbiAqL1xudmFyIGdlbmVyYXRlRGF0YURlc2NyaXB0b3JzID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IFwiXCI7XG4gICAgZGVzY3JpcHRvciA9IHNpZ25hdHVyZS5EQVRBX0RFU0NSSVBUT1IgK1xuICAgICAgICAvLyBjcmMtMzIgICAgICAgICAgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1snY3JjMzInXSwgNCkgK1xuICAgICAgICAvLyBjb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1snY29tcHJlc3NlZFNpemUnXSwgNCkgK1xuICAgICAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZSAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1sndW5jb21wcmVzc2VkU2l6ZSddLCA0KTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxuXG4vKipcbiAqIEEgd29ya2VyIHRvIGNvbmNhdGVuYXRlIG90aGVyIHdvcmtlcnMgdG8gY3JlYXRlIGEgemlwIGZpbGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN0cmVhbUZpbGVzIGB0cnVlYCB0byBzdHJlYW0gdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVzLFxuICogYGZhbHNlYCB0byBhY2N1bXVsYXRlIGl0LlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIGNvbW1lbnQgdG8gdXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHBsYXRmb3JtIHRoZSBwbGF0Zm9ybSB0byB1c2UsIFwiVU5JWFwiIG9yIFwiRE9TXCIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIGZpbGUgbmFtZXMgYW5kIGNvbW1lbnRzLlxuICovXG5mdW5jdGlvbiBaaXBGaWxlV29ya2VyKHN0cmVhbUZpbGVzLCBjb21tZW50LCBwbGF0Zm9ybSwgZW5jb2RlRmlsZU5hbWUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJaaXBGaWxlV29ya2VyXCIpO1xuICAgIC8vIFRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBzbyBmYXIuIFRoaXMgZG9lc24ndCBjb3VudCBhY2N1bXVsYXRlZCBjaHVua3MuXG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwO1xuICAgIC8vIFRoZSBjb21tZW50IG9mIHRoZSB6aXAgZmlsZVxuICAgIHRoaXMuemlwQ29tbWVudCA9IGNvbW1lbnQ7XG4gICAgLy8gVGhlIHBsYXRmb3JtIFwiZ2VuZXJhdGluZ1wiIHRoZSB6aXAgZmlsZS5cbiAgICB0aGlzLnppcFBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgLy8gdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBmaWxlIG5hbWVzIGFuZCBjb21tZW50cy5cbiAgICB0aGlzLmVuY29kZUZpbGVOYW1lID0gZW5jb2RlRmlsZU5hbWU7XG4gICAgLy8gU2hvdWxkIHdlIHN0cmVhbSB0aGUgY29udGVudCBvZiB0aGUgZmlsZXMgP1xuICAgIHRoaXMuc3RyZWFtRmlsZXMgPSBzdHJlYW1GaWxlcztcbiAgICAvLyBJZiBgc3RyZWFtRmlsZXNgIGlzIGZhbHNlLCB3ZSB3aWxsIG5lZWQgdG8gYWNjdW11bGF0ZSB0aGUgY29udGVudCBvZiB0aGVcbiAgICAvLyBmaWxlcyB0byBjYWxjdWxhdGUgc2l6ZXMgLyBjcmMzMiAoYW5kIHdyaXRlIHRoZW0gKmJlZm9yZSogdGhlIGNvbnRlbnQpLlxuICAgIC8vIFRoaXMgYm9vbGVhbiBpbmRpY2F0ZXMgaWYgd2UgYXJlIGFjY3VtdWxhdGluZyBjaHVua3MgKGl0IHdpbGwgY2hhbmdlIGEgbG90XG4gICAgLy8gZHVyaW5nIHRoZSBsaWZldGltZSBvZiB0aGlzIHdvcmtlcikuXG4gICAgdGhpcy5hY2N1bXVsYXRlID0gZmFsc2U7XG4gICAgLy8gVGhlIGJ1ZmZlciByZWNlaXZpbmcgY2h1bmtzIHdoZW4gYWNjdW11bGF0aW5nIGNvbnRlbnQuXG4gICAgdGhpcy5jb250ZW50QnVmZmVyID0gW107XG4gICAgLy8gVGhlIGxpc3Qgb2YgZ2VuZXJhdGVkIGRpcmVjdG9yeSByZWNvcmRzLlxuICAgIHRoaXMuZGlyUmVjb3JkcyA9IFtdO1xuICAgIC8vIFRoZSBvZmZzZXQgKGluIGJ5dGVzKSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHppcCBmaWxlIGZvciB0aGUgY3VycmVudCBzb3VyY2UuXG4gICAgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0ID0gMDtcbiAgICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyB6aXAgZmlsZS5cbiAgICB0aGlzLmVudHJpZXNDb3VudCA9IDA7XG4gICAgLy8gdGhlIG5hbWUgb2YgdGhlIGZpbGUgY3VycmVudGx5IGJlaW5nIGFkZGVkLCBudWxsIHdoZW4gaGFuZGxpbmcgdGhlIGVuZCBvZiB0aGUgemlwIGZpbGUuXG4gICAgLy8gVXNlZCBmb3IgdGhlIGVtaXR0ZWQgbWV0YWRhdGEuXG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IG51bGw7XG5cblxuXG4gICAgdGhpcy5fc291cmNlcyA9IFtdO1xufVxudXRpbHMuaW5oZXJpdHMoWmlwRmlsZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnB1c2hcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaykge1xuXG4gICAgdmFyIGN1cnJlbnRGaWxlUGVyY2VudCA9IGNodW5rLm1ldGEucGVyY2VudCB8fCAwO1xuICAgIHZhciBlbnRyaWVzQ291bnQgPSB0aGlzLmVudHJpZXNDb3VudDtcbiAgICB2YXIgcmVtYWluaW5nRmlsZXMgPSB0aGlzLl9zb3VyY2VzLmxlbmd0aDtcblxuICAgIGlmKHRoaXMuYWNjdW11bGF0ZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnRCdWZmZXIucHVzaChjaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ieXRlc1dyaXR0ZW4gKz0gY2h1bmsuZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGRhdGEgOiBjaHVuay5kYXRhLFxuICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmlsZSA6IHRoaXMuY3VycmVudEZpbGUsXG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IGVudHJpZXNDb3VudCA/IChjdXJyZW50RmlsZVBlcmNlbnQgKyAxMDAgKiAoZW50cmllc0NvdW50IC0gcmVtYWluaW5nRmlsZXMgLSAxKSkgLyBlbnRyaWVzQ291bnQgOiAxMDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIHN0YXJ0ZWQgYSBuZXcgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIG5ldyBzb3VyY2UuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLm9wZW5lZFNvdXJjZSA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0ID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IHN0cmVhbUluZm9bJ2ZpbGUnXS5uYW1lO1xuXG4gICAgdmFyIHN0cmVhbWVkQ29udGVudCA9IHRoaXMuc3RyZWFtRmlsZXMgJiYgIXN0cmVhbUluZm9bJ2ZpbGUnXS5kaXI7XG5cbiAgICAvLyBkb24ndCBzdHJlYW0gZm9sZGVycyAoYmVjYXVzZSB0aGV5IGRvbid0IGhhdmUgYW55IGNvbnRlbnQpXG4gICAgaWYoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIHZhciByZWNvcmQgPSBnZW5lcmF0ZVppcFBhcnRzKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgZmFsc2UsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogcmVjb3JkLmZpbGVSZWNvcmQsXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgd2hvbGUgZmlsZSBiZWZvcmUgcHVzaGluZyBhbnl0aGluZ1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhlIHdvcmtlciBmaW5pc2hlZCBhIHNvdXJjZSAoYW4gb3RoZXIgd29ya2VyKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBzdHJlYW1JbmZvIG9iamVjdCBmcm9tIHRoZSBmaW5pc2hlZCBzb3VyY2UuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmNsb3NlZFNvdXJjZSA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdGhpcy5hY2N1bXVsYXRlID0gZmFsc2U7XG4gICAgdmFyIHN0cmVhbWVkQ29udGVudCA9IHRoaXMuc3RyZWFtRmlsZXMgJiYgIXN0cmVhbUluZm9bJ2ZpbGUnXS5kaXI7XG4gICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCB0cnVlLCB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQsIHRoaXMuemlwUGxhdGZvcm0sIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5kaXJSZWNvcmRzLnB1c2gocmVjb3JkLmRpclJlY29yZCk7XG4gICAgaWYoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIC8vIGFmdGVyIHRoZSBzdHJlYW1lZCBmaWxlLCB3ZSBwdXQgZGF0YSBkZXNjcmlwdG9yc1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGdlbmVyYXRlRGF0YURlc2NyaXB0b3JzKHN0cmVhbUluZm8pLFxuICAgICAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlIGNvbnRlbnQgd2Fzbid0IHN0cmVhbWVkLCB3ZSBuZWVkIHRvIHB1c2ggZXZlcnl0aGluZyBub3dcbiAgICAgICAgLy8gZmlyc3QgdGhlIGZpbGUgcmVjb3JkLCB0aGVuIHRoZSBjb250ZW50XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogcmVjb3JkLmZpbGVSZWNvcmQsXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlKHRoaXMuY29udGVudEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmNvbnRlbnRCdWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBsb2NhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRpclJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiB0aGlzLmRpclJlY29yZHNbaV0sXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGNlbnRyYWxEaXJMZW5ndGggPSB0aGlzLmJ5dGVzV3JpdHRlbiAtIGxvY2FsRGlyTGVuZ3RoO1xuXG4gICAgdmFyIGRpckVuZCA9IGdlbmVyYXRlQ2VudHJhbERpcmVjdG9yeUVuZCh0aGlzLmRpclJlY29yZHMubGVuZ3RoLCBjZW50cmFsRGlyTGVuZ3RoLCBsb2NhbERpckxlbmd0aCwgdGhpcy56aXBDb21tZW50LCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcblxuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBkaXJFbmQsXG4gICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIG5leHQgc291cmNlIHRvIGJlIHJlYWQuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnByZXBhcmVOZXh0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJldmlvdXMgPSB0aGlzLl9zb3VyY2VzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuZWRTb3VyY2UodGhpcy5wcmV2aW91cy5zdHJlYW1JbmZvKTtcbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnBhdXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cy5yZXN1bWUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5yZWdpc3RlclByZXZpb3VzXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnJlZ2lzdGVyUHJldmlvdXMgPSBmdW5jdGlvbiAocHJldmlvdXMpIHtcbiAgICB0aGlzLl9zb3VyY2VzLnB1c2gocHJldmlvdXMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHByZXZpb3VzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHNlbGYucHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgICB9KTtcbiAgICBwcmV2aW91cy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmNsb3NlZFNvdXJjZShzZWxmLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgICAgICBpZihzZWxmLl9zb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5yZXN1bWVcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmIHRoaXMuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZU5leHRTb3VyY2UoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghdGhpcy5wcmV2aW91cyAmJiAhdGhpcy5fc291cmNlcy5sZW5ndGggJiYgIXRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZXJyb3JcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5fc291cmNlcztcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzb3VyY2VzW2ldLmVycm9yKGUpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vIHRoZSBgZXJyb3JgIGV4cGxvZGVkLCBub3RoaW5nIHRvIGRvXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5sb2NrXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUubG9jay5jYWxsKHRoaXMpO1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5fc291cmNlcztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzb3VyY2VzW2ldLmxvY2soKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFppcEZpbGVXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21wcmVzc2lvbnMgPSByZXF1aXJlKCcuLi9jb21wcmVzc2lvbnMnKTtcbnZhciBaaXBGaWxlV29ya2VyID0gcmVxdWlyZSgnLi9aaXBGaWxlV29ya2VyJyk7XG5cbi8qKlxuICogRmluZCB0aGUgY29tcHJlc3Npb24gdG8gdXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVDb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gZGVmaW5lZCBhdCB0aGUgZmlsZSBsZXZlbCwgaWYgYW55LlxuICogQHBhcmFtIHtTdHJpbmd9IHppcENvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBkZWZpbmVkIGF0IHRoZSBsb2FkKCkgbGV2ZWwuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjb21wcmVzc2lvbiBvYmplY3QgdG8gdXNlLlxuICovXG52YXIgZ2V0Q29tcHJlc3Npb24gPSBmdW5jdGlvbiAoZmlsZUNvbXByZXNzaW9uLCB6aXBDb21wcmVzc2lvbikge1xuXG4gICAgdmFyIGNvbXByZXNzaW9uTmFtZSA9IGZpbGVDb21wcmVzc2lvbiB8fCB6aXBDb21wcmVzc2lvbjtcbiAgICB2YXIgY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbnNbY29tcHJlc3Npb25OYW1lXTtcbiAgICBpZiAoIWNvbXByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjb21wcmVzc2lvbk5hbWUgKyBcIiBpcyBub3QgYSB2YWxpZCBjb21wcmVzc2lvbiBtZXRob2QgIVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXByZXNzaW9uO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB3b3JrZXIgdG8gZ2VuZXJhdGUgYSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7SlNaaXB9IHppcCB0aGUgSlNaaXAgaW5zdGFuY2UgYXQgdGhlIHJpZ2h0IHJvb3QgbGV2ZWwuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudCB0aGUgY29tbWVudCB0byB1c2UuXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVXb3JrZXIgPSBmdW5jdGlvbiAoemlwLCBvcHRpb25zLCBjb21tZW50KSB7XG5cbiAgICB2YXIgemlwRmlsZVdvcmtlciA9IG5ldyBaaXBGaWxlV29ya2VyKG9wdGlvbnMuc3RyZWFtRmlsZXMsIGNvbW1lbnQsIG9wdGlvbnMucGxhdGZvcm0sIG9wdGlvbnMuZW5jb2RlRmlsZU5hbWUpO1xuICAgIHZhciBlbnRyaWVzQ291bnQgPSAwO1xuICAgIHRyeSB7XG5cbiAgICAgICAgemlwLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgZW50cmllc0NvdW50Kys7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvbihmaWxlLm9wdGlvbnMuY29tcHJlc3Npb24sIG9wdGlvbnMuY29tcHJlc3Npb24pO1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzaW9uT3B0aW9ucyA9IGZpbGUub3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnMgfHwgb3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgZGlyID0gZmlsZS5kaXIsIGRhdGUgPSBmaWxlLmRhdGU7XG5cbiAgICAgICAgICAgIGZpbGUuX2NvbXByZXNzV29ya2VyKGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpXG4gICAgICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJmaWxlXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lIDogcmVsYXRpdmVQYXRoLFxuICAgICAgICAgICAgICAgIGRpciA6IGRpcixcbiAgICAgICAgICAgICAgICBkYXRlIDogZGF0ZSxcbiAgICAgICAgICAgICAgICBjb21tZW50IDogZmlsZS5jb21tZW50IHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgdW5peFBlcm1pc3Npb25zIDogZmlsZS51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgZG9zUGVybWlzc2lvbnMgOiBmaWxlLmRvc1Blcm1pc3Npb25zXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnBpcGUoemlwRmlsZVdvcmtlcik7XG4gICAgICAgIH0pO1xuICAgICAgICB6aXBGaWxlV29ya2VyLmVudHJpZXNDb3VudCA9IGVudHJpZXNDb3VudDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHppcEZpbGVXb3JrZXIuZXJyb3IoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHppcEZpbGVXb3JrZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIGEgb2YgemlwIGZpbGUgaW4ganNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBKU1ppcCgpIHtcbiAgICAvLyBpZiB0aGlzIGNvbnN0cnVjdG9yIGlzwqB1c2VkIHdpdGhvdXTCoGBuZXdgLCBpdMKgYWRkcyBgbmV3YCBiZWZvcmXCoGl0c2VsZjpcbiAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBKU1ppcCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKU1ppcCgpO1xuICAgIH1cblxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbnN0cnVjdG9yIHdpdGggcGFyYW1ldGVycyBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9XG5cbiAgICAvLyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgOlxuICAgIC8vIHtcbiAgICAvLyAgIFwiZm9sZGVyL1wiIDogey4uLn0sXG4gICAgLy8gICBcImZvbGRlci9kYXRhLnR4dFwiIDogey4uLn1cbiAgICAvLyB9XG4gICAgdGhpcy5maWxlcyA9IHt9O1xuXG4gICAgdGhpcy5jb21tZW50ID0gbnVsbDtcblxuICAgIC8vIFdoZXJlIHdlIGFyZSBpbiB0aGUgaGllcmFyY2h5XG4gICAgdGhpcy5yb290ID0gXCJcIjtcbiAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdPYmogPSBuZXcgSlNaaXAoKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbaV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IHRoaXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9O1xufVxuSlNaaXAucHJvdG90eXBlID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcbkpTWmlwLnByb3RvdHlwZS5sb2FkQXN5bmMgPSByZXF1aXJlKCcuL2xvYWQnKTtcbkpTWmlwLnN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbkpTWmlwLmRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vLyBUT0RPIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzIHZlcnNpb24sXG4vLyBhIHJlcXVpcmUoJ3BhY2thZ2UuanNvbicpLnZlcnNpb24gZG9lc24ndCB3b3JrIHdpdGggd2VicGFjaywgc2VlICMzMjdcbkpTWmlwLnZlcnNpb24gPSBcIjMuNS4wXCI7XG5cbkpTWmlwLmxvYWRBc3luYyA9IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBKU1ppcCgpLmxvYWRBc3luYyhjb250ZW50LCBvcHRpb25zKTtcbn07XG5cbkpTWmlwLmV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG5tb2R1bGUuZXhwb3J0cyA9IEpTWmlwO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIFppcEVudHJpZXMgPSByZXF1aXJlKCcuL3ppcEVudHJpZXMnKTtcbnZhciBDcmMzMlByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vQ3JjMzJQcm9iZScpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG5cbi8qKlxuICogQ2hlY2sgdGhlIENSQzMyIG9mIGFuIGVudHJ5LlxuICogQHBhcmFtIHtaaXBFbnRyeX0gemlwRW50cnkgdGhlIHppcCBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm4ge1Byb21pc2V9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRW50cnlDUkMzMih6aXBFbnRyeSkge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSB6aXBFbnRyeS5kZWNvbXByZXNzZWQuZ2V0Q29udGVudFdvcmtlcigpLnBpcGUobmV3IENyYzMyUHJvYmUoKSk7XG4gICAgICAgIHdvcmtlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAod29ya2VyLnN0cmVhbUluZm8uY3JjMzIgIT09IHppcEVudHJ5LmRlY29tcHJlc3NlZC5jcmMzMikge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogQ1JDMzIgbWlzbWF0Y2hcIikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN1bWUoKTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIHppcCA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgIGJhc2U2NDogZmFsc2UsXG4gICAgICAgIGNoZWNrQ1JDMzI6IGZhbHNlLFxuICAgICAgICBvcHRpbWl6ZWRCaW5hcnlTdHJpbmc6IGZhbHNlLFxuICAgICAgICBjcmVhdGVGb2xkZXJzOiBmYWxzZSxcbiAgICAgICAgZGVjb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGRlY29kZVxuICAgIH0pO1xuXG4gICAgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSlNaaXAgY2FuJ3QgYWNjZXB0IGEgc3RyZWFtIHdoZW4gbG9hZGluZyBhIHppcCBmaWxlLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLnByZXBhcmVDb250ZW50KFwidGhlIGxvYWRlZCB6aXAgZmlsZVwiLCBkYXRhLCB0cnVlLCBvcHRpb25zLm9wdGltaXplZEJpbmFyeVN0cmluZywgb3B0aW9ucy5iYXNlNjQpXG4gICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgemlwRW50cmllcyA9IG5ldyBaaXBFbnRyaWVzKG9wdGlvbnMpO1xuICAgICAgICB6aXBFbnRyaWVzLmxvYWQoZGF0YSk7XG4gICAgICAgIHJldHVybiB6aXBFbnRyaWVzO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gY2hlY2tDUkMzMih6aXBFbnRyaWVzKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoemlwRW50cmllcyldO1xuICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICBpZiAob3B0aW9ucy5jaGVja0NSQzMyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjaGVja0VudHJ5Q1JDMzIoZmlsZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gYWRkRmlsZXMocmVzdWx0cykge1xuICAgICAgICB2YXIgemlwRW50cmllcyA9IHJlc3VsdHMuc2hpZnQoKTtcbiAgICAgICAgdmFyIGZpbGVzID0gemlwRW50cmllcy5maWxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZmlsZXNbaV07XG4gICAgICAgICAgICB6aXAuZmlsZShpbnB1dC5maWxlTmFtZVN0ciwgaW5wdXQuZGVjb21wcmVzc2VkLCB7XG4gICAgICAgICAgICAgICAgYmluYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRlOiBpbnB1dC5kYXRlLFxuICAgICAgICAgICAgICAgIGRpcjogaW5wdXQuZGlyLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQgOiBpbnB1dC5maWxlQ29tbWVudFN0ci5sZW5ndGggPyBpbnB1dC5maWxlQ29tbWVudFN0ciA6IG51bGwsXG4gICAgICAgICAgICAgICAgdW5peFBlcm1pc3Npb25zIDogaW5wdXQudW5peFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgIGRvc1Blcm1pc3Npb25zIDogaW5wdXQuZG9zUGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgY3JlYXRlRm9sZGVyczogb3B0aW9ucy5jcmVhdGVGb2xkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoemlwRW50cmllcy56aXBDb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgemlwLmNvbW1lbnQgPSB6aXBFbnRyaWVzLnppcENvbW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gemlwO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGlzIGlzIHJ1bm5pbmcgaW4gTm9kZWpzLCB3aWxsIGJlIHVuZGVmaW5lZCBpbiBhIGJyb3dzZXIuXG4gICAgICogSW4gYSBicm93c2VyLCBicm93c2VyaWZ5IHdvbid0IGluY2x1ZGUgdGhpcyBmaWxlIGFuZCB0aGUgd2hvbGUgbW9kdWxlXG4gICAgICogd2lsbCBiZSByZXNvbHZlZCBhbiBlbXB0eSBvYmplY3QuXG4gICAgICovXG4gICAgaXNOb2RlIDogdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZWpzIEJ1ZmZlciBmcm9tIGFuIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgdGhlIGRhdGEgdG8gcGFzcyB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UuXG4gICAgICogQHJldHVybiB7QnVmZmVyfSBhIG5ldyBCdWZmZXIuXG4gICAgICovXG4gICAgbmV3QnVmZmVyRnJvbTogZnVuY3Rpb24oZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20pIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBTYWZlZ3VhcmQgZm9yIG9sZCBOb2RlLmpzIHZlcnNpb25zLiBPbiBuZXdlciB2ZXJzaW9ucyxcbiAgICAgICAgICAgICAgICAvLyBCdWZmZXIuZnJvbShudW1iZXIpIC8gQnVmZmVyKG51bWJlciwgZW5jb2RpbmcpIGFscmVhZHkgdGhyb3cuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIFxcXCJkYXRhXFxcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vZGVqcyBCdWZmZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBzaXplIHRoZSBzaXplIG9mIHRoZSBidWZmZXIuXG4gICAgICogQHJldHVybiB7QnVmZmVyfSBhIG5ldyBCdWZmZXIuXG4gICAgICovXG4gICAgYWxsb2NCdWZmZXI6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmIChCdWZmZXIuYWxsb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgICAgIGJ1Zi5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmluZCBvdXQgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBCdWZmZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0J1ZmZlciA6IGZ1bmN0aW9uKGIpe1xuICAgICAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGIpO1xuICAgIH0sXG5cbiAgICBpc1N0cmVhbSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5vbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnBhdXNlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoucmVzdW1lID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgdXNlIGEgbm9kZWpzIHN0cmVhbSBhcyBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSBlbnRyeSBmb3IgdGhpcyBzdHJlYW0uXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihmaWxlbmFtZSwgc3RyZWFtKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiTm9kZWpzIHN0cmVhbSBpbnB1dCBhZGFwdGVyIGZvciBcIiArIGZpbGVuYW1lKTtcbiAgICB0aGlzLl91cHN0cmVhbUVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYmluZFN0cmVhbShzdHJlYW0pO1xufVxuXG51dGlscy5pbmhlcml0cyhOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIHN0cmVhbSBhbmQgYmluZCB0aGUgY2FsbGJhY2tzIG9uIGl0LlxuICogRG8gdGhpcyBBU0FQIG9uIG5vZGUgMC4xMCAhIEEgbGF6eSBiaW5kaW5nIGRvZXNuJ3QgYWx3YXlzIHdvcmsuXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIHRoZSBub2RlanMgc3RyZWFtIHRvIHVzZS5cbiAqL1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5fYmluZFN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIHN0cmVhbVxuICAgIC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHNlbGYucHVzaCh7XG4gICAgICAgICAgICBkYXRhOiBjaHVuayxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZihzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlZEVycm9yID0gZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuX3Vwc3RyZWFtRW5kZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnBhdXNlLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9zdHJlYW0ucGF1c2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHRoaXMuX3Vwc3RyZWFtRW5kZWQpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGU7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG51dGlscy5pbmhlcml0cyhOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLCBSZWFkYWJsZSk7XG5cbi8qKlxuKiBBIG5vZGVqcyBzdHJlYW0gdXNpbmcgYSB3b3JrZXIgYXMgc291cmNlLlxuKiBAc2VlIHRoZSBTb3VyY2VXcmFwcGVyIGluIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbFxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtTdHJlYW1IZWxwZXJ9IGhlbHBlciB0aGUgaGVscGVyIHdyYXBwaW5nIHRoZSB3b3JrZXJcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG5vZGVqcyBzdHJlYW0gb3B0aW9uc1xuKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuKi9cbmZ1bmN0aW9uIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIoaGVscGVyLCBvcHRpb25zLCB1cGRhdGVDYikge1xuICAgIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5faGVscGVyID0gaGVscGVyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGhlbHBlci5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGRhdGEsIG1ldGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnB1c2goZGF0YSkpIHtcbiAgICAgICAgICAgIHNlbGYuX2hlbHBlci5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHVwZGF0ZUNiKSB7XG4gICAgICAgICAgICB1cGRhdGVDYihtZXRhKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSlcbiAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnB1c2gobnVsbCk7XG4gICAgfSk7XG59XG5cblxuTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9oZWxwZXIucmVzdW1lKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZSgnLi9zdHJlYW0vU3RyZWFtSGVscGVyJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIFppcE9iamVjdCA9IHJlcXVpcmUoJy4vemlwT2JqZWN0Jyk7XG52YXIgZ2VuZXJhdGUgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZVwiKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoXCIuL25vZGVqc1V0aWxzXCIpO1xudmFyIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciA9IHJlcXVpcmUoXCIuL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXJcIik7XG5cblxuLyoqXG4gKiBBZGQgYSBmaWxlIGluIHRoZSBjdXJyZW50IGZvbGRlci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbE9wdGlvbnMgdGhlIG9wdGlvbnMgb2YgdGhlIGZpbGVcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG5ldyBmaWxlLlxuICovXG52YXIgZmlsZUFkZCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG9yaWdpbmFsT3B0aW9ucykge1xuICAgIC8vIGJlIHN1cmUgc3ViIGZvbGRlcnMgZXhpc3RcbiAgICB2YXIgZGF0YVR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSksXG4gICAgICAgIHBhcmVudDtcblxuXG4gICAgLypcbiAgICAgKiBDb3JyZWN0IG9wdGlvbnMuXG4gICAgICovXG5cbiAgICB2YXIgbyA9IHV0aWxzLmV4dGVuZChvcmlnaW5hbE9wdGlvbnMgfHwge30sIGRlZmF1bHRzKTtcbiAgICBvLmRhdGUgPSBvLmRhdGUgfHwgbmV3IERhdGUoKTtcbiAgICBpZiAoby5jb21wcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICBvLmNvbXByZXNzaW9uID0gby5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygby51bml4UGVybWlzc2lvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgby51bml4UGVybWlzc2lvbnMgPSBwYXJzZUludChvLnVuaXhQZXJtaXNzaW9ucywgOCk7XG4gICAgfVxuXG4gICAgLy8gVU5YX0lGRElSICAwMDQwMDAwIHNlZSB6aXBpbmZvLmNcbiAgICBpZiAoby51bml4UGVybWlzc2lvbnMgJiYgKG8udW5peFBlcm1pc3Npb25zICYgMHg0MDAwKSkge1xuICAgICAgICBvLmRpciA9IHRydWU7XG4gICAgfVxuICAgIC8vIEJpdCA0ICAgIERpcmVjdG9yeVxuICAgIGlmIChvLmRvc1Blcm1pc3Npb25zICYmIChvLmRvc1Blcm1pc3Npb25zICYgMHgwMDEwKSkge1xuICAgICAgICBvLmRpciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG8uZGlyKSB7XG4gICAgICAgIG5hbWUgPSBmb3JjZVRyYWlsaW5nU2xhc2gobmFtZSk7XG4gICAgfVxuICAgIGlmIChvLmNyZWF0ZUZvbGRlcnMgJiYgKHBhcmVudCA9IHBhcmVudEZvbGRlcihuYW1lKSkpIHtcbiAgICAgICAgZm9sZGVyQWRkLmNhbGwodGhpcywgcGFyZW50LCB0cnVlKTtcbiAgICB9XG5cbiAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gZGF0YVR5cGUgPT09IFwic3RyaW5nXCIgJiYgby5iaW5hcnkgPT09IGZhbHNlICYmIG8uYmFzZTY0ID09PSBmYWxzZTtcbiAgICBpZiAoIW9yaWdpbmFsT3B0aW9ucyB8fCB0eXBlb2Ygb3JpZ2luYWxPcHRpb25zLmJpbmFyeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvLmJpbmFyeSA9ICFpc1VuaWNvZGVTdHJpbmc7XG4gICAgfVxuXG5cbiAgICB2YXIgaXNDb21wcmVzc2VkRW1wdHkgPSAoZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpICYmIGRhdGEudW5jb21wcmVzc2VkU2l6ZSA9PT0gMDtcblxuICAgIGlmIChpc0NvbXByZXNzZWRFbXB0eSB8fCBvLmRpciB8fCAhZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvLmJhc2U2NCA9IGZhbHNlO1xuICAgICAgICBvLmJpbmFyeSA9IHRydWU7XG4gICAgICAgIGRhdGEgPSBcIlwiO1xuICAgICAgICBvLmNvbXByZXNzaW9uID0gXCJTVE9SRVwiO1xuICAgICAgICBkYXRhVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGNvbnRlbnQgdG8gZml0LlxuICAgICAqL1xuXG4gICAgdmFyIHppcE9iamVjdENvbnRlbnQgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCB8fCBkYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gbmV3IE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihuYW1lLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gdXRpbHMucHJlcGFyZUNvbnRlbnQobmFtZSwgZGF0YSwgby5iaW5hcnksIG8ub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvLmJhc2U2NCk7XG4gICAgfVxuXG4gICAgdmFyIG9iamVjdCA9IG5ldyBaaXBPYmplY3QobmFtZSwgemlwT2JqZWN0Q29udGVudCwgbyk7XG4gICAgdGhpcy5maWxlc1tuYW1lXSA9IG9iamVjdDtcbiAgICAvKlxuICAgIFRPRE86IHdlIGNhbid0IHRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIHdlIGhhdmUgYXN5bmMgcHJvbWlzZXNcbiAgICAod2UgY2FuIGhhdmUgYSBwcm9taXNlIG9mIGEgRGF0ZSgpIGZvciBleGFtcGxlKSBidXQgcmV0dXJuaW5nIGFcbiAgICBwcm9taXNlIGlzIHVzZWxlc3MgYmVjYXVzZSBmaWxlKG5hbWUsIGRhdGEpIHJldHVybnMgdGhlIEpTWmlwXG4gICAgb2JqZWN0IGZvciBjaGFpbmluZy4gU2hvdWxkIHdlIGJyZWFrIHRoYXQgdG8gYWxsb3cgdGhlIHVzZXJcbiAgICB0byBjYXRjaCB0aGUgZXJyb3IgP1xuXG4gICAgcmV0dXJuIGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBPYmplY3RDb250ZW50KVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcbiAgICAqL1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBwYXJlbnQgZm9sZGVyIG9mIHRoZSBwYXRoLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIHVzZVxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcGFyZW50IGZvbGRlciwgb3IgXCJcIlxuICovXG52YXIgcGFyZW50Rm9sZGVyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAocGF0aC5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgdmFyIGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICByZXR1cm4gKGxhc3RTbGFzaCA+IDApID8gcGF0aC5zdWJzdHJpbmcoMCwgbGFzdFNsYXNoKSA6IFwiXCI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhdGggd2l0aCBhIHNsYXNoIGF0IHRoZSBlbmQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwYXRoIHdpdGggYSB0cmFpbGluZyBzbGFzaC5cbiAqL1xudmFyIGZvcmNlVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAvLyBDaGVjayB0aGUgbmFtZSBlbmRzIHdpdGggYSAvXG4gICAgaWYgKHBhdGguc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoICs9IFwiL1wiOyAvLyBJRSBkb2Vzbid0IGxpa2Ugc3Vic3RyKC0xKVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn07XG5cbi8qKlxuICogQWRkIGEgKHN1YikgZm9sZGVyIGluIHRoZSBjdXJyZW50IGZvbGRlci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZm9sZGVyJ3MgbmFtZVxuICogQHBhcmFtIHtib29sZWFuPX0gW2NyZWF0ZUZvbGRlcnNdIElmIHRydWUsIGF1dG9tYXRpY2FsbHkgY3JlYXRlIHN1YlxuICogIGZvbGRlcnMuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZvbGRlci5cbiAqL1xudmFyIGZvbGRlckFkZCA9IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZUZvbGRlcnMpIHtcbiAgICBjcmVhdGVGb2xkZXJzID0gKHR5cGVvZiBjcmVhdGVGb2xkZXJzICE9PSAndW5kZWZpbmVkJykgPyBjcmVhdGVGb2xkZXJzIDogZGVmYXVsdHMuY3JlYXRlRm9sZGVycztcblxuICAgIG5hbWUgPSBmb3JjZVRyYWlsaW5nU2xhc2gobmFtZSk7XG5cbiAgICAvLyBEb2VzIHRoaXMgZm9sZGVyIGFscmVhZHkgZXhpc3Q/XG4gICAgaWYgKCF0aGlzLmZpbGVzW25hbWVdKSB7XG4gICAgICAgIGZpbGVBZGQuY2FsbCh0aGlzLCBuYW1lLCBudWxsLCB7XG4gICAgICAgICAgICBkaXI6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBjcmVhdGVGb2xkZXJzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maWxlc1tuYW1lXTtcbn07XG5cbi8qKlxuKiBDcm9zcy13aW5kb3csIGNyb3NzLU5vZGUtY29udGV4dCByZWd1bGFyIGV4cHJlc3Npb24gZGV0ZWN0aW9uXG4qIEBwYXJhbSAge09iamVjdH0gIG9iamVjdCBBbnl0aGluZ1xuKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgcmVndWxhciBleHByZXNzaW9uLFxuKiBmYWxzZSBvdGhlcndpc2VcbiovXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG59XG5cbi8vIHJldHVybiB0aGUgYWN0dWFsIHByb3RvdHlwZSBvZiBKU1ppcFxudmFyIG91dCA9IHtcbiAgICAvKipcbiAgICAgKiBAc2VlIGxvYWRBc3luY1xuICAgICAqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggZW50cnkgYXQgdGhpcyBmb2xkZXIgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lLCByZWxhdGl2ZVBhdGgsIGZpbGU7XG4gICAgICAgIGZvciAoZmlsZW5hbWUgaW4gdGhpcy5maWxlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpbGVzLmhhc093blByb3BlcnR5KGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbZmlsZW5hbWVdO1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gZmlsZW5hbWUuc2xpY2UodGhpcy5yb290Lmxlbmd0aCwgZmlsZW5hbWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhdGggJiYgZmlsZW5hbWUuc2xpY2UoMCwgdGhpcy5yb290Lmxlbmd0aCkgPT09IHRoaXMucm9vdCkgeyAvLyB0aGUgZmlsZSBpcyBpbiB0aGUgY3VycmVudCByb290XG4gICAgICAgICAgICAgICAgY2IocmVsYXRpdmVQYXRoLCBmaWxlKTsgLy8gVE9ETyByZXZlcnNlIHRoZSBwYXJhbWV0ZXJzID8gbmVlZCB0byBiZSBjbGVhbiBBTkQgY29uc2lzdGVudCB3aXRoIHRoZSBmaWx0ZXIgc2VhcmNoIGZuLi4uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIG5lc3RlZCBmaWxlcy9mb2xkZXJzIHdpdGggdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWFyY2ggdGhlIHByZWRpY2F0ZSB0byB1c2UgOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG1hdGNoaW5nIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZpbHRlcjogZnVuY3Rpb24oc2VhcmNoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGVudHJ5KSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoKHJlbGF0aXZlUGF0aCwgZW50cnkpKSB7IC8vIHRoZSBmaWxlIG1hdGNoZXMgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBmaWxlIHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoIGEgZmlsZS5cbiAgICAgKiBAcGFyYW0gICB7c3RyaW5nfFJlZ0V4cH0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBhZGQgKGlmIGRhdGEgaXMgZGVmaW5lZCksXG4gICAgICogdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZmluZCAoaWYgbm8gZGF0YSkgb3IgYSByZWdleCB0byBtYXRjaCBmaWxlcy5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhICBUaGUgZmlsZSBkYXRhLCBlaXRoZXIgcmF3IG9yIGJhc2U2NCBlbmNvZGVkXG4gICAgICogQHBhcmFtICAge09iamVjdH0gbyAgICAgRmlsZSBvcHRpb25zXG4gICAgICogQHJldHVybiAge0pTWmlwfE9iamVjdHxBcnJheX0gdGhpcyBKU1ppcCBvYmplY3QgKHdoZW4gYWRkaW5nIGEgZmlsZSksXG4gICAgICogYSBmaWxlICh3aGVuIHNlYXJjaGluZyBieSBzdHJpbmcpIG9yIGFuIGFycmF5IG9mIGZpbGVzICh3aGVuIHNlYXJjaGluZyBieSByZWdleCkuXG4gICAgICovXG4gICAgZmlsZTogZnVuY3Rpb24obmFtZSwgZGF0YSwgbykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlzUmVnRXhwKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWZpbGUuZGlyICYmIHJlZ2V4cC50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gdGV4dFxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLmZpbGVzW3RoaXMucm9vdCArIG5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgIW9iai5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgOiB3ZSBoYXZlIGRhdGEgIVxuICAgICAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgICAgICBmaWxlQWRkLmNhbGwodGhpcywgbmFtZSwgZGF0YSwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGRpcmVjdG9yeSB0byB0aGUgemlwIGZpbGUsIG9yIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfFJlZ0V4cH0gYXJnIFRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgdG8gYWRkLCBvciBhIHJlZ2V4IHRvIHNlYXJjaCBmb2xkZXJzLlxuICAgICAqIEByZXR1cm4gIHtKU1ppcH0gYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBkaXJlY3RvcnkgYXMgdGhlIHJvb3QsIG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgbWF0Y2hpbmcgZm9sZGVycy5cbiAgICAgKi9cbiAgICBmb2xkZXI6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZWdFeHAoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmRpciAmJiBhcmcudGVzdChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlLCBuYW1lIGlzIGEgbmV3IGZvbGRlclxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucm9vdCArIGFyZztcbiAgICAgICAgdmFyIG5ld0ZvbGRlciA9IGZvbGRlckFkZC5jYWxsKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIC8vIEFsbG93IGNoYWluaW5nIGJ5IHJldHVybmluZyBhIG5ldyBvYmplY3Qgd2l0aCB0aGlzIGZvbGRlciBhcyB0aGUgcm9vdFxuICAgICAgICB2YXIgcmV0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXQucm9vdCA9IG5ld0ZvbGRlci5uYW1lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBmaWxlLCBvciBhIGRpcmVjdG9yeSBhbmQgYWxsIHN1Yi1maWxlcywgZnJvbSB0aGUgemlwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZGVsZXRlXG4gICAgICogQHJldHVybiB7SlNaaXB9IHRoaXMgSlNaaXAgb2JqZWN0XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLnJvb3QgKyBuYW1lO1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGZvbGRlcnNcbiAgICAgICAgICAgIGlmIChuYW1lLnNsaWNlKC0xKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiL1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZSAmJiAhZmlsZS5kaXIpIHtcbiAgICAgICAgICAgIC8vIGZpbGVcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbWF5YmUgYSBmb2xkZXIsIGRlbGV0ZSByZWN1cnNpdmVseVxuICAgICAgICAgICAgdmFyIGtpZHMgPSB0aGlzLmZpbHRlcihmdW5jdGlvbihyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5uYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoKSA9PT0gbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBraWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNba2lkc1tpXS5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUgOlxuICAgICAqIC0gY29tcHJlc3Npb24sIFwiU1RPUkVcIiBieSBkZWZhdWx0LlxuICAgICAqIC0gdHlwZSwgXCJiYXNlNjRcIiBieSBkZWZhdWx0LiBWYWx1ZXMgYXJlIDogc3RyaW5nLCBiYXNlNjQsIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBibG9iLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xVaW50OEFycmF5fEFycmF5QnVmZmVyfEJ1ZmZlcnxCbG9ifSB0aGUgemlwIGZpbGVcbiAgICAgKi9cbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzIGFuIGludGVybmFsIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUgOlxuICAgICAqIC0gY29tcHJlc3Npb24sIFwiU1RPUkVcIiBieSBkZWZhdWx0LlxuICAgICAqIC0gdHlwZSwgXCJiYXNlNjRcIiBieSBkZWZhdWx0LiBWYWx1ZXMgYXJlIDogc3RyaW5nLCBiYXNlNjQsIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBibG9iLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIHN0cmVhbWVkIHppcCBmaWxlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW06IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciB3b3JrZXIsIG9wdHMgPSB7fTtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgb3B0cyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgICAgICAgIHN0cmVhbUZpbGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgY29tcHJlc3Npb246IFwiU1RPUkVcIixcbiAgICAgICAgICAgICAgY29tcHJlc3Npb25PcHRpb25zIDogbnVsbCxcbiAgICAgICAgICAgICAgdHlwZTogXCJcIixcbiAgICAgICAgICAgICAgcGxhdGZvcm06IFwiRE9TXCIsXG4gICAgICAgICAgICAgIGNvbW1lbnQ6IG51bGwsXG4gICAgICAgICAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vemlwJyxcbiAgICAgICAgICAgICAgZW5jb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGVuY29kZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgb3B0cy50eXBlID0gb3B0cy50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgb3B0cy5jb21wcmVzc2lvbiA9IG9wdHMuY29tcHJlc3Npb24udG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIC8vIFwiYmluYXJ5c3RyaW5nXCIgaXMgcHJlZmVycmVkIGJ1dCB0aGUgaW50ZXJuYWxzIHVzZSBcInN0cmluZ1wiLlxuICAgICAgICAgIGlmKG9wdHMudHlwZSA9PT0gXCJiaW5hcnlzdHJpbmdcIikge1xuICAgICAgICAgICAgb3B0cy50eXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW9wdHMudHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQob3B0cy50eXBlKTtcblxuICAgICAgICAgIC8vIGFjY2VwdCBub2RlanMgYHByb2Nlc3MucGxhdGZvcm1gXG4gICAgICAgICAgaWYoXG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdkYXJ3aW4nIHx8XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdmcmVlYnNkJyB8fFxuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSAnbGludXgnIHx8XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdzdW5vcydcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9IFwiVU5JWFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0cy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID0gXCJET1NcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY29tbWVudCA9IG9wdHMuY29tbWVudCB8fCB0aGlzLmNvbW1lbnQgfHwgXCJcIjtcbiAgICAgICAgICB3b3JrZXIgPSBnZW5lcmF0ZS5nZW5lcmF0ZVdvcmtlcih0aGlzLCBvcHRzLCBjb21tZW50KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd29ya2VyID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgd29ya2VyLmVycm9yKGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTdHJlYW1IZWxwZXIod29ya2VyLCBvcHRzLnR5cGUgfHwgXCJzdHJpbmdcIiwgb3B0cy5taW1lVHlwZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXN5bmNocm9ub3VzbHkuXG4gICAgICogQHNlZSBnZW5lcmF0ZUludGVybmFsU3RyZWFtXG4gICAgICovXG4gICAgZ2VuZXJhdGVBc3luYzogZnVuY3Rpb24ob3B0aW9ucywgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbShvcHRpb25zKS5hY2N1bXVsYXRlKG9uVXBkYXRlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAc2VlIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZU5vZGVTdHJlYW06IGZ1bmN0aW9uKG9wdGlvbnMsIG9uVXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgICAgICAgb3B0aW9ucy50eXBlID0gXCJub2RlYnVmZmVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbShvcHRpb25zKS50b05vZGVqc1N0cmVhbShvblVwZGF0ZSk7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gb3V0O1xuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyB1c2VkIGJ5IG1vZHVsZSBidW5kbGVycyAoYnJvd3NlcmlmeS93ZWJwYWNrL2V0Yykgd2hlblxuICogaW5jbHVkaW5nIGEgc3RyZWFtIGltcGxlbWVudGF0aW9uLiBXZSB1c2UgXCJyZWFkYWJsZS1zdHJlYW1cIiB0byBnZXQgYVxuICogY29uc2lzdGVudCBiZWhhdmlvciBiZXR3ZWVuIG5vZGVqcyB2ZXJzaW9ucyBidXQgYnVuZGxlcnMgb2Z0ZW4gaGF2ZSBhIHNoaW1cbiAqIGZvciBcInN0cmVhbVwiLiBVc2luZyB0aGlzIHNoaW0gZ3JlYXRseSBpbXByb3ZlIHRoZSBjb21wYXRpYmlsaXR5IGFuZCBncmVhdGx5XG4gKiByZWR1Y2UgdGhlIGZpbmFsIHNpemUgb2YgdGhlIGJ1bmRsZSAob25seSBvbmUgc3RyZWFtIGltcGxlbWVudGF0aW9uLCBub3RcbiAqIHR3bykuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBEYXRhUmVhZGVyID0gcmVxdWlyZSgnLi9EYXRhUmVhZGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBBcnJheVJlYWRlcihkYXRhKSB7XG4gICAgRGF0YVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZGF0YVtpXSA9IGRhdGFbaV0gJiAweEZGO1xuXHR9XG59XG51dGlscy5pbmhlcml0cyhBcnJheVJlYWRlciwgRGF0YVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5ieXRlQXRcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLmJ5dGVBdCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuemVybyArIGldO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlXG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHZhciBzaWcwID0gc2lnLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIHNpZzEgPSBzaWcuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgc2lnMiA9IHNpZy5jaGFyQ29kZUF0KDIpLFxuICAgICAgICBzaWczID0gc2lnLmNoYXJDb2RlQXQoMyk7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gNDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA9PT0gc2lnMCAmJiB0aGlzLmRhdGFbaSArIDFdID09PSBzaWcxICYmIHRoaXMuZGF0YVtpICsgMl0gPT09IHNpZzIgJiYgdGhpcy5kYXRhW2kgKyAzXSA9PT0gc2lnMykge1xuICAgICAgICAgICAgcmV0dXJuIGkgLSB0aGlzLnplcm87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlXG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkQW5kQ2hlY2tTaWduYXR1cmUgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIHNpZzAgPSBzaWcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgc2lnMSA9IHNpZy5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBzaWcyID0gc2lnLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIHNpZzMgPSBzaWcuY2hhckNvZGVBdCgzKSxcbiAgICAgICAgZGF0YSA9IHRoaXMucmVhZERhdGEoNCk7XG4gICAgcmV0dXJuIHNpZzAgPT09IGRhdGFbMF0gJiYgc2lnMSA9PT0gZGF0YVsxXSAmJiBzaWcyID09PSBkYXRhWzJdICYmIHNpZzMgPT09IGRhdGFbM107XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgaWYoc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXlSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBEYXRhUmVhZGVyKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhOyAvLyB0eXBlIDogc2VlIGltcGxlbWVudGF0aW9uXG4gICAgdGhpcy5sZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLnplcm8gPSAwO1xufVxuRGF0YVJlYWRlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgb2Zmc2V0IHdpbGwgbm90IGdvIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9mZnNldCB0aGUgYWRkaXRpb25hbCBvZmZzZXQgdG8gY2hlY2suXG4gICAgICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBvZmZzZXQgaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgKi9cbiAgICBjaGVja09mZnNldDogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleCh0aGlzLmluZGV4ICsgb2Zmc2V0KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIHNwZWNpZmllZCBpbmRleCB3aWxsIG5vdCBiZSB0b28gZmFyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdJbmRleCB0aGUgaW5kZXggdG8gY2hlY2suXG4gICAgICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIGNoZWNrSW5kZXg6IGZ1bmN0aW9uKG5ld0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA8IHRoaXMuemVybyArIG5ld0luZGV4IHx8IG5ld0luZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5kIG9mIGRhdGEgcmVhY2hlZCAoZGF0YSBsZW5ndGggPSBcIiArIHRoaXMubGVuZ3RoICsgXCIsIGFza2VkIGluZGV4ID0gXCIgKyAobmV3SW5kZXgpICsgXCIpLiBDb3JydXB0ZWQgemlwID9cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0luZGV4IFRoZSBuZXcgaW5kZXguXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBuZXcgaW5kZXggaXMgb3V0IG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHNldEluZGV4OiBmdW5jdGlvbihuZXdJbmRleCkge1xuICAgICAgICB0aGlzLmNoZWNrSW5kZXgobmV3SW5kZXgpO1xuICAgICAgICB0aGlzLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTa2lwIHRoZSBuZXh0IG4gYnl0ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBza2lwLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbmV3IGluZGV4IGlzIG91dCBvZiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBza2lwOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHRoaXMuc2V0SW5kZXgodGhpcy5pbmRleCArIG4pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBieXRlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGkgdGhlIGluZGV4IHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGEgYnl0ZS5cbiAgICAgKi9cbiAgICBieXRlQXQ6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IG51bWJlciB3aXRoIGEgZ2l2ZW4gYnl0ZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBjb3JyZXNwb25kaW5nIG51bWJlci5cbiAgICAgKi9cbiAgICByZWFkSW50OiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICAgICAgZm9yIChpID0gdGhpcy5pbmRleCArIHNpemUgLSAxOyBpID49IHRoaXMuaW5kZXg7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCA4KSArIHRoaXMuYnl0ZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBzdHJpbmcgd2l0aCBhIGdpdmVuIGJ5dGUgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgY29ycmVzcG9uZGluZyBzdHJpbmcuXG4gICAgICovXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdGhpcy5yZWFkRGF0YShzaXplKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgcmF3IGRhdGEgd2l0aG91dCBjb252ZXJzaW9uLCA8c2l6ZT4gYnl0ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHJhdyBkYXRhLCBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYy5cbiAgICAgKi9cbiAgICByZWFkRGF0YTogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYSB6aXAgc2lnbmF0dXJlICg0IGJ5dGVzKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnIHRoZSBzaWduYXR1cmUgdG8gZmluZC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlLCAtMSBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgbGFzdEluZGV4T2ZTaWduYXR1cmU6IGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBzaWduYXR1cmUgKDQgYnl0ZXMpIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBjb21wYXJlIGl0IHdpdGggc2lnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWcgdGhlIGV4cGVjdGVkIHNpZ25hdHVyZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNpZ25hdHVyZSBtYXRjaGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVhZEFuZENoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbihzaWcpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IGRhdGUuXG4gICAgICogQHJldHVybiB7RGF0ZX0gdGhlIGRhdGUuXG4gICAgICovXG4gICAgcmVhZERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG9zdGltZSA9IHRoaXMucmVhZEludCg0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKFxuICAgICAgICAoKGRvc3RpbWUgPj4gMjUpICYgMHg3ZikgKyAxOTgwLCAvLyB5ZWFyXG4gICAgICAgICgoZG9zdGltZSA+PiAyMSkgJiAweDBmKSAtIDEsIC8vIG1vbnRoXG4gICAgICAgIChkb3N0aW1lID4+IDE2KSAmIDB4MWYsIC8vIGRheVxuICAgICAgICAoZG9zdGltZSA+PiAxMSkgJiAweDFmLCAvLyBob3VyXG4gICAgICAgIChkb3N0aW1lID4+IDUpICYgMHgzZiwgLy8gbWludXRlXG4gICAgICAgIChkb3N0aW1lICYgMHgxZikgPDwgMSkpOyAvLyBzZWNvbmRcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBEYXRhUmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFVpbnQ4QXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL1VpbnQ4QXJyYXlSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIE5vZGVCdWZmZXJSZWFkZXIoZGF0YSkge1xuICAgIFVpbnQ4QXJyYXlSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKE5vZGVCdWZmZXJSZWFkZXIsIFVpbnQ4QXJyYXlSZWFkZXIpO1xuXG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5Ob2RlQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gTm9kZUJ1ZmZlclJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBEYXRhUmVhZGVyID0gcmVxdWlyZSgnLi9EYXRhUmVhZGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBTdHJpbmdSZWFkZXIoZGF0YSkge1xuICAgIERhdGFSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKFN0cmluZ1JlYWRlciwgRGF0YVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5ieXRlQXRcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5ieXRlQXQgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMuemVybyArIGkpO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUubGFzdEluZGV4T2ZTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmxhc3RJbmRleE9mKHNpZykgLSB0aGlzLnplcm87XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUucmVhZEFuZENoZWNrU2lnbmF0dXJlID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnID09PSBkYXRhO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICAvLyB0aGlzIHdpbGwgd29yayBiZWNhdXNlIHRoZSBjb25zdHJ1Y3RvciBhcHBsaWVkIHRoZSBcIiYgMHhmZlwiIG1hc2suXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmdSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL0FycmF5UmVhZGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBVaW50OEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoVWludDhBcnJheVJlYWRlciwgQXJyYXlSZWFkZXIpO1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuVWludDhBcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIC8vIGluIElFMTAsIHdoZW4gdXNpbmcgc3ViYXJyYXkoaWR4LCBpZHgpLCB3ZSBnZXQgdGhlIGFycmF5IFsweDAwXSBpbnN0ZWFkIG9mIFtdLlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheVJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi4vc3VwcG9ydCcpO1xudmFyIEFycmF5UmVhZGVyID0gcmVxdWlyZSgnLi9BcnJheVJlYWRlcicpO1xudmFyIFN0cmluZ1JlYWRlciA9IHJlcXVpcmUoJy4vU3RyaW5nUmVhZGVyJyk7XG52YXIgTm9kZUJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoJy4vTm9kZUJ1ZmZlclJlYWRlcicpO1xudmFyIFVpbnQ4QXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL1VpbnQ4QXJyYXlSZWFkZXInKTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWFkZXIgYWRhcHRlZCB0byB0aGUgZGF0YS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhIHRvIHJlYWQuXG4gKiBAcmV0dXJuIHtEYXRhUmVhZGVyfSB0aGUgZGF0YSByZWFkZXIuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKTtcbiAgICB1dGlscy5jaGVja1N1cHBvcnQodHlwZSk7XG4gICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgIXN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1JlYWRlcihkYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZUJ1ZmZlclJlYWRlcihkYXRhKTtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXlSZWFkZXIodXRpbHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5XCIsIGRhdGEpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5leHBvcnRzLkxPQ0FMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAzXFx4MDRcIjtcbmV4cG9ydHMuQ0VOVFJBTF9GSUxFX0hFQURFUiA9IFwiUEtcXHgwMVxceDAyXCI7XG5leHBvcnRzLkNFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNVxceDA2XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IgPSBcIlBLXFx4MDZcXHgwN1wiO1xuZXhwb3J0cy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQgPSBcIlBLXFx4MDZcXHgwNlwiO1xuZXhwb3J0cy5EQVRBX0RFU0NSSVBUT1IgPSBcIlBLXFx4MDdcXHgwOFwiO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjb252ZXJ0IGNodW5rcyB0byBhIHNwZWNpZmllZCB0eXBlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzdFR5cGUgdGhlIGRlc3RpbmF0aW9uIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIENvbnZlcnRXb3JrZXIoZGVzdFR5cGUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDb252ZXJ0V29ya2VyIHRvIFwiICsgZGVzdFR5cGUpO1xuICAgIHRoaXMuZGVzdFR5cGUgPSBkZXN0VHlwZTtcbn1cbnV0aWxzLmluaGVyaXRzKENvbnZlcnRXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ29udmVydFdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IHV0aWxzLnRyYW5zZm9ybVRvKHRoaXMuZGVzdFR5cGUsIGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ29udmVydFdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoJy4uL2NyYzMyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNhbGN1bGF0ZSB0aGUgY3JjMzIgb2YgdGhlIGRhdGEgZmxvd2luZyB0aHJvdWdoLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENyYzMyUHJvYmUoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiQ3JjMzJQcm9iZVwiKTtcbiAgICB0aGlzLndpdGhTdHJlYW1JbmZvKFwiY3JjMzJcIiwgMCk7XG59XG51dGlscy5pbmhlcml0cyhDcmMzMlByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkNyYzMyUHJvYmUucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMuc3RyZWFtSW5mby5jcmMzMiA9IGNyYzMyKGNodW5rLmRhdGEsIHRoaXMuc3RyZWFtSW5mby5jcmMzMiB8fCAwKTtcbiAgICB0aGlzLnB1c2goY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ3JjMzJQcm9iZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGRhdGEgZmxvd2luZyB0aHJvdWdoLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWUgdGhlIG5hbWUgdXNlZCB0byBleHBvc2UgdGhlIGxlbmd0aFxuICovXG5mdW5jdGlvbiBEYXRhTGVuZ3RoUHJvYmUocHJvcE5hbWUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhTGVuZ3RoUHJvYmUgZm9yIFwiICsgcHJvcE5hbWUpO1xuICAgIHRoaXMucHJvcE5hbWUgPSBwcm9wTmFtZTtcbiAgICB0aGlzLndpdGhTdHJlYW1JbmZvKHByb3BOYW1lLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKERhdGFMZW5ndGhQcm9iZSwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5EYXRhTGVuZ3RoUHJvYmUucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmKGNodW5rKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gfHwgMDtcbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvW3RoaXMucHJvcE5hbWVdID0gbGVuZ3RoICsgY2h1bmsuZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuay5jYWxsKHRoaXMsIGNodW5rKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFMZW5ndGhQcm9iZTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcblxuLy8gdGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBjaHVua3Ncbi8vIFRPRE8gZXhwb3NlIHRoaXMgYXMgYSBwdWJsaWMgdmFyaWFibGVcbnZhciBERUZBVUxUX0JMT0NLX1NJWkUgPSAxNiAqIDEwMjQ7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCByZWFkcyBhIGNvbnRlbnQgYW5kIGVtaXRzIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQcm9taXNlfSBkYXRhUCB0aGUgcHJvbWlzZSBvZiB0aGUgZGF0YSB0byBzcGxpdFxuICovXG5mdW5jdGlvbiBEYXRhV29ya2VyKGRhdGFQKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiRGF0YVdvcmtlclwiKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kYXRhSXNSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMubWF4ID0gMDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IFwiXCI7XG5cbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICBkYXRhUC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuZGF0YUlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xuICAgICAgICBzZWxmLm1heCA9IGRhdGEgJiYgZGF0YS5sZW5ndGggfHwgMDtcbiAgICAgICAgc2VsZi50eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgICAgICBpZighc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2VsZi5fdGlja0FuZFJlcGVhdCgpO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbn1cblxudXRpbHMuaW5oZXJpdHMoRGF0YVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuY2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5jbGVhblVwLmNhbGwodGhpcyk7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RpY2tTY2hlZHVsZWQgJiYgdGhpcy5kYXRhSXNSZWFkeSkge1xuICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogVHJpZ2dlciBhIHRpY2sgYSBzY2hlZHVsZSBhbiBvdGhlciBjYWxsIHRvIHRoaXMgZnVuY3Rpb24uXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLl90aWNrQW5kUmVwZWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdGlja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdGljaygpO1xuICAgIGlmKCF0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpO1xuICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlYWQgYW5kIHB1c2ggYSBjaHVuay5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2sgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2l6ZSA9IERFRkFVTFRfQkxPQ0tfU0laRTtcbiAgICB2YXIgZGF0YSA9IG51bGwsIG5leHRJbmRleCA9IE1hdGgubWluKHRoaXMubWF4LCB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy5tYXgpIHtcbiAgICAgICAgLy8gRU9GXG4gICAgICAgIHJldHVybiB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhLnN1YnN0cmluZyh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgOiB0aGlzLm1heCA/IHRoaXMuaW5kZXggLyB0aGlzLm1heCAqIDEwMCA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhV29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgZG9lcyBub3RoaW5nIGJ1dCBwYXNzaW5nIGNodW5rcyB0byB0aGUgbmV4dCBvbmUuIFRoaXMgaXMgbGlrZVxuICogYSBub2RlanMgc3RyZWFtIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXMuIE9uIHRoZSBnb29kIHNpZGUgOlxuICogLSBpdCB3b3JrcyBvbiBJRSA2LTkgd2l0aG91dCBhbnkgaXNzdWUgLyBwb2x5ZmlsbFxuICogLSBpdCB3ZWlnaHRzIGxlc3MgdGhhbiB0aGUgZnVsbCBkZXBlbmRlbmNpZXMgYnVuZGxlZCB3aXRoIGJyb3dzZXJpZnlcbiAqIC0gaXQgZm9yd2FyZHMgZXJyb3JzIChubyBuZWVkIHRvIGRlY2xhcmUgYW4gZXJyb3IgaGFuZGxlciBFVkVSWVdIRVJFKVxuICpcbiAqIEEgY2h1bmsgaXMgYW4gb2JqZWN0IHdpdGggMiBhdHRyaWJ1dGVzIDogYG1ldGFgIGFuZCBgZGF0YWAuIFRoZSBmb3JtZXIgaXMgYW5cbiAqIG9iamVjdCBjb250YWluaW5nIGFueXRoaW5nIChgcGVyY2VudGAgZm9yIGV4YW1wbGUpLCBzZWUgZWFjaCB3b3JrZXIgZm9yIG1vcmVcbiAqIGRldGFpbHMuIFRoZSBsYXR0ZXIgaXMgdGhlIHJlYWwgZGF0YSAoU3RyaW5nLCBVaW50OEFycmF5LCBldGMpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHN0cmVhbSAobWFpbmx5IHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcylcbiAqL1xuZnVuY3Rpb24gR2VuZXJpY1dvcmtlcihuYW1lKSB7XG4gICAgLy8gdGhlIG5hbWUgb2YgdGhlIHdvcmtlclxuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJkZWZhdWx0XCI7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgYWJvdXQgdGhlIHdvcmtlcnMgY2hhaW5cbiAgICB0aGlzLnN0cmVhbUluZm8gPSB7fTtcbiAgICAvLyBhbiBlcnJvciB3aGljaCBoYXBwZW5lZCB3aGVuIHRoZSB3b3JrZXIgd2FzIHBhdXNlZFxuICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBudWxsO1xuICAgIC8vIGFuIG9iamVjdCBjb250YWluaW5nIG1ldGFkYXRhIHRvIGJlIG1lcmdlZCBieSB0aGlzIHdvcmtlciBpbnRvIHRoZSBnZW5lcmFsIG1ldGFkYXRhXG4gICAgdGhpcy5leHRyYVN0cmVhbUluZm8gPSB7fTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgcGF1c2VkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCAoYW5kIHNob3VsZCBub3QgZG8gYW55dGhpbmcpLCBmYWxzZSBvdGhlcndpc2VcbiAgICB0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgbG9ja2VkIHRvIHByZXZlbnQgZnVydGhlciBzdHJ1Y3R1cmUgdXBkYXRlcyAocGlwZSksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAvLyB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgICAnZGF0YSc6W10sXG4gICAgICAgICdlbmQnOltdLFxuICAgICAgICAnZXJyb3InOltdXG4gICAgfTtcbiAgICAvLyB0aGUgcHJldmlvdXMgd29ya2VyLCBpZiBhbnlcbiAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbn1cblxuR2VuZXJpY1dvcmtlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogUHVzaCBhIGNodW5rIHRvIHRoZSBuZXh0IHdvcmtlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwdXNoXG4gICAgICovXG4gICAgcHVzaCA6IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIGNodW5rKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlbmQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW5VcCgpO1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmQgdGhlIHN0cmVhbSB3aXRoIGFuIGVycm9yLlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGUgdGhlIGVycm9yIHdoaWNoIGNhdXNlZCB0aGUgcHJlbWF0dXJlIGVuZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBlbmRlZCB0aGUgd29ya2VyIHdpdGggYW4gZXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBlcnJvciA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSk7XG5cbiAgICAgICAgICAgIC8vIGluIHRoZSB3b3JrZXJzIGNoYWluIGV4cGxvZGVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNoYWluLFxuICAgICAgICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IHdpbGwgZ28gZG93bndhcmQgYnV0IHdlIGFsc28gbmVlZCB0byBub3RpZnlcbiAgICAgICAgICAgIC8vIHdvcmtlcnMgdXB3YXJkIHRoYXQgdGhlcmUgaGFzIGJlZW4gYW4gZXJyb3IuXG4gICAgICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYWxsYmFjayBvbiBhbiBldmVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGRhdGEsIGVuZCwgZXJyb3IpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uIChuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2xlYW4gYW55IHJlZmVyZW5jZXMgd2hlbiBhIHdvcmtlciBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgY2xlYW5VcCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvID0gdGhpcy5nZW5lcmF0ZWRFcnJvciA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50LiBUaGlzIHdpbGwgY2FsbCByZWdpc3RlcmVkIGNhbGxiYWNrIHdpdGggdGhlIHByb3ZpZGVkIGFyZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgKGRhdGEsIGVuZCwgZXJyb3IpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyB0aGUgYXJndW1lbnQgdG8gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICAgKi9cbiAgICBlbWl0IDogZnVuY3Rpb24gKG5hbWUsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW25hbWVdKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzW25hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdW2ldLmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhaW4gYSB3b3JrZXIgd2l0aCBhbiBvdGhlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gbmV4dCB0aGUgd29ya2VyIHJlY2VpdmluZyBldmVudHMgZnJvbSB0aGUgY3VycmVudCBvbmUuXG4gICAgICogQHJldHVybiB7d29ya2VyfSB0aGUgbmV4dCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHBpcGUgOiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXR1cm4gbmV4dC5yZWdpc3RlclByZXZpb3VzKHRoaXMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyBgcGlwZWAgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgICAgKiBVc2luZyBhbiBBUEkgd2l0aCBgcGlwZShuZXh0KWAgaXMgdmVyeSBlYXN5LlxuICAgICAqIEltcGxlbWVudGluZyB0aGUgQVBJIHdpdGggdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIG5leHQgb25lIHJlZ2lzdGVyaW5nXG4gICAgICogYSBzb3VyY2UgaXMgZWFzaWVyLCBzZWUgdGhlIFppcEZpbGVXb3JrZXIuXG4gICAgICogQHBhcmFtIHtXb3JrZXJ9IHByZXZpb3VzIHRoZSBwcmV2aW91cyB3b3JrZXIsIHNlbmRpbmcgZXZlbnRzIHRvIHRoaXMgb25lXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHJlZ2lzdGVyUHJldmlvdXMgOiBmdW5jdGlvbiAocHJldmlvdXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHJlYW0gJ1wiICsgdGhpcyArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hhcmluZyB0aGUgc3RyZWFtSW5mby4uLlxuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSBwcmV2aW91cy5zdHJlYW1JbmZvO1xuICAgICAgICAvLyAuLi4gYW5kIGFkZGluZyBvdXIgb3duIGJpdHNcbiAgICAgICAgdGhpcy5tZXJnZVN0cmVhbUluZm8oKTtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9ICBwcmV2aW91cztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcmV2aW91cy5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJldmlvdXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIHN0cmVhbSBzbyBpdCBkb2Vzbid0IHNlbmQgZXZlbnRzIGFueW1vcmUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcGF1c2VkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwYXVzZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcblxuICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgYSBwYXVzZWQgc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIHJlc3VtZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoIXRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGlmIHRydWUsIHRoZSB3b3JrZXIgdHJpZWQgdG8gcmVzdW1lIGJ1dCBmYWlsZWRcbiAgICAgICAgdmFyIHdpdGhFcnJvciA9IGZhbHNlO1xuICAgICAgICBpZih0aGlzLmdlbmVyYXRlZEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKHRoaXMuZ2VuZXJhdGVkRXJyb3IpO1xuICAgICAgICAgICAgd2l0aEVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICF3aXRoRXJyb3I7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGbHVzaCBhbnkgcmVtYWluaW5nIGJ5dGVzIGFzIHRoZSBzdHJlYW0gaXMgZW5kaW5nLlxuICAgICAqL1xuICAgIGZsdXNoIDogZnVuY3Rpb24gKCkge30sXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIGNodW5rLiBUaGlzIGlzIHVzdWFsbHkgdGhlIG1ldGhvZCBvdmVycmlkZGVuLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaHVuayB0aGUgY2h1bmsgdG8gcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBwcm9jZXNzQ2h1bmsgOiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEga2V5L3ZhbHVlIHRvIGJlIGFkZGVkIGluIHRoZSB3b3JrZXJzIGNoYWluIHN0cmVhbUluZm8gb25jZSBhY3RpdmF0ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSB0aGUga2V5IHRvIHVzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0aGUgYXNzb2NpYXRlZCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1dvcmtlcn0gdGhlIGN1cnJlbnQgd29ya2VyIGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICB3aXRoU3RyZWFtSW5mbyA6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tZXJnZVN0cmVhbUluZm8oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNZXJnZSB0aGlzIHdvcmtlcidzIHN0cmVhbUluZm8gaW50byB0aGUgY2hhaW4ncyBzdHJlYW1JbmZvLlxuICAgICAqL1xuICAgIG1lcmdlU3RyZWFtSW5mbyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gdGhpcy5leHRyYVN0cmVhbUluZm8pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5leHRyYVN0cmVhbUluZm8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdHJlYW1JbmZvW2tleV0gPSB0aGlzLmV4dHJhU3RyZWFtSW5mb1trZXldO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvY2sgdGhlIHN0cmVhbSB0byBwcmV2ZW50IGZ1cnRoZXIgdXBkYXRlcyBvbiB0aGUgd29ya2VycyBjaGFpbi5cbiAgICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLCBhbGwgY2FsbHMgdG8gcGlwZSB3aWxsIGZhaWwuXG4gICAgICovXG4gICAgbG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0xvY2tlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLmxvY2soKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFByZXR0eSBwcmludCB0aGUgd29ya2VycyBjaGFpbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lID0gXCJXb3JrZXIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cyArIFwiIC0+IFwiICsgbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyaWNXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgQ29udmVydFdvcmtlciA9IHJlcXVpcmUoJy4vQ29udmVydFdvcmtlcicpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuLi9iYXNlNjQnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4uL3N1cHBvcnRcIik7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi4vZXh0ZXJuYWxcIik7XG5cbnZhciBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyID0gbnVsbDtcbmlmIChzdXBwb3J0Lm5vZGVzdHJlYW0pIHtcbiAgICB0cnkge1xuICAgICAgICBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyID0gcmVxdWlyZSgnLi4vbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXInKTtcbiAgICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIGZpbmFsIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBkYXRhLiBJZiB0aGUgdXNlciB3YW50cyBhIEJsb2IgZm9yXG4gKiBleGFtcGxlLCBpdCdzIGVhc2llciB0byB3b3JrIHdpdGggYW4gVThpbnRBcnJheSBhbmQgZmluYWxseSBkbyB0aGVcbiAqIEFycmF5QnVmZmVyL0Jsb2IgY29udmVyc2lvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBuYW1lIG9mIHRoZSBmaW5hbCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xVaW50OEFycmF5fEJ1ZmZlcn0gY29udGVudCB0aGUgY29udGVudCB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBjb250ZW50LCBpZiBhcHBsaWNhYmxlLlxuICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8QnVmZmVyfEJsb2J9IHRoZSBjb250ZW50IGluIHRoZSByaWdodCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVppcE91dHB1dCh0eXBlLCBjb250ZW50LCBtaW1lVHlwZSkge1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJibG9iXCIgOlxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm5ld0Jsb2IodXRpbHMudHJhbnNmb3JtVG8oXCJhcnJheWJ1ZmZlclwiLCBjb250ZW50KSwgbWltZVR5cGUpO1xuICAgICAgICBjYXNlIFwiYmFzZTY0XCIgOlxuICAgICAgICAgICAgcmV0dXJuIGJhc2U2NC5lbmNvZGUoY29udGVudCk7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKHR5cGUsIGNvbnRlbnQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbiBhcnJheSBvZiBkYXRhIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIGRhdGEgaW4gdGhlIGdpdmVuIGFycmF5LlxuICogQHBhcmFtIHtBcnJheX0gZGF0YUFycmF5IHRoZSBhcnJheSBjb250YWluaW5nIHRoZSBkYXRhIGNodW5rcyB0byBjb25jYXRlbmF0ZVxuICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgY29uY2F0ZW5hdGVkIGRhdGFcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGFza2VkIHR5cGUgaXMgdW5zdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gY29uY2F0ICh0eXBlLCBkYXRhQXJyYXkpIHtcbiAgICB2YXIgaSwgaW5kZXggPSAwLCByZXMgPSBudWxsLCB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yKGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IGRhdGFBcnJheVtpXS5sZW5ndGg7XG4gICAgfVxuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBkYXRhQXJyYXkuam9pbihcIlwiKTtcbiAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBkYXRhQXJyYXkpO1xuICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgcmVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldChkYXRhQXJyYXlbaV0sIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBkYXRhQXJyYXlbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgY2FzZSBcIm5vZGVidWZmZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGRhdGFBcnJheSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25jYXQgOiB1bnN1cHBvcnRlZCB0eXBlICdcIiAgKyB0eXBlICsgXCInXCIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICogY29tcGxldGUgYmxvY2suXG4gKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgdG8gdXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2FsbGJhY2sgYSBjYWxsYmFjayBjYWxsZWQgb24gZWFjaCB1cGRhdGUuIENhbGxlZFxuICogd2l0aCBvbmUgYXJnIDpcbiAqIC0gdGhlIG1ldGFkYXRhIGxpbmtlZCB0byB0aGUgdXBkYXRlIHJlY2VpdmVkLlxuICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlKGhlbHBlciwgdXBkYXRlQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IGV4dGVybmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGNodW5rVHlwZSA9IGhlbHBlci5faW50ZXJuYWxUeXBlLFxuICAgICAgICAgICAgcmVzdWx0VHlwZSA9IGhlbHBlci5fb3V0cHV0VHlwZSxcbiAgICAgICAgICAgIG1pbWVUeXBlID0gaGVscGVyLl9taW1lVHlwZTtcbiAgICAgICAgaGVscGVyXG4gICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhLCBtZXRhKSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmKHVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2FsbGJhY2sobWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZW5kJywgZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2Zvcm1aaXBPdXRwdXQocmVzdWx0VHlwZSwgY29uY2F0KGNodW5rVHlwZSwgZGF0YUFycmF5KSwgbWltZVR5cGUpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFuIGhlbHBlciB0byBlYXNpbHkgdXNlIHdvcmtlcnMgb3V0c2lkZSBvZiBKU1ppcC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXb3JrZXJ9IHdvcmtlciB0aGUgd29ya2VyIHRvIHdyYXBcbiAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXRUeXBlIHRoZSB0eXBlIG9mIGRhdGEgZXhwZWN0ZWQgYnkgdGhlIHVzZVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIFN0cmVhbUhlbHBlcih3b3JrZXIsIG91dHB1dFR5cGUsIG1pbWVUeXBlKSB7XG4gICAgdmFyIGludGVybmFsVHlwZSA9IG91dHB1dFR5cGU7XG4gICAgc3dpdGNoKG91dHB1dFR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgICAgICBpbnRlcm5hbFR5cGUgPSBcInVpbnQ4YXJyYXlcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIGludGVybmFsVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgaW50ZXJuYWxseVxuICAgICAgICB0aGlzLl9pbnRlcm5hbFR5cGUgPSBpbnRlcm5hbFR5cGU7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgdG8gb3V0cHV0IHJlc3VsdHNcbiAgICAgICAgdGhpcy5fb3V0cHV0VHlwZSA9IG91dHB1dFR5cGU7XG4gICAgICAgIC8vIHRoZSBtaW1lIHR5cGVcbiAgICAgICAgdGhpcy5fbWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KGludGVybmFsVHlwZSk7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlci5waXBlKG5ldyBDb252ZXJ0V29ya2VyKGludGVybmFsVHlwZSkpO1xuICAgICAgICAvLyB0aGUgbGFzdCB3b3JrZXJzIGNhbiBiZSByZXdpcmVkIHdpdGhvdXQgaXNzdWVzIGJ1dCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHByZXZlbnQgYW55IHVwZGF0ZXMgb24gcHJldmlvdXMgd29ya2Vycy5cbiAgICAgICAgd29ya2VyLmxvY2soKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgdGhpcy5fd29ya2VyLmVycm9yKGUpO1xuICAgIH1cbn1cblxuU3RyZWFtSGVscGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICAgICAqIGNvbXBsZXRlIGJsb2NrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICAgICAqL1xuICAgIGFjY3VtdWxhdGUgOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdGUodGhpcywgdXBkYXRlQ2IpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgb24gYW4gZXZlbnQgdHJpZ2dlcmVkIG9uIGEgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnQgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgb24gOiBmdW5jdGlvbiAoZXZ0LCBmbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYoZXZ0ID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChzZWxmLCBjaHVuay5kYXRhLCBjaHVuay5tZXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmRlbGF5KGZuLCBhcmd1bWVudHMsIHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fd29ya2VyLnJlc3VtZSwgW10sIHRoaXMuX3dvcmtlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl93b3JrZXIucGF1c2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBub2RlanMgc3RyZWFtIGZvciB0aGlzIGhlbHBlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXJ9IHRoZSBub2RlanMgc3RyZWFtLlxuICAgICAqL1xuICAgIHRvTm9kZWpzU3RyZWFtIDogZnVuY3Rpb24gKHVwZGF0ZUNiKSB7XG4gICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChcIm5vZGVzdHJlYW1cIik7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRUeXBlICE9PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHN0cmVhbSBjb250YWluaW5nIGJsb2IvYXJyYXlidWZmZXIvdWludDhhcnJheS9zdHJpbmdcbiAgICAgICAgICAgIC8vIGlzIHN0cmFuZ2UgYW5kIEkgZG9uJ3Qga25vdyBpZiBpdCB3b3VsZCBiZSB1c2VmdWwuXG4gICAgICAgICAgICAvLyBJIHlvdSBmaW5kIHRoaXMgY29tbWVudCBhbmQgaGF2ZSBhIGdvb2QgdXNlY2FzZSwgcGxlYXNlIG9wZW4gYVxuICAgICAgICAgICAgLy8gYnVnIHJlcG9ydCAhXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fb3V0cHV0VHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBtZXRob2RcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIodGhpcywge1xuICAgICAgICAgICAgb2JqZWN0TW9kZSA6IHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiXG4gICAgICAgIH0sIHVwZGF0ZUNiKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtSGVscGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmJhc2U2NCA9IHRydWU7XG5leHBvcnRzLmFycmF5ID0gdHJ1ZTtcbmV4cG9ydHMuc3RyaW5nID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXlidWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnRzLm5vZGVidWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiO1xuLy8gY29udGFpbnMgdHJ1ZSBpZiBKU1ppcCBjYW4gcmVhZC9nZW5lcmF0ZSBVaW50OEFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG5leHBvcnRzLnVpbnQ4YXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xufVxuZWxzZSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB0cnkge1xuICAgICAgICBleHBvcnRzLmJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSwge1xuICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi96aXBcIlxuICAgICAgICB9KS5zaXplID09PSAwO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChidWZmZXIpO1xuICAgICAgICAgICAgZXhwb3J0cy5ibG9iID0gYnVpbGRlci5nZXRCbG9iKCdhcHBsaWNhdGlvbi96aXAnKS5zaXplID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudHJ5IHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSAhIXJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlJlYWRhYmxlO1xufSBjYXRjaChlKSB7XG4gICAgZXhwb3J0cy5ub2Rlc3RyZWFtID0gZmFsc2U7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKCcuL25vZGVqc1V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjb21lIGZyb20gcGFrbywgZnJvbSBwYWtvL2xpYi91dGlscy9zdHJpbmdzXG4gKiByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIHNlZSBwYWtvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9cbiAqL1xuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbnZhciBfdXRmOGxlbiA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaT0wOyBpPDI1NjsgaSsrKSB7XG4gIF91dGY4bGVuW2ldID0gKGkgPj0gMjUyID8gNiA6IGkgPj0gMjQ4ID8gNSA6IGkgPj0gMjQwID8gNCA6IGkgPj0gMjI0ID8gMyA6IGkgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XT1fdXRmOGxlblsyNTRdPTE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxudmFyIHN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICAgIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICAgICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcysxIDwgc3RyX2xlbikpIHtcbiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MrMSk7XG4gICAgICAgICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgICAgICAgICAgbV9wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICAgIH1cblxuICAgIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmX2xlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnVmID0gbmV3IEFycmF5KGJ1Zl9sZW4pO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnRcbiAgICBmb3IgKGk9MCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gYztcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG52YXIgdXRmOGJvcmRlciA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7XG4gICAgdmFyIHBvcztcblxuICAgIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICAgIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAgIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICAgIHBvcyA9IG1heC0xO1xuICAgIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gICAgLy8gRnVja3VwIC0gdmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAgIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICAgIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAgIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyB2dWZmZXIgaXMgdG9vIHNtYWxsLFxuICAgIC8vIHJldHVybiBtYXggdG9vLlxuICAgIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbnZhciBidWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHZhciBzdHIsIGksIG91dCwgYywgY19sZW47XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG5cbiAgICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gICAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gICAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuKjIpO1xuXG4gICAgZm9yIChvdXQ9MCwgaT0wOyBpPGxlbjspIHtcbiAgICAgICAgYyA9IGJ1ZltpKytdO1xuICAgICAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgICAgIGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgICAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbi0xOyBjb250aW51ZTsgfVxuXG4gICAgICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgICAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICAgICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICAgICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgICAgICAgIGNfbGVuLS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNocmlua0J1Zih1dGYxNmJ1Ziwgb3V0KVxuICAgIGlmICh1dGYxNmJ1Zi5sZW5ndGggIT09IG91dCkge1xuICAgICAgICBpZih1dGYxNmJ1Zi5zdWJhcnJheSkge1xuICAgICAgICAgICAgdXRmMTZidWYgPSB1dGYxNmJ1Zi5zdWJhcnJheSgwLCBvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRmMTZidWYubGVuZ3RoID0gb3V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRmMTZidWYpO1xuICAgIHJldHVybiB1dGlscy5hcHBseUZyb21DaGFyQ29kZSh1dGYxNmJ1Zik7XG59O1xuXG5cbi8vIFRoYXQncyBhbGwgZm9yIHRoZSBwYWtvIGZ1bmN0aW9ucy5cblxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGphdmFzY3JpcHQgc3RyaW5nIGludG8gYW4gYXJyYXkgKHR5cGVkIGlmIHBvc3NpYmxlKSBvZiBieXRlcyxcbiAqIFVURi04IGVuY29kZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlXG4gKiBAcmV0dXJuIHtBcnJheXxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIFVURi04IGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnRzLnV0ZjhlbmNvZGUgPSBmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cikge1xuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20oc3RyLCBcInV0Zi04XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmcyYnVmKHN0cik7XG59O1xuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgYnl0ZXMgYXJyYXkgKG9yIGEgcmVwcmVzZW50YXRpb24pIHJlcHJlc2VudGluZyBhbiBVVEYtOCBlbmNvZGVkXG4gKiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgc3RyaW5nLlxuICogQHBhcmFtIHtBcnJheXxVaW50OEFycmF5fEJ1ZmZlcn0gYnVmIHRoZSBkYXRhIGRlIGRlY29kZVxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGRlY29kZSA9IGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnVmKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8oXCJub2RlYnVmZmVyXCIsIGJ1ZikudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbiAgICB9XG5cbiAgICBidWYgPSB1dGlscy50cmFuc2Zvcm1UbyhzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIiwgYnVmKTtcblxuICAgIHJldHVybiBidWYyc3RyaW5nKGJ1Zik7XG59O1xuXG4vKipcbiAqIEEgd29ya2VyIHRvIGRlY29kZSB1dGY4IGVuY29kZWQgYmluYXJ5IGNodW5rcyBpbnRvIHN0cmluZyBjaHVua3MuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRmOERlY29kZVdvcmtlcigpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJ1dGYtOCBkZWNvZGVcIik7XG4gICAgLy8gdGhlIGxhc3QgYnl0ZXMgaWYgYSBjaHVuayBkaWRuJ3QgZW5kIHdpdGggYSBjb21wbGV0ZSBjb2RlcG9pbnQuXG4gICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG59XG51dGlscy5pbmhlcml0cyhVdGY4RGVjb2RlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cblV0ZjhEZWNvZGVXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuXG4gICAgdmFyIGRhdGEgPSB1dGlscy50cmFuc2Zvcm1UbyhzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIiwgY2h1bmsuZGF0YSk7XG5cbiAgICAvLyAxc3Qgc3RlcCwgcmUtdXNlIHdoYXQncyBsZWZ0IG9mIHRoZSBwcmV2aW91cyBjaHVua1xuICAgIGlmICh0aGlzLmxlZnRPdmVyICYmIHRoaXMubGVmdE92ZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocHJldmlvdXNEYXRhLmxlbmd0aCArIHRoaXMubGVmdE92ZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGRhdGEuc2V0KHRoaXMubGVmdE92ZXIsIDApO1xuICAgICAgICAgICAgZGF0YS5zZXQocHJldmlvdXNEYXRhLCB0aGlzLmxlZnRPdmVyLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5sZWZ0T3Zlci5jb25jYXQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG5leHRCb3VuZGFyeSA9IHV0Zjhib3JkZXIoZGF0YSk7XG4gICAgdmFyIHVzYWJsZURhdGEgPSBkYXRhO1xuICAgIGlmIChuZXh0Qm91bmRhcnkgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgICAgIHVzYWJsZURhdGEgPSBkYXRhLnN1YmFycmF5KDAsIG5leHRCb3VuZGFyeSk7XG4gICAgICAgICAgICB0aGlzLmxlZnRPdmVyID0gZGF0YS5zdWJhcnJheShuZXh0Qm91bmRhcnksIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVzYWJsZURhdGEgPSBkYXRhLnNsaWNlKDAsIG5leHRCb3VuZGFyeSk7XG4gICAgICAgICAgICB0aGlzLmxlZnRPdmVyID0gZGF0YS5zbGljZShuZXh0Qm91bmRhcnksIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhkZWNvZGUodXNhYmxlRGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5VdGY4RGVjb2RlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZih0aGlzLmxlZnRPdmVyICYmIHRoaXMubGVmdE92ZXIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZGVjb2RlKHRoaXMubGVmdE92ZXIpLFxuICAgICAgICAgICAgbWV0YSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbiAgICB9XG59O1xuZXhwb3J0cy5VdGY4RGVjb2RlV29ya2VyID0gVXRmOERlY29kZVdvcmtlcjtcblxuLyoqXG4gKiBBIHdvcmtlciB0byBlbmRjb2RlIHN0cmluZyBjaHVua3MgaW50byB1dGY4IGVuY29kZWQgYmluYXJ5IGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGY4RW5jb2RlV29ya2VyKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcInV0Zi04IGVuY29kZVwiKTtcbn1cbnV0aWxzLmluaGVyaXRzKFV0ZjhFbmNvZGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuVXRmOEVuY29kZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGVuY29kZShjaHVuay5kYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5leHBvcnRzLlV0ZjhFbmNvZGVXb3JrZXIgPSBVdGY4RW5jb2RlV29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKCcuL25vZGVqc1V0aWxzJyk7XG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnc2V0LWltbWVkaWF0ZS1zaGltJyk7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcblxuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgdGhhdCBwYXNzIGFzIGEgXCJiaW5hcnkgc3RyaW5nXCI6IGl0IHNob3VsZCByZXByZXNlbnQgYSBieXRlXG4gKiBhcnJheSBidXQgbWF5IGhhdmUgPiAyNTUgY2hhciBjb2Rlcy4gQmUgc3VyZSB0byB0YWtlIG9ubHkgdGhlIGZpcnN0IGJ5dGVcbiAqIGFuZCByZXR1cm5zIHRoZSBieXRlIGFycmF5LlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl9IHRoZSBzdHJpbmcgaW4gYSBiaW5hcnkgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBzdHJpbmcyYmluYXJ5KHN0cikge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBuZXcgQXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIHJlc3VsdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGJsb2Igd2l0aCB0aGUgZ2l2ZW4gY29udGVudCBhbmQgdGhlIGdpdmVuIHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcn0gcGFydCB0aGUgY29udGVudCB0byBwdXQgaW4gdGhlIGJsb2IuIERPIE5PVCB1c2VcbiAqIGFuIFVpbnQ4QXJyYXkgYmVjYXVzZSB0aGUgc3RvY2sgYnJvd3NlciBvZiBhbmRyb2lkIDQgd29uJ3QgYWNjZXB0IGl0IChpdFxuICogd2lsbCBiZSBzaWxlbnRseSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcsIFwiW29iamVjdCBVaW50OEFycmF5XVwiKS5cbiAqXG4gKiBVc2Ugb25seSBPTkUgcGFydCB0byBidWlsZCB0aGUgYmxvYiB0byBhdm9pZCBhIG1lbW9yeSBsZWFrIGluIElFMTEgLyBFZGdlOlxuICogd2hlbiBhIGxhcmdlIGFtb3VudCBvZiBBcnJheSBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgQmxvYiwgdGhlIGFtb3VudCBvZlxuICogbWVtb3J5IGNvbnN1bWVkIGlzIG5lYXJseSAxMDAgdGltZXMgdGhlIG9yaWdpbmFsIGRhdGEgYW1vdW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGJsb2IuXG4gKiBAcmV0dXJuIHtCbG9ifSB0aGUgY3JlYXRlZCBibG9iLlxuICovXG5leHBvcnRzLm5ld0Jsb2IgPSBmdW5jdGlvbihwYXJ0LCB0eXBlKSB7XG4gICAgZXhwb3J0cy5jaGVja1N1cHBvcnQoXCJibG9iXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQmxvYiBjb25zdHJ1Y3RvclxuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW3BhcnRdLCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkLCBicm93c2VyIG9ubHksIG9sZCB3YXlcbiAgICAgICAgICAgIHZhciBCdWlsZGVyID0gc2VsZi5CbG9iQnVpbGRlciB8fCBzZWxmLldlYktpdEJsb2JCdWlsZGVyIHx8IHNlbGYuTW96QmxvYkJ1aWxkZXIgfHwgc2VsZi5NU0Jsb2JCdWlsZGVyO1xuICAgICAgICAgICAgdmFyIGJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICAgICAgICAgICAgYnVpbGRlci5hcHBlbmQocGFydCk7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlci5nZXRCbG9iKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgIC8vIHdlbGwsIGZ1Y2sgPyFcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IGNhbid0IGNvbnN0cnVjdCB0aGUgQmxvYi5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cblxufTtcbi8qKlxuICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IHRoZSBpbnB1dC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHNhbWUgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0O1xufVxuXG4vKipcbiAqIEZpbGwgaW4gYW4gYXJyYXkgd2l0aCBhIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB1c2UuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gZmlsbCBpbiAod2lsbCBiZSBtdXRhdGVkKS5cbiAqIEByZXR1cm4ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgdXBkYXRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheUxpa2Uoc3RyLCBhcnJheSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGFycmF5W2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQW4gaGVscGVyIGZvciB0aGUgZnVuY3Rpb24gYXJyYXlMaWtlVG9TdHJpbmcuXG4gKiBUaGlzIGNvbnRhaW5zIHN0YXRpYyBpbmZvcm1hdGlvbiBhbmQgZnVuY3Rpb25zIHRoYXRcbiAqIGNhbiBiZSBvcHRpbWl6ZWQgYnkgdGhlIGJyb3dzZXIgSklUIGNvbXBpbGVyLlxuICovXG52YXIgYXJyYXlUb1N0cmluZ0hlbHBlciA9IHtcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgaW50IGludG8gYSBzdHJpbmcsIGNodW5rIGJ5IGNodW5rLlxuICAgICAqIFNlZSB0aGUgcGVyZm9ybWFuY2VzIG5vdGVzIG9uIGFycmF5TGlrZVRvU3RyaW5nLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIGFycmF5LlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gY2h1bmsgdGhlIGNodW5rIHNpemUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBjaHVuayBpcyB0b28gYmlnIGZvciB0aGUgc3RhY2suXG4gICAgICovXG4gICAgc3RyaW5naWZ5QnlDaHVuazogZnVuY3Rpb24oYXJyYXksIHR5cGUsIGNodW5rKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgayA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgLy8gc2hvcnRjdXRcbiAgICAgICAgaWYgKGxlbiA8PSBjaHVuaykge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhcnJheVwiIHx8IHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheS5zbGljZShrLCBNYXRoLm1pbihrICsgY2h1bmssIGxlbikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5LnN1YmFycmF5KGssIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsgKz0gY2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2FsbCBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgICAqIFRoaXMgaXMgdGhlIG5haXZlIGltcGxlbWVudGF0aW9uLCB3aGljaCBnZW5lcmF0ZSBBIExPVCBvZiBpbnRlcm1lZGlhdGUgc3RyaW5nLlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgd2hlbiBldmVyeXRoaW5nIGVsc2UgZmFpbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlCeUNoYXI6IGZ1bmN0aW9uKGFycmF5KXtcbiAgICAgICAgdmFyIHJlc3VsdFN0ciA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRTdHI7XG4gICAgfSxcbiAgICBhcHBseUNhbkJlVXNlZCA6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgaWYgdGhlIGJyb3dzZXIgYWNjZXB0cyB0byB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZSBvbiBVaW50OEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB1aW50OGFycmF5IDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQudWludDhhcnJheSAmJiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKS5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBpZiB0aGUgYnJvd3NlciBhY2NlcHRzIHRvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIG5vZGVqcyBCdWZmZXIuXG4gICAgICAgICAqL1xuICAgICAgICBub2RlYnVmZmVyIDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQubm9kZWJ1ZmZlciAmJiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5vZGVqc1V0aWxzLmFsbG9jQnVmZmVyKDEpKS5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpXG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXktbGlrZSBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZyhhcnJheSkge1xuICAgIC8vIFBlcmZvcm1hbmNlcyBub3RlcyA6XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5KSBpcyB0aGUgZmFzdGVzdCwgc2VlXG4gICAgLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbnZlcnRpbmctYS11aW50OGFycmF5LXRvLWEtc3RyaW5nLzJcbiAgICAvLyBidXQgdGhlIHN0YWNrIGlzIGxpbWl0ZWQgKGFuZCB3ZSBjYW4gZ2V0IGh1Z2UgYXJyYXlzICEpLlxuICAgIC8vXG4gICAgLy8gcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pOyBnZW5lcmF0ZSB0b28gbWFueSBzdHJpbmdzICFcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBpcyBpbnNwaXJlZCBieSBodHRwOi8vanNwZXJmLmNvbS9hcnJheWJ1ZmZlci10by1zdHJpbmctYXBwbHktcGVyZm9ybWFuY2UvMlxuICAgIC8vIFRPRE8gOiB3ZSBub3cgaGF2ZSB3b3JrZXJzIHRoYXQgc3BsaXQgdGhlIHdvcmsuIERvIHdlIHN0aWxsIG5lZWQgdGhhdCA/XG4gICAgdmFyIGNodW5rID0gNjU1MzYsXG4gICAgICAgIHR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihhcnJheSksXG4gICAgICAgIGNhblVzZUFwcGx5ID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50OGFycmF5XCIpIHtcbiAgICAgICAgY2FuVXNlQXBwbHkgPSBhcnJheVRvU3RyaW5nSGVscGVyLmFwcGx5Q2FuQmVVc2VkLnVpbnQ4YXJyYXk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQubm9kZWJ1ZmZlcjtcbiAgICB9XG5cbiAgICBpZiAoY2FuVXNlQXBwbHkpIHtcbiAgICAgICAgd2hpbGUgKGNodW5rID4gMSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNodW5rKGFycmF5LCB0eXBlLCBjaHVuayk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBNYXRoLmZsb29yKGNodW5rIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBubyBhcHBseSBvciBjaHVuayBlcnJvciA6IHNsb3cgYW5kIHBhaW5mdWwgYWxnb3JpdGhtXG4gICAgLy8gZGVmYXVsdCBicm93c2VyIG9uIGFuZHJvaWQgNC4qXG4gICAgcmV0dXJuIGFycmF5VG9TdHJpbmdIZWxwZXIuc3RyaW5naWZ5QnlDaGFyKGFycmF5KTtcbn1cblxuZXhwb3J0cy5hcHBseUZyb21DaGFyQ29kZSA9IGFycmF5TGlrZVRvU3RyaW5nO1xuXG5cbi8qKlxuICogQ29weSB0aGUgZGF0YSBmcm9tIGFuIGFycmF5LWxpa2UgdG8gYW4gb3RoZXIgYXJyYXktbGlrZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5RnJvbSB0aGUgb3JpZ2luIGFycmF5LlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlUbyB0aGUgZGVzdGluYXRpb24gYXJyYXkgd2hpY2ggd2lsbCBiZSBtdXRhdGVkLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGRlc3RpbmF0aW9uIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VUb0FycmF5TGlrZShhcnJheUZyb20sIGFycmF5VG8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5RnJvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVRvW2ldID0gYXJyYXlGcm9tW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlUbztcbn1cblxuLy8gYSBtYXRyaXggY29udGFpbmluZyBmdW5jdGlvbnMgdG8gdHJhbnNmb3JtIGV2ZXJ5dGhpbmcgaW50byBldmVyeXRoaW5nLlxudmFyIHRyYW5zZm9ybSA9IHt9O1xuXG4vLyBzdHJpbmcgdG8gP1xudHJhbnNmb3JtW1wic3RyaW5nXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGlkZW50aXR5LFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1bXCJzdHJpbmdcIl1bXCJ1aW50OGFycmF5XCJdKGlucHV0KS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5vZGVqc1V0aWxzLmFsbG9jQnVmZmVyKGlucHV0Lmxlbmd0aCkpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5IHRvID9cbnRyYW5zZm9ybVtcImFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKG5ldyBVaW50OEFycmF5KGlucHV0KSkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20oaW5wdXQpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5YnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcImFycmF5YnVmZmVyXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb1N0cmluZyhuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgIH0sXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UobmV3IFVpbnQ4QXJyYXkoaW5wdXQpLCBuZXcgQXJyYXkoaW5wdXQuYnl0ZUxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBpZGVudGl0eSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgIH1cbn07XG5cbi8vIHVpbnQ4YXJyYXkgdG8gP1xudHJhbnNmb3JtW1widWludDhhcnJheVwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBhcnJheUxpa2VUb1N0cmluZyxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGlkZW50aXR5LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gbm9kZWJ1ZmZlciB0byA/XG50cmFuc2Zvcm1bXCJub2RlYnVmZmVyXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1bXCJub2RlYnVmZmVyXCJdW1widWludDhhcnJheVwiXShpbnB1dCkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogaWRlbnRpdHlcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGlucHV0IGludG8gYW55IHR5cGUuXG4gKiBUaGUgc3VwcG9ydGVkIG91dHB1dCB0eXBlIGFyZSA6IHN0cmluZywgYXJyYXksIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBub2RlYnVmZmVyLlxuICogSWYgbm8gb3V0cHV0IHR5cGUgaXMgc3BlY2lmaWVkLCB0aGUgdW5tb2RpZmllZCBpbnB1dCB3aWxsIGJlIHJldHVybmVkLlxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIG91dHB1dCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGlucHV0IHRoZSBpbnB1dCB0byBjb252ZXJ0LlxuICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIG91dHB1dCB0eXBlLlxuICovXG5leHBvcnRzLnRyYW5zZm9ybVRvID0gZnVuY3Rpb24ob3V0cHV0VHlwZSwgaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCwgbnVsbCwgZXRjXG4gICAgICAgIC8vIGFuIGVtcHR5IHN0cmluZyB3b24ndCBoYXJtLlxuICAgICAgICBpbnB1dCA9IFwiXCI7XG4gICAgfVxuICAgIGlmICghb3V0cHV0VHlwZSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGV4cG9ydHMuY2hlY2tTdXBwb3J0KG91dHB1dFR5cGUpO1xuICAgIHZhciBpbnB1dFR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihpbnB1dCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybVtpbnB1dFR5cGVdW291dHB1dFR5cGVdKGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHR5cGUgb2YgdGhlIGlucHV0LlxuICogVGhlIHR5cGUgd2lsbCBiZSBpbiBhIGZvcm1hdCB2YWxpZCBmb3IgSlNaaXAudXRpbHMudHJhbnNmb3JtVG8gOiBzdHJpbmcsIGFycmF5LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCB0aGUgaW5wdXQgdG8gaWRlbnRpZnkuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSAobG93ZXJjYXNlKSB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqL1xuZXhwb3J0cy5nZXRUeXBlT2YgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlciAmJiBub2RlanNVdGlscy5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIFwibm9kZWJ1ZmZlclwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5ICYmIGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gXCJ1aW50OGFycmF5XCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LmFycmF5YnVmZmVyICYmIGlucHV0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlidWZmZXJcIjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGUgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgdHlwZS5cbiAqL1xuZXhwb3J0cy5jaGVja1N1cHBvcnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHN1cHBvcnRlZCA9IHN1cHBvcnRbdHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICBpZiAoIXN1cHBvcnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBwbGF0Zm9ybVwiKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLk1BWF9WQUxVRV8xNkJJVFMgPSA2NTUzNTtcbmV4cG9ydHMuTUFYX1ZBTFVFXzMyQklUUyA9IC0xOyAvLyB3ZWxsLCBcIlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcIiBpcyBwYXJzZWQgYXMgLTFcblxuLyoqXG4gKiBQcmV0dGlmeSBhIHN0cmluZyByZWFkIGFzIGJpbmFyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBwcmV0dGlmeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gYSBwcmV0dHkgc3RyaW5nLlxuICovXG5leHBvcnRzLnByZXR0eSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciByZXMgPSAnJyxcbiAgICAgICAgY29kZSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgKHN0ciB8fCBcIlwiKS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJlcyArPSAnXFxcXHgnICsgKGNvZGUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyBjb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBEZWZlciB0aGUgY2FsbCBvZiBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdGhlIGZ1bmN0aW9uIHRvIGNhbGwgYXN5bmNocm9ub3VzbHkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gZ2l2ZSB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmV4cG9ydHMuZGVsYXkgPSBmdW5jdGlvbihjYWxsYmFjaywgYXJncywgc2VsZikge1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHNlbGYgfHwgbnVsbCwgYXJncyB8fCBbXSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEV4dGVuZHMgYSBwcm90b3R5cGUgd2l0aCBhbiBvdGhlciwgd2l0aG91dCBjYWxsaW5nIGEgY29uc3RydWN0b3Igd2l0aFxuICogc2lkZSBlZmZlY3RzLiBJbnNwaXJlZCBieSBub2RlanMnIGB1dGlscy5pbmhlcml0c2BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN0b3IgdGhlIGNvbnN0cnVjdG9yIHRvIGF1Z21lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ3RvciB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIHRvIHVzZVxuICovXG5leHBvcnRzLmluaGVyaXRzID0gZnVuY3Rpb24gKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIHZhciBPYmogPSBmdW5jdGlvbigpIHt9O1xuICAgIE9iai5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IE9iaigpO1xufTtcblxuLyoqXG4gKiBNZXJnZSB0aGUgb2JqZWN0cyBwYXNzZWQgYXMgcGFyYW1ldGVycyBpbnRvIGEgbmV3IG9uZS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgQWxsIG9iamVjdHMgdG8gbWVyZ2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdCB3aXRoIHRoZSBkYXRhIG9mIHRoZSBvdGhlcnMuXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBpLCBhdHRyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgLy8gYXJndW1lbnRzIGlzIG5vdCBlbnVtZXJhYmxlIGluIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgZm9yIChhdHRyIGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXS5oYXNPd25Qcm9wZXJ0eShhdHRyKSAmJiB0eXBlb2YgcmVzdWx0W2F0dHJdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2F0dHJdID0gYXJndW1lbnRzW2ldW2F0dHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhcmJpdHJhcnkgY29udGVudCBpbnRvIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGEgbmFtZSBmb3IgdGhlIGNvbnRlbnQgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YSB0aGUgY29udGVudCB0byBwcm9jZXNzLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmFyeSB0cnVlIGlmIHRoZSBjb250ZW50IGlzIG5vdCBhbiB1bmljb2RlIHN0cmluZ1xuICogQHBhcmFtIHtCb29sZWFufSBpc09wdGltaXplZEJpbmFyeVN0cmluZyB0cnVlIGlmIHRoZSBzdHJpbmcgY29udGVudCBvbmx5IGhhcyBvbmUgYnl0ZSBwZXIgY2hhcmFjdGVyLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0Jhc2U2NCB0cnVlIGlmIHRoZSBzdHJpbmcgY29udGVudCBpcyBlbmNvZGVkIHdpdGggYmFzZTY0LlxuICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIGluIGEgZm9ybWF0IHVzYWJsZSBieSBKU1ppcC5cbiAqL1xuZXhwb3J0cy5wcmVwYXJlQ29udGVudCA9IGZ1bmN0aW9uKG5hbWUsIGlucHV0RGF0YSwgaXNCaW5hcnksIGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nLCBpc0Jhc2U2NCkge1xuXG4gICAgLy8gaWYgaW5wdXREYXRhIGlzIGFscmVhZHkgYSBwcm9taXNlLCB0aGlzIGZsYXR0ZW4gaXQuXG4gICAgdmFyIHByb21pc2UgPSBleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoaW5wdXREYXRhKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB2YXIgaXNCbG9iID0gc3VwcG9ydC5ibG9iICYmIChkYXRhIGluc3RhbmNlb2YgQmxvYiB8fCBbJ1tvYmplY3QgRmlsZV0nLCAnW29iamVjdCBCbG9iXSddLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSAhPT0gLTEpO1xuXG4gICAgICAgIGlmIChpc0Jsb2IgJiYgdHlwZW9mIEZpbGVSZWFkZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgZGF0YVR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihkYXRhKTtcblxuICAgICAgICBpZiAoIWRhdGFUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKFwiQ2FuJ3QgcmVhZCB0aGUgZGF0YSBvZiAnXCIgKyBuYW1lICsgXCInLiBJcyBpdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW4gYSBzdXBwb3J0ZWQgSmF2YVNjcmlwdCB0eXBlIChTdHJpbmcsIEJsb2IsIEFycmF5QnVmZmVyLCBldGMpID9cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIDogaXQncyB3YXkgZWFzaWVyIHRvIHdvcmsgd2l0aCBVaW50OEFycmF5IHRoYW4gd2l0aCBBcnJheUJ1ZmZlclxuICAgICAgICBpZiAoZGF0YVR5cGUgPT09IFwiYXJyYXlidWZmZXJcIikge1xuICAgICAgICAgICAgZGF0YSA9IGV4cG9ydHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNCYXNlNjQpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYmFzZTY0LmRlY29kZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkQmluYXJ5U3RyaW5nID09PSB0cnVlIG1lYW5zIHRoYXQgdGhlIGZpbGUgaGFzIGFscmVhZHkgYmVlbiBmaWx0ZXJlZCB3aXRoIGEgMHhGRiBtYXNrXG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzdHJpbmcsIG5vdCBpbiBhIGJhc2U2NCBmb3JtYXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlIHN1cmUgdGhhdCB0aGlzIGlzIGEgY29ycmVjdCBcImJpbmFyeSBzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gc3RyaW5nMmJpbmFyeShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlYWRlckZvciA9IHJlcXVpcmUoJy4vcmVhZGVyL3JlYWRlckZvcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHNpZyA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgWmlwRW50cnkgPSByZXF1aXJlKCcuL3ppcEVudHJ5Jyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbi8vICBjbGFzcyBaaXBFbnRyaWVzIHt7e1xuLyoqXG4gKiBBbGwgdGhlIGVudHJpZXMgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyaWVzKGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5maWxlcyA9IFtdO1xuICAgIHRoaXMubG9hZE9wdGlvbnMgPSBsb2FkT3B0aW9ucztcbn1cblppcEVudHJpZXMucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIHJlYWRlciBpcyBvbiB0aGUgc3BlY2lmaWVkIHNpZ25hdHVyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIGV4cGVjdGVkIHNpZ25hdHVyZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgaXMgYW4gb3RoZXIgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGNoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbihleHBlY3RlZFNpZ25hdHVyZSkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShleHBlY3RlZFNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLmluZGV4IC09IDQ7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiB1bmV4cGVjdGVkIHNpZ25hdHVyZSBcIiArIFwiKFwiICsgdXRpbHMucHJldHR5KHNpZ25hdHVyZSkgKyBcIiwgZXhwZWN0ZWQgXCIgKyB1dGlscy5wcmV0dHkoZXhwZWN0ZWRTaWduYXR1cmUpICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGlzIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXNrZWRJbmRleCB0aGUgaW5kZXggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkU2lnbmF0dXJlIHRoZSBzaWduYXR1cmUgdG8gZXhwZWN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNpZ25hdHVyZSBpcyBoZXJlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNTaWduYXR1cmU6IGZ1bmN0aW9uKGFza2VkSW5kZXgsIGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLnJlYWRlci5pbmRleDtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoYXNrZWRJbmRleCk7XG4gICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gc2lnbmF0dXJlID09PSBleHBlY3RlZFNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoY3VycmVudEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZEJsb2NrRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuXG4gICAgICAgIHRoaXMuemlwQ29tbWVudExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIC8vIHdhcm5pbmcgOiB0aGUgZW5jb2RpbmcgZGVwZW5kcyBvZiB0aGUgc3lzdGVtIGxvY2FsZVxuICAgICAgICAvLyBPbiBhIGxpbnV4IG1hY2hpbmUgd2l0aCBMQU5HPWVuX1VTLnV0ZjgsIHRoaXMgZmllbGQgaXMgdXRmOCBlbmNvZGVkLlxuICAgICAgICAvLyBPbiBhIHdpbmRvd3MgbWFjaGluZSwgdGhpcyBmaWVsZCBpcyBlbmNvZGVkIHdpdGggdGhlIGxvY2FsaXplZCB3aW5kb3dzIGNvZGUgcGFnZS5cbiAgICAgICAgdmFyIHppcENvbW1lbnQgPSB0aGlzLnJlYWRlci5yZWFkRGF0YSh0aGlzLnppcENvbW1lbnRMZW5ndGgpO1xuICAgICAgICB2YXIgZGVjb2RlUGFyYW1UeXBlID0gc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG4gICAgICAgIC8vIFRvIGdldCBjb25zaXN0ZW50IGJlaGF2aW9yIHdpdGggdGhlIGdlbmVyYXRpb24gcGFydCwgd2Ugd2lsbCBhc3N1bWUgdGhhdFxuICAgICAgICAvLyB0aGlzIGlzIHV0ZjggZW5jb2RlZCB1bmxlc3Mgc3BlY2lmaWVkIG90aGVyd2lzZS5cbiAgICAgICAgdmFyIGRlY29kZUNvbnRlbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHppcENvbW1lbnQpO1xuICAgICAgICB0aGlzLnppcENvbW1lbnQgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGRlY29kZUNvbnRlbnQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBaaXAgNjQgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICogTm90IG1lcmdlZCB3aXRoIHRoZSBtZXRob2QgcmVhZEVuZE9mQ2VudHJhbCA6XG4gICAgICogVGhlIGVuZCBvZiBjZW50cmFsIGNhbiBjb2V4aXN0IHdpdGggaXRzIFppcDY0IGJyb3RoZXIsXG4gICAgICogSSBkb24ndCB3YW50IHRvIHJlYWQgdGhlIHdyb25nIG51bWJlciBvZiBieXRlcyAhXG4gICAgICovXG4gICAgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMucmVhZGVyLnNraXAoNCk7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk1hZGVCeSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoMik7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk5lZWRlZCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza051bWJlciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHMgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcblxuICAgICAgICB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGEgPSB7fTtcbiAgICAgICAgdmFyIGV4dHJhRGF0YVNpemUgPSB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZSAtIDQ0LFxuICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZXh0cmFEYXRhU2l6ZSkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlID0gdGhpcy5yZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGFbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yLlxuICAgICAqL1xuICAgIHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlza1dpdGhaaXA2NENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuZGlza3NDb3VudCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIGlmICh0aGlzLmRpc2tzQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aS12b2x1bWVzIHppcCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgbG9jYWwgZmlsZXMsIGJhc2VkIG9uIHRoZSBvZmZzZXQgcmVhZCBpbiB0aGUgY2VudHJhbCBwYXJ0LlxuICAgICAqL1xuICAgIHJlYWRMb2NhbEZpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGZpbGU7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tpXTtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KGZpbGUubG9jYWxIZWFkZXJPZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuTE9DQUxfRklMRV9IRUFERVIpO1xuICAgICAgICAgICAgZmlsZS5yZWFkTG9jYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlVVRGOCgpO1xuICAgICAgICAgICAgZmlsZS5wcm9jZXNzQXR0cmlidXRlcygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQ2VudHJhbERpcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWxlO1xuXG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMuY2VudHJhbERpck9mZnNldCk7XG4gICAgICAgIHdoaWxlICh0aGlzLnJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmUoc2lnLkNFTlRSQUxfRklMRV9IRUFERVIpKSB7XG4gICAgICAgICAgICBmaWxlID0gbmV3IFppcEVudHJ5KHtcbiAgICAgICAgICAgICAgICB6aXA2NDogdGhpcy56aXA2NFxuICAgICAgICAgICAgfSwgdGhpcy5sb2FkT3B0aW9ucyk7XG4gICAgICAgICAgICBmaWxlLnJlYWRDZW50cmFsUGFydCh0aGlzLnJlYWRlcik7XG4gICAgICAgICAgICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jZW50cmFsRGlyUmVjb3JkcyAhPT0gdGhpcy5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSAwICYmIHRoaXMuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZXhwZWN0ZWQgc29tZSByZWNvcmRzIGJ1dCBjb3VsZG4ndCBmaW5kIEFOWS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHJlYWxseSBzdXNwaWNpb3VzLCBhcyBpZiBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIG9yIGJ1ZzogZXhwZWN0ZWQgXCIgKyB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICsgXCIgcmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290IFwiICsgdGhpcy5maWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBzb21lIHJlY29yZHMgYnV0IG5vdCBhbGwuXG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIGlzIHdyb25nIGJ1dCB3ZSBnb3Qgc29tZXRoaW5nIGZvciB0aGUgdXNlcjogbm8gZXJyb3IgaGVyZS5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJleHBlY3RlZFwiLCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzLCBcInJlY29yZHMgaW4gY2VudHJhbCBkaXIsIGdvdFwiLCB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRlbnQgaXMgYSB0cnVuY2F0ZWQgemlwIG9yIGNvbXBsZXRlIGdhcmJhZ2UuXG4gICAgICAgICAgICAvLyBBIFwiTE9DQUxfRklMRV9IRUFERVJcIiBpcyBub3QgcmVxdWlyZWQgYXQgdGhlIGJlZ2lubmluZyAoYXV0b1xuICAgICAgICAgICAgLy8gZXh0cmFjdGlibGUgemlwIGZvciBleGFtcGxlKSBidXQgaXQgY2FuIGdpdmUgYSBnb29kIGhpbnQuXG4gICAgICAgICAgICAvLyBJZiBhbiBhamF4IHJlcXVlc3Qgd2FzIHVzZWQgd2l0aG91dCByZXNwb25zZVR5cGUsIHdlIHdpbGwgYWxzb1xuICAgICAgICAgICAgLy8gZ2V0IHVucmVhZGFibGUgZGF0YS5cbiAgICAgICAgICAgIHZhciBpc0dhcmJhZ2UgPSAhdGhpcy5pc1NpZ25hdHVyZSgwLCBzaWcuTE9DQUxfRklMRV9IRUFERVIpO1xuXG4gICAgICAgICAgICBpZiAoaXNHYXJiYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgOiBpcyB0aGlzIGEgemlwIGZpbGUgPyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSWYgaXQgaXMsIHNlZSBodHRwczovL3N0dWsuZ2l0aHViLmlvL2pzemlwL2RvY3VtZW50YXRpb24vaG93dG8vcmVhZF96aXAuaHRtbFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChvZmZzZXQpO1xuICAgICAgICB2YXIgZW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICB0aGlzLnJlYWRCbG9ja0VuZE9mQ2VudHJhbCgpO1xuXG5cbiAgICAgICAgLyogZXh0cmFjdCBmcm9tIHRoZSB6aXAgc3BlYyA6XG4gICAgICAgICAgICA0KSAgSWYgb25lIG9mIHRoZSBmaWVsZHMgaW4gdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgIHJlY29yZCBpcyB0b28gc21hbGwgdG8gaG9sZCByZXF1aXJlZCBkYXRhLCB0aGUgZmllbGRcbiAgICAgICAgICAgICAgICBzaG91bGQgYmUgc2V0IHRvIC0xICgweEZGRkYgb3IgMHhGRkZGRkZGRikgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFpJUDY0IGZvcm1hdCByZWNvcmQgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICAgICAgICA1KSAgVGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFppcDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yIHJlY29yZCBtdXN0XG4gICAgICAgICAgICAgICAgcmVzaWRlIG9uIHRoZSBzYW1lIGRpc2sgd2hlbiBzcGxpdHRpbmcgb3Igc3Bhbm5pbmdcbiAgICAgICAgICAgICAgICBhbiBhcmNoaXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlciA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHMgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUyB8fCB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuemlwNjQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgV2FybmluZyA6IHRoZSB6aXA2NCBleHRlbnNpb24gaXMgc3VwcG9ydGVkLCBidXQgT05MWSBpZiB0aGUgNjRiaXRzIGludGVnZXIgcmVhZCBmcm9tXG4gICAgICAgICAgICB0aGUgemlwIGZpbGUgY2FuIGZpdCBpbnRvIGEgMzJiaXRzIGludGVnZXIuIFRoaXMgY2Fubm90IGJlIHNvbHZlZCA6IEphdmFTY3JpcHQgcmVwcmVzZW50c1xuICAgICAgICAgICAgYWxsIG51bWJlcnMgYXMgNjQtYml0IGRvdWJsZSBwcmVjaXNpb24gSUVFRSA3NTQgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy5cbiAgICAgICAgICAgIFNvLCB3ZSBoYXZlIDUzYml0cyBmb3IgaW50ZWdlcnMgYW5kIGJpdHdpc2Ugb3BlcmF0aW9ucyB0cmVhdCBldmVyeXRoaW5nIGFzIDMyYml0cy5cbiAgICAgICAgICAgIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9CaXR3aXNlX09wZXJhdG9yc1xuICAgICAgICAgICAgYW5kIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvZmlsZXMvRUNNQS1TVC9FQ01BLTI2Mi5wZGYgc2VjdGlvbiA4LjVcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vIHNob3VsZCBsb29rIGZvciBhIHppcDY0IEVPQ0QgbG9jYXRvclxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SKTtcbiAgICAgICAgICAgIHRoaXMucmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yKCk7XG5cbiAgICAgICAgICAgIC8vIG5vdyB0aGUgemlwNjQgRU9DRCByZWNvcmRcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1NpZ25hdHVyZSh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIsIHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IG5vdCB3aGVyZSBleHBlY3RlZC5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpcik7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5jZW50cmFsRGlyT2Zmc2V0ICsgdGhpcy5jZW50cmFsRGlyU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuemlwNjQpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ICs9IDIwOyAvLyBlbmQgb2YgY2VudHJhbCBkaXIgNjQgbG9jYXRvclxuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMTIgLyogc2hvdWxkIG5vdCBpbmNsdWRlIHRoZSBsZWFkaW5nIDEyIGJ5dGVzICovICsgdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXh0cmFCeXRlcyA9IGVuZE9mQ2VudHJhbERpck9mZnNldCAtIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0O1xuXG4gICAgICAgIGlmIChleHRyYUJ5dGVzID4gMCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGV4dHJhQnl0ZXMsIFwiZXh0cmEgYnl0ZXMgYXQgYmVnaW5uaW5nIG9yIHdpdGhpbiB6aXBmaWxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTaWduYXR1cmUoZW5kT2ZDZW50cmFsRGlyT2Zmc2V0LCBzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb2Zmc2V0cyBzZWVtIHdyb25nLCBidXQgd2UgaGF2ZSBzb21ldGhpbmcgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gICAgICAgICAgICAgICAgLy8gU2/igKYgd2Uga2VlcCBpdC5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9mZnNldCBpcyB3cm9uZywgdXBkYXRlIHRoZSBcInplcm9cIiBvZiB0aGUgcmVhZGVyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGlmIGRhdGEgaGFzIGJlZW4gcHJlcGVuZGVkIChjcnggZmlsZXMgZm9yIGV4YW1wbGUpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIuemVybyA9IGV4dHJhQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IG1pc3NpbmcgXCIgKyBNYXRoLmFicyhleHRyYUJ5dGVzKSArIFwiIGJ5dGVzLlwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGFyZVJlYWRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlckZvcihkYXRhKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgYSB6aXAgZmlsZSBhbmQgY3JlYXRlIFppcEVudHJpZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGJpbmFyeSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgemlwIGZpbGUuXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnByZXBhcmVSZWFkZXIoZGF0YSk7XG4gICAgICAgIHRoaXMucmVhZEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB0aGlzLnJlYWRDZW50cmFsRGlyKCk7XG4gICAgICAgIHRoaXMucmVhZExvY2FsRmlsZXMoKTtcbiAgICB9XG59O1xuLy8gfX19IGVuZCBvZiBaaXBFbnRyaWVzXG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJpZXM7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVhZGVyRm9yID0gcmVxdWlyZSgnLi9yZWFkZXIvcmVhZGVyRm9yJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIGNyYzMyZm4gPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoJy4vY29tcHJlc3Npb25zJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuXG52YXIgTUFERV9CWV9ET1MgPSAweDAwO1xudmFyIE1BREVfQllfVU5JWCA9IDB4MDM7XG5cbi8qKlxuICogRmluZCBhIGNvbXByZXNzaW9uIHJlZ2lzdGVyZWQgaW4gSlNaaXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcHJlc3Npb25NZXRob2QgdGhlIG1ldGhvZCBtYWdpYyB0byBmaW5kLlxuICogQHJldHVybiB7T2JqZWN0fG51bGx9IHRoZSBKU1ppcCBjb21wcmVzc2lvbiBvYmplY3QsIG51bGwgaWYgbm9uZSBmb3VuZC5cbiAqL1xudmFyIGZpbmRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uKGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgZm9yICh2YXIgbWV0aG9kIGluIGNvbXByZXNzaW9ucykge1xuICAgICAgICBpZiAoIWNvbXByZXNzaW9ucy5oYXNPd25Qcm9wZXJ0eShtZXRob2QpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Npb25zW21ldGhvZF0ubWFnaWMgPT09IGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3Npb25zW21ldGhvZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBjbGFzcyBaaXBFbnRyeSB7e3tcbi8qKlxuICogQW4gZW50cnkgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9mIHRoZSBjdXJyZW50IGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyeShvcHRpb25zLCBsb2FkT3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cnkucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0VuY3J5cHRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDAwMSkgPT09IDB4MDAwMTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBoYXMgdXRmLTggZmlsZW5hbWUvY29tbWVudC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlbmFtZS9jb21tZW50IGlzIGluIHV0Zi04LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdXNlVVRGODogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxMSBpcyBzZXRcbiAgICAgICAgcmV0dXJuICh0aGlzLmJpdEZsYWcgJiAweDA4MDApID09PSAweDA4MDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkTG9jYWxQYXJ0OiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uLCBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoO1xuXG4gICAgICAgIC8vIHdlIGFscmVhZHkga25vdyBldmVyeXRoaW5nIGZyb20gdGhlIGNlbnRyYWwgZGlyICFcbiAgICAgICAgLy8gSWYgdGhlIGNlbnRyYWwgZGlyIGRhdGEgYXJlIGZhbHNlLCB3ZSBhcmUgZG9vbWVkLlxuICAgICAgICAvLyBPbiB0aGUgYnJpZ2h0IHNpZGUsIHRoZSBsb2NhbCBwYXJ0IGlzIHNjYXJ5ICA6IHppcDY0LCBkYXRhIGRlc2NyaXB0b3JzLCBib3RoLCBldGMuXG4gICAgICAgIC8vIFRoZSBsZXNzIGRhdGEgd2UgZ2V0IGhlcmUsIHRoZSBtb3JlIHJlbGlhYmxlIHRoaXMgc2hvdWxkIGJlLlxuICAgICAgICAvLyBMZXQncyBza2lwIHRoZSB3aG9sZSBoZWFkZXIgYW5kIGRhc2ggdG8gdGhlIGRhdGEgIVxuICAgICAgICByZWFkZXIuc2tpcCgyMik7XG4gICAgICAgIC8vIGluIHNvbWUgemlwIGNyZWF0ZWQgb24gd2luZG93cywgdGhlIGZpbGVuYW1lIHN0b3JlZCBpbiB0aGUgY2VudHJhbCBkaXIgY29udGFpbnMgXFwgaW5zdGVhZCBvZiAvLlxuICAgICAgICAvLyBTdHJhbmdlbHksIHRoZSBmaWxlbmFtZSBoZXJlIGlzIE9LLlxuICAgICAgICAvLyBJIHdvdWxkIGxvdmUgdG8gdHJlYXQgdGhlc2UgemlwIGZpbGVzIGFzIGNvcnJ1cHRlZCAoc2VlIGh0dHA6Ly93d3cuaW5mby16aXAub3JnL0ZBUS5odG1sI2JhY2tzbGFzaGVzXG4gICAgICAgIC8vIG9yIEFQUE5PVEUjNC40LjE3LjEsIFwiQWxsIHNsYXNoZXMgTVVTVCBiZSBmb3J3YXJkIHNsYXNoZXMgJy8nXCIpIGJ1dCB0aGVyZSBhcmUgYSBsb3Qgb2YgYmFkIHppcCBnZW5lcmF0b3JzLi4uXG4gICAgICAgIC8vIFNlYXJjaCBcInVuemlwIG1pc21hdGNoaW5nIFwibG9jYWxcIiBmaWxlbmFtZSBjb250aW51aW5nIHdpdGggXCJjZW50cmFsXCIgZmlsZW5hbWUgdmVyc2lvblwiIG9uXG4gICAgICAgIC8vIHRoZSBpbnRlcm5ldC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSSB0aGluayBJIHNlZSB0aGUgbG9naWMgaGVyZSA6IHRoZSBjZW50cmFsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGRpc3BsYXlcbiAgICAgICAgLy8gY29udGVudCBhbmQgdGhlIGxvY2FsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGV4dHJhY3QgdGhlIGZpbGVzLiBNaXhpbmcgLyBhbmQgXFxcbiAgICAgICAgLy8gbWF5IGJlIHVzZWQgdG8gZGlzcGxheSBcXCB0byB3aW5kb3dzIHVzZXJzIGFuZCB1c2UgLyB3aGVuIGV4dHJhY3RpbmcgdGhlIGZpbGVzLlxuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGlzIGxlYWQgYWxzbyB0byBzb21lIGlzc3VlcyA6IGh0dHA6Ly9zZWNsaXN0cy5vcmcvZnVsbGRpc2Nsb3N1cmUvMjAwOS9TZXAvMzk0XG4gICAgICAgIHRoaXMuZmlsZU5hbWVMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgbG9jYWxFeHRyYUZpZWxkc0xlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpOyAvLyBjYW4ndCBiZSBzdXJlIHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgY2VudHJhbCBkaXJcbiAgICAgICAgLy8gdGhlIGZpbGVOYW1lIGlzIHN0b3JlZCBhcyBiaW5hcnkgZGF0YSwgdGhlIGhhbmRsZVVURjggbWV0aG9kIHdpbGwgdGFrZSBjYXJlIG9mIHRoZSBlbmNvZGluZy5cbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVOYW1lTGVuZ3RoKTtcbiAgICAgICAgcmVhZGVyLnNraXAobG9jYWxFeHRyYUZpZWxkc0xlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyBvciBjb3JydXB0ZWQgemlwIDogZGlkbid0IGdldCBlbm91Z2ggaW5mb3JtYXRpb24gZnJvbSB0aGUgY2VudHJhbCBkaXJlY3RvcnkgXCIgKyBcIihjb21wcmVzc2VkU2l6ZSA9PT0gLTEgfHwgdW5jb21wcmVzc2VkU2l6ZSA9PT0gLTEpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcHJlc3Npb24gPSBmaW5kQ29tcHJlc3Npb24odGhpcy5jb21wcmVzc2lvbk1ldGhvZCk7XG4gICAgICAgIGlmIChjb21wcmVzc2lvbiA9PT0gbnVsbCkgeyAvLyBubyBjb21wcmVzc2lvbiBmb3VuZFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCA6IGNvbXByZXNzaW9uIFwiICsgdXRpbHMucHJldHR5KHRoaXMuY29tcHJlc3Npb25NZXRob2QpICsgXCIgdW5rbm93biAoaW5uZXIgZmlsZSA6IFwiICsgdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdGhpcy5maWxlTmFtZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWNvbXByZXNzZWQgPSBuZXcgQ29tcHJlc3NlZE9iamVjdCh0aGlzLmNvbXByZXNzZWRTaXplLCB0aGlzLnVuY29tcHJlc3NlZFNpemUsIHRoaXMuY3JjMzIsIGNvbXByZXNzaW9uLCByZWFkZXIucmVhZERhdGEodGhpcy5jb21wcmVzc2VkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRDZW50cmFsUGFydDogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbk1hZGVCeSA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICByZWFkZXIuc2tpcCgyKTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTmVlZGVkID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuYml0RmxhZyA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uTWV0aG9kID0gcmVhZGVyLnJlYWRTdHJpbmcoMik7XG4gICAgICAgIHRoaXMuZGF0ZSA9IHJlYWRlci5yZWFkRGF0ZSgpO1xuICAgICAgICB0aGlzLmNyYzMyID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHZhciBmaWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZmlsZUNvbW1lbnRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyU3RhcnQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID0gcmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNFbmNyeXB0ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGVkIHppcCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdpbGwgYmUgcmVhZCBpbiB0aGUgbG9jYWwgcGFydCwgc2VlIHRoZSBjb21tZW50cyB0aGVyZVxuICAgICAgICByZWFkZXIuc2tpcChmaWxlTmFtZUxlbmd0aCk7XG4gICAgICAgIHRoaXMucmVhZEV4dHJhRmllbGRzKHJlYWRlcik7XG4gICAgICAgIHRoaXMucGFyc2VaSVA2NEV4dHJhRmllbGQocmVhZGVyKTtcbiAgICAgICAgdGhpcy5maWxlQ29tbWVudCA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVDb21tZW50TGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcyBhbmQgZ2V0IHRoZSB1bml4L2RvcyBwZXJtaXNzaW9ucy5cbiAgICAgKi9cbiAgICBwcm9jZXNzQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9zUGVybWlzc2lvbnMgPSBudWxsO1xuICAgICAgICB2YXIgbWFkZUJ5ID0gdGhpcy52ZXJzaW9uTWFkZUJ5ID4+IDg7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0aGUgRE9TIGRpcmVjdG9yeSBmbGFnIHNldC5cbiAgICAgICAgLy8gV2UgbG9vayBmb3IgaXQgaW4gdGhlIERPUyBhbmQgVU5JWCBwZXJtaXNzaW9uc1xuICAgICAgICAvLyBidXQgc29tZSB1bmtub3duIHBsYXRmb3JtIGNvdWxkIHNldCBpdCBhcyBhIGNvbXBhdGliaWxpdHkgZmxhZy5cbiAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgJiAweDAwMTAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgaWYobWFkZUJ5ID09PSBNQURFX0JZX0RPUykge1xuICAgICAgICAgICAgLy8gZmlyc3QgNiBiaXRzICgwIHRvIDUpXG4gICAgICAgICAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzICYgMHgzRjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG1hZGVCeSA9PT0gTUFERV9CWV9VTklYKSB7XG4gICAgICAgICAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9ICh0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPj4gMTYpICYgMHhGRkZGO1xuICAgICAgICAgICAgLy8gdGhlIG9jdGFsIHBlcm1pc3Npb25zIGFyZSBpbiAodGhpcy51bml4UGVybWlzc2lvbnMgJiAweDAxRkYpLnRvU3RyaW5nKDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFpbCBzYWZlIDogaWYgdGhlIG5hbWUgZW5kcyB3aXRoIGEgLyBpdCBwcm9iYWJseSBtZWFucyBhIGZvbGRlclxuICAgICAgICBpZiAoIXRoaXMuZGlyICYmIHRoaXMuZmlsZU5hbWVTdHIuc2xpY2UoLTEpID09PSAnLycpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgWklQNjQgZXh0cmEgZmllbGQgYW5kIG1lcmdlIHRoZSBpbmZvIGluIHRoZSBjdXJyZW50IFppcEVudHJ5LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHBhcnNlWklQNjRFeHRyYUZpZWxkOiBmdW5jdGlvbihyZWFkZXIpIHtcblxuICAgICAgICBpZiAoIXRoaXMuZXh0cmFGaWVsZHNbMHgwMDAxXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdWxkIGJlIHNvbWV0aGluZywgcHJlcGFyaW5nIHRoZSBleHRyYSByZWFkZXJcbiAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHRoaXMuZXh0cmFGaWVsZHNbMHgwMDAxXS52YWx1ZSk7XG5cbiAgICAgICAgLy8gSSByZWFsbHkgaG9wZSB0aGF0IHRoZXNlIDY0Yml0cyBpbnRlZ2VyIGNhbiBmaXQgaW4gMzIgYml0cyBpbnRlZ2VyLCBiZWNhdXNlIGpzXG4gICAgICAgIC8vIHdvbid0IGxldCB1cyBoYXZlIG1vcmUuXG4gICAgICAgIGlmICh0aGlzLnVuY29tcHJlc3NlZFNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NlZFNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNrTnVtYmVyU3RhcnQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlza051bWJlclN0YXJ0ID0gZXh0cmFSZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkRXh0cmFGaWVsZHM6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB2YXIgZW5kID0gcmVhZGVyLmluZGV4ICsgdGhpcy5leHRyYUZpZWxkc0xlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhRmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhRmllbGRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocmVhZGVyLmluZGV4ICsgNCA8IGVuZCkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSByZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG5cbiAgICAgICAgICAgIHRoaXMuZXh0cmFGaWVsZHNbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVhZGVyLnNldEluZGV4KGVuZCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBseSBhbiBVVEY4IHRyYW5zZm9ybWF0aW9uIGlmIG5lZWRlZC5cbiAgICAgKi9cbiAgICBoYW5kbGVVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlY29kZVBhcmFtVHlwZSA9IHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuICAgICAgICBpZiAodGhpcy51c2VVVEY4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZpbGVDb21tZW50U3RyID0gdXRmOC51dGY4ZGVjb2RlKHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVwYXRoID0gdGhpcy5maW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoKCk7XG4gICAgICAgICAgICBpZiAodXBhdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdXBhdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFTQ0lJIHRleHQgb3IgdW5zdXBwb3J0ZWQgY29kZSBwYWdlXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lQnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZmlsZU5hbWVCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdWNvbW1lbnQgPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh1Y29tbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1Y29tbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudEJ5dGVBcnJheSA9ICB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGNvbW1lbnRCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgcGF0aCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIHBhdGgsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXBhdGhGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg3MDc1XTtcbiAgICAgICAgaWYgKHVwYXRoRmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1cGF0aEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgZmlsZW5hbWUgY2hhbmdlZCwgdGhpcyBmaWVsZCBpcyBvdXQgb2YgZGF0ZS5cbiAgICAgICAgICAgIGlmIChjcmMzMmZuKHRoaXMuZmlsZU5hbWUpICE9PSBleHRyYVJlYWRlci5yZWFkSW50KDQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1dGY4LnV0ZjhkZWNvZGUoZXh0cmFSZWFkZXIucmVhZERhdGEodXBhdGhGaWVsZC5sZW5ndGggLSA1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgY29tbWVudCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIGNvbW1lbnQsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdWNvbW1lbnRGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg2Mzc1XTtcbiAgICAgICAgaWYgKHVjb21tZW50RmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1Y29tbWVudEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgY29tbWVudCBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlQ29tbWVudCkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1Y29tbWVudEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBaaXBFbnRyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbUhlbHBlciA9IHJlcXVpcmUoJy4vc3RyZWFtL1N0cmVhbUhlbHBlcicpO1xudmFyIERhdGFXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9EYXRhV29ya2VyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIENvbXByZXNzZWRPYmplY3QgPSByZXF1aXJlKCcuL2NvbXByZXNzZWRPYmplY3QnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIEEgc2ltcGxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBmaWxlIGluIHRoZSB6aXAgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICovXG52YXIgWmlwT2JqZWN0ID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kaXIgPSBvcHRpb25zLmRpcjtcbiAgICB0aGlzLmRhdGUgPSBvcHRpb25zLmRhdGU7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0aW9ucy5jb21tZW50O1xuICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gb3B0aW9ucy51bml4UGVybWlzc2lvbnM7XG4gICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG9wdGlvbnMuZG9zUGVybWlzc2lvbnM7XG5cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9kYXRhQmluYXJ5ID0gb3B0aW9ucy5iaW5hcnk7XG4gICAgLy8ga2VlcCBvbmx5IHRoZSBjb21wcmVzc2lvblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgY29tcHJlc3Npb24gOiBvcHRpb25zLmNvbXByZXNzaW9uLFxuICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9uc1xuICAgIH07XG59O1xuXG5aaXBPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnRlcm5hbCBzdHJlYW0gZm9yIHRoZSBjb250ZW50IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHJldHVybiBTdHJlYW1IZWxwZXIgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGwsIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgYXNrVW5pY29kZVN0cmluZyA9IG91dHB1dFR5cGUgPT09IFwic3RyaW5nXCIgfHwgb3V0cHV0VHlwZSA9PT0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBpZiAob3V0cHV0VHlwZSA9PT0gXCJiaW5hcnlzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb21wcmVzc1dvcmtlcigpO1xuXG4gICAgICAgICAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gIXRoaXMuX2RhdGFCaW5hcnk7XG5cbiAgICAgICAgICAgIGlmIChpc1VuaWNvZGVTdHJpbmcgJiYgIWFza1VuaWNvZGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShuZXcgdXRmOC5VdGY4RW5jb2RlV29ya2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1VuaWNvZGVTdHJpbmcgJiYgYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhEZWNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBHZW5lcmljV29ya2VyKFwiZXJyb3JcIik7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IoZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcihyZXN1bHQsIG91dHB1dFR5cGUsIFwiXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBjb250ZW50IGluIHRoZSBhc2tlZCB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gUHJvbWlzZSB0aGUgcHJvbWlzZSBvZiB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSkuYWNjdW11bGF0ZShvblVwZGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgYXMgYSBub2RlanMgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gU3RyZWFtIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgbm9kZVN0cmVhbTogZnVuY3Rpb24gKHR5cGUsIG9uVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RyZWFtKHR5cGUgfHwgXCJub2RlYnVmZmVyXCIpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBvYmplY3QgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gY29tcHJlc3NpbmcuXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfY29tcHJlc3NXb3JrZXI6IGZ1bmN0aW9uIChjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0ICYmXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvbXByZXNzaW9uLm1hZ2ljID09PSBjb21wcmVzc2lvbi5tYWdpY1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbXByZXNzZWRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG4gICAgICAgICAgICBpZighdGhpcy5fZGF0YUJpbmFyeSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ29tcHJlc3NlZE9iamVjdC5jcmVhdGVXb3JrZXJGcm9tKHJlc3VsdCwgY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHdvcmtlciBmb3IgdGhlIGRlY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfZGVjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXRDb250ZW50V29ya2VyKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIEdlbmVyaWNXb3JrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKHRoaXMuX2RhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHJlbW92ZWRNZXRob2RzID0gW1wiYXNUZXh0XCIsIFwiYXNCaW5hcnlcIiwgXCJhc05vZGVCdWZmZXJcIiwgXCJhc1VpbnQ4QXJyYXlcIiwgXCJhc0FycmF5QnVmZmVyXCJdO1xudmFyIHJlbW92ZWRGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbn07XG5cbmZvcih2YXIgaSA9IDA7IGkgPCByZW1vdmVkTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIFppcE9iamVjdC5wcm90b3R5cGVbcmVtb3ZlZE1ldGhvZHNbaV1dID0gcmVtb3ZlZEZuO1xufVxubW9kdWxlLmV4cG9ydHMgPSBaaXBPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaW1tZWRpYXRlID0gcmVxdWlyZSgnaW1tZWRpYXRlJyk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBJTlRFUk5BTCgpIHt9XG5cbnZhciBoYW5kbGVycyA9IHt9O1xuXG52YXIgUkVKRUNURUQgPSBbJ1JFSkVDVEVEJ107XG52YXIgRlVMRklMTEVEID0gWydGVUxGSUxMRUQnXTtcbnZhciBQRU5ESU5HID0gWydQRU5ESU5HJ107XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuICBpZiAodHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVzb2x2ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdGhpcy5zdGF0ZSA9IFBFTkRJTkc7XG4gIHRoaXMucXVldWUgPSBbXTtcbiAgdGhpcy5vdXRjb21lID0gdm9pZCAwO1xuICBpZiAocmVzb2x2ZXIgIT09IElOVEVSTkFMKSB7XG4gICAgc2FmZWx5UmVzb2x2ZVRoZW5hYmxlKHRoaXMsIHJlc29sdmVyKTtcbiAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBwID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHRoaXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgICBmdW5jdGlvbiB5ZXMgKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcC5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oeWVzKTtcbiAgfVxuICBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgZnVuY3Rpb24gbm8gKCkge1xuICAgICAgdGhyb3cgcmVhc29uO1xuICAgIH1cbiAgICByZXR1cm4gcC5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4obm8pO1xuICB9XG59O1xuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCB8fFxuICAgIHR5cGVvZiBvblJlamVjdGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihJTlRFUk5BTCk7XG4gIGlmICh0aGlzLnN0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgdmFyIHJlc29sdmVyID0gdGhpcy5zdGF0ZSA9PT0gRlVMRklMTEVEID8gb25GdWxmaWxsZWQgOiBvblJlamVjdGVkO1xuICAgIHVud3JhcChwcm9taXNlLCByZXNvbHZlciwgdGhpcy5vdXRjb21lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2gobmV3IFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuZnVuY3Rpb24gUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQ7XG4gICAgdGhpcy5jYWxsRnVsZmlsbGVkID0gdGhpcy5vdGhlckNhbGxGdWxmaWxsZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vblJlamVjdGVkID0gb25SZWplY3RlZDtcbiAgICB0aGlzLmNhbGxSZWplY3RlZCA9IHRoaXMub3RoZXJDYWxsUmVqZWN0ZWQ7XG4gIH1cbn1cblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZXNvbHZlKHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25GdWxmaWxsZWQsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZWplY3QodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uUmVqZWN0ZWQsIHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIHVud3JhcChwcm9taXNlLCBmdW5jLCB2YWx1ZSkge1xuICBpbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGUpO1xuICAgIH1cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHByb21pc2UpIHtcbiAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5oYW5kbGVycy5yZXNvbHZlID0gZnVuY3Rpb24gKHNlbGYsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaChnZXRUaGVuLCB2YWx1ZSk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChzZWxmLCByZXN1bHQudmFsdWUpO1xuICB9XG4gIHZhciB0aGVuYWJsZSA9IHJlc3VsdC52YWx1ZTtcblxuICBpZiAodGhlbmFibGUpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgc2VsZi5vdXRjb21lID0gdmFsdWU7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgc2VsZi5xdWV1ZVtpXS5jYWxsRnVsZmlsbGVkKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuaGFuZGxlcnMucmVqZWN0ID0gZnVuY3Rpb24gKHNlbGYsIGVycm9yKSB7XG4gIHNlbGYuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgc2VsZi5vdXRjb21lID0gZXJyb3I7XG4gIHZhciBpID0gLTE7XG4gIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHNlbGYucXVldWVbaV0uY2FsbFJlamVjdGVkKGVycm9yKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIC8vIE1ha2Ugc3VyZSB3ZSBvbmx5IGFjY2VzcyB0aGUgYWNjZXNzb3Igb25jZSBhcyByZXF1aXJlZCBieSB0aGUgc3BlY1xuICB2YXIgdGhlbiA9IG9iaiAmJiBvYmoudGhlbjtcbiAgaWYgKG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBweVRoZW4oKSB7XG4gICAgICB0aGVuLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSkge1xuICAvLyBFaXRoZXIgZnVsZmlsbCwgcmVqZWN0IG9yIHJlamVjdCB3aXRoIGVycm9yXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25FcnJvcih2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZWplY3Qoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TdWNjZXNzKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9VbndyYXAoKSB7XG4gICAgdGhlbmFibGUob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0cnlUb1Vud3JhcCk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgb25FcnJvcihyZXN1bHQudmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGZ1bmMsIHZhbHVlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdHJ5IHtcbiAgICBvdXQudmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICBvdXQuc3RhdHVzID0gJ3N1Y2Nlc3MnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb3V0LnN0YXR1cyA9ICdlcnJvcic7XG4gICAgb3V0LnZhbHVlID0gZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBoYW5kbGVycy5yZXNvbHZlKG5ldyB0aGlzKElOVEVSTkFMKSwgdmFsdWUpO1xufVxuXG5Qcm9taXNlLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG4gIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbn1cblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgcmVzb2x2ZWQgPSAwO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgYWxsUmVzb2x2ZXIoaXRlcmFibGVbaV0sIGkpO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiBhbGxSZXNvbHZlcih2YWx1ZSwgaSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlRnJvbUFsbCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVGcm9tQWxsKG91dFZhbHVlKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvdXRWYWx1ZTtcbiAgICAgIGlmICgrK3Jlc29sdmVkID09PSBsZW4gJiYgIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICByZXNvbHZlcihpdGVyYWJsZVtpXSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIHJlc29sdmVyKHZhbHVlKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvLyBUb3AgbGV2ZWwgZmlsZSBpcyBqdXN0IGEgbWl4aW4gb2Ygc3VibW9kdWxlcyAmIGNvbnN0YW50c1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduICAgID0gcmVxdWlyZSgnLi9saWIvdXRpbHMvY29tbW9uJykuYXNzaWduO1xuXG52YXIgZGVmbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvZGVmbGF0ZScpO1xudmFyIGluZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2luZmxhdGUnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2xpYi96bGliL2NvbnN0YW50cycpO1xuXG52YXIgcGFrbyA9IHt9O1xuXG5hc3NpZ24ocGFrbywgZGVmbGF0ZSwgaW5mbGF0ZSwgY29uc3RhbnRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYWtvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG5cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcblxudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxudmFyIFpfREVGTEFURUQgID0gODtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgZGVmbGF0ZVxuICogLSBgZ3ppcGAgKEJvb2xlYW4pIC0gY3JlYXRlIGd6aXAgd3JhcHBlclxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqIC0gYGhlYWRlcmAgKE9iamVjdCkgLSBjdXN0b20gaGVhZGVyIGZvciBnemlwXG4gKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHRcbiAqICAgLSBgdGltZWAgKE51bWJlcikgLSBtb2RpZmljYXRpb24gdGltZSwgdW5peCB0aW1lc3RhbXBcbiAqICAgLSBgb3NgIChOdW1iZXIpIC0gb3BlcmF0aW9uIHN5c3RlbSBjb2RlXG4gKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpXG4gKiAgIC0gYG5hbWVgIChTdHJpbmcpIC0gZmlsZSBuYW1lIChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBjb21tZW50YCAoU3RyaW5nKSAtIGNvbW1lbnQgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWRcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBkZWZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChkZWZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoZGVmbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coZGVmbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgIG1ldGhvZDogWl9ERUZMQVRFRCxcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIG1lbUxldmVsOiA4LFxuICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIHZhciBkaWN0O1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0RlZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBhcnJheSBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IFpfRklOSVNIIDogWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSCkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTtcblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGRlZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIG9uY2UgYWZ0ZXIgeW91IHRlbGwgZGVmbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogZGVmbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBkYXRhID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwYWtvLmRlZmxhdGUoZGF0YSkpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1zZ1tkZWZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkIG9mXG4gKiBkZWZsYXRlIG9uZS5cbiAqKi9cbmZ1bmN0aW9uIGd6aXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuZ3ppcCA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7XG5leHBvcnRzLmd6aXAgPSBnemlwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvaW5mbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgYyAgICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG52YXIgR1poZWFkZXIgICAgID0gcmVxdWlyZSgnLi96bGliL2d6aGVhZGVyJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICpcbiAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbSW5mbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDAsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgLy8gRm9yY2Ugd2luZG93IHNpemUgZm9yIGByYXdgIGRhdGEsIGlmIG5vdCBzZXQgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2Ugd2UgaGF2ZSBubyBoZWFkZXIgZm9yIGF1dG9kZXRlY3QuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsgb3B0LndpbmRvd0JpdHMgPSAtMTU7IH1cbiAgfVxuXG4gIC8vIElmIGB3aW5kb3dCaXRzYCBub3QgZGVmaW5lZCAoYW5kIG1vZGUgbm90IHJhdykgLSBzZXQgYXV0b2RldGVjdCBmbGFnIGZvciBnemlwL2RlZmxhdGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikgJiZcbiAgICAgICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7XG4gIH1cblxuICAvLyBHemlwIGhlYWRlciBoYXMgbm8gaW5mbyBhYm91dCB3aW5kb3dzIHNpemUsIHdlIGNhbiBkbyBhdXRvZGV0ZWN0IG9ubHlcbiAgLy8gZm9yIGRlZmxhdGUuIFNvLCBpZiB3aW5kb3cgc2l6ZSBub3Qgc2V0LCBmb3JjZSBpdCB0byBtYXggd2hlbiBnemlwIHBvc3NpYmxlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPiAxNSkgJiYgKG9wdC53aW5kb3dCaXRzIDwgNDgpKSB7XG4gICAgLy8gYml0IDMgKDE2KSAtPiBnemlwcGVkIGRhdGFcbiAgICAvLyBiaXQgNCAoMzIpIC0+IGF1dG9kZXRlY3QgZ3ppcC9kZWZsYXRlXG4gICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkge1xuICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtICAgPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC53aW5kb3dCaXRzXG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7XG5cbiAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG5cbiAgLy8gU2V0dXAgZGljdGlvbmFyeVxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9XG4gICAgaWYgKG9wdC5yYXcpIHsgLy9JbiByYXcgbW9kZSB3ZSBuZWVkIHRvIHNldCB0aGUgZGljdGlvbmFyeSBlYXJseVxuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpO1xuICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGFcbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0luZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBkZWNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG4gIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyO1xuXG4gIC8vIEZsYWcgdG8gcHJvcGVybHkgcHJvY2VzcyBaX0JVRl9FUlJPUiBvbiB0ZXN0aW5nIGluZmxhdGUgY2FsbFxuICAvLyB3aGVuIHdlIGNoZWNrIHRoYXQgYWxsIG91dHB1dCBkYXRhIHdhcyBmbHVzaGVkLlxuICB2YXIgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBPbmx5IGJpbmFyeSBzdHJpbmdzIGNhbiBiZSBkZWNvbXByZXNzZWQgb24gcHJhY3RpY2VcbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3Rpb25hcnkpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkge1xuICAgICAgc3RhdHVzID0gYy5aX09LO1xuICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSB7IHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7IH1cblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaGVuIG5vIG1vcmUgaW5wdXQgZGF0YSwgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaW50ZXJuYWwgaW5mbGF0ZSBidWZmZXJzXG4gICAgLy8gYXJlIGZsdXNoZWQuIFRoZSBvbmx5IHdheSB0byBkbyBpdCB3aGVuIGF2YWlsX291dCA9IDAgLSBydW4gb25lIG1vcmVcbiAgICAvLyBpbmZsYXRlIHBhc3MuIEJ1dCBpZiBvdXRwdXQgZGF0YSBub3QgZXhpc3RzLCBpbmZsYXRlIHJldHVybiBaX0JVRl9FUlJPUi5cbiAgICAvLyBIZXJlIHdlIHNldCBmbGFnIHRvIHByb2Nlc3MgdGhpcyBlcnJvciBwcm9wZXJseS5cbiAgICAvL1xuICAgIC8vIE5PVEUuIERlZmxhdGUgZG9lcyBub3QgcmV0dXJuIGVycm9yIGluIHRoaXMgY2FzZSBhbmQgZG9lcyBub3QgbmVlZHMgc3VjaFxuICAgIC8vIGxvZ2ljLlxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EKTtcblxuICBpZiAoc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCkge1xuICAgIF9tb2RlID0gYy5aX0ZJTklTSDtcbiAgfVxuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IGMuWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChjLlpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gR2x1ZSAmIGNvbnZlcnQgaGVyZSwgdW50aWwgd2UgdGVhY2ggcGFrbyB0byBzZW5kXG4gICAgICAvLyB1dGY4IGFsaWduZWQgc3RyaW5ncyB0byBvbkRhdGFcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBpbnB1dCA9IHBha28uZGVmbGF0ZShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKVxuICogICBjb25zb2xlLmxvZyhlcnIpO1xuICogfVxuICogYGBgXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHsgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1zZ1tpbmZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xuZXhwb3J0cy51bmd6aXAgID0gaW5mbGF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuZnVuY3Rpb24gX2hhcyhvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJpXG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyBPbiBDaHJvbWUsIHRoZSBhcmd1bWVudHMgaW4gYSBmdW5jdGlvbiBjYWxsIHRoYXQgYXJlIGFsbG93ZWQgaXMgYDY1NTM0YC5cbiAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiB0aGF0LCB3ZSBjYW4gdXNlIHRoaXMgb3B0aW1pemF0aW9uLFxuICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCB0YWtlIGEgc2xvd2VyIHBhdGguXG4gIGlmIChsZW4gPCA2NTUzNCkge1xuICAgIGlmICgoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHx8ICghYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9PSykpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0aWxzLnNocmlua0J1ZihidWYsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vLyBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gYmluYXJ5IHN0cmluZ1xuZXhwb3J0cy5idWYyYmluc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gYnVmMmJpbnN0cmluZyhidWYsIGJ1Zi5sZW5ndGgpO1xufTtcblxuXG4vLyBDb252ZXJ0IGJpbmFyeSBzdHJpbmcgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5iaW5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmID0gbmV3IHV0aWxzLkJ1Zjgoc3RyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufTtcblxuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xuZXhwb3J0cy5idWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBpLCBvdXQsIGMsIGNfbGVuO1xuICB2YXIgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG5cbiAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuXG4gIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgYyA9IGJ1ZltpKytdO1xuICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgIGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbmV4cG9ydHMudXRmOGJvcmRlciA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgcG9zO1xuXG4gIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9XG5cbiAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gIHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzO1xuICB2YXIgc3RyLCBuO1xuICB2YXIgd3JhcDtcbiAgdmFyIGF2YWlsO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlucHV0O1xuICB2YXIgdG1wRGljdDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTtcbiAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdaaGVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xudmFyIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICB2YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIHZhciBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICB2YXIgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICB2YXIgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHZhciB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHZhciB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgdmFyIHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgdmFyIGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICB2YXIgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICB2YXIgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIHZhciBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICB2YXIgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIHZhciBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICB2YXIgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG5cblxuICB2YXIgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTtcbi8vICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTtcbi8vICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIHdpbmRvdyBpbmRleFxuICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0O1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi9cbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICAgICAgY29udGludWUgZG9kaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICB9XG4gIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7XG5cbiAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovXG4gIGxlbiA9IGJpdHMgPj4gMztcbiAgX2luIC09IGxlbjtcbiAgYml0cyAtPSBsZW4gPDwgMztcbiAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gKi9cbiAgc3RybS5uZXh0X2luID0gX2luO1xuICBzdHJtLm5leHRfb3V0ID0gX291dDtcbiAgc3RybS5hdmFpbF9pbiA9IChfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCkpO1xuICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICByZXR1cm47XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgICAgICAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgYWRsZXIzMiAgICAgICA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgICAgICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgaW5mbGF0ZV9mYXN0ICA9IHJlcXVpcmUoJy4vaW5mZmFzdCcpO1xudmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlKCcuL2luZnRyZWVzJyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4vL3ZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xuLy92YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG4vL3ZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbnZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG52YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG52YXIgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG52YXIgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xudmFyICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbnZhciAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbnZhciAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbnZhciAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG52YXIgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG52YXIgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG52YXIgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG52YXIgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG52YXIgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xudmFyICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG52YXIgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG52YXIgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG52YXIgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xudmFyICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG52YXIgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xudmFyICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmZ1bmN0aW9uIHpzd2FwMzIocSkge1xuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn1cblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHdyYXA7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciByZXQ7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHtcbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufVxuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbnZhciB2aXJnaW4gPSB0cnVlO1xuXG52YXIgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5mdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkge1xuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgdmFyIHN5bTtcblxuICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn1cblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7XG4gIHZhciBkaXN0O1xuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIHN0YXRlLndzaXplLCBzdGF0ZS53c2l6ZSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBpbnB1dCwgb3V0cHV0OyAgICAgICAgICAvLyBpbnB1dC9vdXRwdXQgYnVmZmVyc1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgICAgICAgLyogbmV4dCBpbnB1dCBJTkRFWCAqL1xuICB2YXIgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgdmFyIGhhdmUsIGxlZnQ7ICAgICAgICAgICAgIC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBiaXQgYnVmZmVyICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgdmFyIF9pbiwgX291dDsgICAgICAgICAgICAgIC8qIHNhdmUgc3RhcnRpbmcgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGNvcHk7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBzdG9yZWQgb3IgbWF0Y2ggYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcbiAgdmFyIGhlcmUgPSAwOyAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCB0byBjb3B5IGZvciByZXBlYXRzLCBiaXRzIHRvIGRyb3AgKi9cbiAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovXG4gIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIHZhciBvcHRzO1xuXG4gIHZhciBuOyAvLyB0ZW1wb3JhcnkgdmFyIGZvciBORUVEX0JJVFNcblxuICB2YXIgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi9cbiAgICBbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgSEVBRDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRkxBR1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRJTUU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYTEVOOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYVFJBOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVudCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBIQ1JDOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJQ1RJRDpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESUNUOlxuICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEU6XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMTtcbiAgICAgICAgYml0cyAtPSAxO1xuICAgICAgICAvLy0tLS8vXG5cbiAgICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU1RPUkVEOlxuICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWTpcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVEFCTEU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTl86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOOlxuICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVEVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOR1RIOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBNRU06XG4gICAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICAgIGNhc2UgU1lOQzpcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgc3RhdGU7XG4gIHZhciBkaWN0aWQ7XG4gIHZhciByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmV4cG9ydHMuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0O1xuZXhwb3J0cy5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7XG5leHBvcnRzLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kO1xuZXhwb3J0cy5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjtcbmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5O1xuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xuZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7XG5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xuZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbnZhciBNQVhCSVRTID0gMTU7XG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8qIGVzbGludC1kaXNhYmxlIHNwYWNlLXVuYXJ5LW9wcyAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy92YXIgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vdmFyIFpfUkxFICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL3ZhciBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xudmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG52YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIICAgID0gMztcbnZhciBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxudmFyIE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxudmFyIEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xudmFyIGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdO1xuXG52YXIgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM107XG5cbnZhciBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddO1xuXG52YXIgYmxfb3JkZXIgPVxuICBbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG52YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG52YXIgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbnZhciBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxudmFyIF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5mdW5jdGlvbiBkX2NvZGUoZGlzdCkge1xuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5mdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkge1xuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHtcbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgdmFyIHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIHZhciBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICB2YXIgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgdmFyIG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIHZhciB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICB2YXIgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICB2YXIgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpXG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgdmFyIGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkge1xuICB2YXIgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIHZhciBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICB2YXIgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluaXRfYmxvY2socykge1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpXG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICB2YXIgX24yID0gbiAqIDI7XG4gIHZhciBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICB2YXIgdiA9IHMuaGVhcFtrXTtcbiAgdmFyIGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIHZhciBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgdmFyIGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgdmFyIG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIHZhciBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdmFyIG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7XG4gIHZhciBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICB2YXIgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIHZhciBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgdmFyIG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocylcbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgdmFyIG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nID8gc2V0SW1tZWRpYXRlIDpcblx0ZnVuY3Rpb24gc2V0SW1tZWRpYXRlKCkge1xuXHRcdHZhciBhcmdzID0gW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKTtcblx0XHRhcmdzLnNwbGljZSgxLCAwLCAwKTtcblx0XHRzZXRUaW1lb3V0LmFwcGx5KG51bGwsIGFyZ3MpO1xuXHR9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJpbXBvcnQgSlNaaXAgZnJvbSBcImpzemlwXCI7XHJcbmltcG9ydCB7SXVwbG9hZGZpbGVMaXN0fSBmcm9tIFwiLi9JQ29tbW9uXCI7XHJcbmltcG9ydCB7Z2V0QmluYXJ5Q29udGVudH0gZnJvbSBcIi4vY29tbW9uL21ldGhvZFwiXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEhhbmRsZVppcHtcclxuICAgIHVwbG9hZEZpbGU6RmlsZTsgXHJcbiAgICB3b3JrQm9vazpKU1ppcDsgXHJcbiAgICBcclxuICAgIGNvbnN0cnVjdG9yKGZpbGU/OkZpbGUpe1xyXG4gICAgICAgIC8vIFN1cHBvcnQgbm9kZWpzIGZzIHRvIHJlYWQgZmlsZXNcclxuICAgICAgICAvLyBpZihmaWxlIGluc3RhbmNlb2YgRmlsZSl7XHJcbiAgICAgICAgICAgIHRoaXMudXBsb2FkRmlsZSA9IGZpbGU7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG5cclxuICAgIHVuemlwRmlsZShzdWNjZXNzRnVuYzooZmlsZTpJdXBsb2FkZmlsZUxpc3QpPT52b2lkLCBlcnJvckZ1bmM6KGVycjpFcnJvcik9PnZvaWQpOnZvaWQgeyBcclxuICAgICAgICAvLyB2YXIgbmV3X3ppcDpKU1ppcCA9IG5ldyBKU1ppcCgpO1xyXG4gICAgICAgIEpTWmlwLmxvYWRBc3luYyh0aGlzLnVwbG9hZEZpbGUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxKSByZWFkIHRoZSBCbG9iXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oemlwOmFueSkge1xyXG4gICAgICAgICAgICBsZXQgZmlsZUxpc3Q6SXVwbG9hZGZpbGVMaXN0ID0gPEl1cGxvYWRmaWxlTGlzdD57fSwgbGFzdEluZGV4Om51bWJlciA9IE9iamVjdC5rZXlzKHppcC5maWxlcykubGVuZ3RoLCBpbmRleDpudW1iZXI9MDtcclxuICAgICAgICAgICAgemlwLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aDphbnksIHppcEVudHJ5OmFueSkgeyAgLy8gMikgcHJpbnQgZW50cmllc1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lID0gemlwRW50cnkubmFtZTtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZUFyciA9IGZpbGVOYW1lLnNwbGl0KFwiLlwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdWZmaXggPSBmaWxlTmFtZUFycltmaWxlTmFtZUFyci5sZW5ndGgtMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxlVHlwZSA9IFwic3RyaW5nXCI7XHJcbiAgICAgICAgICAgICAgICBpZihzdWZmaXggaW4ge1wicG5nXCI6MSwgXCJqcGVnXCI6MSwgXCJqcGdcIjoxLCBcImdpZlwiOjEsXCJibXBcIjoxLFwidGlmXCI6MSxcIndlYnBcIjoxLH0pe1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVUeXBlID0gXCJiYXNlNjRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3VmZml4PT1cImVtZlwiKXtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHppcEVudHJ5LmFzeW5jKGZpbGVUeXBlKS50aGVuKGZ1bmN0aW9uIChkYXRhOnN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGZpbGVUeXBlPT1cImJhc2U2NFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFwiZGF0YTppbWFnZS9cIisgc3VmZml4ICtcIjtiYXNlNjQsXCIgKyBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaWxlTGlzdFt6aXBFbnRyeS5uYW1lXSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobGFzdEluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobGFzdEluZGV4PT1pbmRleCsxKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0Z1bmMoZmlsZUxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZTpFcnJvcikge1xyXG4gICAgICAgICAgICBlcnJvckZ1bmMoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdW56aXBGaWxlQnlVcmwodXJsOnN0cmluZyxzdWNjZXNzRnVuYzooZmlsZTpJdXBsb2FkZmlsZUxpc3QpPT52b2lkLCBlcnJvckZ1bmM6KGVycjpFcnJvcik9PnZvaWQpOnZvaWQgeyBcclxuICAgICAgICB2YXIgbmV3X3ppcDpKU1ppcCA9IG5ldyBKU1ppcCgpO1xyXG4gICAgICAgIGdldEJpbmFyeUNvbnRlbnQodXJsLCBmdW5jdGlvbihlcnI6YW55LCBkYXRhOmFueSkge1xyXG4gICAgICAgICAgICBpZihlcnIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjsgLy8gb3IgaGFuZGxlIGVyclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIEpTWmlwLmxvYWRBc3luYyhkYXRhKS50aGVuKGZ1bmN0aW9uKHppcDphbnkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxlTGlzdDpJdXBsb2FkZmlsZUxpc3QgPSA8SXVwbG9hZGZpbGVMaXN0Pnt9LCBsYXN0SW5kZXg6bnVtYmVyID0gT2JqZWN0LmtleXMoemlwLmZpbGVzKS5sZW5ndGgsIGluZGV4Om51bWJlcj0wO1xyXG4gICAgICAgICAgICAgICAgemlwLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aDphbnksIHppcEVudHJ5OmFueSkgeyAgLy8gMikgcHJpbnQgZW50cmllc1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZSA9IHppcEVudHJ5Lm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lQXJyID0gZmlsZU5hbWUuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWZmaXggPSBmaWxlTmFtZUFycltmaWxlTmFtZUFyci5sZW5ndGgtMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZVR5cGUgPSBcInN0cmluZ1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN1ZmZpeCBpbiB7XCJwbmdcIjoxLCBcImpwZWdcIjoxLCBcImpwZ1wiOjEsIFwiZ2lmXCI6MSxcImJtcFwiOjEsXCJ0aWZcIjoxLFwid2VicFwiOjEsfSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVUeXBlID0gXCJiYXNlNjRcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzdWZmaXg9PVwiZW1mXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgemlwRW50cnkuYXN5bmMoZmlsZVR5cGUpLnRoZW4oZnVuY3Rpb24gKGRhdGE6YW55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZpbGVUeXBlPT1cImJhc2U2NFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBcImRhdGE6aW1hZ2UvXCIrIHN1ZmZpeCArXCI7YmFzZTY0LFwiICsgZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlTGlzdFt6aXBFbnRyeS5uYW1lXSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGxhc3RJbmRleCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihsYXN0SW5kZXg9PWluZGV4KzEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0Z1bmMoZmlsZUxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZTpFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JGdW5jKGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBuZXdaaXBGaWxlKCk6dm9pZCB7IFxyXG4gICAgICAgIHZhciB6aXAgPSBuZXcgSlNaaXAoKTtcclxuICAgICAgICB0aGlzLndvcmtCb29rID0gIHppcDtcclxuICAgIH1cclxuXHJcbiAgICAvL3RpdGxlOlwibmVzdGVkL2hlbGxvLnR4dFwiLCBjb250ZW50OlwiSGVsbG8gV29ybGRhc2RmYXNmYXNkZmFzZmFzZmFzZmFzZmFzZGZhc1wiXHJcbiAgICBhZGRUb1ppcEZpbGUodGl0bGU6c3RyaW5nLGNvbnRlbnQ6c3RyaW5nKTp2b2lkIHsgXHJcbiAgICAgICAgaWYodGhpcy53b3JrQm9vaz09bnVsbCl7XHJcbiAgICAgICAgICAgIHZhciB6aXAgPSBuZXcgSlNaaXAoKTtcclxuICAgICAgICAgICAgdGhpcy53b3JrQm9vayA9ICB6aXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud29ya0Jvb2suZmlsZSh0aXRsZSwgY29udGVudCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBJTHVja3lGaWxlLCBJTHVja3lGaWxlSW5mbyxJbHVja3lTaGVldCxJbHVja3lTaGVldENlbGxkYXRhLElsdWNreVNoZWV0Q29uZmlnLElsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSxJbHVja3lTaGVldENlbGxkYXRhVmFsdWVNZXJnZSxJTHVja3lTaGVldENlbGxGb3JtYXQsSWx1Y2t5U2hlZXRDb25maWdNZXJnZXMsSWx1Y2t5U2hlZXRDb25maWdNZXJnZSxJTWFwbHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wLElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZSxJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZSxJbHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wLElsdWNreVNoZWV0Um93QW5kQ29sdW1uTGVuLElsdWNreVNoZWV0Um93QW5kQ29sdW1uSGlkZGVuLElsdWNreVNoZWV0U2VsZWN0aW9uLElsdWNreXNoZWV0RnJvemVuLElsdWNreVNoZWV0Q2hhcnQsSWx1Y2t5U2hlZXRQaXZvdFRhYmxlLElsdWNreXNoZWV0Q29uZGl0aW9uRm9ybWF0LElsdWNreXNoZWV0Q2FsY0NoYWluLElMdWNreUlubGluZVN0cmluZyxJbHVja3lJbWFnZSxJbHVja3lJbWFnZUJvcmRlcixJbHVja3lJbWFnZUNyb3AsSWx1Y2t5SW1hZ2VEZWZhdWx0LElsdWNreUltYWdlcywgSWx1Y2t5c2hlZXRIeXBlcmxpbmssIElsdWNreXNoZWV0RGF0YVZlcmlmaWNhdGlvbn0gZnJvbSBcIi4vSUx1Y2tcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5RmlsZUJhc2UgaW1wbGVtZW50cyBJTHVja3lGaWxlIHtcclxuICAgIGluZm86SUx1Y2t5RmlsZUluZm9cclxuICAgIHNoZWV0czpJbHVja3lTaGVldFtdXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreVNoZWV0QmFzZSBpbXBsZW1lbnRzIElsdWNreVNoZWV0e1xyXG4gICAgbmFtZTpzdHJpbmdcclxuICAgIGNvbG9yOnN0cmluZ1xyXG4gICAgY29uZmlnOklsdWNreVNoZWV0Q29uZmlnXHJcbiAgICBpbmRleDpzdHJpbmdcclxuICAgIHN0YXR1czpzdHJpbmdcclxuICAgIG9yZGVyOnN0cmluZ1xyXG4gICAgcm93Om51bWJlclxyXG4gICAgY29sdW1uOm51bWJlclxyXG4gICAgbHVja3lzaGVldF9zZWxlY3Rfc2F2ZTpJbHVja3lTaGVldFNlbGVjdGlvbltdXHJcbiAgICBzY3JvbGxMZWZ0Om51bWJlclxyXG4gICAgc2Nyb2xsVG9wOm51bWJlclxyXG4gICAgem9vbVJhdGlvOm51bWJlclxyXG4gICAgc2hvd0dyaWRMaW5lczpzdHJpbmdcclxuICAgIGRlZmF1bHRDb2xXaWR0aDpudW1iZXJcclxuICAgIGRlZmF1bHRSb3dIZWlnaHQ6bnVtYmVyXHJcblxyXG4gICAgY2VsbGRhdGE6SWx1Y2t5U2hlZXRDZWxsZGF0YVtdXHJcbiAgICBjaGFydDpJbHVja3lTaGVldENoYXJ0W11cclxuXHJcbiAgICBpc1Bpdm90VGFibGU6Ym9vbGVhblxyXG4gICAgcGl2b3RUYWJsZTpJbHVja3lTaGVldFBpdm90VGFibGVcclxuXHJcbiAgICBsdWNreXNoZWV0X2NvbmRpdGlvbmZvcm1hdF9zYXZlOklsdWNreXNoZWV0Q29uZGl0aW9uRm9ybWF0W11cclxuICAgIGZyZWV6ZW46SWx1Y2t5c2hlZXRGcm96ZW5cclxuXHJcbiAgICBjYWxjQ2hhaW46SWx1Y2t5c2hlZXRDYWxjQ2hhaW5bXVxyXG5cclxuICAgIGltYWdlczpJbHVja3lJbWFnZXNcclxuICAgIFxyXG4gICAgZGF0YVZlcmlmaWNhdGlvbjogSWx1Y2t5c2hlZXREYXRhVmVyaWZpY2F0aW9uO1xyXG4gICAgaHlwZXJsaW5rOiBJbHVja3lzaGVldEh5cGVybGlua1xyXG4gICAgaGlkZTogbnVtYmVyO1xyXG4gICAgXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreUZpbGVJbmZvIGltcGxlbWVudHMgSUx1Y2t5RmlsZUluZm97XHJcbiAgICBuYW1lOnN0cmluZ1xyXG4gICAgY3JlYXRvcjpzdHJpbmdcclxuICAgIGxhc3Rtb2RpZmllZGJ5OnN0cmluZ1xyXG4gICAgY3JlYXRlZFRpbWU6c3RyaW5nXHJcbiAgICBtb2RpZmllZFRpbWU6c3RyaW5nXHJcbiAgICBjb21wYW55OnN0cmluZ1xyXG4gICAgYXBwdmVyc2lvbjpzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXRDZWxsZGF0YUJhc2UgaW1wbGVtZW50cyBJbHVja3lTaGVldENlbGxkYXRhe1xyXG4gICAgcjpudW1iZXJcclxuICAgIGM6bnVtYmVyXHJcbiAgICB2OklsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSB8IHN0cmluZyB8IG51bGxcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlIGltcGxlbWVudHMgSWx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVle1xyXG4gICAgY3Q6IEx1Y2t5U2hlZXRDZWxsRm9ybWF0IHwgdW5kZWZpbmVkIC8vY2VsbHR5cGUsQ2VsbCB2YWx1ZSBmb3JtYXQ6IHRleHQsIHRpbWUsIGV0Yy4gbnVtZm10c1xyXG4gICAgYmc6IHN0cmluZyB8IHVuZGVmaW5lZC8vYmFja2dyb3VuZCwjZmZmMDAwLFx0ZmlsbFxyXG4gICAgZmY6IHN0cmluZyB8IHVuZGVmaW5lZC8vZm9udGZhbWlseSwgZm9udHNcclxuICAgIGZjOiBzdHJpbmcgfCB1bmRlZmluZWQvL2ZvbnRjb2xvciBmb250c1xyXG4gICAgYmw6IG51bWJlciB8IHVuZGVmaW5lZC8vQm9sZCwgZm9udHNcclxuICAgIGl0OiBudW1iZXIgfCB1bmRlZmluZWQvL2l0YWxpYywgZm9udHNcclxuICAgIGZzOiBudW1iZXIgfCB1bmRlZmluZWQvL2ZvbnQgc2l6ZSwgZm9udHNcclxuICAgIGNsOiBudW1iZXIgfCB1bmRlZmluZWQvL3N0cmlrZSwgMCBSZWd1bGFyLCAxIHN0cmlrZXMsIGZvbnRzXHJcbiAgICB1bjogbnVtYmVyIHwgdW5kZWZpbmVkLy91bmRlcmxpbmUsIDAgUmVndWxhciwgMSB1bmRlcmxpbmVzLCBmb250c1xyXG4gICAgdnQ6IG51bWJlciB8IHVuZGVmaW5lZC8vVmVydGljYWwgYWxpZ25tZW50LCAwIG1pZGRsZSwgMSB1cCwgMiBkb3duLCBhbGlnbm1lbnRcclxuICAgIGh0OiBudW1iZXIgfCB1bmRlZmluZWQvL0hvcml6b250YWwgYWxpZ25tZW50LDAgY2VudGVyLCAxIGxlZnQsIDIgcmlnaHQsIGFsaWdubWVudFxyXG4gICAgbWM6IElsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZU1lcmdlIHwgdW5kZWZpbmVkIC8vTWVyZ2UgQ2VsbHMsIG1lcmdlQ2VsbHNcclxuICAgIHRyOiBudW1iZXIgfCB1bmRlZmluZWQgLy9UZXh0IHJvdGF0aW9uLDA6IDDjgIEzIFZlcnRpY2FsIHRleHQgYWxpZ25tZW50XHJcbiAgICB0YjogbnVtYmVyIHwgdW5kZWZpbmVkIC8vVGV4dCB3cmFwLDAgdHJ1bmNhdGlvbiwgMSBvdmVyZmxvdywgMiB3b3JkIHdyYXAsIGFsaWdubWVudFxyXG4gICAgdjogc3RyaW5nIHwgdW5kZWZpbmVkIC8vT3JpZ2luYWwgdmFsdWUsIHZcclxuICAgIG06IHN0cmluZyB8IHVuZGVmaW5lZCAvL0Rpc3BsYXkgdmFsdWUsIHZcclxuICAgIGY6IHN0cmluZyB8IHVuZGVmaW5lZCAvL2Zvcm11bGEsIGZcclxuICAgIHJ0Om51bWJlciB8IHVuZGVmaW5lZCAvL3RleHQgcm90YXRpb24gYW5nbGUgMC0xODAgYWxpZ25tZW50XHJcbiAgICBxcDpudW1iZXIgfCB1bmRlZmluZWQgLy9xdW90ZVByZWZpeCwgc2hvdyBudW1iZXIgYXMgc3RyaW5nXHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldENlbGxGb3JtYXQgaW1wbGVtZW50cyBJTHVja3lTaGVldENlbGxGb3JtYXQge1xyXG4gICAgZmE6c3RyaW5nXHJcbiAgICB0OnN0cmluZ1xyXG4gICAgczpMdWNreUlubGluZVN0cmluZ1tdIHwgdW5kZWZpbmVkXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreUlubGluZVN0cmluZyBpbXBsZW1lbnRzIElMdWNreUlubGluZVN0cmluZyB7XHJcbiAgICBmZjpzdHJpbmcgfCB1bmRlZmluZWQgLy9mb250IGZhbWlseVxyXG4gICAgZmM6c3RyaW5nIHwgdW5kZWZpbmVkLy9mb250IGNvbG9yXHJcbiAgICBmczpudW1iZXIgfCB1bmRlZmluZWQvL2ZvbnQgc2l6ZVxyXG4gICAgY2w6bnVtYmVyIHwgdW5kZWZpbmVkLy9zdHJpa2VcclxuICAgIHVuOm51bWJlciB8IHVuZGVmaW5lZC8vdW5kZXJsaW5lXHJcbiAgICBibDpudW1iZXIgfCB1bmRlZmluZWQvL2Jsb2RcclxuICAgIGl0Om51bWJlciB8IHVuZGVmaW5lZC8vaXRhbGljXHJcbiAgICB2YTpudW1iZXIgfCB1bmRlZmluZWQvLzFzdWIgYW5kIDJzdXBlciBhbmQgMG5vbmVcclxuICAgIHY6c3RyaW5nIHwgdW5kZWZpbmVkXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreUNvbmZpZyBpbXBsZW1lbnRzIElsdWNreVNoZWV0Q29uZmlne1xyXG4gICAgbWVyZ2U6SWx1Y2t5U2hlZXRDb25maWdNZXJnZXNcclxuICAgIGJvcmRlckluZm86SWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcFtdXHJcbiAgICAvLyBfYm9yZGVySW5mbzogSU1hcGx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcFxyXG4gICAgcm93bGVuOklsdWNreVNoZWV0Um93QW5kQ29sdW1uTGVuXHJcbiAgICBjb2x1bW5sZW46SWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5MZW5cclxuICAgIHJvd2hpZGRlbjpJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlblxyXG4gICAgY29saGlkZGVuOklsdWNreVNoZWV0Um93QW5kQ29sdW1uSGlkZGVuXHJcblxyXG4gICAgY3VzdG9tSGVpZ2h0OklsdWNreVNoZWV0Um93QW5kQ29sdW1uSGlkZGVuXHJcbiAgICBjdXN0b21XaWR0aDpJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlblxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wIGltcGxlbWVudHMgSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcHtcclxuICAgIHJhbmdlVHlwZTpzdHJpbmdcclxuICAgIC8vIGNlbGxzOnN0cmluZ1tdXHJcbiAgICB2YWx1ZTpJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlIGltcGxlbWVudHMgSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVle1xyXG4gICAgcm93X2luZGV4OiBudW1iZXJcclxuICAgIGNvbF9pbmRleDogbnVtYmVyXHJcbiAgICBsOiBJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZVxyXG4gICAgcjogSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGVcclxuICAgIHQ6IElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxlXHJcbiAgICBiOiBJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZSBpbXBsZW1lbnRzIElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxle1xyXG4gICAgXCJzdHlsZVwiOiBudW1iZXJcclxuICAgIFwiY29sb3JcIjogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreVNoZWV0Q29uZmlnTWVyZ2UgaW1wbGVtZW50cyBJbHVja3lTaGVldENvbmZpZ01lcmdle1xyXG4gICAgcjogbnVtYmVyXHJcbiAgICBjOiBudW1iZXJcclxuICAgIHJzOiBudW1iZXJcclxuICAgIGNzOiBudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5c2hlZXRDYWxjQ2hhaW4gaW1wbGVtZW50cyBJbHVja3lzaGVldENhbGNDaGFpbntcclxuICAgIHI6bnVtYmVyXHJcbiAgICBjOm51bWJlclxyXG4gICAgaW5kZXg6c3RyaW5nIHwgdW5kZWZpbmVkXHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lJbWFnZUJhc2UgaW1wbGVtZW50cyBJbHVja3lJbWFnZXtcclxuICAgIGJvcmRlcjogSWx1Y2t5SW1hZ2VCb3JkZXJcclxuICAgIGNyb3A6IElsdWNreUltYWdlQ3JvcFxyXG4gICAgZGVmYXVsdDogSWx1Y2t5SW1hZ2VEZWZhdWx0XHJcblxyXG4gICAgZml4ZWRMZWZ0OiBudW1iZXJcclxuICAgIGZpeGVkVG9wOiBudW1iZXJcclxuICAgIGlzRml4ZWRQb3M6IEJvb2xlYW5cclxuICAgIG9yaWdpbkhlaWdodDogbnVtYmVyXHJcbiAgICBvcmlnaW5XaWR0aDogbnVtYmVyXHJcbiAgICBzcmM6IHN0cmluZ1xyXG4gICAgdHlwZTogc3RyaW5nXHJcbn0iLCJpbXBvcnQgeyBJbHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wLElsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSxJbHVja3lTaGVldENlbGxkYXRhVmFsdWVNZXJnZSxJTHVja3lTaGVldENlbGxGb3JtYXQgfSBmcm9tIFwiLi9JTHVja1wiO1xyXG5pbXBvcnQgeyBSZWFkWG1sLCBFbGVtZW50LCBJU3R5bGVDb2xsZWN0aW9ucyxnZXRDb2xvcixnZXRsaW5lU3RyaW5nQXR0ciB9IGZyb20gXCIuL1JlYWRYbWxcIjtcclxuaW1wb3J0IHtnZXRYbWxBdHRpYnV0ZSwgZ2V0Q29sdW1uV2lkdGhQaXhlbCwgZ2V0Um93SGVpZ2h0UGl4ZWwsZ2V0Y2VsbHJhbmdlLCBlc2NhcGVDaGFyYWN0ZXIsIGlzQ2hpbmVzZSwgaXNKYXBhbmVzZSwgaXNLb2VyYSxpc0NvbnRhaW5NdWx0aVR5cGV9IGZyb20gXCIuLi9jb21tb24vbWV0aG9kXCI7XHJcbmltcG9ydCB7IFNUX0NlbGxUeXBlLCBpbmRleGVkQ29sb3JzLCBPRU1fQ0hBUlNFVCxib3JkZXJUeXBlcyxmb250RmFtaWx5cyB9IGZyb20gXCIuLi9jb21tb24vY29uc3RhbnRcIlxyXG5pbXBvcnQgeyBJYXR0cmlidXRlTGlzdCwgc3RyaW5nVG9OdW0gfSBmcm9tIFwiLi4vSUNvbW1vblwiO1xyXG5pbXBvcnQgeyBMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxlLEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCxMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZSxMdWNreVNoZWV0Q2VsbGRhdGFCYXNlLEx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlLEx1Y2t5U2hlZXRDZWxsRm9ybWF0LEx1Y2t5SW5saW5lU3RyaW5nIH0gZnJvbSBcIi4vTHVja3lCYXNlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldENlbGxkYXRhIGV4dGVuZHMgTHVja3lTaGVldENlbGxkYXRhQmFzZXtcclxuICAgIF9ib3JkZXJPYmplY3Q6SWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcFxyXG4gICAgX2ZvbXVsYVJlZjpzdHJpbmdcclxuICAgIF9mb3JtdWxhU2k6c3RyaW5nXHJcbiAgICBfZm9ybXVsYVR5cGU6c3RyaW5nXHJcblxyXG4gICAgcHJpdmF0ZSBzaGVldEZpbGU6c3RyaW5nXHJcbiAgICBwcml2YXRlIHJlYWRYbWw6UmVhZFhtbFxyXG4gICAgcHJpdmF0ZSBjZWxsOkVsZW1lbnRcclxuICAgIHByaXZhdGUgc3R5bGVzOklTdHlsZUNvbGxlY3Rpb25zXHJcbiAgICBwcml2YXRlIHNoYXJlZFN0cmluZ3M6RWxlbWVudFtdXHJcbiAgICBwcml2YXRlIG1lcmdlQ2VsbHM6RWxlbWVudFtdXHJcblxyXG4gICAgY29uc3RydWN0b3IoY2VsbDpFbGVtZW50LCBzdHlsZXM6SVN0eWxlQ29sbGVjdGlvbnMsIHNoYXJlZFN0cmluZ3M6RWxlbWVudFtdLCBtZXJnZUNlbGxzOkVsZW1lbnRbXSwgc2hlZXRGaWxlOnN0cmluZywgUmVhZFhtbDpSZWFkWG1sKXtcclxuICAgICAgICAvL1ByaXZhdGVcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY2VsbCA9IGNlbGw7XHJcbiAgICAgICAgdGhpcy5zaGVldEZpbGUgPSBzaGVldEZpbGU7XHJcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRTdHJpbmdzID0gc2hhcmVkU3RyaW5ncztcclxuICAgICAgICB0aGlzLnJlYWRYbWwgPSBSZWFkWG1sO1xyXG4gICAgICAgIHRoaXMubWVyZ2VDZWxscyA9IG1lcmdlQ2VsbHM7XHJcblxyXG4gICAgICAgIGxldCBhdHRyTGlzdCA9IGNlbGwuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICBsZXQgciA9IGF0dHJMaXN0LnIsIHMgPSBhdHRyTGlzdC5zLCB0ID0gYXR0ckxpc3QudDtcclxuICAgICAgICBsZXQgcmFuZ2UgPSBnZXRjZWxscmFuZ2Uocik7XHJcblxyXG4gICAgICAgIHRoaXMuciA9IHJhbmdlLnJvd1swXTtcclxuICAgICAgICB0aGlzLmMgPSByYW5nZS5jb2x1bW5bMF07XHJcbiAgICAgICAgdGhpcy52ID0gdGhpcy5nZW5lcmF0ZVZhbHVlKHMsIHQpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQHBhcmFtIHMgU3R5bGUgaW5kZXggLHN0YXJ0IDFcclxuICAgICogQHBhcmFtIHQgQ2VsbCB0eXBlLCBPcHRpb25hbCB2YWx1ZSBpcyBTVF9DZWxsVHlwZSwgaXQncyBmb3VuZCBhdCBjb25zdGF0LnRzXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZVZhbHVlKHM6c3RyaW5nLCB0OnN0cmluZyl7XHJcbiAgICAgICAgbGV0IHYgPSB0aGlzLmNlbGwuZ2V0SW5uZXJFbGVtZW50cyhcInZcIik7XHJcbiAgICAgICAgbGV0IGYgPSB0aGlzLmNlbGwuZ2V0SW5uZXJFbGVtZW50cyhcImZcIik7XHJcblxyXG4gICAgICAgIGlmKHY9PW51bGwpe1xyXG4gICAgICAgICAgICB2ID0gdGhpcy5jZWxsLmdldElubmVyRWxlbWVudHMoXCJ0XCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNlbGxYZnMgPSB0aGlzLnN0eWxlc1tcImNlbGxYZnNcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgICAgIGxldCBjZWxsU3R5bGVYZnMgPSB0aGlzLnN0eWxlc1tcImNlbGxTdHlsZVhmc1wiXSBhcyBFbGVtZW50W107XHJcbiAgICAgICAgbGV0IGNlbGxTdHlsZXMgPSB0aGlzLnN0eWxlc1tcImNlbGxTdHlsZXNcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgICAgIGxldCBmb250cyA9IHRoaXMuc3R5bGVzW1wiZm9udHNcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgICAgIGxldCBmaWxscyA9IHRoaXMuc3R5bGVzW1wiZmlsbHNcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgICAgIGxldCBib3JkZXJzID0gdGhpcy5zdHlsZXNbXCJib3JkZXJzXCJdIGFzIEVsZW1lbnRbXTtcclxuICAgICAgICBsZXQgbnVtZm10cyA9IHRoaXMuc3R5bGVzW1wibnVtZm10c1wiXSBhcyBJYXR0cmlidXRlTGlzdDtcclxuICAgICAgICBsZXQgY2xyU2NoZW1lID0gdGhpcy5zdHlsZXNbXCJjbHJTY2hlbWVcIl0gYXMgRWxlbWVudFtdO1xyXG5cclxuICAgICAgICBsZXQgc2hhcmVkU3RyaW5ncyA9IHRoaXMuc2hhcmVkU3RyaW5ncztcclxuICAgICAgICBsZXQgY2VsbFZhbHVlID0gbmV3IEx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlKCk7XHJcblxyXG4gICAgICAgIGlmKGYhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgZm9ybXVsYSA9IGZbMF0sIGF0dHJMaXN0ID0gZm9ybXVsYS5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICBsZXQgdCA9IGF0dHJMaXN0LnQsIHJlZiA9IGF0dHJMaXN0LnJlZiwgc2kgPSBhdHRyTGlzdC5zaTtcclxuICAgICAgICAgICAgbGV0IGZvcm11bGFWYWx1ZSA9ZlswXS52YWx1ZTtcclxuICAgICAgICAgICAgaWYodD09XCJzaGFyZWRcIil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb211bGFSZWYgPSByZWY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JtdWxhVHlwZSA9IHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JtdWxhU2kgPSBzaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZWYsIHQsIHNpKTtcclxuICAgICAgICAgICAgaWYocmVmIT1udWxsIHx8IChmb3JtdWxhVmFsdWUhPW51bGwgJiYgZm9ybXVsYVZhbHVlLmxlbmd0aD4wKSl7XHJcbiAgICAgICAgICAgICAgICBmb3JtdWxhVmFsdWUgPSBlc2NhcGVDaGFyYWN0ZXIoZm9ybXVsYVZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5mID0gXCI9XCIgKyBmb3JtdWxhVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZmFtaWx5Rm9udCA9IG51bGw7XHJcbiAgICAgICAgbGV0IHF1b3RlUHJlZml4O1xyXG4gICAgICAgIGlmKHMhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgc051bSA9IHBhcnNlSW50KHMpO1xyXG4gICAgICAgICAgICBsZXQgY2VsbFhmID0gY2VsbFhmc1tzTnVtXTtcclxuICAgICAgICAgICAgbGV0IHhmSWQgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC54ZklkO1xyXG5cclxuICAgICAgICAgICAgbGV0IG51bUZtdElkLGZvbnRJZCxmaWxsSWQsYm9yZGVySWQ7XHJcbiAgICAgICAgICAgIGxldCBob3Jpem9udGFsLHZlcnRpY2FsLCB3cmFwVGV4dCwgdGV4dFJvdGF0aW9uLCBzaHJpbmtUb0ZpdCwgaW5kZW50LGFwcGx5UHJvdGVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGlmKHhmSWQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbGxTdHlsZVhmID0gY2VsbFN0eWxlWGZzW3BhcnNlSW50KHhmSWQpXTtcclxuICAgICAgICAgICAgICAgIGxldCBhdHRyTGlzdCA9IGNlbGxTdHlsZVhmLmF0dHJpYnV0ZUxpc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGFwcGx5TnVtYmVyRm9ybWF0ID0gYXR0ckxpc3QuYXBwbHlOdW1iZXJGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXBwbHlGb250ID0gYXR0ckxpc3QuYXBwbHlGb250O1xyXG4gICAgICAgICAgICAgICAgbGV0IGFwcGx5RmlsbCA9IGF0dHJMaXN0LmFwcGx5RmlsbDtcclxuICAgICAgICAgICAgICAgIGxldCBhcHBseUJvcmRlciA9IGF0dHJMaXN0LmFwcGx5Qm9yZGVyO1xyXG4gICAgICAgICAgICAgICAgbGV0IGFwcGx5QWxpZ25tZW50ID0gYXR0ckxpc3QuYXBwbHlBbGlnbm1lbnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBsZXQgYXBwbHlQcm90ZWN0aW9uID0gYXR0ckxpc3QuYXBwbHlQcm90ZWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIGFwcGx5UHJvdGVjdGlvbiA9IGF0dHJMaXN0LmFwcGx5UHJvdGVjdGlvbjtcclxuICAgICAgICAgICAgICAgIHF1b3RlUHJlZml4ID0gYXR0ckxpc3QucXVvdGVQcmVmaXg7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYXBwbHlOdW1iZXJGb3JtYXQhPVwiMFwiICYmIGF0dHJMaXN0Lm51bUZtdElkIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZihhdHRyTGlzdC5udW1GbXRJZCE9XCIwXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1GbXRJZCA9IGF0dHJMaXN0Lm51bUZtdElkO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGFwcGx5Rm9udCE9XCIwXCIgJiYgYXR0ckxpc3QuZm9udElkIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBmb250SWQgPSBhdHRyTGlzdC5mb250SWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihhcHBseUZpbGwhPVwiMFwiICYmIGF0dHJMaXN0LmZpbGxJZCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbElkID0gYXR0ckxpc3QuZmlsbElkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoYXBwbHlCb3JkZXIhPVwiMFwiICYmIGF0dHJMaXN0LmJvcmRlcklkIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJJZCA9IGF0dHJMaXN0LmJvcmRlcklkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoYXBwbHlBbGlnbm1lbnQhPW51bGwgJiYgYXBwbHlBbGlnbm1lbnQhPVwiMFwiKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gY2VsbFN0eWxlWGYuZ2V0SW5uZXJFbGVtZW50cyhcImFsaWdubWVudFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihhbGlnbm1lbnQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSBhbGlnbm1lbnRbMF0uYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QuaG9yaXpvbnRhbCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsID0gYXR0ckxpc3QuaG9yaXpvbnRhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC52ZXJ0aWNhbCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbCA9IGF0dHJMaXN0LnZlcnRpY2FsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LndyYXBUZXh0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBUZXh0ID0gYXR0ckxpc3Qud3JhcFRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QudGV4dFJvdGF0aW9uIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRSb3RhdGlvbiA9IGF0dHJMaXN0LnRleHRSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC5zaHJpbmtUb0ZpdCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHJpbmtUb0ZpdCA9IGF0dHJMaXN0LnNocmlua1RvRml0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LmluZGVudCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSBhdHRyTGlzdC5pbmRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBhcHBseU51bWJlckZvcm1hdCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LmFwcGx5TnVtYmVyRm9ybWF0O1xyXG4gICAgICAgICAgICBsZXQgYXBwbHlGb250ID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlGb250O1xyXG4gICAgICAgICAgICBsZXQgYXBwbHlGaWxsID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlGaWxsO1xyXG4gICAgICAgICAgICBsZXQgYXBwbHlCb3JkZXIgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5hcHBseUJvcmRlcjtcclxuICAgICAgICAgICAgbGV0IGFwcGx5QWxpZ25tZW50ID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlBbGlnbm1lbnQ7XHJcblxyXG4gICAgICAgICAgICBpZihjZWxsWGYuYXR0cmlidXRlTGlzdC5hcHBseVByb3RlY3Rpb24hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgYXBwbHlQcm90ZWN0aW9uID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlQcm90ZWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihjZWxsWGYuYXR0cmlidXRlTGlzdC5xdW90ZVByZWZpeCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBxdW90ZVByZWZpeCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LnF1b3RlUHJlZml4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihhcHBseU51bWJlckZvcm1hdCE9XCIwXCIgJiYgY2VsbFhmLmF0dHJpYnV0ZUxpc3QubnVtRm10SWQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgbnVtRm10SWQgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5udW1GbXRJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihhcHBseUZvbnQhPVwiMFwiKXtcclxuICAgICAgICAgICAgICAgIGZvbnRJZCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LmZvbnRJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihhcHBseUZpbGwhPVwiMFwiKXtcclxuICAgICAgICAgICAgICAgIGZpbGxJZCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LmZpbGxJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihhcHBseUJvcmRlciE9XCIwXCIpe1xyXG4gICAgICAgICAgICAgICAgYm9yZGVySWQgPWNlbGxYZi5hdHRyaWJ1dGVMaXN0LmJvcmRlcklkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGFwcGx5QWxpZ25tZW50IT1cIjBcIil7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gY2VsbFhmLmdldElubmVyRWxlbWVudHMoXCJhbGlnbm1lbnRcIik7XHJcbiAgICAgICAgICAgICAgICBpZihhbGlnbm1lbnQhPW51bGwgJiYgYWxpZ25tZW50Lmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSBhbGlnbm1lbnRbMF0uYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC5ob3Jpem9udGFsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbCA9IGF0dHJMaXN0Lmhvcml6b250YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LnZlcnRpY2FsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWwgPSBhdHRyTGlzdC52ZXJ0aWNhbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3Qud3JhcFRleHQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwVGV4dCA9IGF0dHJMaXN0LndyYXBUZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC50ZXh0Um90YXRpb24hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Um90YXRpb24gPSBhdHRyTGlzdC50ZXh0Um90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LnNocmlua1RvRml0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hyaW5rVG9GaXQgPSBhdHRyTGlzdC5zaHJpbmtUb0ZpdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QuaW5kZW50IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gYXR0ckxpc3QuaW5kZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBpZihudW1GbXRJZCE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIGxldCBudW1mID0gbnVtZm10c1twYXJzZUludChudW1GbXRJZCldO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbGxGb3JtYXQgPSBuZXcgTHVja3lTaGVldENlbGxGb3JtYXQoKTtcclxuICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQuZmEgPSBlc2NhcGVDaGFyYWN0ZXIobnVtZik7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhudW1mLCBudW1GbXRJZCwgdGhpcy52KTtcclxuICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQudCA9IHQgfHwgJ2QnO1xyXG4gICAgICAgICAgICAgICAgY2VsbFZhbHVlLmN0ID0gY2VsbEZvcm1hdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZmlsbElkIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGxJZE51bSA9IHBhcnNlSW50KGZpbGxJZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsbCAgPSBmaWxsc1tmaWxsSWROdW1dO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY2VsbFZhbHVlLnYpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJnID0gdGhpcy5nZXRCYWNrZ3JvdW5kQnlGaWxsKGZpbGwsIGNsclNjaGVtZSk7XHJcbiAgICAgICAgICAgICAgICBpZihiZyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmJnID0gYmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBpZihmb250SWQhPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZm9udElkTnVtID0gcGFyc2VJbnQoZm9udElkKTtcclxuICAgICAgICAgICAgICAgIGxldCBmb250ID0gZm9udHNbZm9udElkTnVtXTtcclxuICAgICAgICAgICAgICAgIGlmKGZvbnQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzeiA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcInN6XCIpOy8vZm9udCBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9ycyA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcImNvbG9yXCIpOy8vZm9udCBjb2xvclxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmYW1pbHkgPSBmb250LmdldElubmVyRWxlbWVudHMoXCJuYW1lXCIpOy8vZm9udCBmYW1pbHlcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmFtaWx5T3ZlcnJpZGVzID0gZm9udC5nZXRJbm5lckVsZW1lbnRzKFwiZmFtaWx5XCIpOy8vZm9udCBmYW1pbHkgd2lsbCBiZSBvdmVycmlkZWQgYnkgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGFyc2V0ID0gZm9udC5nZXRJbm5lckVsZW1lbnRzKFwiY2hhcnNldFwiKTsvL2ZvbnQgY2hhcnNldFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBib2xkcyA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcImJcIik7Ly9mb250IGJvbGRcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXRhbGljcyA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcImlcIik7Ly9mb250IGl0YWxpY1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHJpa2VzID0gZm9udC5nZXRJbm5lckVsZW1lbnRzKFwic3RyaWtlXCIpOy8vZm9udCBpdGFsaWNcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdW5kZXJsaW5lcyA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcInVcIik7Ly9mb250IGl0YWxpY1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihzeiE9bnVsbCAmJiBzei5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcyA9IHN6WzBdLmF0dHJpYnV0ZUxpc3QudmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmcyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuZnMgPSBwYXJzZUludChmcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihjb2xvcnMhPW51bGwgJiYgY29sb3JzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gY29sb3JzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmMgPSBnZXRDb2xvcihjb2xvciwgdGhpcy5zdHlsZXMsIFwidFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmZjID0gZmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihmYW1pbHlPdmVycmlkZXMhPW51bGwgJiYgZmFtaWx5T3ZlcnJpZGVzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IGZhbWlseU92ZXJyaWRlc1swXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodmFsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbWlseUZvbnQgPSBmb250RmFtaWx5c1t2YWxdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihmYW1pbHkhPW51bGwgJiYgZmFtaWx5Lmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IGZhbWlseVswXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodmFsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5mZiA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGJvbGRzIT1udWxsICYmIGJvbGRzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJvbGQgPSBib2xkc1swXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYm9sZD09XCIwXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmJsID0gIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5ibCA9ICAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihpdGFsaWNzIT1udWxsICYmIGl0YWxpY3MubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRhbGljID0gaXRhbGljc1swXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRhbGljPT1cIjBcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaXQgPSAgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLml0ID0gIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN0cmlrZXMhPW51bGwgJiYgc3RyaWtlcy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdHJpa2UgPSBzdHJpa2VzWzBdLmF0dHJpYnV0ZUxpc3QudmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzdHJpa2U9PVwiMFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5jbCA9ICAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuY2wgPSAgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodW5kZXJsaW5lcyE9bnVsbMKgJibCoHVuZGVybGluZXMubGVuZ3RoPjApe1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBsZXTCoHVuZGVybGluZcKgPcKgdW5kZXJsaW5lc1swXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgaWYodW5kZXJsaW5lPT1cInNpbmdsZVwiKXtcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjZWxsVmFsdWUudW7CoD3CoMKgMTtcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfVxyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBlbHNlwqBpZih1bmRlcmxpbmU9PVwiZG91YmxlXCIpe1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNlbGxWYWx1ZS51bsKgPcKgwqAyO1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGVsc2XCoGlmKHVuZGVybGluZT09XCJzaW5nbGVBY2NvdW50aW5nXCIpe1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNlbGxWYWx1ZS51bsKgPcKgwqAzO1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGVsc2XCoGlmKHVuZGVybGluZT09XCJkb3VibGVBY2NvdW50aW5nXCIpe1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNlbGxWYWx1ZS51bsKgPcKgwqA0O1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGVsc2V7XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY2VsbFZhbHVlLnVuwqA9wqDCoDA7XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH1cclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdnQ6IG51bWJlciB8IHVuZGVmaW5lZC8vVmVydGljYWwgYWxpZ25tZW50LCAwIG1pZGRsZSwgMSB1cCwgMiBkb3duLCBhbGlnbm1lbnRcclxuICAgICAgICAgICAgLy8gaHQ6IG51bWJlciB8IHVuZGVmaW5lZC8vSG9yaXpvbnRhbCBhbGlnbm1lbnQsMCBjZW50ZXIsIDEgbGVmdCwgMiByaWdodCwgYWxpZ25tZW50XHJcbiAgICAgICAgICAgIC8vIHRyOiBudW1iZXIgfCB1bmRlZmluZWQgLy9UZXh0IHJvdGF0aW9uLDA6IDDjgIExOiA0NSDjgIEyOiAtNDXjgIEzIFZlcnRpY2FsIHRleHTjgIE0OiA5MCDjgIE1OiAtOTAsIGFsaWdubWVudFxyXG4gICAgICAgICAgICAvLyB0YjogbnVtYmVyIHwgdW5kZWZpbmVkIC8vVGV4dCB3cmFwLDAgdHJ1bmNhdGlvbiwgMSBvdmVyZmxvdywgMiB3b3JkIHdyYXAsIGFsaWdubWVudFxyXG5cclxuICAgICAgICAgICAgaWYoaG9yaXpvbnRhbCE9dW5kZWZpbmVkKXsvL0hvcml6b250YWwgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICBpZihob3Jpem9udGFsPT1cImNlbnRlclwiKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihob3Jpem9udGFsPT1cImNlbnRlckNvbnRpbnVvdXNcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmh0ID0gMDsvL2x1Y2t5c2hlZXQgdW5zdXBwb3J0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGhvcml6b250YWw9PVwibGVmdFwiKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaHQgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihob3Jpem9udGFsPT1cInJpZ2h0XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5odCA9IDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGhvcml6b250YWw9PVwiZGlzdHJpYnV0ZWRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmh0ID0gMDsvL2x1Y2t5c2hlZXQgdW5zdXBwb3J0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGhvcml6b250YWw9PVwiZmlsbFwiKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaHQgPSAxOy8vbHVja3lzaGVldCB1bnN1cHBvcnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaG9yaXpvbnRhbD09XCJnZW5lcmFsXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5odCA9IDE7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihob3Jpem9udGFsPT1cImp1c3RpZnlcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmh0ID0gMDsvL2x1Y2t5c2hlZXQgdW5zdXBwb3J0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5odCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHZlcnRpY2FsIT11bmRlZmluZWQpey8vVmVydGljYWwgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICBpZih2ZXJ0aWNhbD09XCJib3R0b21cIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnZ0ID0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodmVydGljYWw9PVwiY2VudGVyXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52dCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHZlcnRpY2FsPT1cImRpc3RyaWJ1dGVkXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52dCA9IDA7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZih2ZXJ0aWNhbD09XCJqdXN0aWZ5XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52dCA9IDA7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZih2ZXJ0aWNhbD09XCJ0b3BcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnZ0ID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnZ0ID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vc29tZXRpbWVzIGJvdHRvbSBzdHlsZSBpcyBsb3N0IGFmdGVyIHNldHRpbmcgaXQgaW4gZXhjZWxcclxuICAgICAgICAgICAgICAgIC8vd2hlbiB2ZXJ0aWNhbCBpcyB1bmRlZmluZWQgc2V0IGl0IHRvIDIuXHJcbiAgICAgICAgICAgICAgICBjZWxsVmFsdWUudnQgPSAyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih3cmFwVGV4dCE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIGlmKHdyYXBUZXh0PT1cIjFcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnRiID0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnRiID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgY2VsbFZhbHVlLnRiID0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYodGV4dFJvdGF0aW9uIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgLy8gdHI6IG51bWJlciB8IHVuZGVmaW5lZCAvL1RleHQgcm90YXRpb24sMDogMOOAgTE6IDQ1IOOAgTI6IC00NeOAgTMgVmVydGljYWwgdGV4dOOAgTQ6IDkwIOOAgTU6IC05MCwgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICBpZih0ZXh0Um90YXRpb249PVwiMjU1XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS50ciA9IDM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBlbHNlIGlmKHRleHRSb3RhdGlvbj09XCI0NVwiKXtcclxuICAgICAgICAgICAgICAgIC8vICAgICBjZWxsVmFsdWUudHIgPSAxO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgLy8gZWxzZSBpZih0ZXh0Um90YXRpb249PVwiOTBcIil7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgY2VsbFZhbHVlLnRyID0gNDtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYodGV4dFJvdGF0aW9uPT1cIjEzNVwiKXtcclxuICAgICAgICAgICAgICAgIC8vICAgICBjZWxsVmFsdWUudHIgPSAyO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgLy8gZWxzZSBpZih0ZXh0Um90YXRpb249PVwiMTgwXCIpe1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGNlbGxWYWx1ZS50ciA9IDU7XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS50ciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnJ0ID0gIHBhcnNlSW50KHRleHRSb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoc2hyaW5rVG9GaXQhPXVuZGVmaW5lZCl7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoaW5kZW50IT11bmRlZmluZWQpey8vbHVja3lzaGVldCB1bnN1cHBvcnRcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGJvcmRlcklkIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvcmRlcklkTnVtID0gcGFyc2VJbnQoYm9yZGVySWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvcmRlciA9IGJvcmRlcnNbYm9yZGVySWROdW1dO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fYm9yZGVySWQgPSBib3JkZXJJZE51bTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgYm9yZGVyT2JqZWN0ID0gbmV3IEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCgpO1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyT2JqZWN0LnJhbmdlVHlwZSA9IFwiY2VsbFwiO1xyXG4gICAgICAgICAgICAgICAgLy8gYm9yZGVyT2JqZWN0LmNlbGxzID0gW107XHJcbiAgICAgICAgICAgICAgICBsZXQgYm9yZGVyQ2VsbFZhbHVlID0gbmV3IEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLnJvd19pbmRleCA9IHRoaXMucjtcclxuICAgICAgICAgICAgICAgIGJvcmRlckNlbGxWYWx1ZS5jb2xfaW5kZXggPSB0aGlzLmM7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGxlZnRzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJsZWZ0XCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0cyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwicmlnaHRcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG9wcyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwidG9wXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvdHRvbXMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcImJvdHRvbVwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBkaWFnb25hbHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcImRpYWdvbmFsXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBzdGFydHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcInN0YXJ0XCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVuZHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcImVuZFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhsZWZ0cyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLmdldEJvcmRlckluZm8ocmlnaHRzKTtcclxuICAgICAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLmdldEJvcmRlckluZm8odG9wcyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgYm90dG9tID0gdGhpcy5nZXRCb3JkZXJJbmZvKGJvdHRvbXMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpYWdvbmFsID0gdGhpcy5nZXRCb3JkZXJJbmZvKGRpYWdvbmFscyk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5nZXRCb3JkZXJJbmZvKHN0YXJ0cyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5nZXRCb3JkZXJJbmZvKGVuZHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBpc0FkZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN0YXJ0IT1udWxsICYmIHN0YXJ0LmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUubCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWRkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihlbmQhPW51bGwgJiYgZW5kLmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUuciA9IGVuZDtcclxuICAgICAgICAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYobGVmdCE9bnVsbCAmJiBsZWZ0LmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUubCA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHJpZ2h0IT1udWxsICYmIHJpZ2h0LmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUuciA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWRkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZih0b3AhPW51bGwgJiYgdG9wLmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUudCA9IHRvcDtcclxuICAgICAgICAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYm90dG9tIT1udWxsICYmIGJvdHRvbS5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLmIgPSBib3R0b207XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGlzQWRkKXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXJPYmplY3QudmFsdWUgPSBib3JkZXJDZWxsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5jb25maWcuX2JvcmRlckluZm9bYm9yZGVySWRdID0gYm9yZGVyT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JvcmRlck9iamVjdCA9IGJvcmRlck9iamVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgY2VsbFZhbHVlLnRiID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHYhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPXZbMF0udmFsdWU7XHJcblxyXG4gICAgICAgICAgICBpZigvJiNcXGQrOy8udGVzdCh2YWx1ZSkpe1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmh0bWxEZWNvZGUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih0PT1TVF9DZWxsVHlwZVtcIlNoYXJlZFN0cmluZ1wiXSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2lJbmRleCA9IHBhcnNlSW50KHZbMF0udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNoYXJlZFNJID0gc2hhcmVkU3RyaW5nc1tzaUluZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgckZsYWcgPSBzaGFyZWRTSS5nZXRJbm5lckVsZW1lbnRzKFwiclwiKTtcclxuICAgICAgICAgICAgICAgIGlmKHJGbGFnPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdEZsYWcgPSBzaGFyZWRTSS5nZXRJbm5lckVsZW1lbnRzKFwidFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZih0RmxhZyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdEZsYWcuZm9yRWFjaCgodCk9PntcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gdC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlQ2hhcmFjdGVyKHRleHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pc0NvbnRhaW5NdWx0aVR5cGUodGV4dCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmFtaWx5Rm9udD09XCJSb21hblwiICYmIHRleHQubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHRBcnJheSA9IHRleHQuc3BsaXQoXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJlV29yZFR5cGU6c3RyaW5nID0gbnVsbCwgd29yZFRleHQ9XCJcIiwgcHJlV2hvbGVmOnN0cmluZz1udWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdob2xlZiA9IFwiVGltZXMgTmV3IFJvbWFuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZmYhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdob2xlZiA9IGNlbGxWYWx1ZS5mZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbEZvcm1hdCA9IGNlbGxWYWx1ZS5jdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxGb3JtYXQ9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQgPSBuZXcgTHVja3lTaGVldENlbGxGb3JtYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsRm9ybWF0LnM9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8dGV4dEFycmF5Lmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3ID0gdGV4dEFycmF5W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eXBlOnN0cmluZyA9IG51bGwsIGZmPXdob2xlZjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNDaGluZXNlKHcpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwiY1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZj1cIuWui+S9k1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGlzSmFwYW5lc2Uodykpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJqXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZmPVwiWXUgR290aGljXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNLb2VyYSh3KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImtcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmY9XCJNYWxndW4gR290aGljXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImVcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCh0eXBlIT1wcmVXb3JkVHlwZSAmJiBwcmVXb3JkVHlwZSE9bnVsbCkgfHwgaT09dGV4dEFycmF5Lmxlbmd0aC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IElubGluZVN0cmluZyA9IG5ldyBMdWNreUlubGluZVN0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZmID0gcHJlV2hvbGVmO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmZjIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mYyA9IGNlbGxWYWx1ZS5mYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmZzIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mcyA9IGNlbGxWYWx1ZS5mcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmNsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5jbCA9IGNlbGxWYWx1ZS5jbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLnVuIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy51biA9IGNlbGxWYWx1ZS51bjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmJsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5ibCA9IGNlbGxWYWx1ZS5ibDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLml0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5pdCA9IGNlbGxWYWx1ZS5pdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaT09dGV4dEFycmF5Lmxlbmd0aC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGU9PXByZVdvcmRUeXBlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmYgPSBmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudiA9IHdvcmRUZXh0ICsgdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZmID0gcHJlV2hvbGVmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy52ID0gd29yZFRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEZvcm1hdC5zLnB1c2goSW5saW5lU3RyaW5nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IElubGluZVN0cmluZ0xhc3QgPSBuZXcgTHVja3lJbmxpbmVTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmdMYXN0LmZmID0gZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC52ID0gdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZmMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmdMYXN0LmZjID0gY2VsbFZhbHVlLmZjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmZzIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC5mcyA9IGNlbGxWYWx1ZS5mcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5jbCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZ0xhc3QuY2wgPSBjZWxsVmFsdWUuY2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUudW4hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmdMYXN0LnVuID0gY2VsbFZhbHVlLnVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmJsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC5ibCA9IGNlbGxWYWx1ZS5ibDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5pdCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZ0xhc3QuaXQgPSBjZWxsVmFsdWUuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQucy5wdXNoKElubGluZVN0cmluZ0xhc3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnYgPSB3b3JkVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQucy5wdXNoKElubGluZVN0cmluZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkVGV4dCA9IHc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRUZXh0ICs9IHc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlV29yZFR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZVdob2xlZiA9IGZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQudCA9IFwiaW5saW5lU3RyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjZWxsRm9ybWF0LnMgPSBbSW5saW5lU3RyaW5nXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5jdCA9IGNlbGxGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjZWxsVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLnJlcGxhY2VTcGVjaWFsV3JhcCh0ZXh0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0ZXh0LmluZGV4T2YoXCJcXHJcXG5cIik+LTEgfHwgdGV4dC5pbmRleE9mKFwiXFxuXCIpPi0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgSW5saW5lU3RyaW5nID0gbmV3IEx1Y2t5SW5saW5lU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnYgPSB0ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjZWxsRm9ybWF0ID0gY2VsbFZhbHVlLmN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxGb3JtYXQ9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0ID0gbmV3IEx1Y2t5U2hlZXRDZWxsRm9ybWF0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZmYhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmYgPSBjZWxsVmFsdWUuZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZmMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjZWxsVmFsdWUuZmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuZnMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZnMgPSBjZWxsVmFsdWUuZnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuY2whPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuY2wgPSBjZWxsVmFsdWUuY2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUudW4hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudW4gPSBjZWxsVmFsdWUudW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuYmwhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuYmwgPSBjZWxsVmFsdWUuYmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuaXQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuaXQgPSBjZWxsVmFsdWUuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnQgPSBcImlubGluZVN0clwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQucyA9IFtJbmxpbmVTdHJpbmddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5jdCA9IGNlbGxGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52ID0gdGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90ZVByZWZpeCA9IFwiMVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlczpMdWNreUlubGluZVN0cmluZ1tdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgckZsYWcuZm9yRWFjaCgocik9PntcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRGbGFnID0gci5nZXRJbm5lckVsZW1lbnRzKFwidFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJQciA9IHIuZ2V0SW5uZXJFbGVtZW50cyhcInJQclwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBJbmxpbmVTdHJpbmcgPSBuZXcgTHVja3lJbmxpbmVTdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRGbGFnIT1udWxsICYmIHRGbGFnLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gdEZsYWdbMF0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5yZXBsYWNlU3BlY2lhbFdyYXAodGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlQ2hhcmFjdGVyKHRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnYgPSB0ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyUHIhPW51bGwgJiYgclByLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcnByID0gclByWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN6ID0gZ2V0bGluZVN0cmluZ0F0dHIoZnJwcixcInN6XCIpLCByRm9udD1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwickZvbnRcIiksIGZhbWlseT1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwiZmFtaWx5XCIpLCBjaGFyc2V0PWdldGxpbmVTdHJpbmdBdHRyKGZycHIsXCJjaGFyc2V0XCIpLCBzY2hlbWU9Z2V0bGluZVN0cmluZ0F0dHIoZnJwcixcInNjaGVtZVwiKSwgYj1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwiYlwiKSwgaT1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwiaVwiKSwgdT1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwidVwiKSwgc3RyaWtlPWdldGxpbmVTdHJpbmdBdHRyKGZycHIsXCJzdHJpa2VcIiksIHZlcnRBbGlnbj1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwidmVydEFsaWduXCIpLCBjb2xvcjtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNFbGUgPSBmcnByLmdldElubmVyRWxlbWVudHMoXCJjb2xvclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNFbGUhPW51bGwgJiYgY0VsZS5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBnZXRDb2xvcihjRWxlWzBdLHRoaXMuc3R5bGVzLCBcInRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmKGZhbWlseSE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgZmYgPSBmb250RmFtaWx5c1tmYW1pbHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYockZvbnQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZmID0gckZvbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmZiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZmID0gZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNlbGxWYWx1ZS5mZiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZmID0gY2VsbFZhbHVlLmZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY2VsbFZhbHVlLmZjIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjZWxsVmFsdWUuZmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ohPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mcyA9IHBhcnNlSW50KHN6KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY2VsbFZhbHVlLmZzIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZnMgPSBjZWxsVmFsdWUuZnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RyaWtlIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuY2wgPSBwYXJzZUludChzdHJpa2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjZWxsVmFsdWUuY2whPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5jbCA9IGNlbGxWYWx1ZS5jbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih1IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudW4gPSBwYXJzZUludCh1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY2VsbFZhbHVlLnVuIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudW4gPSBjZWxsVmFsdWUudW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmJsID0gcGFyc2VJbnQoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNlbGxWYWx1ZS5ibCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmJsID0gY2VsbFZhbHVlLmJsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGkhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5pdCA9IHBhcnNlSW50KGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjZWxsVmFsdWUuaXQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5pdCA9IGNlbGxWYWx1ZS5pdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih2ZXJ0QWxpZ24hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy52YSA9IHBhcnNlSW50KHZlcnRBbGlnbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZmOnN0cmluZyB8IHVuZGVmaW5lZCAvL2ZvbnQgZmFtaWx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYzpzdHJpbmcgfCB1bmRlZmluZWQvL2ZvbnQgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZzOm51bWJlciB8IHVuZGVmaW5lZC8vZm9udCBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbDpudW1iZXIgfCB1bmRlZmluZWQvL3N0cmlrZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW46bnVtYmVyIHwgdW5kZWZpbmVkLy91bmRlcmxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJsOm51bWJlciB8IHVuZGVmaW5lZC8vYmxvZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQ6bnVtYmVyIHwgdW5kZWZpbmVkLy9pdGFsaWNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHY6c3RyaW5nIHwgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5mZj09bnVsbCAmJiBjZWxsVmFsdWUuZmYhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mZiA9IGNlbGxWYWx1ZS5mZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihJbmxpbmVTdHJpbmcuZmM9PW51bGwgJiYgY2VsbFZhbHVlLmZjIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjZWxsVmFsdWUuZmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoSW5saW5lU3RyaW5nLmZzPT1udWxsICYmIGNlbGxWYWx1ZS5mcyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZzID0gY2VsbFZhbHVlLmZzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5jbD09bnVsbCAmJiBjZWxsVmFsdWUuY2whPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5jbCA9IGNlbGxWYWx1ZS5jbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihJbmxpbmVTdHJpbmcudW49PW51bGwgJiYgY2VsbFZhbHVlLnVuIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudW4gPSBjZWxsVmFsdWUudW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoSW5saW5lU3RyaW5nLmJsPT1udWxsICYmIGNlbGxWYWx1ZS5ibCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmJsID0gY2VsbFZhbHVlLmJsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5pdD09bnVsbCAmJiBjZWxsVmFsdWUuaXQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5pdCA9IGNlbGxWYWx1ZS5pdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKElubGluZVN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsRm9ybWF0ID0gY2VsbFZhbHVlLmN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNlbGxGb3JtYXQ9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0ID0gbmV3IEx1Y2t5U2hlZXRDZWxsRm9ybWF0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQudCA9IFwiaW5saW5lU3RyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbEZvcm1hdC5zID0gc3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5jdCA9IGNlbGxGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdG8gYmUgY29uZmlybWVkXHJcbiAgICAgICAgICAgIGVsc2UgaWYodD09U1RfQ2VsbFR5cGVbXCJJbmxpbmVTdHJpbmdcIl0gJiYgdiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBjZWxsVmFsdWUudiA9IFwiJ1wiKyB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXNjYXBlQ2hhcmFjdGVyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHF1b3RlUHJlZml4IT1udWxsKXtcclxuICAgICAgICAgICAgY2VsbFZhbHVlLnFwID0gcGFyc2VJbnQocXVvdGVQcmVmaXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNlbGxWYWx1ZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZXBsYWNlU3BlY2lhbFdyYXAodGV4dDpzdHJpbmcpOnN0cmluZ3tcclxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9feDAwMERfL2csIFwiXCIpLnJlcGxhY2UoLyYjMTM7JiMxMDsvZywgXCJcXHJcXG5cIikucmVwbGFjZSgvJiMxMzsvZywgXCJcXHJcIikucmVwbGFjZSgvJiMxMDsvZywgXCJcXG5cIik7XHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgZ2V0QmFja2dyb3VuZEJ5RmlsbChmaWxsOkVsZW1lbnQsIGNsclNjaGVtZTpFbGVtZW50W10pOnN0cmluZ3xudWxse1xyXG4gICAgICAgIGxldCBwYXR0ZXJuRmlsbHMgPSBmaWxsLmdldElubmVyRWxlbWVudHMoXCJwYXR0ZXJuRmlsbFwiKTtcclxuICAgICAgICBpZihwYXR0ZXJuRmlsbHMhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgcGF0dGVybkZpbGwgPSBwYXR0ZXJuRmlsbHNbMF07XHJcbiAgICAgICAgICAgIGxldCBmZ0NvbG9ycyA9IHBhdHRlcm5GaWxsLmdldElubmVyRWxlbWVudHMoXCJmZ0NvbG9yXCIpO1xyXG4gICAgICAgICAgICBsZXQgYmdDb2xvcnMgPSBwYXR0ZXJuRmlsbC5nZXRJbm5lckVsZW1lbnRzKFwiYmdDb2xvclwiKTtcclxuICAgICAgICAgICAgbGV0IGZnLCBiZztcclxuICAgICAgICAgICAgaWYoZmdDb2xvcnMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGZnQ29sb3IgPSBmZ0NvbG9yc1swXTtcclxuICAgICAgICAgICAgICAgIGZnID0gZ2V0Q29sb3IoZmdDb2xvciwgdGhpcy5zdHlsZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihiZ0NvbG9ycyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgYmdDb2xvciA9IGJnQ29sb3JzWzBdO1xyXG4gICAgICAgICAgICAgICAgYmcgPSBnZXRDb2xvcihiZ0NvbG9yLCB0aGlzLnN0eWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZmdDb2xvcnMsYmdDb2xvcnMsY2xyU2NoZW1lKTtcclxuICAgICAgICAgICAgaWYoZmchPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoYmchPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGxldCBncmFkaWVudGZpbGxzID0gZmlsbC5nZXRJbm5lckVsZW1lbnRzKFwiZ3JhZGllbnRGaWxsXCIpO1xyXG4gICAgICAgICAgICBpZihncmFkaWVudGZpbGxzIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIC8vZ3JhaWVudCBjb2xvciBmaWxsIGhhbmRsZXJcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEJvcmRlckluZm8oYm9yZGVyczpFbGVtZW50W10pOkx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGV7XHJcbiAgICAgICAgaWYoYm9yZGVycz09bnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGJvcmRlciA9IGJvcmRlcnNbMF0sIGF0dHJMaXN0ID0gYm9yZGVyLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgbGV0IGNsclNjaGVtZSA9IHRoaXMuc3R5bGVzW1wiY2xyU2NoZW1lXCJdIGFzIEVsZW1lbnRbXTtcclxuICAgICAgICBsZXQgc3R5bGU6c3RyaW5nID0gYXR0ckxpc3Quc3R5bGU7XHJcbiAgICAgICAgaWYoc3R5bGU9PW51bGwgfHwgc3R5bGU9PVwibm9uZVwiKXtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY29sb3JzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJjb2xvclwiKTtcclxuICAgICAgICBsZXQgY29sb3JSZXQgPSBcIiMwMDAwMDBcIjtcclxuICAgICAgICBpZihjb2xvcnMhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgY29sb3IgPSBjb2xvcnNbMF07XHJcbiAgICAgICAgICAgIGNvbG9yUmV0ID0gZ2V0Q29sb3IoY29sb3IsIHRoaXMuc3R5bGVzLCBcImJcIik7XHJcbiAgICAgICAgICAgIGlmKGNvbG9yUmV0PT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGNvbG9yUmV0ID0gXCIjMDAwMDAwXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZXQgPSBuZXcgTHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZSgpO1xyXG4gICAgICAgIHJldC5zdHlsZSA9IGJvcmRlclR5cGVzW3N0eWxlXTtcclxuICAgICAgICByZXQuY29sb3IgPSBjb2xvclJldDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGh0bWxEZWNvZGUgKHN0cjpzdHJpbmcpOnN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIyh4KT8oW14mXXsxLDV9KTsvZyxmdW5jdGlvbigkLCQxLCQyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KCQyICwgJDEgPyAxNjoxMCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbn1cclxuXHJcbiIsIu+7v2ltcG9ydCB7IElMdWNreUZpbGUsSWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5IaWRkZW4sSWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5MZW59IGZyb20gXCIuL0lMdWNrXCI7XHJcbmltcG9ydCB7IEx1Y2t5U2hlZXR9IGZyb20gXCIuL0x1Y2t5U2hlZXRcIjtcclxuaW1wb3J0IHtJdXBsb2FkZmlsZUxpc3QsIElhdHRyaWJ1dGVMaXN0fSBmcm9tIFwiLi4vSUNvbW1vblwiO1xyXG5pbXBvcnQge3dvcmtCb29rRmlsZSwgY29yZUZpbGUsIGFwcEZpbGUsIHN0eWxlc0ZpbGUsIHNoYXJlZFN0cmluZ3NGaWxlLG51bUZtdERlZmF1bHQsdGhlbWUxRmlsZSxjYWxjQ2hhaW5GaWxlLHdvcmtib29rUmVscywgbnVtRm10RGVmYXVsdE1hcH0gZnJvbSBcIi4uL2NvbW1vbi9jb25zdGFudFwiO1xyXG5pbXBvcnQgeyBSZWFkWG1sLElTdHlsZUNvbGxlY3Rpb25zLEVsZW1lbnQgfSBmcm9tIFwiLi9SZWFkWG1sXCI7XHJcbmltcG9ydCB7Z2V0WG1sQXR0aWJ1dGV9IGZyb20gXCIuLi9jb21tb24vbWV0aG9kXCI7XHJcbmltcG9ydCB7IEx1Y2t5RmlsZUJhc2UsTHVja3lGaWxlSW5mbyxMdWNreVNoZWV0QmFzZSxMdWNreVNoZWV0Q2VsbGRhdGFCYXNlLEx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlLEx1Y2t5U2hlZXRDZWxsRm9ybWF0IH0gZnJvbSBcIi4vTHVja3lCYXNlXCI7XHJcbmltcG9ydCB7SW1hZ2VMaXN0fSBmcm9tIFwiLi9MdWNreUltYWdlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lGaWxlIGV4dGVuZHMgTHVja3lGaWxlQmFzZSB7XHJcblxyXG4gICAgcHJpdmF0ZSBmaWxlczpJdXBsb2FkZmlsZUxpc3RcclxuICAgIHByaXZhdGUgc2hlZXROYW1lTGlzdDpJYXR0cmlidXRlTGlzdFxyXG4gICAgcHJpdmF0ZSByZWFkWG1sOlJlYWRYbWxcclxuICAgIHByaXZhdGUgZmlsZU5hbWU6c3RyaW5nXHJcbiAgICBwcml2YXRlIHN0eWxlczpJU3R5bGVDb2xsZWN0aW9uc1xyXG4gICAgcHJpdmF0ZSBzaGFyZWRTdHJpbmdzOkVsZW1lbnRbXVxyXG4gICAgcHJpdmF0ZSBjYWxjQ2hhaW46RWxlbWVudFtdXHJcbiAgICBwcml2YXRlIGltYWdlTGlzdDpJbWFnZUxpc3RcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihmaWxlczpJdXBsb2FkZmlsZUxpc3QsIGZpbGVOYW1lOnN0cmluZykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5maWxlcyA9IGZpbGVzO1xyXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBmaWxlTmFtZTtcclxuICAgICAgICB0aGlzLnJlYWRYbWwgPSBuZXcgUmVhZFhtbChmaWxlcyk7XHJcbiAgICAgICAgdGhpcy5nZXRTaGVldE5hbWVMaXN0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcmVkU3RyaW5ncyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNzdC9zaVwiLCBzaGFyZWRTdHJpbmdzRmlsZSk7XHJcbiAgICAgICAgdGhpcy5jYWxjQ2hhaW4gPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjYWxjQ2hhaW4vY1wiLCBjYWxjQ2hhaW5GaWxlKTtcclxuICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuc3R5bGVzW1wiY2VsbFhmc1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjZWxsWGZzL3hmXCIsIHN0eWxlc0ZpbGUpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzW1wiY2VsbFN0eWxlWGZzXCJdID0gIHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNlbGxTdHlsZVhmcy94ZlwiLCBzdHlsZXNGaWxlKTtcclxuICAgICAgICB0aGlzLnN0eWxlc1tcImNlbGxTdHlsZXNcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY2VsbFN0eWxlcy9jZWxsU3R5bGVcIiwgc3R5bGVzRmlsZSk7XHJcbiAgICAgICAgdGhpcy5zdHlsZXNbXCJmb250c1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmb250cy9mb250XCIsIHN0eWxlc0ZpbGUpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzW1wiZmlsbHNcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZmlsbHMvZmlsbFwiLCBzdHlsZXNGaWxlKTtcclxuICAgICAgICB0aGlzLnN0eWxlc1tcImJvcmRlcnNcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9yZGVycy9ib3JkZXJcIiwgc3R5bGVzRmlsZSk7XHJcbiAgICAgICAgdGhpcy5zdHlsZXNbXCJjbHJTY2hlbWVcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYTpjbHJTY2hlbWUvYTpkazF8YTpsdDF8YTpkazJ8YTpsdDJ8YTphY2NlbnQxfGE6YWNjZW50MnxhOmFjY2VudDN8YTphY2NlbnQ0fGE6YWNjZW50NXxhOmFjY2VudDZ8YTpobGlua3xhOmZvbEhsaW5rXCIsIHRoZW1lMUZpbGUpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzW1wiaW5kZXhlZENvbG9yc1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjb2xvcnMvaW5kZXhlZENvbG9ycy9yZ2JDb2xvclwiLCBzdHlsZXNGaWxlKTtcclxuICAgICAgICB0aGlzLnN0eWxlc1tcIm1ydUNvbG9yc1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjb2xvcnMvbXJ1Q29sb3JzL2NvbG9yXCIsIHN0eWxlc0ZpbGUpO1xyXG5cclxuICAgICAgICB0aGlzLmltYWdlTGlzdCA9IG5ldyBJbWFnZUxpc3QoZmlsZXMpO1xyXG5cclxuICAgICAgICBsZXQgbnVtZm10cyA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJudW1GbXQvbnVtRm10XCIsIHN0eWxlc0ZpbGUpO1xyXG4gICAgICAgIGxldCBudW1GbXREZWZhdWx0QyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobnVtRm10RGVmYXVsdCkpO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8bnVtZm10cy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgbGV0IGF0dHJMaXN0ID0gbnVtZm10c1tpXS5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICBsZXQgbnVtZm10aWQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJudW1GbXRJZFwiLCBcIjQ5XCIpO1xyXG4gICAgICAgICAgICBsZXQgZm9ybWF0Y29kZSA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcImZvcm1hdENvZGVcIiwgXCJAXCIpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhudW1mbXRpZCwgZm9ybWF0Y29kZSk7XHJcbiAgICAgICAgICAgIGlmKCEobnVtZm10aWQgaW4gbnVtRm10RGVmYXVsdCkpe1xyXG4gICAgICAgICAgICAgICAgbnVtRm10RGVmYXVsdENbbnVtZm10aWRdID0gbnVtRm10RGVmYXVsdE1hcFtmb3JtYXRjb2RlXSB8fCBmb3JtYXRjb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShudW1GbXREZWZhdWx0QyksIG51bWZtdHMpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzW1wibnVtZm10c1wiXSA9ICBudW1GbXREZWZhdWx0QztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQHJldHVybiBBbGwgc2hlZXQgbmFtZSBvZiB3b3JrYm9va1xyXG4gICAgKi9cclxuICAgIHByaXZhdGUgZ2V0U2hlZXROYW1lTGlzdCgpe1xyXG4gICAgICAgIGxldCB3b3JrYm9va1JlbExpc3QgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJSZWxhdGlvbnNoaXBzL1JlbGF0aW9uc2hpcFwiLCB3b3JrYm9va1JlbHMpO1xyXG4gICAgICAgIGlmKHdvcmtib29rUmVsTGlzdD09bnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZWdleCA9IG5ldyBSZWdFeHAoXCJ3b3Jrc2hlZXRzL1teL10qPy54bWxcIik7XHJcbiAgICAgICAgbGV0IHNoZWV0TmFtZXM6SWF0dHJpYnV0ZUxpc3QgPSB7fTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHdvcmtib29rUmVsTGlzdC5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgbGV0IHJlbCA9IHdvcmtib29rUmVsTGlzdFtpXSwgYXR0ckxpc3QgPSByZWwuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgbGV0IGlkID0gYXR0ckxpc3RbXCJJZFwiXSwgdGFyZ2V0ID0gYXR0ckxpc3RbXCJUYXJnZXRcIl07XHJcbiAgICAgICAgICAgIGlmKHJlZ2V4LnRlc3QodGFyZ2V0KSl7XHJcbiAgICAgICAgICAgICAgICBpZih0YXJnZXQuaW5kZXhPZignL3hsJykgPT09IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0TmFtZXNbaWRdID0gICB0YXJnZXQuc3Vic3RyKDEpO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hlZXROYW1lc1tpZF0gPSAgIFwieGwvXCIgKyB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNoZWV0TmFtZUxpc3QgPSBzaGVldE5hbWVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcGFyYW0gc2hlZXROYW1lIFdvcmtTaGVldCduYW1lXHJcbiAgICAqIEByZXR1cm4gc2hlZXQgZmlsZSBuYW1lIGFuZCBwYXRoIGluIHppcFxyXG4gICAgKi9cclxuICAgcHJpdmF0ZSBnZXRTaGVldEZpbGVCeXNoZWV0SWQoc2hlZXRJZDpzdHJpbmcpe1xyXG4gICAgICAgIC8vIGZvcihsZXQgaT0wO2k8dGhpcy5zaGVldE5hbWVMaXN0Lmxlbmd0aDtpKyspe1xyXG4gICAgICAgIC8vICAgICBsZXQgc2hlZXRGaWxlTmFtZSA9IHRoaXMuc2hlZXROYW1lTGlzdFtpXTtcclxuICAgICAgICAvLyAgICAgaWYoc2hlZXRGaWxlTmFtZS5pbmRleE9mKFwic2hlZXRcIitzaGVldElkKT4tMSl7XHJcbiAgICAgICAgLy8gICAgICAgICByZXR1cm4gc2hlZXRGaWxlTmFtZTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zaGVldE5hbWVMaXN0W3NoZWV0SWRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcmV0dXJuIHdvcmtCb29rIGluZm9ybWF0aW9uXHJcbiAgICAqL1xyXG4gICAgZ2V0V29ya0Jvb2tJbmZvKCl7XHJcbiAgICAgICAgbGV0IENvbXBhbnkgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJDb21wYW55XCIsIGFwcEZpbGUpO1xyXG4gICAgICAgIGxldCBBcHBWZXJzaW9uID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiQXBwVmVyc2lvblwiLCBhcHBGaWxlKTtcclxuICAgICAgICBsZXQgY3JlYXRvciA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRjOmNyZWF0b3JcIiwgY29yZUZpbGUpO1xyXG4gICAgICAgIGxldCBsYXN0TW9kaWZpZWRCeSA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNwOmxhc3RNb2RpZmllZEJ5XCIsIGNvcmVGaWxlKTtcclxuICAgICAgICBsZXQgY3JlYXRlZCA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRjdGVybXM6Y3JlYXRlZFwiLCBjb3JlRmlsZSk7XHJcbiAgICAgICAgbGV0IG1vZGlmaWVkID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGN0ZXJtczptb2RpZmllZFwiLCBjb3JlRmlsZSk7XHJcbiAgICAgICAgdGhpcy5pbmZvID0gbmV3IEx1Y2t5RmlsZUluZm8oKTtcclxuICAgICAgICB0aGlzLmluZm8ubmFtZSA9IHRoaXMuZmlsZU5hbWU7XHJcbiAgICAgICAgdGhpcy5pbmZvLmNyZWF0b3IgPSBjcmVhdG9yLmxlbmd0aD4wP2NyZWF0b3JbMF0udmFsdWU6XCJcIjtcclxuICAgICAgICB0aGlzLmluZm8ubGFzdG1vZGlmaWVkYnkgPSBsYXN0TW9kaWZpZWRCeS5sZW5ndGg+MD9sYXN0TW9kaWZpZWRCeVswXS52YWx1ZTpcIlwiO1xyXG4gICAgICAgIHRoaXMuaW5mby5jcmVhdGVkVGltZSA9IGNyZWF0ZWQubGVuZ3RoPjA/Y3JlYXRlZFswXS52YWx1ZTpcIlwiO1xyXG4gICAgICAgIHRoaXMuaW5mby5tb2RpZmllZFRpbWUgPSBtb2RpZmllZC5sZW5ndGg+MD9tb2RpZmllZFswXS52YWx1ZTpcIlwiO1xyXG4gICAgICAgIHRoaXMuaW5mby5jb21wYW55ID0gQ29tcGFueS5sZW5ndGg+MD9Db21wYW55WzBdLnZhbHVlOlwiXCI7XHJcbiAgICAgICAgdGhpcy5pbmZvLmFwcHZlcnNpb24gPSBBcHBWZXJzaW9uLmxlbmd0aD4wP0FwcFZlcnNpb25bMF0udmFsdWU6XCJcIjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQHJldHVybiBBbGwgc2hlZXQgLCBpbmNsdWRlIHdob2xlIGluZm9ybWF0aW9uXHJcbiAgICAqL1xyXG4gICAgZ2V0U2hlZXRzRnVsbChpc0luaXRpYWxDZWxsOmJvb2xlYW49dHJ1ZSl7XHJcbiAgICAgICAgbGV0IHNoZWV0cyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNoZWV0cy9zaGVldFwiLCB3b3JrQm9va0ZpbGUpO1xyXG4gICAgICAgIGxldCBzaGVldExpc3Q6SWF0dHJpYnV0ZUxpc3QgPSB7fTtcclxuICAgICAgICBmb3IobGV0IGtleSBpbiBzaGVldHMpe1xyXG4gICAgICAgICAgICBsZXQgc2hlZXQgPSBzaGVldHNba2V5XTtcclxuICAgICAgICAgICAgc2hlZXRMaXN0W3NoZWV0LmF0dHJpYnV0ZUxpc3QubmFtZV0gPSBzaGVldC5hdHRyaWJ1dGVMaXN0W1wic2hlZXRJZFwiXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zaGVldHMgPSBbXTtcclxuICAgICAgICBsZXQgb3JkZXIgPSAwO1xyXG4gICAgICAgIGZvcihsZXQga2V5IGluIHNoZWV0cyl7XHJcbiAgICAgICAgICAgIGxldCBzaGVldCA9IHNoZWV0c1trZXldO1xyXG4gICAgICAgICAgICBsZXQgc2hlZXROYW1lID0gc2hlZXQuYXR0cmlidXRlTGlzdC5uYW1lO1xyXG4gICAgICAgICAgICBsZXQgc2hlZXRJZCA9IHNoZWV0LmF0dHJpYnV0ZUxpc3RbXCJzaGVldElkXCJdO1xyXG4gICAgICAgICAgICBsZXQgcmlkID0gc2hlZXQuYXR0cmlidXRlTGlzdFtcInI6aWRcIl07XHJcbiAgICAgICAgICAgIGxldCBzaGVldEZpbGUgPSB0aGlzLmdldFNoZWV0RmlsZUJ5c2hlZXRJZChyaWQpO1xyXG4gICAgICAgICAgICBsZXQgaGlkZSA9IHNoZWV0LmF0dHJpYnV0ZUxpc3Quc3RhdGUgPT09IFwiaGlkZGVuXCIgPyAxIDogMDtcclxuXHJcbiAgICAgICAgICAgIGxldCBkcmF3aW5nID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwid29ya3NoZWV0L2RyYXdpbmdcIiwgc2hlZXRGaWxlKSwgZHJhd2luZ0ZpbGUsIGRyYXdpbmdSZWxzRmlsZTtcclxuICAgICAgICAgICAgaWYoZHJhd2luZyE9bnVsbCAmJiBkcmF3aW5nLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgIGxldCBhdHRyTGlzdCA9IGRyYXdpbmdbMF0uYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgICAgIGxldCByaWQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJyOmlkXCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgaWYocmlkIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBkcmF3aW5nRmlsZSA9IHRoaXMuZ2V0RHJhd2luZ0ZpbGUocmlkLCBzaGVldEZpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYXdpbmdSZWxzRmlsZSA9IHRoaXMuZ2V0RHJhd2luZ1JlbHNGaWxlKGRyYXdpbmdGaWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoc2hlZXRGaWxlIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGxldCBzaGVldCA9IG5ldyBMdWNreVNoZWV0KHNoZWV0TmFtZSwgc2hlZXRJZCwgb3JkZXIsIGlzSW5pdGlhbENlbGwsXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGVldEZpbGU6c2hlZXRGaWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkWG1sOnRoaXMucmVhZFhtbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hlZXRMaXN0OnNoZWV0TGlzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOnRoaXMuc3R5bGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRTdHJpbmdzOnRoaXMuc2hhcmVkU3RyaW5ncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsY0NoYWluOnRoaXMuY2FsY0NoYWluLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZUxpc3Q6dGhpcy5pbWFnZUxpc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdpbmdGaWxlOmRyYXdpbmdGaWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3aW5nUmVsc0ZpbGU6IGRyYXdpbmdSZWxzRmlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogaGlkZSxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbldpZHRoU2V0ID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvd0hlaWdodFNldCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VQb3NpdGlvbkNhY3VsYXRpb24oc2hlZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc2hlZXRzLnB1c2goc2hlZXQpO1xyXG4gICAgICAgICAgICAgICAgb3JkZXIrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNvbHVtbldpZHRoU2V0Om51bWJlcltdID0gW107XHJcbiAgICBwcml2YXRlIHJvd0hlaWdodFNldDpudW1iZXJbXSA9IFtdO1xyXG5cclxuICAgIHByaXZhdGUgZXh0ZW5kQXJyYXkoaW5kZXg6bnVtYmVyLCBzZXRzOm51bWJlcltdLGRlZjpudW1iZXIsIGhpZGRlbjpJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlbiwgbGVuczpJbHVja3lTaGVldFJvd0FuZENvbHVtbkxlbil7XHJcbiAgICAgICAgaWYoaW5kZXg8c2V0cy5sZW5ndGgpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHNldHMubGVuZ3RoLCBlbmRJbmRleCA9IGluZGV4O1xyXG4gICAgICAgIGxldCBhbGxHYXAgPSAwO1xyXG4gICAgICAgIGlmKHN0YXJ0SW5kZXg+MCl7XHJcbiAgICAgICAgICAgIGFsbEdhcCA9IHNldHNbc3RhcnRJbmRleC0xXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZWxzZXtcclxuICAgICAgICAvLyAgICAgc2V0cy5wdXNoKDApO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBmb3IobGV0IGk9c3RhcnRJbmRleDtpPD1lbmRJbmRleDtpKyspe1xyXG4gICAgICAgICAgICBsZXQgZ2FwID0gZGVmLCBpc3RyaW5nICA9IGkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYoaXN0cmluZyBpbiBoaWRkZW4pe1xyXG4gICAgICAgICAgICAgICAgZ2FwID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGlzdHJpbmcgaW4gbGVucyl7XHJcbiAgICAgICAgICAgICAgICBnYXAgPSBsZW5zW2lzdHJpbmddO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhbGxHYXAgKz0gTWF0aC5yb3VuZChnYXAgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIHNldHMucHVzaChhbGxHYXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGltYWdlUG9zaXRpb25DYWN1bGF0aW9uKHNoZWV0Okx1Y2t5U2hlZXQpe1xyXG4gICAgICAgIGxldCBpbWFnZXMgPSBzaGVldC5pbWFnZXMsIGRlZmF1bHRDb2xXaWR0aCA9IHNoZWV0LmRlZmF1bHRDb2xXaWR0aCwgZGVmYXVsdFJvd0hlaWdodCA9IHNoZWV0LmRlZmF1bHRSb3dIZWlnaHQ7XHJcbiAgICAgICAgbGV0IGNvbGhpZGRlbiA9IHt9O1xyXG4gICAgICAgIGlmKHNoZWV0LmNvbmZpZy5jb2xoaWRkZW4pe1xyXG4gICAgICAgICAgICBjb2xoaWRkZW4gPSBzaGVldC5jb25maWcuY29saGlkZGVuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNvbHVtbmxlbiA9IHt9O1xyXG4gICAgICAgIGlmKHNoZWV0LmNvbmZpZy5jb2x1bW5sZW4pe1xyXG4gICAgICAgICAgICBjb2x1bW5sZW4gPSBzaGVldC5jb25maWcuY29sdW1ubGVuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJvd2hpZGRlbiA9IHt9O1xyXG4gICAgICAgIGlmKHNoZWV0LmNvbmZpZy5yb3doaWRkZW4pe1xyXG4gICAgICAgICAgICByb3doaWRkZW4gPSBzaGVldC5jb25maWcucm93aGlkZGVuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJvd2xlbiA9IHt9O1xyXG4gICAgICAgIGlmKHNoZWV0LmNvbmZpZy5yb3dsZW4pe1xyXG4gICAgICAgICAgICByb3dsZW4gPSBzaGVldC5jb25maWcucm93bGVuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gaW1hZ2VzKXtcclxuICAgICAgICAgICAgbGV0IGltYWdlT2JqZWN0OmFueSA9IGltYWdlc1trZXldOy8vSW1hZ2UsIGx1Y2t5SW1hZ2VcclxuICAgICAgICAgICAgbGV0IGZyb21Db2wgPSBpbWFnZU9iamVjdC5mcm9tQ29sO1xyXG4gICAgICAgICAgICBsZXQgZnJvbUNvbE9mZiA9IGltYWdlT2JqZWN0LmZyb21Db2xPZmY7XHJcbiAgICAgICAgICAgIGxldCBmcm9tUm93ID0gaW1hZ2VPYmplY3QuZnJvbVJvdztcclxuICAgICAgICAgICAgbGV0IGZyb21Sb3dPZmYgPSBpbWFnZU9iamVjdC5mcm9tUm93T2ZmO1xyXG5cclxuICAgICAgICAgICAgbGV0IHRvQ29sID0gaW1hZ2VPYmplY3QudG9Db2w7XHJcbiAgICAgICAgICAgIGxldCB0b0NvbE9mZiA9IGltYWdlT2JqZWN0LnRvQ29sT2ZmO1xyXG4gICAgICAgICAgICBsZXQgdG9Sb3cgPSBpbWFnZU9iamVjdC50b1JvdztcclxuICAgICAgICAgICAgbGV0IHRvUm93T2ZmID0gaW1hZ2VPYmplY3QudG9Sb3dPZmY7XHJcblxyXG4gICAgICAgICAgICBsZXQgeF9uID0wLHlfbiA9IDA7XHJcbiAgICAgICAgICAgIGxldCBjeF9uID0gMCwgY3lfbiA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZihmcm9tQ29sPj10aGlzLmNvbHVtbldpZHRoU2V0Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZEFycmF5KGZyb21Db2wsIHRoaXMuY29sdW1uV2lkdGhTZXQsIGRlZmF1bHRDb2xXaWR0aCwgY29saGlkZGVuLCBjb2x1bW5sZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGZyb21Db2w9PTApe1xyXG4gICAgICAgICAgICAgICAgeF9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgeF9uID0gdGhpcy5jb2x1bW5XaWR0aFNldFtmcm9tQ29sLTFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHhfbiA9IHhfbiArIGZyb21Db2xPZmY7XHJcblxyXG4gICAgICAgICAgICBpZihmcm9tUm93Pj10aGlzLnJvd0hlaWdodFNldC5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRBcnJheShmcm9tUm93LCB0aGlzLnJvd0hlaWdodFNldCwgZGVmYXVsdFJvd0hlaWdodCwgcm93aGlkZGVuLCByb3dsZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGZyb21Sb3c9PTApe1xyXG4gICAgICAgICAgICAgICAgeV9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgeV9uID0gdGhpcy5yb3dIZWlnaHRTZXRbZnJvbVJvdy0xXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5X24gPSB5X24gKyBmcm9tUm93T2ZmO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmKHRvQ29sPj10aGlzLmNvbHVtbldpZHRoU2V0Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZEFycmF5KHRvQ29sLCB0aGlzLmNvbHVtbldpZHRoU2V0LCBkZWZhdWx0Q29sV2lkdGgsIGNvbGhpZGRlbiwgY29sdW1ubGVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0b0NvbD09MCl7XHJcbiAgICAgICAgICAgICAgICBjeF9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgY3hfbiA9IHRoaXMuY29sdW1uV2lkdGhTZXRbdG9Db2wtMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3hfbiA9IGN4X24gKyB0b0NvbE9mZi0geF9uO1xyXG5cclxuICAgICAgICAgICAgaWYodG9Sb3c+PXRoaXMucm93SGVpZ2h0U2V0Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZEFycmF5KHRvUm93LCB0aGlzLnJvd0hlaWdodFNldCwgZGVmYXVsdFJvd0hlaWdodCwgcm93aGlkZGVuLCByb3dsZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHRvUm93PT0wKXtcclxuICAgICAgICAgICAgICAgIGN5X24gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBjeV9uID0gdGhpcy5yb3dIZWlnaHRTZXRbdG9Sb3ctMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN5X24gPSBjeV9uICsgdG9Sb3dPZmYgLSB5X247XHJcblxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhkZWZhdWx0Q29sV2lkdGgsIGNvbGhpZGRlbiAsIGNvbHVtbmxlbik7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGZyb21Db2wsIHRoaXMuY29sdW1uV2lkdGhTZXRbZnJvbUNvbF0gLCBmcm9tQ29sT2ZmKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codG9Db2wsIHRoaXMuY29sdW1uV2lkdGhTZXRbdG9Db2xdICwgdG9Db2xPZmYsIEpTT04uc3RyaW5naWZ5KHRoaXMuY29sdW1uV2lkdGhTZXQpKTtcclxuXHJcbiAgICAgICAgICAgIGltYWdlT2JqZWN0Lm9yaWdpbldpZHRoID0gY3hfbjtcclxuICAgICAgICAgICAgaW1hZ2VPYmplY3Qub3JpZ2luSGVpZ2h0ID0gY3lfbjtcclxuXHJcbiAgICAgICAgICAgIGltYWdlT2JqZWN0LmNyb3AuaGVpZ2h0ID0gY3lfbjtcclxuICAgICAgICAgICAgaW1hZ2VPYmplY3QuY3JvcC53aWR0aCA9IGN4X247XHJcblxyXG4gICAgICAgICAgICBpbWFnZU9iamVjdC5kZWZhdWx0LmhlaWdodCA9IGN5X247XHJcbiAgICAgICAgICAgIGltYWdlT2JqZWN0LmRlZmF1bHQubGVmdCA9IHhfbjtcclxuICAgICAgICAgICAgaW1hZ2VPYmplY3QuZGVmYXVsdC50b3AgPSB5X247XHJcbiAgICAgICAgICAgIGltYWdlT2JqZWN0LmRlZmF1bHQud2lkdGggPSBjeF9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLmNvbHVtbldpZHRoU2V0LCB0aGlzLnJvd0hlaWdodFNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEByZXR1cm4gZHJhd2luZyBmaWxlIHN0cmluZ1xyXG4gICAgKi9cclxuICAgcHJpdmF0ZSBnZXREcmF3aW5nRmlsZShyaWQ6c3RyaW5nLCBzaGVldEZpbGU6c3RyaW5nKTpzdHJpbmd7XHJcbiAgICAgICAgbGV0IHNoZWV0UmVsc1BhdGggPSBcInhsL3dvcmtzaGVldHMvX3JlbHMvXCI7XHJcbiAgICAgICAgbGV0IHNoZWV0RmlsZUFyciA9IHNoZWV0RmlsZS5zcGxpdChcIi9cIik7XHJcbiAgICAgICAgbGV0IHNoZWV0UmVsc05hbWUgPSBzaGVldEZpbGVBcnJbc2hlZXRGaWxlQXJyLmxlbmd0aC0xXTtcclxuXHJcbiAgICAgICAgbGV0IHNoZWV0UmVsc0ZpbGUgPSBzaGVldFJlbHNQYXRoICsgc2hlZXRSZWxzTmFtZSArIFwiLnJlbHNcIjtcclxuXHJcbiAgICAgICAgbGV0IGRyYXdpbmcgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJSZWxhdGlvbnNoaXBzL1JlbGF0aW9uc2hpcFwiLCBzaGVldFJlbHNGaWxlKTtcclxuICAgICAgICBpZihkcmF3aW5nLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTxkcmF3aW5nLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlbGF0aW9uc2hpcCA9IGRyYXdpbmdbaV07XHJcbiAgICAgICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSByZWxhdGlvbnNoaXAuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgICAgIGxldCByZWxhdGlvbnNoaXBJZCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIklkXCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgaWYocmVsYXRpb25zaGlwSWQ9PXJpZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIlRhcmdldFwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZih0YXJnZXQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnJlcGxhY2UoL1xcLlxcLlxcLy9nLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBnZXREcmF3aW5nUmVsc0ZpbGUoZHJhd2luZ0ZpbGU6c3RyaW5nKTpzdHJpbmd7XHJcbiAgICAgICAgbGV0IGRyYXdpbmdSZWxzUGF0aCA9IFwieGwvZHJhd2luZ3MvX3JlbHMvXCI7XHJcbiAgICAgICAgbGV0IGRyYXdpbmdGaWxlQXJyID0gZHJhd2luZ0ZpbGUuc3BsaXQoXCIvXCIpO1xyXG4gICAgICAgIGxldCBkcmF3aW5nUmVsc05hbWUgPSBkcmF3aW5nRmlsZUFycltkcmF3aW5nRmlsZUFyci5sZW5ndGgtMV07XHJcblxyXG4gICAgICAgIGxldCBkcmF3aW5nUmVsc0ZpbGUgPSBkcmF3aW5nUmVsc1BhdGggKyBkcmF3aW5nUmVsc05hbWUgKyBcIi5yZWxzXCI7XHJcblxyXG4gICAgICAgIHJldHVybiBkcmF3aW5nUmVsc0ZpbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEByZXR1cm4gQWxsIHNoZWV0IGJhc2UgaW5mb3JtYXRpb24gd2lkdGhvdXQgY2VsbCBhbmQgY29uZmlnXHJcbiAgICAqL1xyXG4gICAgZ2V0U2hlZXRzV2l0aG91dENlbGwoKXtcclxuICAgICAgICB0aGlzLmdldFNoZWV0c0Z1bGwoZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcmV0dXJuIEx1Y2t5U2hlZXQgZmlsZSBqc29uXHJcbiAgICAqL1xyXG4gICAgUGFyc2UoKTpzdHJpbmd7XHJcbiAgICAgICAgLy8gbGV0IHhtbCA9IHRoaXMucmVhZFhtbDtcclxuICAgICAgICAvLyBmb3IobGV0IGtleSBpbiB0aGlzLnNoZWV0TmFtZUxpc3Qpe1xyXG4gICAgICAgIC8vICAgICBsZXQgc2hlZXROYW1lPXRoaXMuc2hlZXROYW1lTGlzdFtrZXldO1xyXG4gICAgICAgIC8vICAgICBsZXQgc2hlZXRDb2x1bW5zID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicm93L2MvZlwiLCBzaGVldE5hbWUpO1xyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhzaGVldENvbHVtbnMpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRXb3JrQm9va0luZm8oKTtcclxuICAgICAgICB0aGlzLmdldFNoZWV0c0Z1bGwoKTtcclxuXHJcbiAgICAgICAgLy8gZm9yKGxldCBpPTA7aTx0aGlzLnNoZWV0cy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAvLyAgICAgbGV0IHNoZWV0ID0gdGhpcy5zaGVldHNbaV07XHJcbiAgICAgICAgLy8gICAgIGxldCBfYm9yZGVySW5mbyA9IHNoZWV0LmNvbmZpZy5fYm9yZGVySW5mbztcclxuICAgICAgICAvLyAgICAgaWYoX2JvcmRlckluZm89PW51bGwpe1xyXG4gICAgICAgIC8vICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgbGV0IF9ib3JkZXJJbmZvS2V5cyA9IE9iamVjdC5rZXlzKF9ib3JkZXJJbmZvKTtcclxuICAgICAgICAvLyAgICAgX2JvcmRlckluZm9LZXlzLnNvcnQoKTtcclxuICAgICAgICAvLyAgICAgZm9yKGxldCBhPTA7YTxfYm9yZGVySW5mb0tleXMubGVuZ3RoO2ErKyl7XHJcbiAgICAgICAgLy8gICAgICAgICBsZXQga2V5ID0gcGFyc2VJbnQoX2JvcmRlckluZm9LZXlzW2FdKTtcclxuICAgICAgICAvLyAgICAgICAgIGxldCBiID0gX2JvcmRlckluZm9ba2V5XTtcclxuICAgICAgICAvLyAgICAgICAgIGlmKGIuY2VsbHMubGVuZ3RoPT0wKXtcclxuICAgICAgICAvLyAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgIGlmKHNoZWV0LmNvbmZpZy5ib3JkZXJJbmZvPT1udWxsKXtcclxuICAgICAgICAvLyAgICAgICAgICAgICBzaGVldC5jb25maWcuYm9yZGVySW5mbyA9IFtdO1xyXG4gICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICAgc2hlZXQuY29uZmlnLmJvcmRlckluZm8ucHVzaChiKTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Kc29uU3RyaW5nKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdG9Kc29uU3RyaW5nKGZpbGU6SUx1Y2t5RmlsZSk6c3RyaW5ne1xyXG4gICAgICAgIGxldCBMdWNreU91dFB1dEZpbGUgPSBuZXcgTHVja3lGaWxlQmFzZSgpO1xyXG4gICAgICAgIEx1Y2t5T3V0UHV0RmlsZS5pbmZvID0gZmlsZS5pbmZvO1xyXG4gICAgICAgIEx1Y2t5T3V0UHV0RmlsZS5zaGVldHMgPSBbXTtcclxuXHJcbiAgICAgICAgZmlsZS5zaGVldHMuZm9yRWFjaCgoc2hlZXQpPT57XHJcbiAgICAgICAgICAgIGxldCBzaGVldG91dCA9IG5ldyBMdWNreVNoZWV0QmFzZSgpO1xyXG4gICAgICAgICAgICAvL2xldCBhdHRyTmFtZSA9IFtcIm5hbWVcIixcImNvbG9yXCIsXCJjb25maWdcIixcImluZGV4XCIsXCJzdGF0dXNcIixcIm9yZGVyXCIsXCJyb3dcIixcImNvbHVtblwiLFwibHVja3lzaGVldF9zZWxlY3Rfc2F2ZVwiLFwic2Nyb2xsTGVmdFwiLFwic2Nyb2xsVG9wXCIsXCJ6b29tUmF0aW9cIixcInNob3dHcmlkTGluZXNcIixcImRlZmF1bHRDb2xXaWR0aFwiLFwiZGVmYXVsdFJvd0hlaWdodFwiLFwiY2VsbGRhdGFcIixcImNoYXJ0XCIsXCJpc1Bpdm90VGFibGVcIixcInBpdm90VGFibGVcIixcImx1Y2t5c2hlZXRfY29uZGl0aW9uZm9ybWF0X3NhdmVcIixcImZyZWV6ZW5cIixcImNhbGNDaGFpblwiXTtcclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0Lm5hbWUhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQubmFtZSA9IHNoZWV0Lm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmNvbG9yID0gc2hlZXQuY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmNvbmZpZyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5jb25maWcgPSBzaGVldC5jb25maWc7XHJcbiAgICAgICAgICAgICAgICAvLyBpZihzaGVldG91dC5jb25maWcuX2JvcmRlckluZm8hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGRlbGV0ZSBzaGVldG91dC5jb25maWcuX2JvcmRlckluZm87XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmluZGV4IT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmluZGV4ID0gc2hlZXQuaW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LnN0YXR1cyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5zdGF0dXMgPSBzaGVldC5zdGF0dXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0Lm9yZGVyIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0Lm9yZGVyID0gc2hlZXQub3JkZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LnJvdyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5yb3cgPSBzaGVldC5yb3c7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmNvbHVtbiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5jb2x1bW4gPSBzaGVldC5jb2x1bW47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0Lmx1Y2t5c2hlZXRfc2VsZWN0X3NhdmUhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQubHVja3lzaGVldF9zZWxlY3Rfc2F2ZSA9IHNoZWV0Lmx1Y2t5c2hlZXRfc2VsZWN0X3NhdmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LnNjcm9sbExlZnQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuc2Nyb2xsTGVmdCA9IHNoZWV0LnNjcm9sbExlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LnNjcm9sbFRvcCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5zY3JvbGxUb3AgPSBzaGVldC5zY3JvbGxUb3A7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0Lnpvb21SYXRpbyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC56b29tUmF0aW8gPSBzaGVldC56b29tUmF0aW87XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LnNob3dHcmlkTGluZXMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuc2hvd0dyaWRMaW5lcyA9IHNoZWV0LnNob3dHcmlkTGluZXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmRlZmF1bHRDb2xXaWR0aCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5kZWZhdWx0Q29sV2lkdGggPSBzaGVldC5kZWZhdWx0Q29sV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmRlZmF1bHRSb3dIZWlnaHQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuZGVmYXVsdFJvd0hlaWdodCA9IHNoZWV0LmRlZmF1bHRSb3dIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmNlbGxkYXRhIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIC8vIHNoZWV0b3V0LmNlbGxkYXRhID0gc2hlZXQuY2VsbGRhdGE7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5jZWxsZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgc2hlZXQuY2VsbGRhdGEuZm9yRWFjaCgoY2VsbCk9PntcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbG91dCA9IG5ldyBMdWNreVNoZWV0Q2VsbGRhdGFCYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbG91dC5yID0gY2VsbC5yO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxvdXQuYyA9IGNlbGwuYztcclxuICAgICAgICAgICAgICAgICAgICBjZWxsb3V0LnYgPSBjZWxsLnY7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hlZXRvdXQuY2VsbGRhdGEucHVzaChjZWxsb3V0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5jaGFydCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5jaGFydCA9IHNoZWV0LmNoYXJ0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5pc1Bpdm90VGFibGUhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuaXNQaXZvdFRhYmxlID0gc2hlZXQuaXNQaXZvdFRhYmxlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5waXZvdFRhYmxlIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LnBpdm90VGFibGUgPSBzaGVldC5waXZvdFRhYmxlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5sdWNreXNoZWV0X2NvbmRpdGlvbmZvcm1hdF9zYXZlIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0Lmx1Y2t5c2hlZXRfY29uZGl0aW9uZm9ybWF0X3NhdmUgPSBzaGVldC5sdWNreXNoZWV0X2NvbmRpdGlvbmZvcm1hdF9zYXZlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5mcmVlemVuIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmZyZWV6ZW4gPSBzaGVldC5mcmVlemVuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5jYWxjQ2hhaW4hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuY2FsY0NoYWluID0gc2hlZXQuY2FsY0NoYWluO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5pbWFnZXMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuaW1hZ2VzID0gc2hlZXQuaW1hZ2VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHNoZWV0LmRhdGFWZXJpZmljYXRpb24gIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgc2hlZXRvdXQuZGF0YVZlcmlmaWNhdGlvbiA9IHNoZWV0LmRhdGFWZXJpZmljYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoc2hlZXQuaHlwZXJsaW5rICE9IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuaHlwZXJsaW5rID0gc2hlZXQuaHlwZXJsaW5rO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHNoZWV0LmhpZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIHNoZWV0b3V0LmhpZGUgPSBzaGVldC5oaWRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBMdWNreU91dFB1dEZpbGUuc2hlZXRzLnB1c2goc2hlZXRvdXQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoTHVja3lPdXRQdXRGaWxlKTtcclxuICAgIH1cclxuXHJcblxyXG59XHJcbiIsImltcG9ydCB7IElsdWNreUltYWdlIH0gZnJvbSBcIi4vSUx1Y2tcIjtcclxuaW1wb3J0IHtMdWNreVNoZWV0Q2VsbGRhdGF9IGZyb20gXCIuL0x1Y2t5Q2VsbFwiO1xyXG5pbXBvcnQgeyBJdXBsb2FkZmlsZUxpc3QsIElhdHRyaWJ1dGVMaXN0IH0gZnJvbSBcIi4uL0lDb21tb25cIjtcclxuaW1wb3J0IHtnZXRYbWxBdHRpYnV0ZSwgZ2V0Q29sdW1uV2lkdGhQaXhlbCwgZnJvbXVsYVJlZixnZXRSb3dIZWlnaHRQaXhlbCxnZXRjZWxscmFuZ2V9IGZyb20gXCIuLi9jb21tb24vbWV0aG9kXCI7XHJcbmltcG9ydCB7Ym9yZGVyVHlwZXN9IGZyb20gXCIuLi9jb21tb24vY29uc3RhbnRcIjtcclxuaW1wb3J0IHsgUmVhZFhtbCwgSVN0eWxlQ29sbGVjdGlvbnMsIEVsZW1lbnQsZ2V0Q29sb3IgfSBmcm9tIFwiLi9SZWFkWG1sXCI7XHJcbmltcG9ydCB7IEx1Y2t5SW1hZ2VCYXNlIH0gZnJvbSBcIi4vTHVja3lCYXNlXCI7XHJcbmltcG9ydCB7IFVET0MsRnJvbUVNRixUb0NvbnRleHQyRCAgfSBmcm9tIFwiLi4vY29tbW9uL2VtZlwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBJbWFnZUxpc3Qge1xyXG4gICAgcHJpdmF0ZSBpbWFnZXM6SWF0dHJpYnV0ZUxpc3RcclxuICAgIGNvbnN0cnVjdG9yKGZpbGVzOkl1cGxvYWRmaWxlTGlzdCkge1xyXG4gICAgICAgIGlmKGZpbGVzPT1udWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmltYWdlcyA9IHt9O1xyXG4gICAgICAgIGZvcihsZXQgZmlsZUtleSBpbiBmaWxlcyl7XHJcbiAgICAgICAgICAgIC8vIGxldCByZWcgPSBuZXcgUmVnRXhwKFwieGwvbWVkaWEvaW1hZ2UxLnBuZ1wiLCBcImdcIik7XHJcbiAgICAgICAgICAgIGlmKGZpbGVLZXkuaW5kZXhPZihcInhsL21lZGlhL1wiKT4tMSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsZU5hbWVBcnIgPSBmaWxlS2V5LnNwbGl0KFwiLlwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdWZmaXggPSBmaWxlTmFtZUFycltmaWxlTmFtZUFyci5sZW5ndGgtMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmKHN1ZmZpeCBpbiB7XCJwbmdcIjoxLCBcImpwZWdcIjoxLCBcImpwZ1wiOjEsIFwiZ2lmXCI6MSxcImJtcFwiOjEsXCJ0aWZcIjoxLFwid2VicFwiOjEsXCJlbWZcIjoxfSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3VmZml4PT1cImVtZlwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBOdW0gID0gMDsgIC8vIG51bWJlciBvZiB0aGUgcGFnZSwgdGhhdCB5b3Ugd2FudCB0byByZW5kZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gMTsgIC8vIHRoZSBzY2FsZSBvZiB0aGUgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdydCA9IG5ldyBUb0NvbnRleHQyRChwTnVtLCBzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnAsIG91dCwgc3R0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBGcm9tRU1GLksgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wID0gRnJvbUVNRi5DOyAgIG91dCA9IEZyb21FTUYuSzsgICBzdHQ9NDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBwIGluIGlucCkgb3V0W2lucFtwXV0gPSBwLnNsaWNlKHN0dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZyb21FTUYuUGFyc2UoZmlsZXNbZmlsZUtleV0sIHdydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzW2ZpbGVLZXldID0gd3J0LmNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzW2ZpbGVLZXldID0gZmlsZXNbZmlsZUtleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldEltYWdlQnlOYW1lKHBhdGhOYW1lOnN0cmluZyk6SW1hZ2V7XHJcbiAgICAgICAgaWYocGF0aE5hbWUgaW4gdGhpcy5pbWFnZXMpe1xyXG4gICAgICAgICAgICBsZXQgYmFzZTY0ID0gdGhpcy5pbWFnZXNbcGF0aE5hbWVdO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlKHBhdGhOYW1lLCBiYXNlNjQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmNsYXNzIEltYWdlIGV4dGVuZHMgTHVja3lJbWFnZUJhc2Uge1xyXG5cclxuICAgIGZyb21Db2w6bnVtYmVyXHJcbiAgICBmcm9tQ29sT2ZmOm51bWJlclxyXG4gICAgZnJvbVJvdzpudW1iZXJcclxuICAgIGZyb21Sb3dPZmY6bnVtYmVyXHJcblxyXG4gICAgdG9Db2w6bnVtYmVyXHJcbiAgICB0b0NvbE9mZjpudW1iZXJcclxuICAgIHRvUm93Om51bWJlclxyXG4gICAgdG9Sb3dPZmY6bnVtYmVyXHJcblxyXG4gICAgY29uc3RydWN0b3IocGF0aE5hbWU6c3RyaW5nLCBiYXNlNjQ6c3RyaW5nKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnNyYyA9IGJhc2U2NDtcclxuICAgIH1cclxuXHJcbiAgICBzZXREZWZhdWx0KCl7XHJcblxyXG4gICAgfVxyXG59Iiwi77u/aW1wb3J0IHsgSWx1Y2t5SW1hZ2VCb3JkZXIsSWx1Y2t5SW1hZ2VDcm9wLElsdWNreUltYWdlRGVmYXVsdCxJbHVja3lJbWFnZXMsSWx1Y2t5U2hlZXRDZWxsZGF0YSxJbHVja3lTaGVldENlbGxkYXRhVmFsdWUsSU1hcGx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCxJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWUsSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGUsSUZvcm11bGFTSSxJbHVja3lTaGVldFJvd0FuZENvbHVtbkxlbixJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlbixJbHVja3lTaGVldFNlbGVjdGlvbixJY2VsbE90aGVySW5mbyxJZm9ybXVsYUxpc3QsSWZvcm11bGFMaXN0SXRlbSwgSWx1Y2t5c2hlZXRIeXBlcmxpbmssIElsdWNreXNoZWV0SHlwZXJsaW5rVHlwZSwgSWx1Y2t5c2hlZXREYXRhVmVyaWZpY2F0aW9ufSBmcm9tIFwiLi9JTHVja1wiO1xyXG5pbXBvcnQge0x1Y2t5U2hlZXRDZWxsZGF0YX0gZnJvbSBcIi4vTHVja3lDZWxsXCI7XHJcbmltcG9ydCB7IElhdHRyaWJ1dGVMaXN0IH0gZnJvbSBcIi4uL0lDb21tb25cIjtcclxuaW1wb3J0IHtnZXRYbWxBdHRpYnV0ZSwgZ2V0Q29sdW1uV2lkdGhQaXhlbCwgZnJvbXVsYVJlZixnZXRSb3dIZWlnaHRQaXhlbCxnZXRjZWxscmFuZ2UsZ2VuZXJhdGVSYW5kb21JbmRleCxnZXRQeEJ5RU1VcywgZ2V0TXVsdGlTZXF1ZW5jZVRvTnVtLCBnZXRUcmFuc1IxQzFUb1NlcXVlbmNlLCBnZXRQZWVsT2ZmWDE0LCBnZXRNdWx0aUZvcm11bGFWYWx1ZX0gZnJvbSBcIi4uL2NvbW1vbi9tZXRob2RcIjtcclxuaW1wb3J0IHtib3JkZXJUeXBlcywgQ09NTU9OX1RZUEUyLCBEQVRBX1ZFUklGSUNBVElPTl9NQVAsIERBVEFfVkVSSUZJQ0FUSU9OX1RZUEUyX01BUCwgd29ya3NoZWV0RmlsZVBhdGh9IGZyb20gXCIuLi9jb21tb24vY29uc3RhbnRcIjtcclxuaW1wb3J0IHsgUmVhZFhtbCwgSVN0eWxlQ29sbGVjdGlvbnMsIEVsZW1lbnQsZ2V0Q29sb3IgfSBmcm9tIFwiLi9SZWFkWG1sXCI7XHJcbmltcG9ydCB7IEx1Y2t5RmlsZUJhc2UsTHVja3lTaGVldEJhc2UsTHVja3lDb25maWcsTHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wLEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlLEx1Y2t5c2hlZXRDYWxjQ2hhaW4sTHVja3lTaGVldENvbmZpZ01lcmdlIH0gZnJvbSBcIi4vTHVja3lCYXNlXCI7XHJcbmltcG9ydCB7SW1hZ2VMaXN0fSBmcm9tIFwiLi9MdWNreUltYWdlXCI7XHJcbmltcG9ydCBkYXlqcyBmcm9tIFwiZGF5anNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreVNoZWV0IGV4dGVuZHMgTHVja3lTaGVldEJhc2Uge1xyXG5cclxuICAgIHByaXZhdGUgcmVhZFhtbDpSZWFkWG1sXHJcbiAgICBwcml2YXRlIHNoZWV0RmlsZTpzdHJpbmdcclxuICAgIHByaXZhdGUgaXNJbml0aWFsQ2VsbDpib29sZWFuXHJcbiAgICBwcml2YXRlIHN0eWxlczpJU3R5bGVDb2xsZWN0aW9uc1xyXG4gICAgcHJpdmF0ZSBzaGFyZWRTdHJpbmdzOkVsZW1lbnRbXVxyXG4gICAgcHJpdmF0ZSBtZXJnZUNlbGxzOkVsZW1lbnRbXVxyXG4gICAgcHJpdmF0ZSBjYWxjQ2hhaW5FbGVzOkVsZW1lbnRbXVxyXG4gICAgcHJpdmF0ZSBzaGVldExpc3Q6SWF0dHJpYnV0ZUxpc3RcclxuXHJcbiAgICBwcml2YXRlIGltYWdlTGlzdDpJbWFnZUxpc3RcclxuXHJcbiAgICBwcml2YXRlIGZvcm11bGFSZWZMaXN0OklGb3JtdWxhU0lcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzaGVldE5hbWU6c3RyaW5nLCBzaGVldElkOnN0cmluZywgc2hlZXRPcmRlcjpudW1iZXIsaXNJbml0aWFsQ2VsbDpib29sZWFuPWZhbHNlLCBhbGxGaWxlT3B0aW9uOmFueSl7XHJcbiAgICAgICAgLy9Qcml2YXRlXHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlzSW5pdGlhbENlbGwgPSBpc0luaXRpYWxDZWxsO1xyXG5cclxuICAgICAgICB0aGlzLnJlYWRYbWwgPSBhbGxGaWxlT3B0aW9uLnJlYWRYbWw7XHJcbiAgICAgICAgdGhpcy5zaGVldEZpbGUgPSBhbGxGaWxlT3B0aW9uLnNoZWV0RmlsZTtcclxuICAgICAgICB0aGlzLnN0eWxlcyA9IGFsbEZpbGVPcHRpb24uc3R5bGVzO1xyXG4gICAgICAgIHRoaXMuc2hhcmVkU3RyaW5ncyA9IGFsbEZpbGVPcHRpb24uc2hhcmVkU3RyaW5ncztcclxuICAgICAgICB0aGlzLmNhbGNDaGFpbkVsZXMgPSBhbGxGaWxlT3B0aW9uLmNhbGNDaGFpbjtcclxuICAgICAgICB0aGlzLnNoZWV0TGlzdCA9IGFsbEZpbGVPcHRpb24uc2hlZXRMaXN0O1xyXG4gICAgICAgIHRoaXMuaW1hZ2VMaXN0ID0gYWxsRmlsZU9wdGlvbi5pbWFnZUxpc3Q7XHJcbiAgICAgICAgdGhpcy5oaWRlID0gYWxsRmlsZU9wdGlvbi5oaWRlO1xyXG5cclxuICAgICAgICAvL091dHB1dFxyXG4gICAgICAgIHRoaXMubmFtZSA9IHNoZWV0TmFtZTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gc2hlZXRJZDtcclxuICAgICAgICB0aGlzLm9yZGVyID0gc2hlZXRPcmRlci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gbmV3IEx1Y2t5Q29uZmlnKCk7XHJcbiAgICAgICAgdGhpcy5jZWxsZGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMubWVyZ2VDZWxscyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm1lcmdlQ2VsbHMvbWVyZ2VDZWxsXCIsIHRoaXMuc2hlZXRGaWxlKTtcclxuICAgICAgICBsZXQgY2xyU2NoZW1lID0gdGhpcy5zdHlsZXNbXCJjbHJTY2hlbWVcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgICAgIGxldCBzaGVldFZpZXcgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzaGVldFZpZXdzL3NoZWV0Vmlld1wiLCB0aGlzLnNoZWV0RmlsZSk7XHJcbiAgICAgICAgbGV0IHNob3dHcmlkTGluZXMgPSBcIjFcIiwgdGFiU2VsZWN0ZWQ9XCIwXCIsIHpvb21TY2FsZSA9IFwiMTAwXCIsIGFjdGl2ZUNlbGwgPSBcIkExXCI7XHJcbiAgICAgICAgaWYoc2hlZXRWaWV3Lmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgbGV0IGF0dHJMaXN0ID0gc2hlZXRWaWV3WzBdLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgIHNob3dHcmlkTGluZXMgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJzaG93R3JpZExpbmVzXCIsIFwiMVwiKTtcclxuICAgICAgICAgICAgdGFiU2VsZWN0ZWQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJ0YWJTZWxlY3RlZFwiLCBcIjBcIik7XHJcbiAgICAgICAgICAgIHpvb21TY2FsZSA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcInpvb21TY2FsZVwiLCBcIjEwMFwiKTtcclxuICAgICAgICAgICAgLy8gbGV0IGNvbG9ySWQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJjb2xvcklkXCIsIFwiMFwiKTtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbnMgPSBzaGVldFZpZXdbMF0uZ2V0SW5uZXJFbGVtZW50cyhcInNlbGVjdGlvblwiKTtcclxuICAgICAgICAgICAgaWYoc2VsZWN0aW9ucyE9bnVsbCAmJiBzZWxlY3Rpb25zLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUNlbGwgPSBnZXRYbWxBdHRpYnV0ZShzZWxlY3Rpb25zWzBdLmF0dHJpYnV0ZUxpc3QsIFwiYWN0aXZlQ2VsbFwiLCBcIkExXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlOklsdWNreVNoZWV0U2VsZWN0aW9uID0gZ2V0Y2VsbHJhbmdlKGFjdGl2ZUNlbGwsIHRoaXMuc2hlZXRMaXN0LCBzaGVldElkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubHVja3lzaGVldF9zZWxlY3Rfc2F2ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sdWNreXNoZWV0X3NlbGVjdF9zYXZlLnB1c2gocmFuZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2hvd0dyaWRMaW5lcyA9IHNob3dHcmlkTGluZXM7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB0YWJTZWxlY3RlZDtcclxuICAgICAgICB0aGlzLnpvb21SYXRpbyA9IHBhcnNlSW50KHpvb21TY2FsZSkvMTAwO1xyXG5cclxuICAgICAgICBsZXQgdGFiQ29sb3JzID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2hlZXRQci90YWJDb2xvclwiLCB0aGlzLnNoZWV0RmlsZSk7XHJcbiAgICAgICAgaWYodGFiQ29sb3JzIT1udWxsICYmIHRhYkNvbG9ycy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgIGxldCB0YWJDb2xvciA9IHRhYkNvbG9yc1swXSwgYXR0ckxpc3QgPSB0YWJDb2xvci5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICAvLyBpZihhdHRyTGlzdC5yZ2IhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHRjID0gZ2V0Q29sb3IodGFiQ29sb3IsIHRoaXMuc3R5bGVzLCBcImJcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yID0gdGM7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzaGVldEZvcm1hdFByID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2hlZXRGb3JtYXRQclwiLCB0aGlzLnNoZWV0RmlsZSk7XHJcbiAgICAgICAgbGV0IGRlZmF1bHRDb2xXaWR0aCwgZGVmYXVsdFJvd0hlaWdodDtcclxuICAgICAgICBpZihzaGVldEZvcm1hdFByLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgbGV0IGF0dHJMaXN0ID0gc2hlZXRGb3JtYXRQclswXS5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICBkZWZhdWx0Q29sV2lkdGggPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJkZWZhdWx0Q29sV2lkdGhcIiwgXCI5LjIxXCIpO1xyXG4gICAgICAgICAgICBkZWZhdWx0Um93SGVpZ2h0ID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiZGVmYXVsdFJvd0hlaWdodFwiLCBcIjE5XCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29sV2lkdGggPSBnZXRDb2x1bW5XaWR0aFBpeGVsKHBhcnNlRmxvYXQoZGVmYXVsdENvbFdpZHRoKSk7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0Um93SGVpZ2h0ID0gZ2V0Um93SGVpZ2h0UGl4ZWwocGFyc2VGbG9hdChkZWZhdWx0Um93SGVpZ2h0KSk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmdlbmVyYXRlQ29uZmlnQ29sdW1uTGVuQW5kSGlkZGVuKCk7XHJcbiAgICAgICAgbGV0IGNlbGxPdGhlckluZm86SWNlbGxPdGhlckluZm8gPSAgdGhpcy5nZW5lcmF0ZUNvbmZpZ1Jvd0xlbkFuZEhpZGRlbkFkZENlbGwoKTtcclxuICAgICAgICBcclxuICAgICAgICBpZih0aGlzLmNhbGNDaGFpbj09bnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY0NoYWluID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZm9ybXVsYUxpc3RFeGlzdDpJZm9ybXVsYUxpc3Q9e307XHJcbiAgICAgICAgZm9yKGxldCBjPTA7Yzx0aGlzLmNhbGNDaGFpbkVsZXMubGVuZ3RoO2MrKyl7XHJcbiAgICAgICAgICAgIGxldCBjYWxjQ2hhaW5FbGUgPSB0aGlzLmNhbGNDaGFpbkVsZXNbY10sIGF0dHJMaXN0ID0gY2FsY0NoYWluRWxlLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgIGlmKGF0dHJMaXN0LmkhPXNoZWV0SWQpe1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCByID0gYXR0ckxpc3QuciAsIGkgPSBhdHRyTGlzdC5pLCBsID0gYXR0ckxpc3QubCwgcyA9IGF0dHJMaXN0LnMsIGEgPSBhdHRyTGlzdC5hLCB0ID0gYXR0ckxpc3QudDtcclxuXHJcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGdldGNlbGxyYW5nZShyKTtcclxuICAgICAgICAgICAgbGV0IGNoYWluID0gbmV3IEx1Y2t5c2hlZXRDYWxjQ2hhaW4oKTtcclxuICAgICAgICAgICAgY2hhaW4uciA9IHJhbmdlLnJvd1swXTtcclxuICAgICAgICAgICAgY2hhaW4uYyA9IHJhbmdlLmNvbHVtblswXTtcclxuICAgICAgICAgICAgY2hhaW4uaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICB0aGlzLmNhbGNDaGFpbi5wdXNoKGNoYWluKTtcclxuICAgICAgICAgICAgZm9ybXVsYUxpc3RFeGlzdFtcInJcIityK1wiY1wiK2NdID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIGlmKHRoaXMuZm9ybXVsYVJlZkxpc3QhPW51bGwpe1xyXG4gICAgICAgICAgICBmb3IobGV0IGtleSBpbiB0aGlzLmZvcm11bGFSZWZMaXN0KXtcclxuICAgICAgICAgICAgICAgIGxldCBmdW5jbGlzdCA9IHRoaXMuZm9ybXVsYVJlZkxpc3Rba2V5XTtcclxuICAgICAgICAgICAgICAgIGxldCBtYWluRnVuYyA9IGZ1bmNsaXN0W1wibWFpblJlZlwiXSwgbWFpbkNlbGxWYWx1ZSA9IG1haW5GdW5jLmNlbGxWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGxldCBmb3JtdWxhVHh0ID0gbWFpbkZ1bmMuZnY7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFpblIgPSBtYWluQ2VsbFZhbHVlLnIsIG1haW5DID0gbWFpbkNlbGxWYWx1ZS5jO1xyXG4gICAgICAgICAgICAgICAgLy8gbGV0IHJlZlJhbmdlID0gZ2V0Y2VsbHJhbmdlKHJlZik7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IG5hbWUgaW4gZnVuY2xpc3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG5hbWUgPT0gXCJtYWluUmVmXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmdW5jVmFsdWUgPSBmdW5jbGlzdFtuYW1lXSwgY2VsbFZhbHVlID0gZnVuY1ZhbHVlLmNlbGxWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWU9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHIgPSBjZWxsVmFsdWUuciwgYyA9IGNlbGxWYWx1ZS5jO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZnVuYyA9IGZvcm11bGFUeHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldFJvdyA9IHIgLSBtYWluUiwgb2Zmc2V0Q29sID0gYyAtIG1haW5DO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpZihvZmZzZXRSb3cgPiAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYyA9IFwiPVwiICsgZnJvbXVsYVJlZi5mdW5jdGlvbkNvcHkoZnVuYywgXCJkb3duXCIsIG9mZnNldFJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYob2Zmc2V0Um93IDwgMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMgPSBcIj1cIiArIGZyb211bGFSZWYuZnVuY3Rpb25Db3B5KGZ1bmMsIFwidXBcIiwgTWF0aC5hYnMob2Zmc2V0Um93KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihvZmZzZXRDb2wgPiAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYyA9IFwiPVwiICsgZnJvbXVsYVJlZi5mdW5jdGlvbkNvcHkoZnVuYywgXCJyaWdodFwiLCBvZmZzZXRDb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKG9mZnNldENvbCA8IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jID0gXCI9XCIgKyBmcm9tdWxhUmVmLmZ1bmN0aW9uQ29weShmdW5jLCBcImxlZnRcIiwgTWF0aC5hYnMob2Zmc2V0Q29sKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhvZmZzZXRSb3csIG9mZnNldENvbCwgZnVuYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIChjZWxsVmFsdWUudiBhcyBJbHVja3lTaGVldENlbGxkYXRhVmFsdWUgKS5mID0gZnVuYztcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvL+a3u+WKoOWFseS6q+WFrOW8j+mTvlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGFpbiA9IG5ldyBMdWNreXNoZWV0Q2FsY0NoYWluKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhaW4uciA9IGNlbGxWYWx1ZS5yO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYWluLmMgPSBjZWxsVmFsdWUuYztcclxuICAgICAgICAgICAgICAgICAgICBjaGFpbi5pbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjQ2hhaW4ucHVzaChjaGFpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvL1RoZXJlIG1heSBiZSBmb3JtdWxhcyB0aGF0IGRvIG5vdCBhcHBlYXIgaW4gY2FsY0NoYWluXHJcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gY2VsbE90aGVySW5mby5mb3JtdWxhTGlzdCl7XHJcbiAgICAgICAgICAgIGlmKCEoa2V5IGluIGZvcm11bGFMaXN0RXhpc3QpKXtcclxuICAgICAgICAgICAgICAgIGxldCBmb3JtdWxhTGlzdEl0ZW0gPSBjZWxsT3RoZXJJbmZvLmZvcm11bGFMaXN0W2tleV07XHJcbiAgICAgICAgICAgICAgICBsZXQgY2hhaW4gPSBuZXcgTHVja3lzaGVldENhbGNDaGFpbigpO1xyXG4gICAgICAgICAgICAgICAgY2hhaW4uciA9IGZvcm11bGFMaXN0SXRlbS5yO1xyXG4gICAgICAgICAgICAgICAgY2hhaW4uYyA9IGZvcm11bGFMaXN0SXRlbS5jO1xyXG4gICAgICAgICAgICAgICAgY2hhaW4uaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjQ2hhaW4ucHVzaChjaGFpbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAgIC8vIGRhdGFWZXJpZmljYXRpb24gY29uZmlnXHJcbiAgICAgICAgdGhpcy5kYXRhVmVyaWZpY2F0aW9uID0gdGhpcy5nZW5lcmF0ZUNvbmZpZ0RhdGFWYWxpZGF0aW9ucygpO1xyXG5cclxuICAgICAgICAvLyBoeXBlcmxpbmsgY29uZmlnXHJcbiAgICAgICAgdGhpcy5oeXBlcmxpbmsgPSB0aGlzLmdlbmVyYXRlQ29uZmlnSHlwZXJsaW5rcygpO1xyXG4gICAgICBcclxuICAgICAgICAvLyBzaGVldCBoaWRlXHJcbiAgICAgICAgdGhpcy5oaWRlID0gdGhpcy5oaWRlO1xyXG5cclxuICAgICAgICBpZih0aGlzLm1lcmdlQ2VsbHMhPW51bGwpe1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMubWVyZ2VDZWxscy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgIGxldCBtZXJnZSA9IHRoaXMubWVyZ2VDZWxsc1tpXSwgYXR0ckxpc3QgPSBtZXJnZS5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlZiA9IGF0dHJMaXN0LnJlZjtcclxuICAgICAgICAgICAgICAgIGlmKHJlZj09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBnZXRjZWxscmFuZ2UocmVmLCB0aGlzLnNoZWV0TGlzdCwgc2hlZXRJZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWVyZ2VWYWx1ZSA9IG5ldyBMdWNreVNoZWV0Q29uZmlnTWVyZ2UoKTtcclxuICAgICAgICAgICAgICAgIG1lcmdlVmFsdWUuciA9IHJhbmdlLnJvd1swXTtcclxuICAgICAgICAgICAgICAgIG1lcmdlVmFsdWUuYyA9IHJhbmdlLmNvbHVtblswXTtcclxuICAgICAgICAgICAgICAgIG1lcmdlVmFsdWUucnMgPSByYW5nZS5yb3dbMV0tcmFuZ2Uucm93WzBdKzE7XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZhbHVlLmNzID0gcmFuZ2UuY29sdW1uWzFdLXJhbmdlLmNvbHVtblswXSsxO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcubWVyZ2U9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLm1lcmdlID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5tZXJnZVtyYW5nZS5yb3dbMF0gKyBcIl9cIiArIHJhbmdlLmNvbHVtblswXV0gPSBtZXJnZVZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZHJhd2luZ0ZpbGUgPSBhbGxGaWxlT3B0aW9uLmRyYXdpbmdGaWxlLCBkcmF3aW5nUmVsc0ZpbGUgPSBhbGxGaWxlT3B0aW9uLmRyYXdpbmdSZWxzRmlsZTtcclxuICAgICAgICBpZihkcmF3aW5nRmlsZSE9bnVsbCAmJiBkcmF3aW5nUmVsc0ZpbGUhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgdHdvQ2VsbEFuY2hvcnMgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ4ZHI6dHdvQ2VsbEFuY2hvclwiLCBkcmF3aW5nRmlsZSk7XHJcblxyXG4gICAgICAgICAgICBpZih0d29DZWxsQW5jaG9ycyE9bnVsbCAmJiB0d29DZWxsQW5jaG9ycy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGk9MDtpPHR3b0NlbGxBbmNob3JzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0d29DZWxsQW5jaG9yID0gdHdvQ2VsbEFuY2hvcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVkaXRBcyA9IGdldFhtbEF0dGlidXRlKHR3b0NlbGxBbmNob3IuYXR0cmlidXRlTGlzdCwgXCJlZGl0QXNcIiwgXCJ0d29DZWxsXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgeGRyRnJvbXMgPSB0d29DZWxsQW5jaG9yLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6ZnJvbVwiKSwgeGRyVG9zID0gdHdvQ2VsbEFuY2hvci5nZXRJbm5lckVsZW1lbnRzKFwieGRyOnRvXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgeGRyX2JsaXBmaWxscyA9IHR3b0NlbGxBbmNob3IuZ2V0SW5uZXJFbGVtZW50cyhcImE6YmxpcFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZih4ZHJGcm9tcyE9bnVsbCAmJiB4ZHJfYmxpcGZpbGxzIT1udWxsICYmIHhkckZyb21zLmxlbmd0aD4wICYmIHhkcl9ibGlwZmlsbHMubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeGRyRnJvbSA9IHhkckZyb21zWzBdLCB4ZHJUbyA9IHhkclRvc1swXSx4ZHJfYmxpcGZpbGwgPSB4ZHJfYmxpcGZpbGxzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlbWJlZCA9IGdldFhtbEF0dGlidXRlKHhkcl9ibGlwZmlsbC5hdHRyaWJ1dGVMaXN0LCBcInI6ZW1iZWRcIiwgbnVsbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VPYmplY3QgPSB0aGlzLmdldEJhc2U2NEJ5UmlkKHJlbWJlZCwgZHJhd2luZ1JlbHNGaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWFnZU9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGFvZmYgPSB4ZHJfeGZybS5nZXRJbm5lckVsZW1lbnRzKFwiYTpvZmZcIiksIGFleHQgPSB4ZHJfeGZybS5nZXRJbm5lckVsZW1lbnRzKFwiYTpleHRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmKGFvZmYhPW51bGwgJiYgYWV4dCE9bnVsbCAmJiBhb2ZmLmxlbmd0aD4wICYmIGFleHQubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgbGV0IGFvZmZBdHRyaWJ1dGUgPSBhb2ZmWzBdLmF0dHJpYnV0ZUxpc3QsIGFleHRBdHRyaWJ1dGUgPSBhZXh0WzBdLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBsZXQgeCA9IGdldFhtbEF0dGlidXRlKGFvZmZBdHRyaWJ1dGUsIFwieFwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxldCB5ID0gZ2V0WG1sQXR0aWJ1dGUoYW9mZkF0dHJpYnV0ZSwgXCJ5XCIsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxldCBjeCA9IGdldFhtbEF0dGlidXRlKGFleHRBdHRyaWJ1dGUsIFwiY3hcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBsZXQgY3kgPSBnZXRYbWxBdHRpYnV0ZShhZXh0QXR0cmlidXRlLCBcImN5XCIsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGlmKHghPW51bGwgJiYgeSE9bnVsbCAmJiBjeCE9bnVsbCAmJiBjeSE9bnVsbCAmJiBpbWFnZU9iamVjdCAhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgeF9uID0gZ2V0UHhCeUVNVXMocGFyc2VJbnQoeCksIFwiY1wiKSx5X24gPSBnZXRQeEJ5RU1VcyhwYXJzZUludCh5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBjeF9uID0gZ2V0UHhCeUVNVXMocGFyc2VJbnQoY3gpLCBcImNcIiksY3lfbiA9IGdldFB4QnlFTVVzKHBhcnNlSW50KGN5KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeF9uID0wLHlfbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjeF9uID0gMCwgY3lfbiA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5mcm9tQ29sID0gdGhpcy5nZXRYZHJWYWx1ZSh4ZHJGcm9tLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6Y29sXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QuZnJvbUNvbE9mZiA9IGdldFB4QnlFTVVzKHRoaXMuZ2V0WGRyVmFsdWUoeGRyRnJvbS5nZXRJbm5lckVsZW1lbnRzKFwieGRyOmNvbE9mZlwiKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5mcm9tUm93PSB0aGlzLmdldFhkclZhbHVlKHhkckZyb20uZ2V0SW5uZXJFbGVtZW50cyhcInhkcjpyb3dcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5mcm9tUm93T2ZmID0gZ2V0UHhCeUVNVXModGhpcy5nZXRYZHJWYWx1ZSh4ZHJGcm9tLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6cm93T2ZmXCIpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC50b0NvbCA9IHRoaXMuZ2V0WGRyVmFsdWUoeGRyVG8uZ2V0SW5uZXJFbGVtZW50cyhcInhkcjpjb2xcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC50b0NvbE9mZiA9IGdldFB4QnlFTVVzKHRoaXMuZ2V0WGRyVmFsdWUoeGRyVG8uZ2V0SW5uZXJFbGVtZW50cyhcInhkcjpjb2xPZmZcIikpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QudG9Sb3cgPSB0aGlzLmdldFhkclZhbHVlKHhkclRvLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6cm93XCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QudG9Sb3dPZmYgPSBnZXRQeEJ5RU1Vcyh0aGlzLmdldFhkclZhbHVlKHhkclRvLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6cm93T2ZmXCIpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5vcmlnaW5XaWR0aCA9IGN4X247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0Lm9yaWdpbkhlaWdodCA9IGN5X247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlZGl0QXM9PVwiYWJzb2x1dGVcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC50eXBlID0gXCIzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihlZGl0QXM9PVwib25lQ2VsbFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LnR5cGUgPSBcIjJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QudHlwZSA9IFwiMVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5pc0ZpeGVkUG9zID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmZpeGVkTGVmdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmZpeGVkVG9wID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUJvcmRlcjpJbHVja3lJbWFnZUJvcmRlciA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIiMwMDBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcInNvbGlkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmJvcmRlciA9IGltYWdlQm9yZGVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlQ3JvcDpJbHVja3lJbWFnZUNyb3AgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGN5X24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGN4X25cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5jcm9wID0gaW1hZ2VDcm9wO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlRGVmYXVsdDpJbHVja3lJbWFnZURlZmF1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGN5X24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB4X24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHlfbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjeF9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QuZGVmYXVsdCA9IGltYWdlRGVmYXVsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuaW1hZ2VzPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZXNbZ2VuZXJhdGVSYW5kb21JbmRleChcImltYWdlXCIpXSA9IGltYWdlT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0gXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRYZHJWYWx1ZShlbGU6RWxlbWVudFtdKTpudW1iZXJ7XHJcbiAgICAgICAgaWYoZWxlPT1udWxsIHx8IGVsZS5sZW5ndGg9PTApe1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJzZUludChlbGVbMF0udmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0QmFzZTY0QnlSaWQocmlkOnN0cmluZywgZHJhd2luZ1JlbHNGaWxlOnN0cmluZyl7XHJcbiAgICAgICAgbGV0IFJlbGF0aW9uc2hpcHMgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJSZWxhdGlvbnNoaXBzL1JlbGF0aW9uc2hpcFwiLCBkcmF3aW5nUmVsc0ZpbGUpO1xyXG5cclxuICAgICAgICBpZihSZWxhdGlvbnNoaXBzIT1udWxsICYmIFJlbGF0aW9uc2hpcHMubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPFJlbGF0aW9uc2hpcHMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgUmVsYXRpb25zaGlwID0gUmVsYXRpb25zaGlwc1tpXTtcclxuICAgICAgICAgICAgICAgIGxldCBhdHRyTGlzdCA9IFJlbGF0aW9uc2hpcC5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICAgICAgbGV0IElkID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiSWRcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3JjID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiVGFyZ2V0XCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgaWYoSWQgPT0gcmlkKXtcclxuICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFwuXFwuXFwvL2csIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IFwieGwvXCIgKyBzcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGltZ2FnZSA9IHRoaXMuaW1hZ2VMaXN0LmdldEltYWdlQnlOYW1lKHNyYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltZ2FnZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBkZXNjIFRoaXMgd2lsbCBjb252ZXJ0IGNvbHMvY29sIHRvIGx1Y2t5c2hlZXQgY29uZmlnIG9mIGNvbHVtbid3aWR0aFxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgZ2VuZXJhdGVDb25maWdDb2x1bW5MZW5BbmRIaWRkZW4oKXtcclxuICAgICAgICBsZXQgY29scyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNvbHMvY29sXCIsIHRoaXMuc2hlZXRGaWxlKTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPGNvbHMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBjb2wgPSBjb2xzW2ldLCBhdHRyTGlzdCA9IGNvbC5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICBsZXQgbWluID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwibWluXCIsIG51bGwpO1xyXG4gICAgICAgICAgICBsZXQgbWF4ID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwibWF4XCIsIG51bGwpO1xyXG4gICAgICAgICAgICBsZXQgd2lkdGggPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJ3aWR0aFwiLCBudWxsKTtcclxuICAgICAgICAgICAgbGV0IGhpZGRlbiA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcImhpZGRlblwiLCBudWxsKTtcclxuICAgICAgICAgICAgbGV0IGN1c3RvbVdpZHRoID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiY3VzdG9tV2lkdGhcIiwgbnVsbCk7XHJcblxyXG5cclxuICAgICAgICAgICAgaWYobWluPT1udWxsIHx8IG1heD09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IG1pbk51bSA9IHBhcnNlSW50KG1pbiktMSwgbWF4TnVtPXBhcnNlSW50KG1heCktMSwgd2lkdGhOdW09cGFyc2VGbG9hdCh3aWR0aCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IobGV0IG09bWluTnVtO208PW1heE51bTttKyspe1xyXG4gICAgICAgICAgICAgICAgaWYod2lkdGghPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLmNvbHVtbmxlbj09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmNvbHVtbmxlbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jb2x1bW5sZW5bbV0gPSBnZXRDb2x1bW5XaWR0aFBpeGVsKHdpZHRoTnVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihoaWRkZW49PVwiMVwiKXtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5jb2xoaWRkZW49PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jb2xoaWRkZW4gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY29saGlkZGVuW21dID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcuY29sdW1ubGVuKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29uZmlnLmNvbHVtbmxlblttXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoY3VzdG9tV2lkdGghPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLmN1c3RvbVdpZHRoPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY3VzdG9tV2lkdGggPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY3VzdG9tV2lkdGhbbV0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQGRlc2MgVGhpcyB3aWxsIGNvbnZlcnQgY29scy9jb2wgdG8gbHVja3lzaGVldCBjb25maWcgb2YgY29sdW1uJ3dpZHRoXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZUNvbmZpZ1Jvd0xlbkFuZEhpZGRlbkFkZENlbGwoKTpJY2VsbE90aGVySW5mb3tcclxuICAgICAgICBsZXQgcm93cyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNoZWV0RGF0YS9yb3dcIiwgdGhpcy5zaGVldEZpbGUpO1xyXG4gICAgICAgIGxldCBjZWxsT3RoZXJJbmZvOkljZWxsT3RoZXJJbmZvID0ge307XHJcbiAgICAgICAgbGV0IGZvcm11bGFMaXN0Oklmb3JtdWxhTGlzdCA9IHt9O1xyXG4gICAgICAgIGNlbGxPdGhlckluZm8uZm9ybXVsYUxpc3QgPSBmb3JtdWxhTGlzdDtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHJvd3MubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIGxldCByb3cgPSByb3dzW2ldLCBhdHRyTGlzdCA9IHJvdy5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICBsZXQgcm93Tm8gPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJyXCIsIG51bGwpO1xyXG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiaHRcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgIGxldCBoaWRkZW4gPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJoaWRkZW5cIiwgbnVsbCk7XHJcbiAgICAgICAgICAgIGxldCBjdXN0b21IZWlnaHQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJjdXN0b21IZWlnaHRcIiwgbnVsbCk7XHJcblxyXG4gICAgICAgICAgICBpZihyb3dObz09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHJvd05vTnVtID0gcGFyc2VJbnQocm93Tm8pIC0gMTtcclxuICAgICAgICAgICAgaWYoaGVpZ2h0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGxldCBoZWlnaHROdW0gPSBwYXJzZUZsb2F0KGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5yb3dsZW49PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnJvd2xlbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcucm93bGVuW3Jvd05vTnVtXSA9IGdldFJvd0hlaWdodFBpeGVsKGhlaWdodE51bSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGhpZGRlbj09XCIxXCIpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcucm93aGlkZGVuPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5yb3doaWRkZW4gPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnJvd2hpZGRlbltyb3dOb051bV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5yb3dsZW4pe1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbmZpZy5yb3dsZW5bcm93Tm9OdW1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGN1c3RvbUhlaWdodCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5jdXN0b21IZWlnaHQ9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmN1c3RvbUhlaWdodCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY3VzdG9tSGVpZ2h0W3Jvd05vTnVtXSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmlzSW5pdGlhbENlbGwpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbGxzID0gcm93LmdldElubmVyRWxlbWVudHMoXCJjXCIpO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBrZXkgaW4gY2VsbHMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsID0gY2VsbHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbFZhbHVlID0gbmV3IEx1Y2t5U2hlZXRDZWxsZGF0YShjZWxsLCB0aGlzLnN0eWxlcywgdGhpcy5zaGFyZWRTdHJpbmdzLCB0aGlzLm1lcmdlQ2VsbHMsdGhpcy5zaGVldEZpbGUsIHRoaXMucmVhZFhtbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLl9ib3JkZXJPYmplY3QhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5ib3JkZXJJbmZvPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmJvcmRlckluZm8gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5ib3JkZXJJbmZvLnB1c2goY2VsbFZhbHVlLl9ib3JkZXJPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2VsbFZhbHVlLl9ib3JkZXJPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCBib3JkZXJJZCA9IGNlbGxWYWx1ZS5fYm9yZGVySWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYoYm9yZGVySWQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBsZXQgYm9yZGVycyA9IHRoaXMuc3R5bGVzW1wiYm9yZGVyc1wiXSBhcyBFbGVtZW50W107XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGlmKHRoaXMuY29uZmlnLl9ib3JkZXJJbmZvPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHRoaXMuY29uZmlnLl9ib3JkZXJJbmZvID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgaWYoIGJvcmRlcklkIGluIHRoaXMuY29uZmlnLl9ib3JkZXJJbmZvKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHRoaXMuY29uZmlnLl9ib3JkZXJJbmZvW2JvcmRlcklkXS5jZWxscy5wdXNoKGNlbGxWYWx1ZS5yICsgXCJfXCIgKyBjZWxsVmFsdWUuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBib3JkZXIgPSBib3JkZXJzW2JvcmRlcklkXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBib3JkZXJPYmplY3QgPSBuZXcgTHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBib3JkZXJPYmplY3QucmFuZ2VUeXBlID0gXCJjZWxsR3JvdXBcIjtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGJvcmRlck9iamVjdC5jZWxscyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGJvcmRlckNlbGxWYWx1ZSA9IG5ldyBMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgbGVmdHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcImxlZnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgcmlnaHRzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJyaWdodFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCB0b3BzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJ0b3BcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgYm90dG9tcyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwiYm90dG9tXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGRpYWdvbmFscyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwiZGlhZ29uYWxcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmdldEJvcmRlckluZm8obGVmdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IHJpZ2h0ID0gdGhpcy5nZXRCb3JkZXJJbmZvKHJpZ2h0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgdG9wID0gdGhpcy5nZXRCb3JkZXJJbmZvKHRvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGJvdHRvbSA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhib3R0b21zKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBkaWFnb25hbCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhkaWFnb25hbHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBpc0FkZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYobGVmdCE9bnVsbCAmJiBsZWZ0LmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUubCA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgaXNBZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGlmKHJpZ2h0IT1udWxsICYmIHJpZ2h0LmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUuciA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGlzQWRkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBpZih0b3AhPW51bGwgJiYgdG9wLmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUudCA9IHRvcDtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYoYm90dG9tIT1udWxsICYmIGJvdHRvbS5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLmIgPSBib3R0b207XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgaXNBZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGlmKGlzQWRkKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBib3JkZXJPYmplY3QudmFsdWUgPSBib3JkZXJDZWxsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgdGhpcy5jb25maWcuX2JvcmRlckluZm9bYm9yZGVySWRdID0gYm9yZGVyT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuX2Zvcm11bGFUeXBlPT1cInNoYXJlZFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5mb3JtdWxhUmVmTGlzdD09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm11bGFSZWZMaXN0ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZm9ybXVsYVJlZkxpc3RbY2VsbFZhbHVlLl9mb3JtdWxhU2ldPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybXVsYVJlZkxpc3RbY2VsbFZhbHVlLl9mb3JtdWxhU2ldID0ge31cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZ2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUudiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdiA9IChjZWxsVmFsdWUudiBhcyBJbHVja3lTaGVldENlbGxkYXRhVmFsdWUpLmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWZWYWx1ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQ6Y2VsbFZhbHVlLl9mb3JtdWxhVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjpjZWxsVmFsdWUuX2ZvbXVsYVJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpOmNlbGxWYWx1ZS5fZm9ybXVsYVNpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnY6ZnYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWU6Y2VsbFZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5fZm9tdWxhUmVmIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybXVsYVJlZkxpc3RbY2VsbFZhbHVlLl9mb3JtdWxhU2ldW1wibWFpblJlZlwiXSA9IHJlZlZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm11bGFSZWZMaXN0W2NlbGxWYWx1ZS5fZm9ybXVsYVNpXVtjZWxsVmFsdWUucitcIl9cIitjZWxsVmFsdWUuY10gPSByZWZWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocmVmVmFsdWUsIHRoaXMuZm9ybXVsYVJlZkxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9UaGVyZSBtYXkgYmUgZm9ybXVsYXMgdGhhdCBkbyBub3QgYXBwZWFyIGluIGNhbGNDaGFpblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS52IT1udWxsICYmIChjZWxsVmFsdWUudiBhcyBJbHVja3lTaGVldENlbGxkYXRhVmFsdWUpLmYhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm9ybXVsYUNlbGw6SWZvcm11bGFMaXN0SXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6Y2VsbFZhbHVlLnIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOmNlbGxWYWx1ZS5jXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbE90aGVySW5mby5mb3JtdWxhTGlzdFtcInJcIitjZWxsVmFsdWUucitcImNcIitjZWxsVmFsdWUuY10gPSBmb3JtdWxhQ2VsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2VsbGRhdGEucHVzaChjZWxsVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjZWxsT3RoZXJJbmZvO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgLyoqXHJcbiAgICAgKiBsdWNreXNoZWV0IGNvbmZpZyBvZiBkYXRhVmFsaWRhdGlvbnNcclxuICAgICAqIFxyXG4gICAgICogQHJldHVybnMge0lsdWNreXNoZWV0RGF0YVZlcmlmaWNhdGlvbn0gLSBkYXRhVmFsaWRhdGlvbnMgY29uZmlnXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2VuZXJhdGVDb25maWdEYXRhVmFsaWRhdGlvbnMoKTogSWx1Y2t5c2hlZXREYXRhVmVyaWZpY2F0aW9uIHtcclxuICAgICAgXHJcbiAgICAgIGxldCByb3dzID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxyXG4gICAgICAgIFwiZGF0YVZhbGlkYXRpb25zL2RhdGFWYWxpZGF0aW9uXCIsXHJcbiAgICAgICAgdGhpcy5zaGVldEZpbGVcclxuICAgICAgKTtcclxuICAgICAgbGV0IGV4dExzdCA9XHJcbiAgICAgICAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxyXG4gICAgICAgICAgXCJleHRMc3QvZXh0L3gxNDpkYXRhVmFsaWRhdGlvbnMveDE0OmRhdGFWYWxpZGF0aW9uXCIsXHJcbiAgICAgICAgICB0aGlzLnNoZWV0RmlsZVxyXG4gICAgICAgICkgfHwgW107XHJcbiAgICAgIFxyXG4gICAgICByb3dzID0gcm93cy5jb25jYXQoZXh0THN0KTtcclxuICBcclxuICAgICAgbGV0IGRhdGFWZXJpZmljYXRpb246IElsdWNreXNoZWV0RGF0YVZlcmlmaWNhdGlvbiA9IHt9O1xyXG4gIFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgcm93ID0gcm93c1tpXTtcclxuICAgICAgICBsZXQgYXR0ckxpc3QgPSByb3cuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICBsZXQgZm9ybXVsYVZhbHVlID0gcm93LnZhbHVlO1xyXG4gIFxyXG4gICAgICAgIGxldCB0eXBlID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwidHlwZVwiLCBudWxsKTtcclxuICAgICAgICBpZighdHlwZSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG9wZXJhdG9yID0gXCJcIixcclxuICAgICAgICAgICAgc3FyZWYgPSBcIlwiLFxyXG4gICAgICAgICAgICBzcXJlZkluZGV4QXJyOiBzdHJpbmdbXSA9IFtdLFxyXG4gICAgICAgICAgICB2YWx1ZUFycjogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICBsZXQgX3Byb2hpYml0SW5wdXQgPVxyXG4gICAgICAgICAgZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiYWxsb3dCbGFua1wiLCBudWxsKSAhPT0gXCIxXCIgPyBmYWxzZSA6IHRydWU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8geDE0IHByb2Nlc3NpbmdcclxuICAgICAgICBjb25zdCBmb3JtdWxhUmVnID0gbmV3IFJlZ0V4cCgvPHgxNDpmb3JtdWxhMT58PHhtOnNxcmVmPi9nKVxyXG4gICAgICAgIGlmIChmb3JtdWxhUmVnLnRlc3QoZm9ybXVsYVZhbHVlKSAmJiBleHRMc3Q/Lmxlbmd0aCA+PSAwKSB7XHJcbiAgICAgICAgICBvcGVyYXRvciA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIm9wZXJhdG9yXCIsIG51bGwpO1xyXG4gICAgICAgICAgY29uc3QgcGVlbE9mZkRhdGEgPSBnZXRQZWVsT2ZmWDE0KGZvcm11bGFWYWx1ZSk7XHJcbiAgICAgICAgICBzcXJlZiA9IHBlZWxPZmZEYXRhPy5zcXJlZjtcclxuICAgICAgICAgIHNxcmVmSW5kZXhBcnIgPSBnZXRNdWx0aVNlcXVlbmNlVG9OdW0oc3FyZWYpO1xyXG4gICAgICAgICAgdmFsdWVBcnIgPSBnZXRNdWx0aUZvcm11bGFWYWx1ZShwZWVsT2ZmRGF0YT8uZm9ybXVsYSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9wZXJhdG9yID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwib3BlcmF0b3JcIiwgbnVsbCk7XHJcbiAgICAgICAgICBzcXJlZiA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcInNxcmVmXCIsIG51bGwpO1xyXG4gICAgICAgICAgc3FyZWZJbmRleEFyciA9IGdldE11bHRpU2VxdWVuY2VUb051bShzcXJlZik7XHJcbiAgICAgICAgICB2YWx1ZUFyciA9IGdldE11bHRpRm9ybXVsYVZhbHVlKGZvcm11bGFWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgX3R5cGUgPSBEQVRBX1ZFUklGSUNBVElPTl9NQVBbdHlwZV07XHJcbiAgICAgICAgbGV0IF90eXBlMiA9IG51bGw7XHJcbiAgICAgICAgbGV0IF92YWx1ZTE6IHN0cmluZyB8IG51bWJlciA9IHZhbHVlQXJyPy5sZW5ndGggPj0gMSA/IHZhbHVlQXJyWzBdIDogXCJcIjtcclxuICAgICAgICBsZXQgX3ZhbHVlMjogc3RyaW5nIHwgbnVtYmVyID0gdmFsdWVBcnI/Lmxlbmd0aCA9PT0gMiA/IHZhbHVlQXJyWzFdIDogXCJcIjtcclxuICAgICAgICBsZXQgX2hpbnQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJwcm9tcHRcIiwgbnVsbCk7XHJcbiAgICAgICAgbGV0IF9oaW50U2hvdyA9IF9oaW50ID8gdHJ1ZSA6IGZhbHNlXHJcbiAgXHJcbiAgICAgICAgY29uc3QgbWF0Y2hUeXBlID0gQ09NTU9OX1RZUEUyLmluY2x1ZGVzKF90eXBlKSA/IFwiY29tbW9uXCIgOiBfdHlwZTtcclxuICAgICAgICBfdHlwZTIgPSBvcGVyYXRvclxyXG4gICAgICAgICAgPyBEQVRBX1ZFUklGSUNBVElPTl9UWVBFMl9NQVBbbWF0Y2hUeXBlXVtvcGVyYXRvcl1cclxuICAgICAgICAgIDogXCJid1wiO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIG1vYmlsZSBwaG9uZSBudW1iZXIgcHJvY2Vzc2luZ1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIF90eXBlID09PSBcInRleHRfY29udGVudFwiICYmXHJcbiAgICAgICAgICAoX3ZhbHVlMT8uaW5jbHVkZXMoXCJMRU5cIikgfHwgX3ZhbHVlMT8uaW5jbHVkZXMoXCJsZW5cIikpICYmXHJcbiAgICAgICAgICBfdmFsdWUxPy5pbmNsdWRlcyhcIj0xMVwiKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgX3R5cGUgPSBcInZhbGlkaXR5XCI7XHJcbiAgICAgICAgICBfdHlwZTIgPSBcInBob25lXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkYXRlIHByb2Nlc3NpbmdcclxuICAgICAgICBpZiAoX3R5cGUgPT09IFwiZGF0ZVwiKSB7XHJcbiAgICAgICAgICBjb25zdCBEMTkwMCA9IG5ldyBEYXRlKDE4OTksIDExLCAzMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgICBfdmFsdWUxID0gZGF5anMoRDE5MDApXHJcbiAgICAgICAgICAgIC5jbG9uZSgpXHJcbiAgICAgICAgICAgIC5hZGQoTnVtYmVyKF92YWx1ZTEpLCBcImRheVwiKVxyXG4gICAgICAgICAgICAuZm9ybWF0KFwiWVlZWS1NTS1ERFwiKTtcclxuICAgICAgICAgIF92YWx1ZTIgPSBkYXlqcyhEMTkwMClcclxuICAgICAgICAgICAgLmNsb25lKClcclxuICAgICAgICAgICAgLmFkZChOdW1iZXIoX3ZhbHVlMiksIFwiZGF5XCIpXHJcbiAgICAgICAgICAgIC5mb3JtYXQoXCJZWVlZLU1NLUREXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBjaGVja2JveCBhbmQgZHJvcGRvd24gcHJvY2Vzc2luZ1xyXG4gICAgICAgIGlmIChfdHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IF90eXBlID09PSBcImRyb3Bkb3duXCIpIHtcclxuICAgICAgICAgIF90eXBlMiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGR5bmFtaWNhbGx5IGFkZCBkYXRhVmVyaWZpY2F0aW9uc1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHNxcmVmSW5kZXhBcnIpIHtcclxuICAgICAgICAgIGRhdGFWZXJpZmljYXRpb25bcmVmXSA9IHtcclxuICAgICAgICAgICAgdHlwZTogX3R5cGUsXHJcbiAgICAgICAgICAgIHR5cGUyOiBfdHlwZTIsXHJcbiAgICAgICAgICAgIHZhbHVlMTogX3ZhbHVlMSxcclxuICAgICAgICAgICAgdmFsdWUyOiBfdmFsdWUyLFxyXG4gICAgICAgICAgICBjaGVja2VkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVtb3RlOiBmYWxzZSxcclxuICAgICAgICAgICAgcHJvaGliaXRJbnB1dDogX3Byb2hpYml0SW5wdXQsXHJcbiAgICAgICAgICAgIGhpbnRTaG93OiBfaGludFNob3csXHJcbiAgICAgICAgICAgIGhpbnRUZXh0OiBfaGludFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgcmV0dXJuIGRhdGFWZXJpZmljYXRpb247XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvKipcclxuICAgICAqIGx1Y2t5c2hlZXQgY29uZmlnIG9mIGh5cGVybGlua1xyXG4gICAgICogXHJcbiAgICAgKiBAcmV0dXJucyB7SWx1Y2t5c2hlZXRIeXBlcmxpbmt9IC0gaHlwZXJsaW5rIGNvbmZpZ1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdlbmVyYXRlQ29uZmlnSHlwZXJsaW5rcygpOiBJbHVja3lzaGVldEh5cGVybGluayB7XHJcbiAgICAgIGxldCByb3dzID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxyXG4gICAgICAgIFwiaHlwZXJsaW5rcy9oeXBlcmxpbmtcIixcclxuICAgICAgICB0aGlzLnNoZWV0RmlsZVxyXG4gICAgICApO1xyXG4gICAgICBsZXQgaHlwZXJsaW5rOiBJbHVja3lzaGVldEh5cGVybGluayA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgcm93ID0gcm93c1tpXTtcclxuICAgICAgICBsZXQgYXR0ckxpc3QgPSByb3cuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICBsZXQgcmVmID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwicmVmXCIsIG51bGwpLFxyXG4gICAgICAgICAgICByZWZBcnIgPSBnZXRNdWx0aVNlcXVlbmNlVG9OdW0ocmVmKSxcclxuICAgICAgICAgICAgX2Rpc3BsYXkgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJkaXNwbGF5XCIsIG51bGwpLFxyXG4gICAgICAgICAgICBfYWRkcmVzcyA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcImxvY2F0aW9uXCIsIG51bGwpLFxyXG4gICAgICAgICAgICBfdG9vbHRpcCA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcInRvb2x0aXBcIiwgbnVsbCk7XHJcbiAgICAgICAgbGV0IF90eXBlOiBJbHVja3lzaGVldEh5cGVybGlua1R5cGUgPSBfYWRkcmVzcyA/IFwiaW50ZXJuYWxcIiA6IFwiZXh0ZXJuYWxcIjtcclxuICBcclxuICAgICAgICAvLyBleHRlcm5hbCBoeXBlcmxpbmtcclxuICAgICAgICBpZiAoIV9hZGRyZXNzKSB7XHJcbiAgICAgICAgICBsZXQgcmlkID0gYXR0ckxpc3RbXCJyOmlkXCJdO1xyXG4gICAgICAgICAgbGV0IHNoZWV0RmlsZSA9IHRoaXMuc2hlZXRGaWxlO1xyXG4gICAgICAgICAgbGV0IHJlbGF0aW9uc2hpcExpc3QgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXHJcbiAgICAgICAgICAgIFwiUmVsYXRpb25zaGlwcy9SZWxhdGlvbnNoaXBcIixcclxuICAgICAgICAgICAgYHhsL3dvcmtzaGVldHMvX3JlbHMvJHtzaGVldEZpbGUucmVwbGFjZSh3b3Jrc2hlZXRGaWxlUGF0aCwgXCJcIil9LnJlbHNgXHJcbiAgICAgICAgICApO1xyXG4gIFxyXG4gICAgICAgICAgY29uc3QgZmluZFJpZCA9IHJlbGF0aW9uc2hpcExpc3Q/LmZpbmQoXHJcbiAgICAgICAgICAgIChlKSA9PiBlLmF0dHJpYnV0ZUxpc3RbXCJJZFwiXSA9PT0gcmlkXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGlmIChmaW5kUmlkKSB7XHJcbiAgICAgICAgICAgIF9hZGRyZXNzID0gZmluZFJpZC5hdHRyaWJ1dGVMaXN0W1wiVGFyZ2V0XCJdO1xyXG4gICAgICAgICAgICBfdHlwZSA9IGZpbmRSaWQuYXR0cmlidXRlTGlzdFtcclxuICAgICAgICAgICAgICBcIlRhcmdldE1vZGVcIlxyXG4gICAgICAgICAgICBdPy50b0xvY2FsZUxvd2VyQ2FzZSgpIGFzIElsdWNreXNoZWV0SHlwZXJsaW5rVHlwZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG1hdGNoIFIxQzFcclxuICAgICAgICBjb25zdCBhZGRyZXNzUmVnID0gbmV3IFJlZ0V4cCgvXi4qIVIoW1xcZCRdKStDKFtcXGQkXSkqJC9nKVxyXG4gICAgICAgIGlmIChhZGRyZXNzUmVnLnRlc3QoX2FkZHJlc3MpKSB7XHJcbiAgICAgICAgICBfYWRkcmVzcyA9IGdldFRyYW5zUjFDMVRvU2VxdWVuY2UoX2FkZHJlc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBkeW5hbWljYWxseSBhZGQgaHlwZXJsaW5rc1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHJlZkFycikge1xyXG4gICAgICAgICAgaHlwZXJsaW5rW3JlZl0gPSB7XHJcbiAgICAgICAgICAgIGxpbmtBZGRyZXNzOiBfYWRkcmVzcyxcclxuICAgICAgICAgICAgbGlua1Rvb2x0aXA6IF90b29sdGlwIHx8IFwiXCIsXHJcbiAgICAgICAgICAgIGxpbmtUeXBlOiBfdHlwZSxcclxuICAgICAgICAgICAgZGlzcGxheTogX2Rpc3BsYXkgfHwgXCJcIixcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gaHlwZXJsaW5rO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHByaXZhdGUgZ2V0Qm9yZGVySW5mbyhib3JkZXJzOkVsZW1lbnRbXSk6THVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZXtcclxuICAgIC8vICAgICBpZihib3JkZXJzPT1udWxsKXtcclxuICAgIC8vICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAvLyAgICAgfVxyXG5cclxuICAgIC8vICAgICBsZXQgYm9yZGVyID0gYm9yZGVyc1swXSwgYXR0ckxpc3QgPSBib3JkZXIuYXR0cmlidXRlTGlzdDtcclxuICAgIC8vICAgICBsZXQgY2xyU2NoZW1lID0gdGhpcy5zdHlsZXNbXCJjbHJTY2hlbWVcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgLy8gICAgIGxldCBzdHlsZTpzdHJpbmcgPSBhdHRyTGlzdC5zdHlsZTtcclxuICAgIC8vICAgICBpZihzdHlsZT09bnVsbCB8fCBzdHlsZT09XCJub25lXCIpe1xyXG4gICAgLy8gICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIC8vICAgICB9XHJcblxyXG4gICAgLy8gICAgIGxldCBjb2xvcnMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcImNvbG9yXCIpO1xyXG4gICAgLy8gICAgIGxldCBjb2xvclJldCA9IFwiIzAwMDAwMFwiO1xyXG4gICAgLy8gICAgIGlmKGNvbG9ycyE9bnVsbCl7XHJcbiAgICAvLyAgICAgICAgIGxldCBjb2xvciA9IGNvbG9yc1swXTtcclxuICAgIC8vICAgICAgICAgY29sb3JSZXQgPSBnZXRDb2xvcihjb2xvciwgY2xyU2NoZW1lKTtcclxuICAgIC8vICAgICB9XHJcblxyXG4gICAgLy8gICAgIGxldCByZXQgPSBuZXcgTHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZSgpO1xyXG4gICAgLy8gICAgIHJldC5zdHlsZSA9IGJvcmRlclR5cGVzW3N0eWxlXTtcclxuICAgIC8vICAgICByZXQuY29sb3IgPSBjb2xvclJldDtcclxuXHJcbiAgICAvLyAgICAgcmV0dXJuIHJldDtcclxuICAgIC8vIH1cclxufVxyXG4iLCJpbXBvcnQge0l1cGxvYWRmaWxlTGlzdCwgSWF0dHJpYnV0ZUxpc3QsIHN0cmluZ1RvTnVtfSBmcm9tIFwiLi4vSUNvbW1vblwiO1xyXG5pbXBvcnQge2luZGV4ZWRDb2xvcnN9ICBmcm9tIFwiLi4vY29tbW9uL2NvbnN0YW50XCI7XHJcbmltcG9ydCB7TGlnaHRlbkRhcmtlbkNvbG9yfSAgZnJvbSBcIi4uL2NvbW1vbi9tZXRob2RcIjtcclxuXHJcblxyXG5jbGFzcyB4bWxvcGVyYXRpb24ge1xyXG4gICAgLyoqXHJcbiAgICAqIEBwYXJhbSB0YWcgU2VhcmNoIHhtbCB0YWcgbmFtZSAsIGRpdix0aXRsZSBldGMuXHJcbiAgICAqIEBwYXJhbSBmaWxlIFhtbCBzdHJpbmdcclxuICAgICogQHJldHVybiBYbWwgZWxlbWVudCBzdHJpbmcgXHJcbiAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGdldEVsZW1lbnRzQnlPbmVUYWcodGFnOnN0cmluZywgZmlsZTpzdHJpbmcpOnN0cmluZ1tde1xyXG4gICAgICAgIC8vPGE6W14vPjogXSs/Pi4qPzwvYTpbXi8+OiBdKz8+XHJcbiAgICAgICAgbGV0IHJlYWRUYWdSZWc7XHJcbiAgICAgICAgaWYodGFnLmluZGV4T2YoXCJ8XCIpPi0xKXtcclxuICAgICAgICAgICAgbGV0IHRhZ3MgPSB0YWcuc3BsaXQoXCJ8XCIpLCB0YWdzUmVnVHh0PVwiXCI7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8dGFncy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgIGxldCB0ID0gdGFnc1tpXTtcclxuICAgICAgICAgICAgICAgIHRhZ3NSZWdUeHQgKz0gXCJ8PFwiKyB0ICtcIiBbXj5dKz9bXi9dPltcXFxcc1xcXFxTXSo/PC9cIisgdCArXCI+fDxcIisgdCArXCIgW14+XSs/Lz58PFwiKyB0ICtcIj5bXFxcXHNcXFxcU10qPzwvXCIrIHQgK1wiPnw8XCIrIHQgK1wiLz5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YWdzUmVnVHh0ID0gdGFnc1JlZ1R4dC5zdWJzdHIoMSwgdGFnc1JlZ1R4dC5sZW5ndGgpO1xyXG4gICAgICAgICAgICByZWFkVGFnUmVnID0gbmV3IFJlZ0V4cCh0YWdzUmVnVHh0LCBcImdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHJlYWRUYWdSZWcgPSBuZXcgUmVnRXhwKFwiPFwiKyB0YWcgK1wiIFtePl0rP1teL10+W1xcXFxzXFxcXFNdKj88L1wiKyB0YWcgK1wiPnw8XCIrIHRhZyArXCIgW14+XSs/Lz58PFwiKyB0YWcgK1wiPltcXFxcc1xcXFxTXSo/PC9cIisgdGFnICtcIj58PFwiKyB0YWcgK1wiLz5cIiwgXCJnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBsZXQgcmV0ID0gZmlsZS5tYXRjaChyZWFkVGFnUmVnKTtcclxuICAgICAgICBpZihyZXQ9PW51bGwpe1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUmVhZFhtbCBleHRlbmRzIHhtbG9wZXJhdGlvbntcclxuICAgIG9yaWdpbkZpbGU6SXVwbG9hZGZpbGVMaXN0XHJcbiAgICBjb25zdHJ1Y3RvcihmaWxlczpJdXBsb2FkZmlsZUxpc3Qpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5GaWxlID0gZmlsZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogQHBhcmFtIHBhdGggU2VhcmNoIHhtbCB0YWcgZ3JvdXAgLCBkaXYsdGl0bGUgZXRjLlxyXG4gICAgKiBAcGFyYW0gZmlsZU5hbWUgT25lIG9mIHVwbG9hZGZpbGVMaXN0LCB1cGxvYWRmaWxlTGlzdCBpcyBmaWxlIGdyb3VwLCB7a2V5OnZhbHVlfVxyXG4gICAgKiBAcmV0dXJuIFhtbCBlbGVtZW50IGNhbHNzXHJcbiAgICAqL1xyXG4gICAgZ2V0RWxlbWVudHNCeVRhZ05hbWUocGF0aDpzdHJpbmcsIGZpbGVOYW1lOnN0cmluZyk6IEVsZW1lbnRbXXtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5TmFtZShmaWxlTmFtZSk7XHJcbiAgICAgICAgbGV0IHBhdGhBcnIgPSBwYXRoLnNwbGl0KFwiL1wiKSwgcmV0OnN0cmluZ1tdIHwgc3RyaW5nO1xyXG4gICAgICAgIGZvcihsZXQga2V5IGluIHBhdGhBcnIpe1xyXG4gICAgICAgICAgICBsZXQgcGF0aCA9IHBhdGhBcnJba2V5XTtcclxuICAgICAgICAgICAgaWYocmV0PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5nZXRFbGVtZW50c0J5T25lVGFnKHBhdGgsZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGlmKHJldCBpbnN0YW5jZW9mIEFycmF5KXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbXM6c3RyaW5nW109W107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBrZXkgaW4gcmV0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSByZXRba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQodGhpcy5nZXRFbGVtZW50c0J5T25lVGFnKHBhdGgsaXRlbSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXQgPSBpdGVtcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5nZXRFbGVtZW50c0J5T25lVGFnKHBhdGgscmV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGVsZW1lbnRzOkVsZW1lbnRbXSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IobGV0IGk9MDtpPHJldC5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgbGV0IGVsZSA9IG5ldyBFbGVtZW50KHJldFtpXSk7XHJcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQHBhcmFtIG5hbWUgT25lIG9mIHVwbG9hZGZpbGVMaXN0J3MgbmFtZSwgc2VhcmNoIGZvciBmaWxlIGJ5IHRoaXMgcGFyYW1ldGVyXHJcbiAgICAqIEByZXRydW4gU2VsZWN0IGEgZmlsZSBmcm9tIHVwbG9hZGZpbGVMaXN0XHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRGaWxlQnlOYW1lKG5hbWU6c3RyaW5nKTpzdHJpbmd7XHJcbiAgICAgICAgZm9yKGxldCBmaWxlS2V5IGluIHRoaXMub3JpZ2luRmlsZSl7XHJcbiAgICAgICAgICAgIGlmKGZpbGVLZXkuaW5kZXhPZihuYW1lKT4tMSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5GaWxlW2ZpbGVLZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIFxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgRWxlbWVudCBleHRlbmRzIHhtbG9wZXJhdGlvbiB7XHJcbiAgICBlbGVtZW50U3RyaW5nOnN0cmluZ1xyXG4gICAgYXR0cmlidXRlTGlzdDpJYXR0cmlidXRlTGlzdFxyXG4gICAgdmFsdWU6c3RyaW5nXHJcbiAgICBjb250YWluZXI6c3RyaW5nXHJcbiAgICBjb25zdHJ1Y3RvcihzdHI6c3RyaW5nKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudFN0cmluZyA9IHN0cjtcclxuICAgICAgICB0aGlzLnNldFZhbHVlKCk7XHJcbiAgICAgICAgY29uc3QgcmVhZEF0dHJSZWcgPSBuZXcgUmVnRXhwKCdbYS16QS1aMC05XzpdKj89XCIuKj9cIicsIFwiZ1wiKTtcclxuICAgICAgICBsZXQgYXR0ckxpc3QgPSB0aGlzLmNvbnRhaW5lci5tYXRjaChyZWFkQXR0clJlZyk7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVMaXN0ID0ge307XHJcbiAgICAgICAgaWYoYXR0ckxpc3QhPW51bGwpe1xyXG4gICAgICAgICAgICBmb3IobGV0IGtleSBpbiBhdHRyTGlzdCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXR0ckZ1bGwgPSBhdHRyTGlzdFtrZXldO1xyXG4gICAgICAgICAgICAgICAgLy8gbGV0IGFsPSBhdHRyRnVsbC5zcGxpdChcIj1cIik7XHJcbiAgICAgICAgICAgICAgICBpZihhdHRyRnVsbC5sZW5ndGg9PTApe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGF0dHJLZXkgPSBhdHRyRnVsbC5zdWJzdHIoMCwgYXR0ckZ1bGwuaW5kZXhPZignPScpKTtcclxuICAgICAgICAgICAgICAgIGxldCBhdHRyVmFsdWUgPSBhdHRyRnVsbC5zdWJzdHIoYXR0ckZ1bGwuaW5kZXhPZignPScpICsgMSk7XHJcbiAgICAgICAgICAgICAgICBpZihhdHRyS2V5PT1udWxsIHx8IGF0dHJWYWx1ZT09bnVsbCB8fGF0dHJLZXkubGVuZ3RoPT0wIHx8IGF0dHJWYWx1ZS5sZW5ndGg9PTApe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVMaXN0W2F0dHJLZXldID0gYXR0clZhbHVlLnN1YnN0cigxLCBhdHRyVmFsdWUubGVuZ3RoLTIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcGFyYW0gbmFtZSBHZXQgYXR0cmlidXRlIGJ5IGtleSBpbiBlbGVtZW50XHJcbiAgICAqIEByZXR1cm4gU2luZ2xlIGF0dHJpYnV0ZVxyXG4gICAgKi9cclxuICAgIGdldChuYW1lOnN0cmluZyk6c3RyaW5nfG51bWJlcnxib29sZWFue1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZUxpc3RbbmFtZV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwYXJhbSB0YWcgR2V0IGVsZW1lbnRzIGJ5IHRhZyBpbiBlbGVtZW50U3RyaW5nXHJcbiAgICAqIEByZXR1cm4gRWxlbWVudCBncm91cFxyXG4gICAgKi9cclxuICAgIGdldElubmVyRWxlbWVudHModGFnOnN0cmluZyk6RWxlbWVudFtde1xyXG4gICAgICAgIGxldCByZXQgPSB0aGlzLmdldEVsZW1lbnRzQnlPbmVUYWcodGFnLHRoaXMuZWxlbWVudFN0cmluZyk7XHJcbiAgICAgICAgbGV0IGVsZW1lbnRzOkVsZW1lbnRbXSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IobGV0IGk9MDtpPHJldC5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgbGV0IGVsZSA9IG5ldyBFbGVtZW50KHJldFtpXSk7XHJcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGVsZW1lbnRzLmxlbmd0aD09MCl7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBkZXNjIGdldCB4bWwgZG9tIHZhbHVlIGFuZCBjb250YWluZXIsIDxjb250YWluZXI+dmFsdWU8L2NvbnRhaW5lcj5cclxuICAgICovXHJcbiAgICBwcml2YXRlIHNldFZhbHVlKCl7XHJcbiAgICAgICAgbGV0IHN0ciA9IHRoaXMuZWxlbWVudFN0cmluZztcclxuICAgICAgICBpZihzdHIuc3Vic3RyKHN0ci5sZW5ndGgtMiwgMik9PVwiLz5cIil7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHN0cjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgbGV0IGZpcnN0VGFnID0gdGhpcy5nZXRGaXJzdFRhZygpO1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdFRhZ1JlZyA9IG5ldyBSZWdFeHAoXCIoPFwiKyBmaXJzdFRhZyArXCIgW14+XSs/W14vXT4pKFtcXFxcc1xcXFxTXSo/KTwvXCIrIGZpcnN0VGFnICtcIj58KDxcIisgZmlyc3RUYWcgK1wiPikoW1xcXFxzXFxcXFNdKj8pPC9cIisgZmlyc3RUYWcgK1wiPlwiLCBcImdcIik7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmaXJzdFRhZ1JlZy5leGVjKHN0cik7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYocmVzdWx0WzFdIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHJlc3VsdFsxXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcmVzdWx0WzJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHJlc3VsdFszXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcmVzdWx0WzRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAZGVzYyBnZXQgeG1sIGRvbSBmaXJzdCB0YWcsIDxhPjxiPjwvYj48L2E+LCBnZXQgYVxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgZ2V0Rmlyc3RUYWcoKXtcclxuICAgICAgICBsZXQgc3RyID0gdGhpcy5lbGVtZW50U3RyaW5nO1xyXG4gICAgICAgIGxldCBmaXJzdFRhZyA9IHN0ci5zdWJzdHIoMCwgc3RyLmluZGV4T2YoJyAnKSk7XHJcbiAgICAgICAgaWYoZmlyc3RUYWc9PVwiXCIgfHwgZmlyc3RUYWcuaW5kZXhPZihcIj5cIik+LTEpe1xyXG4gICAgICAgICAgICBmaXJzdFRhZyA9IHN0ci5zdWJzdHIoMCwgc3RyLmluZGV4T2YoJz4nKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpcnN0VGFnID0gZmlyc3RUYWcuc3Vic3RyKDEsZmlyc3RUYWcubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gZmlyc3RUYWc7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElTdHlsZUNvbGxlY3Rpb25zIHtcclxuICAgIFtpbmRleDpzdHJpbmddOkVsZW1lbnRbXSB8IElhdHRyaWJ1dGVMaXN0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbWJpbmVJbmRleGVkQ29sb3IoaW5kZXhlZENvbG9yc0lubmVyOkVsZW1lbnRbXSwgaW5kZXhlZENvbG9yczpJYXR0cmlidXRlTGlzdCk6SWF0dHJpYnV0ZUxpc3R7XHJcbiAgICBsZXQgcmV0OklhdHRyaWJ1dGVMaXN0ID0ge307XHJcbiAgICBpZihpbmRleGVkQ29sb3JzSW5uZXI9PW51bGwgfHwgaW5kZXhlZENvbG9yc0lubmVyLmxlbmd0aD09MCl7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ZWRDb2xvcnM7XHJcbiAgICB9XHJcbiAgICBmb3IobGV0IGtleSBpbiBpbmRleGVkQ29sb3JzKXtcclxuICAgICAgICBsZXQgdmFsdWUgPSBpbmRleGVkQ29sb3JzW2tleV0sIGtuID0gcGFyc2VJbnQoa2V5KTtcclxuICAgICAgICBsZXQgaW5uZXIgPSBpbmRleGVkQ29sb3JzSW5uZXJba25dO1xyXG4gICAgICAgIGlmKGlubmVyPT1udWxsKXtcclxuICAgICAgICAgICAgcmV0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgbGV0IHJnYiA9IGlubmVyLmF0dHJpYnV0ZUxpc3QucmdiO1xyXG4gICAgICAgICAgICByZXRba2V5XSA9IHJnYjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuLy9jbHJTY2hlbWU6RWxlbWVudFtdXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xvcihjb2xvcjpFbGVtZW50LCBzdHlsZXM6SVN0eWxlQ29sbGVjdGlvbnMgLCB0eXBlOnN0cmluZz1cImdcIil7XHJcbiAgICBsZXQgYXR0ckxpc3QgPSBjb2xvci5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgbGV0IGNsclNjaGVtZSA9IHN0eWxlc1tcImNsclNjaGVtZVwiXSBhcyBFbGVtZW50W107XHJcbiAgICBsZXQgaW5kZXhlZENvbG9yc0lubmVyID0gc3R5bGVzW1wiaW5kZXhlZENvbG9yc1wiXSBhcyBFbGVtZW50W107XHJcbiAgICBsZXQgbXJ1Q29sb3JzSW5uZXIgPSBzdHlsZXNbXCJtcnVDb2xvcnNcIl07XHJcbiAgICBsZXQgaW5kZXhlZENvbG9yc0xpc3QgPSBjb21iaW5lSW5kZXhlZENvbG9yKGluZGV4ZWRDb2xvcnNJbm5lciwgaW5kZXhlZENvbG9ycyk7XHJcbiAgICBsZXQgaW5kZXhlZCA9IGF0dHJMaXN0LmluZGV4ZWQsIHJnYiA9IGF0dHJMaXN0LnJnYiwgdGhlbWUgPSBhdHRyTGlzdC50aGVtZSwgdGludCA9IGF0dHJMaXN0LnRpbnQ7XHJcbiAgICBsZXQgYmc7XHJcbiAgICBpZihpbmRleGVkIT1udWxsKXtcclxuICAgICAgICBsZXQgaW5kZXhlZE51bSA9IHBhcnNlSW50KGluZGV4ZWQpO1xyXG4gICAgICAgIGJnID0gaW5kZXhlZENvbG9yc0xpc3RbaW5kZXhlZE51bV07XHJcbiAgICAgICAgaWYoYmchPW51bGwpe1xyXG4gICAgICAgICAgICBiZyA9IGJnLnN1YnN0cmluZyhiZy5sZW5ndGgtNiwgYmcubGVuZ3RoKTtcclxuICAgICAgICAgICAgYmcgPSBcIiNcIitiZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKHJnYiE9bnVsbCl7XHJcbiAgICAgICAgcmdiID0gcmdiLnN1YnN0cmluZyhyZ2IubGVuZ3RoLTYsIHJnYi5sZW5ndGgpO1xyXG4gICAgICAgIGJnID0gXCIjXCIrcmdiO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZih0aGVtZSE9bnVsbCl7XHJcbiAgICAgICAgbGV0IHRoZW1lTnVtID0gcGFyc2VJbnQodGhlbWUpO1xyXG4gICAgICAgIGlmKHRoZW1lTnVtPT0wKXtcclxuICAgICAgICAgICAgdGhlbWVOdW0gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoZW1lTnVtPT0xKXtcclxuICAgICAgICAgICAgdGhlbWVOdW0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoZW1lTnVtPT0yKXtcclxuICAgICAgICAgICAgdGhlbWVOdW0gPSAzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoZW1lTnVtPT0zKXtcclxuICAgICAgICAgICAgdGhlbWVOdW0gPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY2xyU2NoZW1lRWxlbWVudCA9IGNsclNjaGVtZVt0aGVtZU51bV07XHJcbiAgICAgICAgaWYoY2xyU2NoZW1lRWxlbWVudCE9bnVsbCl7XHJcbiAgICAgICAgICAgIGxldCBjbHJzID0gY2xyU2NoZW1lRWxlbWVudC5nZXRJbm5lckVsZW1lbnRzKFwiYTpzeXNDbHJ8YTpzcmdiQ2xyXCIpO1xyXG4gICAgICAgICAgICBpZihjbHJzIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGxldCBjbHIgPSBjbHJzWzBdO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNsckF0dHJMaXN0ID0gY2xyLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjbHIuY29udGFpbmVyLCApO1xyXG4gICAgICAgICAgICAgICAgaWYoY2xyLmNvbnRhaW5lci5pbmRleE9mKFwic3lzQ2xyXCIpPi0xKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZih0eXBlPT1cImdcIiAmJiBjbHJBdHRyTGlzdC52YWw9PVwid2luZG93VGV4dFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgYmcgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGlmKCh0eXBlPT1cInRcIiB8fCB0eXBlPT1cImJcIikgJiYgY2xyQXR0ckxpc3QudmFsPT1cIndpbmRvd1wiKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgYmcgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIH0gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2xyQXR0ckxpc3QubGFzdENsciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJnID0gXCIjXCIgKyBjbHJBdHRyTGlzdC5sYXN0Q2xyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNsckF0dHJMaXN0LnZhbCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJnID0gXCIjXCIgKyBjbHJBdHRyTGlzdC52YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoY2xyLmNvbnRhaW5lci5pbmRleE9mKFwic3JnYkNsclwiKT4tMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY2xyQXR0ckxpc3QudmFsKTtcclxuICAgICAgICAgICAgICAgICAgICBiZyA9IFwiI1wiICsgY2xyQXR0ckxpc3QudmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZih0aW50IT1udWxsKXtcclxuICAgICAgICBsZXQgdGludE51bSA9IHBhcnNlRmxvYXQodGludCk7XHJcbiAgICAgICAgaWYoYmchPW51bGwpe1xyXG4gICAgICAgICAgICBiZyA9IExpZ2h0ZW5EYXJrZW5Db2xvcihiZywgdGludE51bSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBiZztcclxufVxyXG5cclxuXHJcbi8qKiBcclxuICogQGRvbSB4bWwgYXR0cmlidXRlIG9iamVjdFxyXG4gKiBAYXR0ciBhdHRyaWJ1dGUgbmFtZVxyXG4gKiBAZCBpZiBhdHRyaWJ1dGUgaXMgbnVsbCwgcmV0dXJuIGRlZmF1bHQgdmFsdWUgXHJcbiAqIEByZXR1cm4gYXR0cmlidXRlIHZhbHVlXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRsaW5lU3RyaW5nQXR0cihmcnByOkVsZW1lbnQsIGF0dHI6c3RyaW5nKTpzdHJpbmd7XHJcbiAgICBsZXQgYXR0ckVsZSA9IGZycHIuZ2V0SW5uZXJFbGVtZW50cyhhdHRyKSwgdmFsdWU7XHJcblxyXG4gICAgaWYoYXR0ckVsZSE9bnVsbCAmJiBhdHRyRWxlLmxlbmd0aD4wKXtcclxuICAgICAgICBpZihhdHRyPT1cImJcIiB8fCBhdHRyPT1cImlcIiB8fCBhdHRyPT1cInN0cmlrZVwiKXtcclxuICAgICAgICAgICAgdmFsdWUgPSBcIjFcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihhdHRyPT1cInVcIil7XHJcbiAgICAgICAgICAgIGxldCB2ID0gYXR0ckVsZVswXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICAgICAgaWYodj09XCJkb3VibGVcIil7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZcKgPcKgwqBcIjJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlwqBpZih2PT1cInNpbmdsZUFjY291bnRpbmdcIil7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZcKgPcKgwqBcIjNcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlwqBpZih2PT1cImRvdWJsZUFjY291bnRpbmdcIil7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZcKgPcKgwqBcIjRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjFcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGF0dHI9PVwidmVydEFsaWduXCIpe1xyXG4gICAgICAgICAgICBsZXQgdiA9IGF0dHJFbGVbMF0uYXR0cmlidXRlTGlzdC52YWw7XHJcbiAgICAgICAgICAgIGlmKHY9PVwic3Vic2NyaXB0XCIpe1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjFcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHY9PVwic3VwZXJzY3JpcHRcIil7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiMlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHZhbHVlID0gYXR0ckVsZVswXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59IiwiaW1wb3J0IHtzdHJpbmdUb051bSwgSWF0dHJpYnV0ZUxpc3QsIG51bVRvc3RyaW5nLCBJRGF0YVZlcmlmaWNhdGlvbk1hcCwgSURhdGFWZXJpZmljYXRpb25UeXBlMk1hcH0gZnJvbSBcIi4uL0lDb21tb25cIjtcclxuXHJcbmV4cG9ydCBjb25zdCBjb2x1bWVIZWFkZXJfd29yZDpzdHJpbmdbXSA9IFsnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJ107XHJcblxyXG5leHBvcnQgY29uc3QgY29sdW1lSGVhZGVyX3dvcmRfaW5kZXg6c3RyaW5nVG9OdW0gPSB7ICdBJzogMCwgJ0InOiAxLCAnQyc6IDIsICdEJzogMywgJ0UnOiA0LCAnRic6IDUsICdHJzogNiwgJ0gnOiA3LCAnSSc6IDgsICdKJzogOSwgJ0snOiAxMCwgJ0wnOiAxMSwgJ00nOiAxMiwgJ04nOiAxMywgJ08nOiAxNCwgJ1AnOiAxNSwgJ1EnOiAxNiwgJ1InOiAxNywgJ1MnOiAxOCwgJ1QnOiAxOSwgJ1UnOiAyMCwgJ1YnOiAyMSwgJ1cnOiAyMiwgJ1gnOiAyMywgJ1knOiAyNCwgJ1onOiAyNSB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvcmVGaWxlID0gXCJkb2NQcm9wcy9jb3JlLnhtbFwiO1xyXG5leHBvcnQgY29uc3QgYXBwRmlsZSA9IFwiZG9jUHJvcHMvYXBwLnhtbFwiO1xyXG5leHBvcnQgY29uc3QgY29udGVudFR5cGVzRmlsZSA9IFwiW0NvbnRlbnRfVHlwZXNdLnhtbFwiO1xyXG5leHBvcnQgY29uc3Qgd29ya0Jvb2tGaWxlID0gXCJ4bC93b3JrYm9vay54bWxcIjtcclxuZXhwb3J0IGNvbnN0IGNhbGNDaGFpbkZpbGUgPSBcInhsL2NhbGNDaGFpbi54bWxcIjtcclxuZXhwb3J0IGNvbnN0IHN0eWxlc0ZpbGUgPSBcInhsL3N0eWxlcy54bWxcIjtcclxuZXhwb3J0IGNvbnN0IHNoYXJlZFN0cmluZ3NGaWxlID0gXCJ4bC9zaGFyZWRTdHJpbmdzLnhtbFwiO1xyXG5leHBvcnQgY29uc3Qgd29ya3NoZWV0RmlsZVBhdGggPSBcInhsL3dvcmtzaGVldHMvXCI7XHJcbmV4cG9ydCBjb25zdCB0aGVtZTFGaWxlID0gXCJ4bC90aGVtZS90aGVtZTEueG1sXCI7XHJcbmV4cG9ydCBjb25zdCB3b3JrYm9va1JlbHM9IFwieGwvX3JlbHMvd29ya2Jvb2sueG1sLnJlbHNcIjtcclxuXHJcblxyXG5cclxuXHJcbi8vRXhjZWwgQnVpbHQtSW4gY2VsbCB0eXBlXHJcbmV4cG9ydCBjb25zdCBTVF9DZWxsVHlwZTpJYXR0cmlidXRlTGlzdCA9e1xyXG4gICAgXCJCb29sZWFuXCI6XCJiXCIsXHJcbiAgICBcIkRhdGVcIjpcImRcIixcclxuICAgIFwiRXJyb3JcIjpcImVcIixcclxuICAgIFwiSW5saW5lU3RyaW5nXCI6XCJpbmxpbmVTdHJcIixcclxuICAgIFwiTnVtYmVyXCI6XCJuXCIsXHJcbiAgICBcIlNoYXJlZFN0cmluZ1wiOlwic1wiLFxyXG4gICAgXCJTdHJpbmdcIjpcInN0clwiLFxyXG59XHJcblxyXG4vL0V4Y2VsIEJ1aWx0LUluIGNlbGwgc3R5bGVcclxuZXhwb3J0IGNvbnN0IEJ1aWx0SW5DZWxsU3R5bGVzOklhdHRyaWJ1dGVMaXN0ID0ge1xyXG4gICAgXCIwXCI6XCJOb3JtYWxcIixcclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgbGV0IG51bUZtdERlZmF1bHQ6SWF0dHJpYnV0ZUxpc3QgPSB7XHJcbiAgICBcIjBcIjonR2VuZXJhbCcsXHJcbiAgICBcIjFcIjogJzAnLFxyXG4gICAgXCIyXCI6ICcwLjAwJyxcclxuICAgIFwiM1wiOiAnIywjIzAnLFxyXG4gICAgXCI0XCI6ICcjLCMjMC4wMCcsXHJcbiAgICBcIjlcIjonMCUnLFxyXG4gICAgXCIxMFwiOiAnMC4wMCUnLFxyXG4gICAgXCIxMVwiOiAnMC4wMEUrMDAnLFxyXG4gICAgXCIxMlwiOiAnIyA/Lz8nLFxyXG4gICAgXCIxM1wiOiAnIyA/Py8/PycsXHJcbiAgICBcIjE0XCI6ICdtL2QveXknLFxyXG4gICAgXCIxNVwiOiAnZC1tbW0teXknLFxyXG4gICAgXCIxNlwiOiAnZC1tbW0nLFxyXG4gICAgXCIxN1wiOiAnbW1tLXl5JyxcclxuICAgIFwiMThcIjogJ2g6bW0gQU0vUE0nLFxyXG4gICAgXCIxOVwiOiAnaDptbTpzcyBBTS9QTScsXHJcbiAgICBcIjIwXCI6ICdoOm1tJyxcclxuICAgIFwiMjFcIjogJ2g6bW06c3MnLFxyXG4gICAgXCIyMlwiOiAnbS9kL3l5IGg6bW0nLFxyXG4gICAgXCIzN1wiOiAnIywjIzAgOygjLCMjMCknLFxyXG4gICAgXCIzOFwiOiAnIywjIzAgO1tSZWRdKCMsIyMwKScsXHJcbiAgICBcIjM5XCI6ICcjLCMjMC4wMDsoIywjIzAuMDApJyxcclxuICAgIFwiNDBcIjogJyMsIyMwLjAwO1tSZWRdKCMsIyMwLjAwKScsXHJcbiAgICBcIjQ1XCI6ICdtbTpzcycsXHJcbiAgICBcIjQ2XCI6ICdbaF06bW06c3MnLFxyXG4gICAgXCI0N1wiOiAnbW1zcy4wJyxcclxuICAgIFwiNDhcIjogJyMjMC4wRSswJyxcclxuICAgIFwiNDlcIjogJ0AnXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBpbmRleGVkQ29sb3JzOklhdHRyaWJ1dGVMaXN0ID0ge1xyXG4gICAgXCIwXCI6JzAwMDAwMDAwJyxcclxuICAgIFwiMVwiOicwMEZGRkZGRicsXHJcbiAgICBcIjJcIjonMDBGRjAwMDAnLFxyXG4gICAgXCIzXCI6JzAwMDBGRjAwJyxcclxuICAgIFwiNFwiOicwMDAwMDBGRicsXHJcbiAgICBcIjVcIjonMDBGRkZGMDAnLFxyXG4gICAgXCI2XCI6JzAwRkYwMEZGJyxcclxuICAgIFwiN1wiOicwMDAwRkZGRicsXHJcbiAgICBcIjhcIjonMDAwMDAwMDAnLFxyXG4gICAgXCI5XCI6JzAwRkZGRkZGJyxcclxuICAgIFwiMTBcIjonMDBGRjAwMDAnLFxyXG4gICAgXCIxMVwiOicwMDAwRkYwMCcsXHJcbiAgICBcIjEyXCI6JzAwMDAwMEZGJyxcclxuICAgIFwiMTNcIjonMDBGRkZGMDAnLFxyXG4gICAgXCIxNFwiOicwMEZGMDBGRicsXHJcbiAgICBcIjE1XCI6JzAwMDBGRkZGJyxcclxuICAgIFwiMTZcIjonMDA4MDAwMDAnLFxyXG4gICAgXCIxN1wiOicwMDAwODAwMCcsXHJcbiAgICBcIjE4XCI6JzAwMDAwMDgwJyxcclxuICAgIFwiMTlcIjonMDA4MDgwMDAnLFxyXG4gICAgXCIyMFwiOicwMDgwMDA4MCcsXHJcbiAgICBcIjIxXCI6JzAwMDA4MDgwJyxcclxuICAgIFwiMjJcIjonMDBDMEMwQzAnLFxyXG4gICAgXCIyM1wiOicwMDgwODA4MCcsXHJcbiAgICBcIjI0XCI6JzAwOTk5OUZGJyxcclxuICAgIFwiMjVcIjonMDA5OTMzNjYnLFxyXG4gICAgXCIyNlwiOicwMEZGRkZDQycsXHJcbiAgICBcIjI3XCI6JzAwQ0NGRkZGJyxcclxuICAgIFwiMjhcIjonMDA2NjAwNjYnLFxyXG4gICAgXCIyOVwiOicwMEZGODA4MCcsXHJcbiAgICBcIjMwXCI6JzAwMDA2NkNDJyxcclxuICAgIFwiMzFcIjonMDBDQ0NDRkYnLFxyXG4gICAgXCIzMlwiOicwMDAwMDA4MCcsXHJcbiAgICBcIjMzXCI6JzAwRkYwMEZGJyxcclxuICAgIFwiMzRcIjonMDBGRkZGMDAnLFxyXG4gICAgXCIzNVwiOicwMDAwRkZGRicsXHJcbiAgICBcIjM2XCI6JzAwODAwMDgwJyxcclxuICAgIFwiMzdcIjonMDA4MDAwMDAnLFxyXG4gICAgXCIzOFwiOicwMDAwODA4MCcsXHJcbiAgICBcIjM5XCI6JzAwMDAwMEZGJyxcclxuICAgIFwiNDBcIjonMDAwMENDRkYnLFxyXG4gICAgXCI0MVwiOicwMENDRkZGRicsXHJcbiAgICBcIjQyXCI6JzAwQ0NGRkNDJyxcclxuICAgIFwiNDNcIjonMDBGRkZGOTknLFxyXG4gICAgXCI0NFwiOicwMDk5Q0NGRicsXHJcbiAgICBcIjQ1XCI6JzAwRkY5OUNDJyxcclxuICAgIFwiNDZcIjonMDBDQzk5RkYnLFxyXG4gICAgXCI0N1wiOicwMEZGQ0M5OScsXHJcbiAgICBcIjQ4XCI6JzAwMzM2NkZGJyxcclxuICAgIFwiNDlcIjonMDAzM0NDQ0MnLFxyXG4gICAgXCI1MFwiOicwMDk5Q0MwMCcsXHJcbiAgICBcIjUxXCI6JzAwRkZDQzAwJyxcclxuICAgIFwiNTJcIjonMDBGRjk5MDAnLFxyXG4gICAgXCI1M1wiOicwMEZGNjYwMCcsXHJcbiAgICBcIjU0XCI6JzAwNjY2Njk5JyxcclxuICAgIFwiNTVcIjonMDA5Njk2OTYnLFxyXG4gICAgXCI1NlwiOicwMDAwMzM2NicsXHJcbiAgICBcIjU3XCI6JzAwMzM5OTY2JyxcclxuICAgIFwiNThcIjonMDAwMDMzMDAnLFxyXG4gICAgXCI1OVwiOicwMDMzMzMwMCcsXHJcbiAgICBcIjYwXCI6JzAwOTkzMzAwJyxcclxuICAgIFwiNjFcIjonMDA5OTMzNjYnLFxyXG4gICAgXCI2MlwiOicwMDMzMzM5OScsXHJcbiAgICBcIjYzXCI6JzAwMzMzMzMzJyxcclxuICAgIFwiNjRcIjpudWxsLC8vc3lzdGVtIEZvcmVncm91bmQgbi9hXHJcbiAgICBcIjY1XCI6bnVsbCwvL3N5c3RlbSBCYWNrZ3JvdW5kIG4vYVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgT0VNX0NIQVJTRVQ6SWF0dHJpYnV0ZUxpc3QgPSB7XHJcbiAgICBcIjBcIjogXCJBTlNJX0NIQVJTRVRcIixcclxuICAgIFwiMVwiOiBcIkRFRkFVTFRfQ0hBUlNFVFwiLFxyXG4gICAgXCIyXCI6IFwiU1lNQk9MX0NIQVJTRVRcIixcclxuICAgIFwiNzdcIjogXCJNQUNfQ0hBUlNFVFwiLFxyXG4gICAgXCIxMjhcIjogXCJTSElGVEpJU19DSEFSU0VUXCIsXHJcbiAgICBcIjEyOVwiOiBcIkhBTkdVTF9DSEFSU0VUXCIsXHJcbiAgICBcIjEzMFwiOiBcIkpPSEFCX0NIQVJTRVRcIixcclxuICAgIFwiMTM0XCI6IFwiR0IyMzEyX0NIQVJTRVRcIixcclxuICAgIFwiMTM2XCI6IFwiQ0hJTkVTRUJJRzVfQ0hBUlNFVFwiLFxyXG4gICAgXCIxNjFcIjogXCJHUkVFS19DSEFSU0VUXCIsXHJcbiAgICBcIjE2MlwiOiBcIlRVUktJU0hfQ0hBUlNFVFwiLFxyXG4gICAgXCIxNjNcIjogXCJWSUVUTkFNRVNFX0NIQVJTRVRcIixcclxuICAgIFwiMTc3XCI6IFwiSEVCUkVXX0NIQVJTRVRcIixcclxuICAgIFwiMTc4XCI6IFwiQVJBQklDX0NIQVJTRVRcIixcclxuICAgIFwiMTg2XCI6IFwiQkFMVElDX0NIQVJTRVRcIixcclxuICAgIFwiMjA0XCI6IFwiUlVTU0lBTl9DSEFSU0VUXCIsXHJcbiAgICBcIjIyMlwiOiBcIlRIQUlfQ0hBUlNFVFwiLFxyXG4gICAgXCIyMzhcIjogXCJFQVNURVVST1BFX0NIQVJTRVRcIixcclxuICAgIFwiMjU1XCI6IFwiT0VNX0NIQVJTRVRcIixcclxufVxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBib3JkZXJUeXBlczpzdHJpbmdUb051bSA9IHtcclxuICAgIFwibm9uZVwiOjAsXHJcbiAgICBcInRoaW5cIjoxLCBcclxuICAgIFwiaGFpclwiOjIsIFxyXG4gICAgXCJkb3R0ZWRcIjozLCBcclxuICAgIFwiZGFzaGVkXCI6NCwgXHJcbiAgICBcImRhc2hEb3RcIjo1LCBcclxuICAgIFwiZGFzaERvdERvdFwiOjYsIFxyXG4gICAgXCJkb3VibGVcIjo3LCBcclxuICAgIFwibWVkaXVtXCI6OCwgXHJcbiAgICBcIm1lZGl1bURhc2hlZFwiOjksIFxyXG4gICAgXCJtZWRpdW1EYXNoRG90XCI6MTAsIFxyXG4gICAgXCJtZWRpdW1EYXNoRG90RG90XCI6MTEsIFxyXG4gICAgXCJzbGFudERhc2hEb3RcIjoxMiwgXHJcbiAgICBcInRoaWNrXCI6MTNcclxufVxyXG5cclxuXHJcbmV4cG9ydCBsZXQgbnVtRm10RGVmYXVsdE1hcDogSWF0dHJpYnV0ZUxpc3QgPSB7XHJcbiAgICBcInl5eXkvbS9kO0BcIjogXCJ5eXl5L01NL2RkXCIsXHJcbiAgICBcInl5eXkmcXVvdDvlubQmcXVvdDttJnF1b3Q75pyIJnF1b3Q7ZCZxdW90O+aXpSZxdW90OztAXCI6XHJcbiAgICAgIFwieXl5eSZxdW90O+W5tCZxdW90O01NJnF1b3Q75pyIJnF1b3Q7ZGQmcXVvdDvml6UmcXVvdDtcIixcclxuICAgIFwiWyQtNDA5XXl5eXkvbS9kXFxcXCBoOm1tXFxcXCBBTS9QTTtAXCI6IFwieXl5eS9NTS9kZCBoaDptbSBBTS9QTVwiLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGZvbnRGYW1pbHlzOklhdHRyaWJ1dGVMaXN0ID0ge1xyXG4gICAgXCIwXCI6XCJkZWZ1YWx0XCIsXHJcbiAgICBcIjFcIjpcIlJvbWFuXCIsXHJcbiAgICBcIjJcIjpcIlN3aXNzXCIsXHJcbiAgICBcIjNcIjpcIk1vZGVyblwiLFxyXG4gICAgXCI0XCI6XCJTY3JpcHRcIixcclxuICAgIFwiNVwiOlwiRGVjb3JhdGl2ZVwiXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBEQVRBX1ZFUklGSUNBVElPTl9NQVA6IElEYXRhVmVyaWZpY2F0aW9uTWFwID0ge1xyXG4gICAgbGlzdDogXCJkcm9wZG93blwiLFxyXG4gICAgd2hvbGU6IFwibnVtYmVyX2ludGVnZXJcIixcclxuICAgIGRlY2ltYWw6IFwibnVtYmVyX2RlY2ltYWxcIixcclxuICAgIGN1c3RvbTogXCJ0ZXh0X2NvbnRlbnRcIixcclxuICAgIHRleHRMZW5ndGg6IFwidGV4dF9sZW5ndGhcIixcclxuICAgIGRhdGU6IFwiZGF0ZVwiLFxyXG4gICAgXCJ1bmtub3duMVwiOiBcIm51bWJlclwiLCAvLyBubyBtYXRjaCB5ZXRcclxuICAgIFwidW5rbm93bjJcIjogXCJjaGVja2JveFwiLCAvLyBubyBtYXRjaCB5ZXRcclxuICAgIFwidW5rbm93bjNcIjogXCJ2YWxpZGl0eVwiLCAvLyBubyBtYXRjaCB5ZXRcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBDT01NT05fVFlQRTI6IHN0cmluZ1tdID0gW1xyXG4gICAgXCJudW1iZXJcIixcclxuICAgIFwibnVtYmVyX2ludGVnZXJcIixcclxuICAgIFwibnVtYmVyX2RlY2ltYWxcIixcclxuICAgIFwidGV4dF9sZW5ndGhcIixcclxuXTtcclxuXHJcbmV4cG9ydCBjb25zdCBEQVRBX1ZFUklGSUNBVElPTl9UWVBFMl9NQVA6IElEYXRhVmVyaWZpY2F0aW9uVHlwZTJNYXAgPSB7XHJcbiAgICBjb21tb246IHtcclxuICAgICAgYmV0d2VlbjogXCJid1wiLFxyXG4gICAgICBub3RCZXR3ZWVuOiBcIm5iXCIsXHJcbiAgICAgIGVxdWFsOiBcImVxXCIsXHJcbiAgICAgIG5vdEVxdWFsVG86IFwibmVcIixcclxuICAgICAgbW9yZVRoYW5UaGU6IFwiZ3RcIixcclxuICAgICAgbGVzc1RoYW46IFwibHRcIixcclxuICAgICAgZ3JlYXRlck9yRXF1YWxUbzogXCJndGVcIixcclxuICAgICAgbGVzc1RoYW5PckVxdWFsVG86IFwibHRlXCIsXHJcbiAgICB9LFxyXG4gICAgdGV4dF9jb250ZW50OiB7XHJcbiAgICAgIGluY2x1ZGU6IFwiaW5jbHVkZVwiLFxyXG4gICAgICBleGNsdWRlOiBcImV4Y2x1ZGVcIixcclxuICAgICAgZXF1YWw6IFwiZXF1YWxcIixcclxuICAgIH0sXHJcbiAgICBkYXRlOiB7XHJcbiAgICAgIGJldHdlZW46IFwiYndcIixcclxuICAgICAgbm90QmV0d2VlbjogXCJuYlwiLFxyXG4gICAgICBlcXVhbDogXCJlcVwiLFxyXG4gICAgICBub3RFcXVhbFRvOiBcIm5lXCIsXHJcbiAgICAgIGVhcmxpZXJUaGFuOiBcImJmXCIsXHJcbiAgICAgIG5vRWFybGllclRoYW46IFwibmJmXCIsXHJcbiAgICAgIGxhdGVyVGhhbjogXCJhZlwiLFxyXG4gICAgICBub0xhdGVyVGhhbjogXCJuYWZcIixcclxuICAgIH0sXHJcbiAgICB2YWxpZGl0eToge1xyXG4gICAgICBjYXJkOiBcImNhcmRcIixcclxuICAgICAgcGhvbmU6IFwicGhvbmVcIixcclxuICAgIH0sXHJcbn07XHJcbiIsImV4cG9ydCBsZXQgVURPQzphbnkgPSB7fTtcclxuXHRcclxuXHRVRE9DLkcgPSB7XHJcblx0XHRjb25jYXQgOiBmdW5jdGlvbihwOmFueSxyOmFueSkge1xyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTxyLmNtZHMubGVuZ3RoOyBpKyspIHAuY21kcy5wdXNoKHIuY21kc1tpXSk7XHJcblx0XHRcdGZvcih2YXIgaT0wOyBpPHIuY3Jkcy5sZW5ndGg7IGkrKykgcC5jcmRzLnB1c2goci5jcmRzW2ldKTtcclxuXHRcdH0sXHJcblx0XHRnZXRCQiAgOiBmdW5jdGlvbihwczphbnkpIHtcclxuXHRcdFx0dmFyIHgwPTFlOTksIHkwPTFlOTksIHgxPS14MCwgeTE9LXkwO1xyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTxwcy5sZW5ndGg7IGkrPTIpIHsgIHZhciB4PXBzW2ldLHk9cHNbaSsxXTsgIGlmKHg8eDApeDA9eDsgZWxzZSBpZih4PngxKXgxPXg7ICBpZih5PHkwKXkwPXk7ICBlbHNlIGlmKHk+eTEpeTE9eTsgIH1cclxuXHRcdFx0cmV0dXJuIFt4MCx5MCx4MSx5MV07XHJcblx0XHR9LFxyXG5cdFx0cmVjdFRvUGF0aDogZnVuY3Rpb24ocjphbnkpIHsgIHJldHVybiAge2NtZHM6W1wiTVwiLFwiTFwiLFwiTFwiLFwiTFwiLFwiWlwiXSxjcmRzOltyWzBdLHJbMV0sclsyXSxyWzFdLCByWzJdLHJbM10sclswXSxyWzNdXX07ICB9LFxyXG5cdFx0Ly8gYSBpbnNpZGUgYlxyXG5cdFx0aW5zaWRlQm94OiBmdW5jdGlvbihhOmFueSxiOmFueSkgeyAgcmV0dXJuIGJbMF08PWFbMF0gJiYgYlsxXTw9YVsxXSAmJiBhWzJdPD1iWzJdICYmIGFbM108PWJbM107ICAgfSxcclxuXHRcdGlzQm94IDogZnVuY3Rpb24ocDphbnksIGJiOmFueSkge1xyXG5cdFx0XHR2YXIgc2FtZUNyZDggPSBmdW5jdGlvbihwY3JkOmFueSwgY3JkczphbnkpIHtcclxuXHRcdFx0XHRmb3IodmFyIG89MDsgbzw4OyBvKz0yKSB7ICB2YXIgZXEgPSB0cnVlOyAgZm9yKHZhciBqPTA7IGo8ODsgaisrKSBpZihNYXRoLmFicyhjcmRzW2pdLXBjcmRbKGorbykmN10pPj0yKSB7ICBlcSA9IGZhbHNlOyAgYnJlYWs7ICB9ICAgIGlmKGVxKSByZXR1cm4gdHJ1ZTsgIH1cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH07XHJcblx0XHRcdGlmKHAuY21kcy5sZW5ndGg+MTApIHJldHVybiBmYWxzZTtcclxuXHRcdFx0dmFyIGNtZHM9cC5jbWRzLmpvaW4oXCJcIiksIGNyZHM9cC5jcmRzO1xyXG5cdFx0XHR2YXIgc2FtZVJlY3QgPSBmYWxzZTtcclxuXHRcdFx0aWYoKGNtZHM9PVwiTUxMTFpcIiAgJiYgY3Jkcy5sZW5ndGg9PSA4KSBcclxuXHRcdFx0IHx8KGNtZHM9PVwiTUxMTExaXCIgJiYgY3Jkcy5sZW5ndGg9PTEwKSApIHtcclxuXHRcdFx0XHRpZihjcmRzLmxlbmd0aD09MTApIGNyZHM9Y3Jkcy5zbGljZSgwLDgpO1xyXG5cdFx0XHRcdHZhciB4MD1iYlswXSx5MD1iYlsxXSx4MT1iYlsyXSx5MT1iYlszXTtcclxuXHRcdFx0XHRpZighc2FtZVJlY3QpIHNhbWVSZWN0ID0gc2FtZUNyZDgoY3JkcywgW3gwLHkwLHgxLHkwLHgxLHkxLHgwLHkxXSk7XHJcblx0XHRcdFx0aWYoIXNhbWVSZWN0KSBzYW1lUmVjdCA9IHNhbWVDcmQ4KGNyZHMsIFt4MCx5MSx4MSx5MSx4MSx5MCx4MCx5MF0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBzYW1lUmVjdDtcclxuXHRcdH0sXHJcblx0XHRib3hBcmVhOiBmdW5jdGlvbihhOmFueSkgeyAgdmFyIHc9YVsyXS1hWzBdLCBoPWFbM10tYVsxXTsgIHJldHVybiB3Kmg7ICB9LFxyXG5cdFx0bmV3UGF0aDogZnVuY3Rpb24oZ3N0OmFueSAgICApIHsgIGdzdC5wdGggPSB7Y21kczpbXSwgY3JkczpbXX07ICB9LFxyXG5cdFx0bW92ZVRvIDogZnVuY3Rpb24oZ3N0OmFueSx4OmFueSx5OmFueSkgeyAgdmFyIHA9VURPQy5NLm11bHRQb2ludChnc3QuY3RtLFt4LHldKTsgIC8vaWYoZ3N0LmNwb3NbMF09PXBbMF0gJiYgZ3N0LmNwb3NbMV09PXBbMV0pIHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRnc3QucHRoLmNtZHMucHVzaChcIk1cIik7ICBnc3QucHRoLmNyZHMucHVzaChwWzBdLHBbMV0pOyAgZ3N0LmNwb3MgPSBwOyAgfSxcclxuXHRcdGxpbmVUbyA6IGZ1bmN0aW9uKGdzdDphbnkseDphbnkseTphbnkpIHsgIHZhciBwPVVET0MuTS5tdWx0UG9pbnQoZ3N0LmN0bSxbeCx5XSk7ICBpZihnc3QuY3Bvc1swXT09cFswXSAmJiBnc3QuY3Bvc1sxXT09cFsxXSkgcmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGdzdC5wdGguY21kcy5wdXNoKFwiTFwiKTsgIGdzdC5wdGguY3Jkcy5wdXNoKHBbMF0scFsxXSk7ICBnc3QuY3BvcyA9IHA7ICB9LFxyXG5cdFx0Y3VydmVUbzogZnVuY3Rpb24oZ3N0OmFueSx4MTphbnkseTE6YW55LHgyOmFueSx5MjphbnkseDM6YW55LHkzOmFueSkgeyAgIHZhciBwOyAgXHJcblx0XHRcdHA9VURPQy5NLm11bHRQb2ludChnc3QuY3RtLFt4MSx5MV0pOyAgeDE9cFswXTsgIHkxPXBbMV07XHJcblx0XHRcdHA9VURPQy5NLm11bHRQb2ludChnc3QuY3RtLFt4Mix5Ml0pOyAgeDI9cFswXTsgIHkyPXBbMV07XHJcblx0XHRcdHA9VURPQy5NLm11bHRQb2ludChnc3QuY3RtLFt4Myx5M10pOyAgeDM9cFswXTsgIHkzPXBbMV07ICBnc3QuY3BvcyA9IHA7XHJcblx0XHRcdGdzdC5wdGguY21kcy5wdXNoKFwiQ1wiKTsgIFxyXG5cdFx0XHRnc3QucHRoLmNyZHMucHVzaCh4MSx5MSx4Mix5Mix4Myx5Myk7ICBcclxuXHRcdH0sXHJcblx0XHRjbG9zZVBhdGg6IGZ1bmN0aW9uKGdzdDphbnkgICkgeyAgZ3N0LnB0aC5jbWRzLnB1c2goXCJaXCIpOyAgfSxcclxuXHRcdGFyYyA6IGZ1bmN0aW9uKGdzdDphbnkseDphbnkseTphbnkscjphbnksYTA6YW55LGExOmFueSwgbmVnOmFueSkge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gY2lyY2xlIGZyb20gYTAgY291bnRlci1jbG9jay13aXNlIHRvIGExXHJcblx0XHRcdGlmKG5lZykgd2hpbGUoYTE+YTApIGExLT0yKk1hdGguUEk7XHJcblx0XHRcdGVsc2UgICAgd2hpbGUoYTE8YTApIGExKz0yKk1hdGguUEk7XHJcblx0XHRcdHZhciB0aCA9IChhMS1hMCkvNDtcclxuXHRcdFx0XHJcblx0XHRcdHZhciB4MCA9IE1hdGguY29zKHRoLzIpLCB5MCA9IC1NYXRoLnNpbih0aC8yKTtcclxuXHRcdFx0dmFyIHgxID0gKDQteDApLzMsIHkxID0geTA9PTAgPyB5MCA6ICgxLXgwKSooMy14MCkvKDMqeTApO1xyXG5cdFx0XHR2YXIgeDIgPSB4MSwgeTIgPSAteTE7XHJcblx0XHRcdHZhciB4MyA9IHgwLCB5MyA9IC15MDtcclxuXHRcdFx0XHJcblx0XHRcdHZhciBwMCA9IFt4MCx5MF0sIHAxID0gW3gxLHkxXSwgcDIgPSBbeDIseTJdLCBwMyA9IFt4Myx5M107XHJcblx0XHRcdFxyXG5cdFx0XHR2YXIgcHRoID0ge2NtZHM6Wyhnc3QucHRoLmNtZHMubGVuZ3RoPT0wKT9cIk1cIjpcIkxcIixcIkNcIixcIkNcIixcIkNcIixcIkNcIl0sIGNyZHM6W3gwLHkwLHgxLHkxLHgyLHkyLHgzLHkzXX07XHJcblx0XHRcdFxyXG5cdFx0XHR2YXIgcm90ID0gWzEsMCwwLDEsMCwwXTsgIFVET0MuTS5yb3RhdGUocm90LC10aCk7XHJcblx0XHRcdFxyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTwzOyBpKyspIHtcclxuXHRcdFx0XHRwMSA9IFVET0MuTS5tdWx0UG9pbnQocm90LHAxKTsgIHAyID0gVURPQy5NLm11bHRQb2ludChyb3QscDIpOyAgcDMgPSBVRE9DLk0ubXVsdFBvaW50KHJvdCxwMyk7XHJcblx0XHRcdFx0cHRoLmNyZHMucHVzaChwMVswXSxwMVsxXSxwMlswXSxwMlsxXSxwM1swXSxwM1sxXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHZhciBzYyA9IFtyLDAsMCxyLHgseV07ICBcclxuXHRcdFx0VURPQy5NLnJvdGF0ZShyb3QsIC1hMCt0aC8yKTsgIFVET0MuTS5jb25jYXQocm90LCBzYyk7ICBVRE9DLk0ubXVsdEFycmF5KHJvdCwgcHRoLmNyZHMpO1xyXG5cdFx0XHRVRE9DLk0ubXVsdEFycmF5KGdzdC5jdG0sIHB0aC5jcmRzKTtcclxuXHRcdFx0XHJcblx0XHRcdFVET0MuRy5jb25jYXQoZ3N0LnB0aCwgcHRoKTtcclxuXHRcdFx0dmFyIHk6YW55PXB0aC5jcmRzLnBvcCgpOyAgeD1wdGguY3Jkcy5wb3AoKTtcclxuXHRcdFx0Z3N0LmNwb3MgPSBbeCx5XTtcclxuXHRcdH0sXHJcblx0XHR0b1BvbHkgOiBmdW5jdGlvbihwOmFueSkge1xyXG5cdFx0XHRpZihwLmNtZHNbMF0hPVwiTVwiIHx8IHAuY21kc1twLmNtZHMubGVuZ3RoLTFdIT1cIlpcIikgcmV0dXJuIG51bGw7XHJcblx0XHRcdGZvcih2YXIgaT0xOyBpPHAuY21kcy5sZW5ndGgtMTsgaSsrKSBpZihwLmNtZHNbaV0hPVwiTFwiKSByZXR1cm4gbnVsbDtcclxuXHRcdFx0dmFyIG91dCA9IFtdLCBjbCA9IHAuY3Jkcy5sZW5ndGg7XHJcblx0XHRcdGlmKHAuY3Jkc1swXT09cC5jcmRzW2NsLTJdICYmIHAuY3Jkc1sxXT09cC5jcmRzW2NsLTFdKSBjbC09MjtcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8Y2w7IGkrPTIpIG91dC5wdXNoKFtwLmNyZHNbaV0scC5jcmRzW2krMV1dKTtcclxuXHRcdFx0aWYoVURPQy5HLnBvbHlBcmVhKHAuY3Jkcyk8MCkgb3V0LnJldmVyc2UoKTtcclxuXHRcdFx0cmV0dXJuIG91dDtcclxuXHRcdH0sXHJcblx0XHRmcm9tUG9seSA6IGZ1bmN0aW9uKHA6YW55KSB7XHJcblx0XHRcdHZhciBvOmFueSA9IHtjbWRzOltdLGNyZHM6W119O1xyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTxwLmxlbmd0aDsgaSsrKSB7IG8uY3Jkcy5wdXNoKHBbaV1bMF0sIHBbaV1bMV0pOyAgby5jbWRzLnB1c2goaT09MD9cIk1cIjpcIkxcIik7ICB9XHJcblx0XHRcdG8uY21kcy5wdXNoKFwiWlwiKTtcclxuXHRcdFx0cmV0dXJuIG87XHJcblx0XHR9LFxyXG5cdFx0cG9seUFyZWEgOiBmdW5jdGlvbihwOmFueSkge1xyXG5cdFx0XHRpZihwLmxlbmd0aCA8NikgcmV0dXJuIDA7XHJcblx0XHRcdHZhciBsID0gcC5sZW5ndGggLSAyO1xyXG5cdFx0XHR2YXIgc3VtID0gKHBbMF0tcFtsXSkgKiAocFtsKzFdK3BbMV0pO1xyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxyXG5cdFx0XHRcdHN1bSArPSAocFtpKzJdLXBbaV0pICogKHBbaSsxXStwW2krM10pO1xyXG5cdFx0XHRyZXR1cm4gLSBzdW0gKiAwLjU7XHJcblx0XHR9LFxyXG5cdFx0cG9seUNsaXAgOiBmdW5jdGlvbihwMDphbnksIHAxOmFueSkgeyAgLy8gcDAgY2xpcHBlZCBieSBwMVxyXG4gICAgICAgICAgICB2YXIgY3AxOmFueSwgY3AyOmFueSwgczphbnksIGU6YW55O1xyXG4gICAgICAgICAgICB2YXIgaW5zaWRlID0gZnVuY3Rpb24gKHA6YW55KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNwMlswXS1jcDFbMF0pKihwWzFdLWNwMVsxXSkgPiAoY3AyWzFdLWNwMVsxXSkqKHBbMF0tY3AxWzBdKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGlzYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYyA9IFsgY3AxWzBdIC0gY3AyWzBdLCBjcDFbMV0gLSBjcDJbMV0gXSxcclxuICAgICAgICAgICAgICAgICAgICBkcCA9IFsgc1swXSAtIGVbMF0sIHNbMV0gLSBlWzFdIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgbjEgPSBjcDFbMF0gKiBjcDJbMV0gLSBjcDFbMV0gKiBjcDJbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgbjIgPSBzWzBdICogZVsxXSAtIHNbMV0gKiBlWzBdLCBcclxuICAgICAgICAgICAgICAgICAgICBuMyA9IDEuMCAvIChkY1swXSAqIGRwWzFdIC0gZGNbMV0gKiBkcFswXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWyhuMSpkcFswXSAtIG4yKmRjWzBdKSAqIG4zLCAobjEqZHBbMV0gLSBuMipkY1sxXSkgKiBuM107XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBwMDtcclxuICAgICAgICAgICAgY3AxID0gcDFbcDEubGVuZ3RoLTFdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqIGluIHAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3AyID0gcDFbal07XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wID0gb3V0O1xyXG4gICAgICAgICAgICAgICAgb3V0ID0gW107XHJcbiAgICAgICAgICAgICAgICBzID0gaW5wW2lucC5sZW5ndGggLSAxXTsgLy9sYXN0IG9uIHRoZSBpbnB1dCBsaXN0XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIGlucCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gaW5wW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNpZGUoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnNpZGUocykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGlzYygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5zaWRlKHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGlzYygpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjcDEgPSBjcDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dFxyXG4gICAgICAgIH1cclxuXHR9XHJcblx0VURPQy5NID0ge1xyXG5cdFx0Z2V0U2NhbGUgOiBmdW5jdGlvbihtOmFueSkgeyAgcmV0dXJuIE1hdGguc3FydChNYXRoLmFicyhtWzBdKm1bM10tbVsxXSptWzJdKSk7ICB9LFxyXG5cdFx0dHJhbnNsYXRlOiBmdW5jdGlvbihtOmFueSx4OmFueSx5OmFueSkgeyAgVURPQy5NLmNvbmNhdChtLCBbMSwwLDAsMSx4LHldKTsgIH0sXHJcblx0XHRyb3RhdGUgICA6IGZ1bmN0aW9uKG06YW55LGE6YW55ICApIHsgIFVET0MuTS5jb25jYXQobSwgW01hdGguY29zKGEpLCAtTWF0aC5zaW4oYSksIE1hdGguc2luKGEpLCBNYXRoLmNvcyhhKSwwLDBdKTsgIH0sXHJcblx0XHRzY2FsZSAgICA6IGZ1bmN0aW9uKG06YW55LHg6YW55LHk6YW55KSB7ICBVRE9DLk0uY29uY2F0KG0sIFt4LDAsMCx5LDAsMF0pOyAgfSxcclxuXHRcdGNvbmNhdCAgIDogZnVuY3Rpb24obTphbnksdzphbnkgICkgeyAgXHJcblx0XHRcdHZhciBhPW1bMF0sYj1tWzFdLGM9bVsyXSxkPW1bM10sdHg9bVs0XSx0eT1tWzVdO1xyXG5cdFx0XHRtWzBdID0gKGEgKndbMF0pKyhiICp3WzJdKTsgICAgICAgbVsxXSA9IChhICp3WzFdKSsoYiAqd1szXSk7XHJcblx0XHRcdG1bMl0gPSAoYyAqd1swXSkrKGQgKndbMl0pOyAgICAgICBtWzNdID0gKGMgKndbMV0pKyhkICp3WzNdKTtcclxuXHRcdFx0bVs0XSA9ICh0eCp3WzBdKSsodHkqd1syXSkrd1s0XTsgIG1bNV0gPSAodHgqd1sxXSkrKHR5KndbM10pK3dbNV07IFxyXG5cdFx0fSxcclxuXHRcdGludmVydCAgIDogZnVuY3Rpb24obTphbnkgICAgKSB7ICBcclxuXHRcdFx0dmFyIGE9bVswXSxiPW1bMV0sYz1tWzJdLGQ9bVszXSx0eD1tWzRdLHR5PW1bNV0sIGFkYmM9YSpkLWIqYztcclxuXHRcdFx0bVswXSA9IGQvYWRiYzsgIG1bMV0gPSAtYi9hZGJjOyAgbVsyXSA9LWMvYWRiYzsgIG1bM10gPSAgYS9hZGJjO1xyXG5cdFx0XHRtWzRdID0gKGMqdHkgLSBkKnR4KS9hZGJjOyAgbVs1XSA9IChiKnR4IC0gYSp0eSkvYWRiYztcclxuXHRcdH0sXHJcblx0XHRtdWx0UG9pbnQ6IGZ1bmN0aW9uKG06YW55LCBwOmFueSApIHsgIHZhciB4PXBbMF0seT1wWzFdOyAgcmV0dXJuIFt4Km1bMF0reSptWzJdK21bNF0sICAgeCptWzFdK3kqbVszXSttWzVdXTsgIH0sXHJcblx0XHRtdWx0QXJyYXk6IGZ1bmN0aW9uKG06YW55LCBhOmFueSApIHsgIGZvcih2YXIgaT0wOyBpPGEubGVuZ3RoOyBpKz0yKSB7ICB2YXIgeD1hW2ldLHk9YVtpKzFdOyAgYVtpXT14Km1bMF0reSptWzJdK21bNF07ICBhW2krMV09eCptWzFdK3kqbVszXSttWzVdOyAgfSAgfVxyXG5cdH1cclxuXHRVRE9DLkMgPSB7XHJcblx0XHRzcmdiR2FtbWEgOiBmdW5jdGlvbih4OmFueSkgeyAgcmV0dXJuIHggPCAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEuMCAvIDIuNCkgLSAwLjA1NTsgIH0sXHJcblx0XHRjbXlrVG9SZ2IgOiBmdW5jdGlvbihjbHI6YW55KSB7IFxyXG5cdFx0XHR2YXIgYz1jbHJbMF0sIG09Y2xyWzFdLCB5PWNsclsyXSwgaz1jbHJbM107XHJcblx0XHRcdC8vIHJldHVybiBbMS1NYXRoLm1pbigxLGMrayksIDEtTWF0aC5taW4oMSwgbStrKSwgMS1NYXRoLm1pbigxLHkrayldO1xyXG5cdFx0XHR2YXIgciA9IDI1NVxyXG5cdFx0XHQrIGMgKiAoLTQuMzg3MzMyMzg0NjA5OTg4ICAqIGMgKyA1NC40ODYxNTE5NDE4OTE3NiAgKiBtICsgIDE4LjgyMjkwNTAyMTY1MzAyICAqIHkgKyAyMTIuMjU2NjI0NTE2Mzk1ODUgKiBrICsgIC0yODUuMjMzMTAyNjEzNzAwNCkgXHJcblx0XHRcdCsgbSAqICggMS43MTQ5NzYzNDc3MzYyMTM0ICogbSAtIDUuNjA5NjczNjkwNDA0NzMxNSAqIHkgKyAtMTcuODczODcwODYxNDE1NDQ0ICogayAtIDUuNDk3MDA2NDI3MTk2MzY2KSBcclxuXHRcdFx0KyB5ICogKC0yLjUyMTczNDAxMzE2ODMwMzMgKiB5IC0gMjEuMjQ4OTIzMzM3MzUzMDczICogayArICAxNy41MTE5MjcwODQxODEzKSBcclxuXHRcdFx0KyBrICogKC0yMS44NjEyMjE0NzQ2MzYwNSAgKiBrIC0gMTg5LjQ4MTgwODM1OTIyNzQ3KTtcclxuXHRcdFx0dmFyIGcgPSAyNTVcclxuXHRcdFx0KyBjICogKDguODQxMDQxNDIyMDM2MTQ5ICAgKiBjICsgNjAuMTE4MDI3MDQ1NTk3MzY2ICogbSArICA2Ljg3MTQyNTU5MjA0OTAwNyAgKiB5ICsgMzEuMTU5MTAwMTMwMDU1OTIyICogayArICAtNzkuMjk3MDg0NDgxNjU0OCkgXHJcblx0XHRcdCsgbSAqICgtMTUuMzEwMzYxMzA2OTY3ODE3ICogbSArIDE3LjU3NTI1MTI2MTEwOTQ4MiAqIHkgKyAgMTMxLjM1MjUwOTEyNDkzOTc2ICogayAtIDE5MC45NDUzMzAyNTg4OTUxKSBcclxuXHRcdFx0KyB5ICogKDQuNDQ0MzM5MTAyODUyNzM5ICAgKiB5ICsgOS44NjMyODYxNDkzNDA1ICAgICogayAtICAyNC44Njc0MTU4MjU1NTg3OCkgXHJcblx0XHRcdCsgayAqICgtMjAuNzM3MzI1NDcxMTgxMDM0ICogayAtIDE4Ny44MDQ1MzcwOTcxOTU3OCk7XHJcblx0XHRcdHZhciBiID0gMjU1XHJcblx0XHRcdCsgYyAqICgwLjg4NDI1MjI0MzAwMDMyOTYgICogYyArIDguMDc4Njc3NTAzMTEyOTI4ICAqIG0gKyAgMzAuODk5NzgzMDk3MDM3MjkgICogeSAtIDAuMjM4ODMyMzg2ODkxNzg5MzQgKiBrICsgLTE0LjE4MzU3Njc5OTY3MzI4NikgXHJcblx0XHRcdCsgbSAqICgxMC40OTU5MzI3MzQzMjA3MiAgICogbSArIDYzLjAyMzc4NDk0NzU0MDUyICAqIHkgKyAgNTAuNjA2OTU3NjU2MzYwNzM0ICogayAtIDExMi4yMzg4NDI1MzcxOTI0OCkgXHJcblx0XHRcdCsgeSAqICgwLjAzMjk2MDQxMTE0ODczMjE3ICogeSArIDExNS42MDM4NDQ0OTY0NjY0MSAqIGsgKyAtMTkzLjU4MjA5MzU2ODYxNTA1KVxyXG5cdFx0XHQrIGsgKiAoLTIyLjMzODE2ODA3MzA5ODg2ICAqIGsgLSAxODAuMTI2MTM5NzQ3MDgzNjcpO1xyXG5cclxuXHRcdFx0cmV0dXJuIFtNYXRoLm1heCgwLCBNYXRoLm1pbigxLCByLzI1NSkpLCBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBnLzI1NSkpLCBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBiLzI1NSkpXTtcclxuXHRcdFx0Ly92YXIgaUsgPSAxLWNbM107ICBcclxuXHRcdFx0Ly9yZXR1cm4gWygxLWNbMF0pKmlLLCAoMS1jWzFdKSppSywgKDEtY1syXSkqaUtdOyAgXHJcblx0XHR9LFxyXG5cdFx0bGFiVG9SZ2IgIDogZnVuY3Rpb24obGFiOmFueSkge1xyXG5cdFx0XHR2YXIgayA9IDkwMy4zLCBlID0gMC4wMDg4NTYsIEwgPSBsYWJbMF0sIGEgPSBsYWJbMV0sIGIgPSBsYWJbMl07XHJcblx0XHRcdHZhciBmeSA9IChMKzE2KS8xMTYsIGZ5MyA9IGZ5KmZ5KmZ5O1xyXG5cdFx0XHR2YXIgZnogPSBmeSAtIGIvMjAwLCBmejMgPSBmeipmeipmejtcclxuXHRcdFx0dmFyIGZ4ID0gYS81MDAgKyBmeSwgZngzID0gZngqZngqZng7XHJcblx0XHRcdHZhciB6ciA9IGZ6Mz5lID8gZnozIDogKDExNipmei0xNikvaztcclxuXHRcdFx0dmFyIHlyID0gZnkzPmUgPyBmeTMgOiAoMTE2KmZ5LTE2KS9rO1xyXG5cdFx0XHR2YXIgeHIgPSBmeDM+ZSA/IGZ4MyA6ICgxMTYqZngtMTYpL2s7XHJcblx0XHRcdFx0XHJcblx0XHRcdHZhciBYID0geHIqOTYuNzIsIFkgPSB5cioxMDAsIFogPSB6cio4MS40MjcsIHh5eiA9IFtYLzEwMCxZLzEwMCxaLzEwMF07XHJcblx0XHRcdHZhciB4MnMgPSBbMy4xMzM4NTYxLCAtMS42MTY4NjY3LCAtMC40OTA2MTQ2LCAtMC45Nzg3Njg0LCAgMS45MTYxNDE1LCAgMC4wMzM0NTQwLCAwLjA3MTk0NTMsIC0wLjIyODk5MTQsICAxLjQwNTI0MjddO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHJnYiA9IFsgeDJzWzBdKnh5elswXSArIHgyc1sxXSp4eXpbMV0gKyB4MnNbMl0qeHl6WzJdLFxyXG5cdFx0XHRcdFx0XHR4MnNbM10qeHl6WzBdICsgeDJzWzRdKnh5elsxXSArIHgyc1s1XSp4eXpbMl0sXHJcblx0XHRcdFx0XHRcdHgyc1s2XSp4eXpbMF0gKyB4MnNbN10qeHl6WzFdICsgeDJzWzhdKnh5elsyXSAgXTtcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8MzsgaSsrKSByZ2JbaV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBVRE9DLkMuc3JnYkdhbW1hKHJnYltpXSkpKTtcclxuXHRcdFx0cmV0dXJuIHJnYjtcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0VURPQy5nZXRTdGF0ZSA9IGZ1bmN0aW9uKGNyZHM6YW55KTphbnkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Zm9udCA6IFVET0MuZ2V0Rm9udCgpLFxyXG5cdFx0XHRkZDoge2ZsYXQ6MX0sICAvLyBkZXZpY2UtZGVwZW5kZW50XHJcblx0XHRcdHNwYWNlIDpcIi9EZXZpY2VHcmF5XCIsXHJcblx0XHRcdC8vIGZpbGxcclxuXHRcdFx0Y2E6IDEsXHJcblx0XHRcdGNvbHIgIDogWzAsMCwwXSxcclxuXHRcdFx0c3NwYWNlOlwiL0RldmljZUdyYXlcIixcclxuXHRcdFx0Ly8gc3Ryb2tlXHJcblx0XHRcdENBOiAxLFxyXG5cdFx0XHRDT0xSIDogWzAsMCwwXSxcclxuXHRcdFx0Ym1vZGU6IFwiL05vcm1hbFwiLFxyXG5cdFx0XHRTQTpmYWxzZSwgT1BNOjAsIEFJUzpmYWxzZSwgT1A6ZmFsc2UsIG9wOmZhbHNlLCBTTWFzazpcIi9Ob25lXCIsXHJcblx0XHRcdGx3aWR0aCA6IDEsXHJcblx0XHRcdGxjYXA6IDAsXHJcblx0XHRcdGxqb2luOiAwLFxyXG5cdFx0XHRtbGltaXQ6IDEwLFxyXG5cdFx0XHRTTSA6IDAuMSxcclxuXHRcdFx0ZG9mZjogMCxcclxuXHRcdFx0ZGFzaDogW10sXHJcblx0XHRcdGN0bSA6IFsxLDAsMCwxLDAsMF0sXHJcblx0XHRcdGNwb3M6IFswLDBdLFxyXG5cdFx0XHRwdGggOiB7Y21kczpbXSxjcmRzOltdfSwgXHJcblx0XHRcdGNwdGg6IGNyZHMgPyBVRE9DLkcucmVjdFRvUGF0aChjcmRzKSA6IG51bGwgIC8vIGNsaXBwaW5nIHBhdGhcclxuXHRcdH07XHJcblx0fVxyXG5cdFxyXG5cdFVET0MuZ2V0Rm9udCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0VGM6IDAsIC8vIGNoYXJhY3RlciBzcGFjaW5nXHJcblx0XHRcdFR3OiAwLCAvLyB3b3JkIHNwYWNpbmdcclxuXHRcdFx0VGg6MTAwLCAvLyBob3Jpem9udGFsIHNjYWxlXHJcblx0XHRcdFRsOiAwLCAvLyBsZWFkaW5nXHJcblx0XHRcdFRmOlwiSGVsdmV0aWNhLUJvbGRcIiwgXHJcblx0XHRcdFRmczoxLCAvLyBmb250IHNpemVcclxuXHRcdFx0VG1vZGU6MCwgLy8gcmVuZGVyaW5nIG1vZGVcclxuXHRcdFx0VHJpc2U6MCwgLy8gcmlzZVxyXG5cdFx0XHRUazogMCwgIC8vIGtub2Nrb3V0XHJcblx0XHRcdFRhbDowLCAgLy8gYWxpZ24sIDA6IGxlZnQsIDE6IHJpZ2h0LCAyOiBjZW50ZXJcclxuXHRcdFx0VHVuOjAsICAvLyAwOiBubywgMTogdW5kZXJsaW5lXHJcblx0XHRcdFxyXG5cdFx0XHRUbSA6WzEsMCwwLDEsMCwwXSxcclxuXHRcdFx0VGxtOlsxLDAsMCwxLDAsMF0sXHJcblx0XHRcdFRybTpbMSwwLDAsMSwwLDBdXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblxyXG5leHBvcnQgbGV0IEZyb21FTUY6YW55ID0gZnVuY3Rpb24oKVxyXG57XHJcbn1cclxuXHJcbkZyb21FTUYuUGFyc2UgPSBmdW5jdGlvbihidWZmOmFueSwgZ2VudjphbnkpXHJcbntcclxuICAgIGJ1ZmYgPSBuZXcgVWludDhBcnJheShidWZmKTsgIHZhciBvZmY9MDtcclxuICAgIC8vY29uc29sZS5sb2coYnVmZi5zbGljZSgwLDMyKSk7XHJcbiAgICB2YXIgcHJtczphbnkgPSB7ZmlsbDpmYWxzZSwgc3RyazpmYWxzZSwgYmI6WzAsMCwxLDFdLCB3YmI6WzAsMCwxLDFdLCBmbnQ6e25hbTpcIkFyaWFsXCIsaGdoOjI1LHVuZDpmYWxzZSxvcm46MH0sIHRjbHI6WzAsMCwwXSwgdGFsZzowfSwgZ3N0LCB0YWIgPSBbXSwgc3RzPVtdO1xyXG4gICAgXHJcbiAgICB2YXIgckkgPSBGcm9tRU1GLkIucmVhZFNob3J0LCByVSA9IEZyb21FTUYuQi5yZWFkVXNob3J0LCBySTMyID0gRnJvbUVNRi5CLnJlYWRJbnQsIHJVMzIgPSBGcm9tRU1GLkIucmVhZFVpbnQsIHJGMzIgPSBGcm9tRU1GLkIucmVhZEZsb2F0O1x0XHJcbiAgICBcclxuICAgIHZhciBvcG49MDtcclxuICAgIHdoaWxlKHRydWUpIHtcclxuICAgICAgICB2YXIgZm5jID0gclUzMihidWZmLCBvZmYpOyAgb2ZmKz00O1xyXG4gICAgICAgIHZhciBmbm0gPSBGcm9tRU1GLktbZm5jXTsgXHJcbiAgICAgICAgdmFyIHNpeiA9IHJVMzIoYnVmZiwgb2ZmKTsgIG9mZis9NDtcclxuICAgICAgICBcclxuICAgICAgICAvL2lmKGdzdCAmJiBpc05hTihnc3QuY3RtWzBdKSkgdGhyb3cgXCJlXCI7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhmbmMsZm5tLHNpeik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGxvZmYgPSBvZmY7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9pZihvcG4rKz09MjUzKSBicmVhaztcclxuICAgICAgICB2YXIgb2JqOmFueSA9IG51bGwsIG9pZCA9IDA7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhmbm0sIHNpeik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoZmFsc2UpIHt9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiRU9GXCIpIHsgIGJyZWFrOyAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkhFQURFUlwiKSB7XHJcbiAgICAgICAgICAgIHBybXMuYmIgPSBGcm9tRU1GLl9yZWFkQm94KGJ1ZmYsbG9mZik7ICAgbG9mZis9MTY7ICAvL2NvbnNvbGUubG9nKGZubSwgcHJtcy5iYik7XHJcbiAgICAgICAgICAgIGdlbnYuU3RhcnRQYWdlKHBybXMuYmJbMF0scHJtcy5iYlsxXSxwcm1zLmJiWzJdLHBybXMuYmJbM10pO1xyXG4gICAgICAgICAgICBnc3QgPSBVRE9DLmdldFN0YXRlKHBybXMuYmIpO1x0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNBVkVEQ1wiKSBzdHMucHVzaChKU09OLnN0cmluZ2lmeShnc3QpLCBKU09OLnN0cmluZ2lmeShwcm1zKSk7XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiUkVTVE9SRURDXCIpIHtcclxuICAgICAgICAgICAgdmFyIGRpZiA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB3aGlsZShkaWY8LTEpIHsgIHN0cy5wb3AoKTsgIHN0cy5wb3AoKTsgIH1cclxuICAgICAgICAgICAgcHJtcyA9IEpTT04ucGFyc2Uoc3RzLnBvcCgpKTsgIGdzdCA9IEpTT04ucGFyc2Uoc3RzLnBvcCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VMRUNUQ0xJUFBBVEhcIikgeyAgZ3N0LmNwdGggPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdzdC5wdGgpKTsgIH1cclxuICAgICAgICBlbHNlIGlmKFtcIlNFVE1BUE1PREVcIixcIlNFVFBPTFlGSUxMTU9ERVwiLFwiU0VUQktNT0RFXCIvKixcIlNFVFZJRVdQT1JURVhURVhcIiovLFwiU0VUSUNNTU9ERVwiLFwiU0VUUk9QMlwiLFwiRVhUU0VMRUNUQ0xJUFJHTlwiXS5pbmRleE9mKGZubSkhPS0xKSB7fVxyXG4gICAgICAgIC8vZWxzZSBpZihmbm09PVwiSU5URVJTRUNUQ0xJUFJFQ1RcIikgeyAgdmFyIHI9cHJtcy5jcmN0PUZyb21FTUYuX3JlYWRCb3goYnVmZiwgbG9mZik7ICAvKnZhciB5MD1yWzFdLHkxPXJbM107IGlmKHkwPnkxKXtyWzFdPXkxOyByWzNdPXkwO30qLyBjb25zb2xlLmxvZyhwcm1zLmNyY3QpOyAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFVE1JVEVSTElNSVRcIikgZ3N0Lm1saW1pdCA9IHJVMzIoYnVmZiwgbG9mZik7XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VUVEVYVENPTE9SXCIpIHBybXMudGNsciA9IFtidWZmW2xvZmZdLzI1NSwgYnVmZltsb2ZmKzFdLzI1NSwgYnVmZltsb2ZmKzJdLzI1NV07IFxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFVFRFWFRBTElHTlwiKSBwcm1zLnRhbGcgPSByVTMyKGJ1ZmYsIGxvZmYpO1xyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFVFZJRVdQT1JURVhURVhcIiB8fCBmbm09PVwiU0VUVklFV1BPUlRPUkdFWFwiKSB7XHJcbiAgICAgICAgICAgIGlmKHBybXMudmJiPT1udWxsKSBwcm1zLnZiYj1bXTtcclxuICAgICAgICAgICAgdmFyIGNvZmYgPSBmbm09PVwiU0VUVklFV1BPUlRPUkdFWFwiID8gMCA6IDI7XHJcbiAgICAgICAgICAgIHBybXMudmJiW2NvZmYgIF0gPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgcHJtcy52YmJbY29mZisxXSA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBybXMudmJiKTtcclxuICAgICAgICAgICAgaWYoZm5tPT1cIlNFVFZJRVdQT1JURVhURVhcIikgRnJvbUVNRi5fdXBkYXRlQ3RtKHBybXMsIGdzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFVFdJTkRPV0VYVEVYXCIgfHwgZm5tPT1cIlNFVFdJTkRPV09SR0VYXCIpIHtcclxuICAgICAgICAgICAgdmFyIGNvZmYgPSBmbm09PVwiU0VUV0lORE9XT1JHRVhcIiA/IDAgOiAyO1xyXG4gICAgICAgICAgICBwcm1zLndiYltjb2ZmICBdID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHBybXMud2JiW2NvZmYrMV0gPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgaWYoZm5tPT1cIlNFVFdJTkRPV0VYVEVYXCIpIEZyb21FTUYuX3VwZGF0ZUN0bShwcm1zLCBnc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2Vsc2UgaWYoZm5tPT1cIlNFVE1FVEFSR05cIikge31cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJDT01NRU5UXCIpIHsgIHZhciBkcyA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00OyAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFTEVDVE9CSkVDVFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhpbmQudG9TdHJpbmcoMTYpLCB0YWIsIHRhYltpbmRdKTtcclxuICAgICAgICAgICAgaWYgICAgIChpbmQ9PTB4ODAwMDAwMDApIHsgIHBybXMuZmlsbD10cnVlIDsgIGdzdC5jb2xyPVsxLDEsMV07ICB9IC8vIHdoaXRlIGJydXNoXHJcbiAgICAgICAgICAgIGVsc2UgaWYoaW5kPT0weDgwMDAwMDA1KSB7ICBwcm1zLmZpbGw9ZmFsc2U7ICB9IC8vIG51bGwgYnJ1c2hcclxuICAgICAgICAgICAgZWxzZSBpZihpbmQ9PTB4ODAwMDAwMDcpIHsgIHBybXMuc3Ryaz10cnVlIDsgIHBybXMubHdpZHRoPTE7ICBnc3QuQ09MUj1bMCwwLDBdOyAgfSAvLyBibGFjayBwZW5cclxuICAgICAgICAgICAgZWxzZSBpZihpbmQ9PTB4ODAwMDAwMDgpIHsgIHBybXMuc3Ryaz1mYWxzZTsgIH0gLy8gbnVsbCAgcGVuXHJcbiAgICAgICAgICAgIGVsc2UgaWYoaW5kPT0weDgwMDAwMDBkKSB7fSAvLyBzeXN0ZW0gZm9udFxyXG4gICAgICAgICAgICBlbHNlIGlmKGluZD09MHg4MDAwMDAwZSkge30gIC8vIGRldmljZSBkZWZhdWx0IGZvbnRcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY286YW55ID0gdGFiW2luZF07ICAvL2NvbnNvbGUubG9nKGluZCwgY28pO1xyXG4gICAgICAgICAgICAgICAgaWYoY28udD09XCJiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm1zLmZpbGw9Y28uc3RsIT0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICAgICAoY28uc3RsPT0wKSB7fVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY28uc3RsPT0xKSB7fVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgY28uc3RsK1wiIGVcIjtcclxuICAgICAgICAgICAgICAgICAgICBnc3QuY29scj1jby5jbHI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGNvLnQ9PVwicFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJtcy5zdHJrPWNvLnN0bCE9NTtcclxuICAgICAgICAgICAgICAgICAgICBnc3QubHdpZHRoID0gY28ud2lkO1xyXG4gICAgICAgICAgICAgICAgICAgIGdzdC5DT0xSPWNvLmNscjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoY28udD09XCJmXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm1zLmZudCA9IGNvO1xyXG4gICAgICAgICAgICAgICAgICAgIGdzdC5mb250LlRmID0gY28ubmFtO1xyXG4gICAgICAgICAgICAgICAgICAgIGdzdC5mb250LlRmcyA9IE1hdGguYWJzKGNvLmhnaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3N0LmZvbnQuVHVuID0gY28udW5kO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBcImVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJERUxFVEVPQkpFQ1RcIikge1xyXG4gICAgICAgICAgICB2YXIgaW5kID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIGlmKHRhYltpbmRdIT1udWxsKSB0YWJbaW5kXT1udWxsO1xyXG4gICAgICAgICAgICBlbHNlIHRocm93IFwiZVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJDUkVBVEVCUlVTSElORElSRUNUXCIpIHtcclxuICAgICAgICAgICAgb2lkID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIG9iaiA9IHt0OlwiYlwifTtcclxuICAgICAgICAgICAgb2JqLnN0bCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICBvYmouY2xyID0gW2J1ZmZbbG9mZl0vMjU1LCBidWZmW2xvZmYrMV0vMjU1LCBidWZmW2xvZmYrMl0vMjU1XTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIG9iai5odGMgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhvaWQsIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkNSRUFURVBFTlwiIHx8IGZubT09XCJFWFRDUkVBVEVQRU5cIikge1xyXG4gICAgICAgICAgICBvaWQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgb2JqID0ge3Q6XCJwXCJ9O1xyXG4gICAgICAgICAgICBpZihmbm09PVwiRVhUQ1JFQVRFUEVOXCIpIHtcclxuICAgICAgICAgICAgICAgIGxvZmYrPTE2O1xyXG4gICAgICAgICAgICAgICAgb2JqLnN0bCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICAgICAgb2JqLndpZCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICAgICAgLy9vYmouc3RsID0gclUzMihidWZmLCBsb2ZmKTsgIFxyXG4gICAgICAgICAgICAgICAgbG9mZis9NDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9iai5zdGwgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgICAgIG9iai53aWQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqLmNsciA9IFtidWZmW2xvZmZdLzI1NSwgYnVmZltsb2ZmKzFdLzI1NSwgYnVmZltsb2ZmKzJdLzI1NV07ICBsb2ZmKz00O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJFWFRDUkVBVEVGT05USU5ESVJFQ1RXXCIpIHtcclxuICAgICAgICAgICAgb2lkID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIG9iaiA9IHt0OlwiZlwiLCBuYW06XCJcIn07XHJcbiAgICAgICAgICAgIG9iai5oZ2ggPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZiArPSA0O1xyXG4gICAgICAgICAgICBsb2ZmICs9IDQqMjtcclxuICAgICAgICAgICAgb2JqLm9ybiA9IHJJMzIoYnVmZiwgbG9mZikvMTA7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgd2doID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICAvL2NvbnNvbGUubG9nKGZubSwgb2JqLm9ybiwgd2doKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyVTMyKGJ1ZmYsbG9mZiksIHJVMzIoYnVmZixsb2ZmKzQpLCBidWZmLnNsaWNlKGxvZmYsbG9mZis4KSk7XHJcbiAgICAgICAgICAgIG9iai51bmQgPSBidWZmW2xvZmYrMV07ICBvYmouc3RrID0gYnVmZltsb2ZmKzJdOyAgbG9mZiArPSA0KjI7XHJcbiAgICAgICAgICAgIHdoaWxlKHJVKGJ1ZmYsbG9mZikhPTApIHsgIG9iai5uYW0rPVN0cmluZy5mcm9tQ2hhckNvZGUoclUoYnVmZixsb2ZmKSk7ICBsb2ZmKz0yOyAgfVxyXG4gICAgICAgICAgICBpZih3Z2g+NTAwKSBvYmoubmFtKz1cIi1Cb2xkXCI7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cod2doLCBvYmoubmFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiRVhUVEVYVE9VVFdcIikge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGJ1ZmYuc2xpY2UobG9mZi04LCBsb2ZmLTgrc2l6KSk7XHJcbiAgICAgICAgICAgIGxvZmYrPTE2O1xyXG4gICAgICAgICAgICB2YXIgbW9kID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICAvL2NvbnNvbGUubG9nKG1vZCk7XHJcbiAgICAgICAgICAgIHZhciBzY3ggPSByRjMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHNjeSA9IHJGMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgcmZ4ID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciByZnkgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhtb2QsIHNjeCwgc2N5LHJmeCxyZnkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZ3N0LmZvbnQuVG0gPSBbMSwwLDAsLTEsMCwwXTtcclxuICAgICAgICAgICAgVURPQy5NLnJvdGF0ZShnc3QuZm9udC5UbSwgcHJtcy5mbnQub3JuKk1hdGguUEkvMTgwKTtcclxuICAgICAgICAgICAgVURPQy5NLnRyYW5zbGF0ZShnc3QuZm9udC5UbSwgcmZ4LCByZnkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGFsZyA9IHBybXMudGFsZzsgIC8vY29uc29sZS5sb2coYWxnLnRvU3RyaW5nKDIpKTtcclxuICAgICAgICAgICAgaWYgICAgICgoYWxnJjYpPT02KSBnc3QuZm9udC5UYWwgPSAyO1xyXG4gICAgICAgICAgICBlbHNlIGlmKChhbGcmNyk9PTApIGdzdC5mb250LlRhbCA9IDA7XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgYWxnK1wiIGVcIjtcclxuICAgICAgICAgICAgaWYoKGFsZyYyNCk9PTI0KSB7fSAgLy8gYmFzZWxpbmVcclxuICAgICAgICAgICAgZWxzZSBpZigoYWxnJjI0KT09MCkgVURPQy5NLnRyYW5zbGF0ZShnc3QuZm9udC5UbSwgMCwgZ3N0LmZvbnQuVGZzKTtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBcImVcIjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgY3JzID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciBvZnMgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIG9wcyA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00OyAgLy9pZihvcHMhPTApIHRocm93IFwiZVwiO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG9mcyxvcHMsY3JzKTtcclxuICAgICAgICAgICAgbG9mZis9MTY7XHJcbiAgICAgICAgICAgIHZhciBvZkQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIC8vY29uc29sZS5sb2cob3BzLCBvZkQsIGxvZmYsIG9mcytvZmYtOCk7XHJcbiAgICAgICAgICAgIG9mcyArPSBvZmYtODsgIC8vY29uc29sZS5sb2coY3JzLCBvcHMpO1xyXG4gICAgICAgICAgICB2YXIgc3RyID0gXCJcIjtcclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8Y3JzOyBpKyspIHsgIHZhciBjYz1yVShidWZmLG9mcytpKjIpOyAgc3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGNjKTsgIH07XHJcbiAgICAgICAgICAgIHZhciBvY2xyID0gZ3N0LmNvbHI7ICBnc3QuY29sciA9IHBybXMudGNscjtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzdHIsIGdzdC5jb2xyLCBnc3QuZm9udC5UbSk7XHJcbiAgICAgICAgICAgIC8vdmFyIG90ZnMgPSBnc3QuZm9udC5UZnM7ICBnc3QuZm9udC5UZnMgKj0gMS9nc3QuY3RtWzBdO1xyXG4gICAgICAgICAgICBnZW52LlB1dFRleHQoZ3N0LCBzdHIsIHN0ci5sZW5ndGgqZ3N0LmZvbnQuVGZzKjAuNSk7ICBnc3QuY29scj1vY2xyO1xyXG4gICAgICAgICAgICAvL2dzdC5mb250LlRmcyA9IG90ZnM7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmZ4LCByZnksIHNjeCwgb3BzLCByY1gsIHJjWSwgcmNXLCByY0gsIG9mZkR4LCBzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJCRUdJTlBBVEhcIikgeyAgVURPQy5HLm5ld1BhdGgoZ3N0KTsgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJFTkRQQVRIXCIgICkgeyAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiQ0xPU0VGSUdVUkVcIikgVURPQy5HLmNsb3NlUGF0aChnc3QpO1xyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIk1PVkVUT0VYXCIgKSB7ICBVRE9DLkcubW92ZVRvKGdzdCwgckkzMihidWZmLGxvZmYpLCBySTMyKGJ1ZmYsbG9mZis0KSk7ICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiTElORVRPXCIgICApIHsgIFxyXG4gICAgICAgICAgICBpZihnc3QucHRoLmNtZHMubGVuZ3RoPT0wKSB7ICB2YXIgaW09Z3N0LmN0bS5zbGljZSgwKTsgIFVET0MuTS5pbnZlcnQoaW0pOyAgdmFyIHAgPSBVRE9DLk0ubXVsdFBvaW50KGltLCBnc3QuY3Bvcyk7ICBVRE9DLkcubW92ZVRvKGdzdCwgcFswXSwgcFsxXSk7ICB9ICBcclxuICAgICAgICAgICAgVURPQy5HLmxpbmVUbyhnc3QsIHJJMzIoYnVmZixsb2ZmKSwgckkzMihidWZmLGxvZmYrNCkpOyAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlBPTFlHT05cIiB8fCBmbm09PVwiUE9MWUdPTjE2XCIgfHwgZm5tPT1cIlBPTFlMSU5FXCIgfHwgZm5tPT1cIlBPTFlMSU5FMTZcIiB8fCBmbm09PVwiUE9MWUxJTkVUT1wiIHx8IGZubT09XCJQT0xZTElORVRPMTZcIikge1xyXG4gICAgICAgICAgICBsb2ZmKz0xNjtcclxuICAgICAgICAgICAgdmFyIG5kZiA9IGZubS5zdGFydHNXaXRoKFwiUE9MWUdPTlwiKSwgaXNUbyA9IGZubS5pbmRleE9mKFwiVE9cIikhPS0xO1xyXG4gICAgICAgICAgICB2YXIgY250ID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIGlmKCFpc1RvKSBVRE9DLkcubmV3UGF0aChnc3QpO1xyXG4gICAgICAgICAgICBsb2ZmID0gRnJvbUVNRi5fZHJhd1BvbHkoYnVmZixsb2ZmLGNudCxnc3QsIGZubS5lbmRzV2l0aChcIjE2XCIpPzI6NCwgIG5kZiwgaXNUbyk7XHJcbiAgICAgICAgICAgIGlmKCFpc1RvKSBGcm9tRU1GLl9kcmF3KGdlbnYsZ3N0LHBybXMsIG5kZik7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocHJtcywgZ3N0Lmx3aWR0aCk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShnc3QucHRoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJQT0xZUE9MWUdPTjE2XCIpIHtcclxuICAgICAgICAgICAgbG9mZis9MTY7XHJcbiAgICAgICAgICAgIHZhciBuZGYgPSBmbm0uc3RhcnRzV2l0aChcIlBPTFlQT0xZR09OXCIpLCBpc1RvID0gZm5tLmluZGV4T2YoXCJUT1wiKSE9LTE7XHJcbiAgICAgICAgICAgIHZhciBub3AgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciBwaSA9IGxvZmY7ICBsb2ZmKz0gbm9wKjQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZighaXNUbykgVURPQy5HLm5ld1BhdGgoZ3N0KTtcclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8bm9wOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcHAgPSByVShidWZmLCBwaStpKjQpO1xyXG4gICAgICAgICAgICAgICAgbG9mZiA9IEZyb21FTUYuX2RyYXdQb2x5KGJ1ZmYsbG9mZixwcHAsZ3N0LCBmbm0uZW5kc1dpdGgoXCIxNlwiKT8yOjQsIG5kZiwgaXNUbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIWlzVG8pIEZyb21FTUYuX2RyYXcoZ2Vudixnc3QscHJtcywgbmRmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiUE9MWUJFWklFUlwiIHx8IGZubT09XCJQT0xZQkVaSUVSMTZcIiB8fCBmbm09PVwiUE9MWUJFWklFUlRPXCIgfHwgZm5tPT1cIlBPTFlCRVpJRVJUTzE2XCIpIHtcclxuICAgICAgICAgICAgbG9mZis9MTY7XHJcbiAgICAgICAgICAgIHZhciBpczE2ID0gZm5tLmVuZHNXaXRoKFwiMTZcIiksIHJDID0gaXMxNj9ySTpySTMyLCBubCA9IGlzMTY/Mjo0O1xyXG4gICAgICAgICAgICB2YXIgY250ID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIGlmKGZubS5pbmRleE9mKFwiVE9cIik9PS0xKSB7XHJcbiAgICAgICAgICAgICAgICBVRE9DLkcubW92ZVRvKGdzdCwgckMoYnVmZixsb2ZmKSwgckMoYnVmZixsb2ZmK25sKSk7ICBsb2ZmKz0yKm5sOyAgY250LS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUoY250PjApIHtcclxuICAgICAgICAgICAgICAgIFVET0MuRy5jdXJ2ZVRvKGdzdCwgckMoYnVmZixsb2ZmKSwgckMoYnVmZixsb2ZmK25sKSwgckMoYnVmZixsb2ZmKzIqbmwpLCByQyhidWZmLGxvZmYrMypubCksIHJDKGJ1ZmYsbG9mZis0Km5sKSwgckMoYnVmZixsb2ZmKzUqbmwpICk7XHJcbiAgICAgICAgICAgICAgICBsb2ZmKz02Km5sO1xyXG4gICAgICAgICAgICAgICAgY250LT0zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShnc3QucHRoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJSRUNUQU5HTEVcIiB8fCBmbm09PVwiRUxMSVBTRVwiKSB7XHJcbiAgICAgICAgICAgIFVET0MuRy5uZXdQYXRoKGdzdCk7XHJcbiAgICAgICAgICAgIHZhciBieCA9IEZyb21FTUYuX3JlYWRCb3goYnVmZiwgbG9mZik7XHJcbiAgICAgICAgICAgIGlmKGZubT09XCJSRUNUQU5HTEVcIikge1xyXG4gICAgICAgICAgICAgICAgVURPQy5HLm1vdmVUbyhnc3QsIGJ4WzBdLGJ4WzFdKTtcclxuICAgICAgICAgICAgICAgIFVET0MuRy5saW5lVG8oZ3N0LCBieFsyXSxieFsxXSk7XHJcbiAgICAgICAgICAgICAgICBVRE9DLkcubGluZVRvKGdzdCwgYnhbMl0sYnhbM10pO1xyXG4gICAgICAgICAgICAgICAgVURPQy5HLmxpbmVUbyhnc3QsIGJ4WzBdLGJ4WzNdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gKGJ4WzBdK2J4WzJdKS8yLCB5ID0gKGJ4WzFdK2J4WzNdKS8yO1xyXG4gICAgICAgICAgICAgICAgVURPQy5HLmFyYyhnc3QseCx5LChieFsyXS1ieFswXSkvMiwwLDIqTWF0aC5QSSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFVET0MuRy5jbG9zZVBhdGgoZ3N0KTtcclxuICAgICAgICAgICAgRnJvbUVNRi5fZHJhdyhnZW52LGdzdCxwcm1zLCB0cnVlKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhwcm1zLCBnc3QubHdpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiRklMTFBBVEhcIiAgKSBnZW52LkZpbGwoZ3N0LCBmYWxzZSk7XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU1RST0tFUEFUSFwiKSBnZW52LlN0cm9rZShnc3QpO1xyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNUUk9LRUFOREZJTExQQVRIXCIpIHsgIGdlbnYuRmlsbChnc3QsIGZhbHNlKTsgIGdlbnYuU3Ryb2tlKGdzdCk7ICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VUV09STERUUkFOU0ZPUk1cIiB8fCBmbm09PVwiTU9ESUZZV09STERUUkFOU0ZPUk1cIikge1xyXG4gICAgICAgICAgICB2YXIgbWF0ID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPDY7IGkrKykgbWF0LnB1c2gockYzMihidWZmLGxvZmYraSo0KSk7ICBsb2ZmKz0yNDtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhmbm0sIGdzdC5jdG0uc2xpY2UoMCksIG1hdCk7XHJcbiAgICAgICAgICAgIGlmKGZubT09XCJTRVRXT1JMRFRSQU5TRk9STVwiKSBnc3QuY3RtPW1hdDtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kID0gclUzMihidWZmLGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgICAgIGlmKG1vZD09MikgeyAgdmFyIG9tPWdzdC5jdG07ICBnc3QuY3RtPW1hdDsgIFVET0MuTS5jb25jYXQoZ3N0LmN0bSwgb20pOyAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBcImVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTRVRTVFJFVENIQkxUTU9ERVwiKSB7ICB2YXIgc20gPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTVFJFVENIRElCSVRTXCIpIHtcclxuICAgICAgICAgICAgdmFyIGJ4ID0gRnJvbUVNRi5fcmVhZEJveChidWZmLCBsb2ZmKTsgIGxvZmYrPTE2O1xyXG4gICAgICAgICAgICB2YXIgeEQgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHlEID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciB4UyA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgeVMgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHdTID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciBoUyA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgb2ZIID0gclUzMihidWZmLCBsb2ZmKStvZmYtODsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciBzekggPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIG9mQiA9IHJVMzIoYnVmZiwgbG9mZikrb2ZmLTg7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgc3pCID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciB1c2cgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIGlmKHVzZyE9MCkgdGhyb3cgXCJlXCI7XHJcbiAgICAgICAgICAgIHZhciBib3AgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHdEID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciBoRCA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00OyAgLy9jb25zb2xlLmxvZyhib3AsIHdELCBoRCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG9mSCwgc3pILCBvZkIsIHN6Qiwgb2ZIKzQwKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhieCwgeEQseUQsd0QsaEQpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHhTLHlTLHdTLGhTKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhvZkgsc3pILG9mQixzekIsdXNnLGJvcCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgaGwgPSByVTMyKGJ1ZmYsIG9mSCk7ICBvZkgrPTQ7XHJcbiAgICAgICAgICAgIHZhciB3ICA9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDtcclxuICAgICAgICAgICAgdmFyIGggID0gclUzMihidWZmLCBvZkgpOyAgb2ZIKz00OyAgaWYodyE9d1MgfHwgaCE9aFMpIHRocm93IFwiZVwiO1xyXG4gICAgICAgICAgICB2YXIgcHMgPSByVSAgKGJ1ZmYsIG9mSCk7ICBvZkgrPTI7XHJcbiAgICAgICAgICAgIHZhciBiYyA9IHJVICAoYnVmZiwgb2ZIKTsgIG9mSCs9MjsgIGlmKGJjIT04ICYmIGJjIT0yNCAmJiBiYyE9MzIpIHRocm93IGJjK1wiIGVcIjtcclxuICAgICAgICAgICAgdmFyIGNwcj0gclUzMihidWZmLCBvZkgpOyAgb2ZIKz00OyAgaWYoY3ByIT0wKSB0aHJvdyBjcHIrXCIgZVwiO1xyXG4gICAgICAgICAgICB2YXIgc3ogPSByVTMyKGJ1ZmYsIG9mSCk7ICBvZkgrPTQ7XHJcbiAgICAgICAgICAgIHZhciB4cG09IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDtcclxuICAgICAgICAgICAgdmFyIHlwbT0gclUzMihidWZmLCBvZkgpOyAgb2ZIKz00O1xyXG4gICAgICAgICAgICB2YXIgY3UgPSByVTMyKGJ1ZmYsIG9mSCk7ICBvZkgrPTQ7XHJcbiAgICAgICAgICAgIHZhciBjaSA9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDsgIC8vY29uc29sZS5sb2coaGwsIHcsIGgsIHBzLCBiYywgY3ByLCBzeiwgeHBtLCB5cG0sIGN1LCBjaSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGhsLHcsaCxcIixcIix4Uyx5Uyx3UyxoUyxcIixcIix4RCx5RCx3RCxoRCxcIixcIix4cG0seXBtKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBybCA9IE1hdGguZmxvb3IoKCh3ICogcHMgKiBiYyArIDMxKSAmIH4zMSkgLyA4KTtcclxuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBVaW50OEFycmF5KHcqaCo0KTtcclxuICAgICAgICAgICAgaWYoYmM9PTgpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeT0wOyB5PGg7IHkrKykgXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4PTA7IHg8dzsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxaSA9ICh5KncreCk8PDIsIGluZDphbnkgPSBidWZmW29mQisoaC0xLXkpKnJsK3hdPDwyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkgIF0gPSBidWZmW29mSCtpbmQrMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSsxXSA9IGJ1ZmZbb2ZIK2luZCsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzJdID0gYnVmZltvZkgraW5kKzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkrM10gPSAyNTU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGJjPT0yNCkge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB5PTA7IHk8aDsgeSsrKSBcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHFpID0gKHkqdyt4KTw8MiwgdGk9b2ZCKyhoLTEteSkqcmwreCozO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkgIF0gPSBidWZmW3RpKzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkrMV0gPSBidWZmW3RpKzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkrMl0gPSBidWZmW3RpKzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkrM10gPSAyNTU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGJjPT0zMikge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB5PTA7IHk8aDsgeSsrKSBcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHFpID0gKHkqdyt4KTw8MiwgdGk9b2ZCKyhoLTEteSkqcmwreCo0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkgIF0gPSBidWZmW3RpKzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkrMV0gPSBidWZmW3RpKzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkrMl0gPSBidWZmW3RpKzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkrM10gPSBidWZmW3RpKzNdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGN0bSA9IGdzdC5jdG0uc2xpY2UoMCk7XHJcbiAgICAgICAgICAgIGdzdC5jdG0gPSBbMSwwLDAsMSwwLDBdO1xyXG4gICAgICAgICAgICBVRE9DLk0uc2NhbGUoZ3N0LmN0bSwgd0QsIC1oRCk7XHJcbiAgICAgICAgICAgIFVET0MuTS50cmFuc2xhdGUoZ3N0LmN0bSwgeEQsIHlEK2hEKTtcclxuICAgICAgICAgICAgVURPQy5NLmNvbmNhdChnc3QuY3RtLCBjdG0pO1xyXG4gICAgICAgICAgICBnZW52LlB1dEltYWdlKGdzdCwgaW1nLCB3LCBoKTtcclxuICAgICAgICAgICAgZ3N0LmN0bSA9IGN0bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGZubSwgc2l6KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYob2JqIT1udWxsKSB0YWJbb2lkXT1vYmo7XHJcbiAgICAgICAgXHJcbiAgICAgICAgb2ZmKz1zaXotODtcclxuICAgIH1cclxuICAgIC8vZ2Vudi5TdHJva2UoZ3N0KTtcclxuICAgIGdlbnYuU2hvd1BhZ2UoKTsgIGdlbnYuRG9uZSgpO1xyXG59XHJcbkZyb21FTUYuX3JlYWRCb3ggPSBmdW5jdGlvbihidWZmOmFueSwgb2ZmOmFueSkgeyAgdmFyIGI9W107ICBmb3IodmFyIGk9MDsgaTw0OyBpKyspIGJbaV0gPSBGcm9tRU1GLkIucmVhZEludChidWZmLG9mZitpKjQpOyAgcmV0dXJuIGI7ICB9XHRcclxuXHJcbkZyb21FTUYuX3VwZGF0ZUN0bSA9IGZ1bmN0aW9uKHBybXM6YW55LCBnc3Q6YW55KSB7XHJcbiAgICB2YXIgbWF0ID0gWzEsMCwwLDEsMCwwXTtcclxuICAgIHZhciB3YmIgPSBwcm1zLndiYiwgYmIgPSBwcm1zLmJiLCB2YmI9KHBybXMudmJiICYmIHBybXMudmJiLmxlbmd0aD09NCkgPyBwcm1zLnZiYjpwcm1zLmJiO1xyXG4gICAgXHJcbiAgICAvL3ZhciB5MCA9IGJiWzFdLCB5MSA9IGJiWzNdOyAgYmJbMV09TWF0aC5taW4oeTAseTEpOyAgYmJbM109TWF0aC5tYXgoeTAseTEpO1xyXG4gICAgXHJcbiAgICBVRE9DLk0udHJhbnNsYXRlKG1hdCwgLXdiYlswXSwtd2JiWzFdKTtcclxuICAgIFVET0MuTS5zY2FsZShtYXQsIDEvd2JiWzJdLCAxL3diYlszXSk7XHJcbiAgICBcclxuICAgIFVET0MuTS5zY2FsZShtYXQsIHZiYlsyXSwgdmJiWzNdKTtcclxuICAgIC8vVURPQy5NLnNjYWxlKG1hdCwgdmJiWzJdLyhiYlsyXS1iYlswXSksIHZiYlszXS8oYmJbM10tYmJbMV0pKTtcclxuICAgIFxyXG4gICAgLy9VRE9DLk0uc2NhbGUobWF0LCBiYlsyXS1iYlswXSxiYlszXS1iYlsxXSk7XHJcbiAgICBcclxuICAgIGdzdC5jdG0gPSBtYXQ7XHJcbn1cclxuRnJvbUVNRi5fZHJhdyA9IGZ1bmN0aW9uKGdlbnY6YW55LCBnc3Q6YW55LCBwcm1zOmFueSwgbmVlZEZpbGw6YW55KSB7XHJcbiAgICBpZihwcm1zLmZpbGwgJiYgbmVlZEZpbGwgICAgICkgZ2Vudi5GaWxsICAoZ3N0LCBmYWxzZSk7XHJcbiAgICBpZihwcm1zLnN0cmsgJiYgZ3N0Lmx3aWR0aCE9MCkgZ2Vudi5TdHJva2UoZ3N0KTtcclxufVxyXG5Gcm9tRU1GLl9kcmF3UG9seSA9IGZ1bmN0aW9uKGJ1ZmY6YW55LCBvZmY6YW55LCBwcHA6YW55LCBnc3Q6YW55LCBubDphbnksIGNsb3M6YW55LCBqdXN0TGluZTphbnkpIHtcclxuICAgIHZhciByUyA9IG5sPT0yID8gRnJvbUVNRi5CLnJlYWRTaG9ydCA6IEZyb21FTUYuQi5yZWFkSW50O1xyXG4gICAgZm9yKHZhciBqPTA7IGo8cHBwOyBqKyspIHtcclxuICAgICAgICB2YXIgcHggPSByUyhidWZmLCBvZmYpOyAgb2ZmKz1ubDsgIFxyXG4gICAgICAgIHZhciBweSA9IHJTKGJ1ZmYsIG9mZik7ICBvZmYrPW5sO1xyXG4gICAgICAgIGlmKGo9PTAgJiYgIWp1c3RMaW5lKSBVRE9DLkcubW92ZVRvKGdzdCxweCxweSk7ICBlbHNlIFVET0MuRy5saW5lVG8oZ3N0LHB4LHB5KTtcclxuICAgIH1cclxuICAgIGlmKGNsb3MpIFVET0MuRy5jbG9zZVBhdGgoZ3N0KTtcclxuICAgIHJldHVybiBvZmY7XHJcbn1cclxuXHJcbkZyb21FTUYuQiA9IHtcclxuICAgIHVpbnQ4IDogbmV3IFVpbnQ4QXJyYXkoNCksXHJcbiAgICByZWFkU2hvcnQgIDogZnVuY3Rpb24oYnVmZjphbnkscDphbnkpOmFueSAgeyAgdmFyIHU4PUZyb21FTUYuQi51aW50ODsgIHU4WzBdPWJ1ZmZbcF07ICB1OFsxXT1idWZmW3ArMV07ICByZXR1cm4gRnJvbUVNRi5CLmludDE2IFswXTsgIH0sXHJcbiAgICByZWFkVXNob3J0IDogZnVuY3Rpb24oYnVmZjphbnkscDphbnkpOmFueSAgeyAgdmFyIHU4PUZyb21FTUYuQi51aW50ODsgIHU4WzBdPWJ1ZmZbcF07ICB1OFsxXT1idWZmW3ArMV07ICByZXR1cm4gRnJvbUVNRi5CLnVpbnQxNlswXTsgIH0sXHJcbiAgICByZWFkSW50ICAgIDogZnVuY3Rpb24oYnVmZjphbnkscDphbnkpOmFueSAgeyAgdmFyIHU4PUZyb21FTUYuQi51aW50ODsgIHU4WzBdPWJ1ZmZbcF07ICB1OFsxXT1idWZmW3ArMV07ICB1OFsyXT1idWZmW3ArMl07ICB1OFszXT1idWZmW3ArM107ICByZXR1cm4gRnJvbUVNRi5CLmludDMyIFswXTsgIH0sXHJcbiAgICByZWFkVWludCAgIDogZnVuY3Rpb24oYnVmZjphbnkscDphbnkpOmFueSAgeyAgdmFyIHU4PUZyb21FTUYuQi51aW50ODsgIHU4WzBdPWJ1ZmZbcF07ICB1OFsxXT1idWZmW3ArMV07ICB1OFsyXT1idWZmW3ArMl07ICB1OFszXT1idWZmW3ArM107ICByZXR1cm4gRnJvbUVNRi5CLnVpbnQzMlswXTsgIH0sXHJcbiAgICByZWFkRmxvYXQgIDogZnVuY3Rpb24oYnVmZjphbnkscDphbnkpOmFueSAgeyAgdmFyIHU4PUZyb21FTUYuQi51aW50ODsgIHU4WzBdPWJ1ZmZbcF07ICB1OFsxXT1idWZmW3ArMV07ICB1OFsyXT1idWZmW3ArMl07ICB1OFszXT1idWZmW3ArM107ICByZXR1cm4gRnJvbUVNRi5CLmZsb3QzMlswXTsgIH0sXHJcbiAgICByZWFkQVNDSUkgIDogZnVuY3Rpb24oYnVmZjphbnkscDphbnksbDphbnkpOmFueSB7ICB2YXIgcyA9IFwiXCI7ICBmb3IodmFyIGk9MDsgaTxsOyBpKyspIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmW3AraV0pOyAgcmV0dXJuIHM7ICAgIH1cclxufVxyXG5Gcm9tRU1GLkIuaW50MTYgID0gbmV3IEludDE2QXJyYXkgKEZyb21FTUYuQi51aW50OC5idWZmZXIpO1xyXG5Gcm9tRU1GLkIudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KEZyb21FTUYuQi51aW50OC5idWZmZXIpO1xyXG5Gcm9tRU1GLkIuaW50MzIgID0gbmV3IEludDMyQXJyYXkgKEZyb21FTUYuQi51aW50OC5idWZmZXIpO1xyXG5Gcm9tRU1GLkIudWludDMyID0gbmV3IFVpbnQzMkFycmF5KEZyb21FTUYuQi51aW50OC5idWZmZXIpO1xyXG5Gcm9tRU1GLkIuZmxvdDMyID0gbmV3IEZsb2F0MzJBcnJheShGcm9tRU1GLkIudWludDguYnVmZmVyKTtcclxuXHJcblxyXG5Gcm9tRU1GLkMgPSB7XHJcbiAgICBFTVJfSEVBREVSIDogMHgwMDAwMDAwMSxcclxuICAgIEVNUl9QT0xZQkVaSUVSIDogMHgwMDAwMDAwMixcclxuICAgIEVNUl9QT0xZR09OIDogMHgwMDAwMDAwMyxcclxuICAgIEVNUl9QT0xZTElORSA6IDB4MDAwMDAwMDQsXHJcbiAgICBFTVJfUE9MWUJFWklFUlRPIDogMHgwMDAwMDAwNSxcclxuICAgIEVNUl9QT0xZTElORVRPIDogMHgwMDAwMDAwNixcclxuICAgIEVNUl9QT0xZUE9MWUxJTkUgOiAweDAwMDAwMDA3LFxyXG4gICAgRU1SX1BPTFlQT0xZR09OIDogMHgwMDAwMDAwOCxcclxuICAgIEVNUl9TRVRXSU5ET1dFWFRFWCA6IDB4MDAwMDAwMDksXHJcbiAgICBFTVJfU0VUV0lORE9XT1JHRVggOiAweDAwMDAwMDBBLFxyXG4gICAgRU1SX1NFVFZJRVdQT1JURVhURVggOiAweDAwMDAwMDBCLFxyXG4gICAgRU1SX1NFVFZJRVdQT1JUT1JHRVggOiAweDAwMDAwMDBDLFxyXG4gICAgRU1SX1NFVEJSVVNIT1JHRVggOiAweDAwMDAwMDBELFxyXG4gICAgRU1SX0VPRiA6IDB4MDAwMDAwMEUsXHJcbiAgICBFTVJfU0VUUElYRUxWIDogMHgwMDAwMDAwRixcclxuICAgIEVNUl9TRVRNQVBQRVJGTEFHUyA6IDB4MDAwMDAwMTAsXHJcbiAgICBFTVJfU0VUTUFQTU9ERSA6IDB4MDAwMDAwMTEsXHJcbiAgICBFTVJfU0VUQktNT0RFIDogMHgwMDAwMDAxMixcclxuICAgIEVNUl9TRVRQT0xZRklMTE1PREUgOiAweDAwMDAwMDEzLFxyXG4gICAgRU1SX1NFVFJPUDIgOiAweDAwMDAwMDE0LFxyXG4gICAgRU1SX1NFVFNUUkVUQ0hCTFRNT0RFIDogMHgwMDAwMDAxNSxcclxuICAgIEVNUl9TRVRURVhUQUxJR04gOiAweDAwMDAwMDE2LFxyXG4gICAgRU1SX1NFVENPTE9SQURKVVNUTUVOVCA6IDB4MDAwMDAwMTcsXHJcbiAgICBFTVJfU0VUVEVYVENPTE9SIDogMHgwMDAwMDAxOCxcclxuICAgIEVNUl9TRVRCS0NPTE9SIDogMHgwMDAwMDAxOSxcclxuICAgIEVNUl9PRkZTRVRDTElQUkdOIDogMHgwMDAwMDAxQSxcclxuICAgIEVNUl9NT1ZFVE9FWCA6IDB4MDAwMDAwMUIsXHJcbiAgICBFTVJfU0VUTUVUQVJHTiA6IDB4MDAwMDAwMUMsXHJcbiAgICBFTVJfRVhDTFVERUNMSVBSRUNUIDogMHgwMDAwMDAxRCxcclxuICAgIEVNUl9JTlRFUlNFQ1RDTElQUkVDVCA6IDB4MDAwMDAwMUUsXHJcbiAgICBFTVJfU0NBTEVWSUVXUE9SVEVYVEVYIDogMHgwMDAwMDAxRixcclxuICAgIEVNUl9TQ0FMRVdJTkRPV0VYVEVYIDogMHgwMDAwMDAyMCxcclxuICAgIEVNUl9TQVZFREMgOiAweDAwMDAwMDIxLFxyXG4gICAgRU1SX1JFU1RPUkVEQyA6IDB4MDAwMDAwMjIsXHJcbiAgICBFTVJfU0VUV09STERUUkFOU0ZPUk0gOiAweDAwMDAwMDIzLFxyXG4gICAgRU1SX01PRElGWVdPUkxEVFJBTlNGT1JNIDogMHgwMDAwMDAyNCxcclxuICAgIEVNUl9TRUxFQ1RPQkpFQ1QgOiAweDAwMDAwMDI1LFxyXG4gICAgRU1SX0NSRUFURVBFTiA6IDB4MDAwMDAwMjYsXHJcbiAgICBFTVJfQ1JFQVRFQlJVU0hJTkRJUkVDVCA6IDB4MDAwMDAwMjcsXHJcbiAgICBFTVJfREVMRVRFT0JKRUNUIDogMHgwMDAwMDAyOCxcclxuICAgIEVNUl9BTkdMRUFSQyA6IDB4MDAwMDAwMjksXHJcbiAgICBFTVJfRUxMSVBTRSA6IDB4MDAwMDAwMkEsXHJcbiAgICBFTVJfUkVDVEFOR0xFIDogMHgwMDAwMDAyQixcclxuICAgIEVNUl9ST1VORFJFQ1QgOiAweDAwMDAwMDJDLFxyXG4gICAgRU1SX0FSQyA6IDB4MDAwMDAwMkQsXHJcbiAgICBFTVJfQ0hPUkQgOiAweDAwMDAwMDJFLFxyXG4gICAgRU1SX1BJRSA6IDB4MDAwMDAwMkYsXHJcbiAgICBFTVJfU0VMRUNUUEFMRVRURSA6IDB4MDAwMDAwMzAsXHJcbiAgICBFTVJfQ1JFQVRFUEFMRVRURSA6IDB4MDAwMDAwMzEsXHJcbiAgICBFTVJfU0VUUEFMRVRURUVOVFJJRVMgOiAweDAwMDAwMDMyLFxyXG4gICAgRU1SX1JFU0laRVBBTEVUVEUgOiAweDAwMDAwMDMzLFxyXG4gICAgRU1SX1JFQUxJWkVQQUxFVFRFIDogMHgwMDAwMDAzNCxcclxuICAgIEVNUl9FWFRGTE9PREZJTEwgOiAweDAwMDAwMDM1LFxyXG4gICAgRU1SX0xJTkVUTyA6IDB4MDAwMDAwMzYsXHJcbiAgICBFTVJfQVJDVE8gOiAweDAwMDAwMDM3LFxyXG4gICAgRU1SX1BPTFlEUkFXIDogMHgwMDAwMDAzOCxcclxuICAgIEVNUl9TRVRBUkNESVJFQ1RJT04gOiAweDAwMDAwMDM5LFxyXG4gICAgRU1SX1NFVE1JVEVSTElNSVQgOiAweDAwMDAwMDNBLFxyXG4gICAgRU1SX0JFR0lOUEFUSCA6IDB4MDAwMDAwM0IsXHJcbiAgICBFTVJfRU5EUEFUSCA6IDB4MDAwMDAwM0MsXHJcbiAgICBFTVJfQ0xPU0VGSUdVUkUgOiAweDAwMDAwMDNELFxyXG4gICAgRU1SX0ZJTExQQVRIIDogMHgwMDAwMDAzRSxcclxuICAgIEVNUl9TVFJPS0VBTkRGSUxMUEFUSCA6IDB4MDAwMDAwM0YsXHJcbiAgICBFTVJfU1RST0tFUEFUSCA6IDB4MDAwMDAwNDAsXHJcbiAgICBFTVJfRkxBVFRFTlBBVEggOiAweDAwMDAwMDQxLFxyXG4gICAgRU1SX1dJREVOUEFUSCA6IDB4MDAwMDAwNDIsXHJcbiAgICBFTVJfU0VMRUNUQ0xJUFBBVEggOiAweDAwMDAwMDQzLFxyXG4gICAgRU1SX0FCT1JUUEFUSCA6IDB4MDAwMDAwNDQsXHJcbiAgICBFTVJfQ09NTUVOVCA6IDB4MDAwMDAwNDYsXHJcbiAgICBFTVJfRklMTFJHTiA6IDB4MDAwMDAwNDcsXHJcbiAgICBFTVJfRlJBTUVSR04gOiAweDAwMDAwMDQ4LFxyXG4gICAgRU1SX0lOVkVSVFJHTiA6IDB4MDAwMDAwNDksXHJcbiAgICBFTVJfUEFJTlRSR04gOiAweDAwMDAwMDRBLFxyXG4gICAgRU1SX0VYVFNFTEVDVENMSVBSR04gOiAweDAwMDAwMDRCLFxyXG4gICAgRU1SX0JJVEJMVCA6IDB4MDAwMDAwNEMsXHJcbiAgICBFTVJfU1RSRVRDSEJMVCA6IDB4MDAwMDAwNEQsXHJcbiAgICBFTVJfTUFTS0JMVCA6IDB4MDAwMDAwNEUsXHJcbiAgICBFTVJfUExHQkxUIDogMHgwMDAwMDA0RixcclxuICAgIEVNUl9TRVRESUJJVFNUT0RFVklDRSA6IDB4MDAwMDAwNTAsXHJcbiAgICBFTVJfU1RSRVRDSERJQklUUyA6IDB4MDAwMDAwNTEsXHJcbiAgICBFTVJfRVhUQ1JFQVRFRk9OVElORElSRUNUVyA6IDB4MDAwMDAwNTIsXHJcbiAgICBFTVJfRVhUVEVYVE9VVEEgOiAweDAwMDAwMDUzLFxyXG4gICAgRU1SX0VYVFRFWFRPVVRXIDogMHgwMDAwMDA1NCxcclxuICAgIEVNUl9QT0xZQkVaSUVSMTYgOiAweDAwMDAwMDU1LFxyXG4gICAgRU1SX1BPTFlHT04xNiA6IDB4MDAwMDAwNTYsXHJcbiAgICBFTVJfUE9MWUxJTkUxNiA6IDB4MDAwMDAwNTcsXHJcbiAgICBFTVJfUE9MWUJFWklFUlRPMTYgOiAweDAwMDAwMDU4LFxyXG4gICAgRU1SX1BPTFlMSU5FVE8xNiA6IDB4MDAwMDAwNTksXHJcbiAgICBFTVJfUE9MWVBPTFlMSU5FMTYgOiAweDAwMDAwMDVBLFxyXG4gICAgRU1SX1BPTFlQT0xZR09OMTYgOiAweDAwMDAwMDVCLFxyXG4gICAgRU1SX1BPTFlEUkFXMTYgOiAweDAwMDAwMDVDLFxyXG4gICAgRU1SX0NSRUFURU1PTk9CUlVTSCA6IDB4MDAwMDAwNUQsXHJcbiAgICBFTVJfQ1JFQVRFRElCUEFUVEVSTkJSVVNIUFQgOiAweDAwMDAwMDVFLFxyXG4gICAgRU1SX0VYVENSRUFURVBFTiA6IDB4MDAwMDAwNUYsXHJcbiAgICBFTVJfUE9MWVRFWFRPVVRBIDogMHgwMDAwMDA2MCxcclxuICAgIEVNUl9QT0xZVEVYVE9VVFcgOiAweDAwMDAwMDYxLFxyXG4gICAgRU1SX1NFVElDTU1PREUgOiAweDAwMDAwMDYyLFxyXG4gICAgRU1SX0NSRUFURUNPTE9SU1BBQ0UgOiAweDAwMDAwMDYzLFxyXG4gICAgRU1SX1NFVENPTE9SU1BBQ0UgOiAweDAwMDAwMDY0LFxyXG4gICAgRU1SX0RFTEVURUNPTE9SU1BBQ0UgOiAweDAwMDAwMDY1LFxyXG4gICAgRU1SX0dMU1JFQ09SRCA6IDB4MDAwMDAwNjYsXHJcbiAgICBFTVJfR0xTQk9VTkRFRFJFQ09SRCA6IDB4MDAwMDAwNjcsXHJcbiAgICBFTVJfUElYRUxGT1JNQVQgOiAweDAwMDAwMDY4LFxyXG4gICAgRU1SX0RSQVdFU0NBUEUgOiAweDAwMDAwMDY5LFxyXG4gICAgRU1SX0VYVEVTQ0FQRSA6IDB4MDAwMDAwNkEsXHJcbiAgICBFTVJfU01BTExURVhUT1VUIDogMHgwMDAwMDA2QyxcclxuICAgIEVNUl9GT1JDRVVGSU1BUFBJTkcgOiAweDAwMDAwMDZELFxyXG4gICAgRU1SX05BTUVERVNDQVBFIDogMHgwMDAwMDA2RSxcclxuICAgIEVNUl9DT0xPUkNPUlJFQ1RQQUxFVFRFIDogMHgwMDAwMDA2RixcclxuICAgIEVNUl9TRVRJQ01QUk9GSUxFQSA6IDB4MDAwMDAwNzAsXHJcbiAgICBFTVJfU0VUSUNNUFJPRklMRVcgOiAweDAwMDAwMDcxLFxyXG4gICAgRU1SX0FMUEhBQkxFTkQgOiAweDAwMDAwMDcyLFxyXG4gICAgRU1SX1NFVExBWU9VVCA6IDB4MDAwMDAwNzMsXHJcbiAgICBFTVJfVFJBTlNQQVJFTlRCTFQgOiAweDAwMDAwMDc0LFxyXG4gICAgRU1SX0dSQURJRU5URklMTCA6IDB4MDAwMDAwNzYsXHJcbiAgICBFTVJfU0VUTElOS0VEVUZJUyA6IDB4MDAwMDAwNzcsXHJcbiAgICBFTVJfU0VUVEVYVEpVU1RJRklDQVRJT04gOiAweDAwMDAwMDc4LFxyXG4gICAgRU1SX0NPTE9STUFUQ0hUT1RBUkdFVFcgOiAweDAwMDAwMDc5LFxyXG4gICAgRU1SX0NSRUFURUNPTE9SU1BBQ0VXIDogMHgwMDAwMDA3QVxyXG59O1xyXG5Gcm9tRU1GLksgPSBbXTtcclxuXHJcbi8vIChmdW5jdGlvbigpIHtcclxuLy8gICAgIHZhciBpbnAsIG91dCwgc3R0O1xyXG4vLyAgICAgaW5wID0gRnJvbUVNRi5DOyAgIG91dCA9IEZyb21FTUYuSzsgICBzdHQ9NDtcclxuLy8gICAgIGZvcih2YXIgcCBpbiBpbnApIG91dFtpbnBbcF1dID0gcC5zbGljZShzdHQpO1xyXG4vLyB9ICApKCk7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBsZXQgVG9Db250ZXh0MkQ6YW55ID0gZnVuY3Rpb24gKG5lZWRQYWdlOmFueSwgc2NhbGU6YW55KVxyXG57XHJcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgIHRoaXMuYmIgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyUGFnZSA9IDA7XHJcbiAgICB0aGlzLm5lZWRQYWdlID0gbmVlZFBhZ2U7XHJcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XHJcbn1cclxuVG9Db250ZXh0MkQucHJvdG90eXBlLlN0YXJ0UGFnZSA9IGZ1bmN0aW9uKHg6YW55LHk6YW55LHc6YW55LGg6YW55KSB7XHJcbiAgICBpZih0aGlzLmN1cnJQYWdlIT10aGlzLm5lZWRQYWdlKSByZXR1cm47XHJcbiAgICB0aGlzLmJiID0gW3gseSx3LGhdO1xyXG4gICAgdmFyIHNjbCA9IHRoaXMuc2NhbGUsIGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgdmFyIGNudiA9IHRoaXMuY2FudmFzLCBjdHggPSB0aGlzLmN0eDtcclxuICAgIGNudi53aWR0aCA9IE1hdGgucm91bmQodypzY2wpOyAgY252LmhlaWdodCA9IE1hdGgucm91bmQoaCpzY2wpO1xyXG4gICAgY3R4LnRyYW5zbGF0ZSgwLGgqc2NsKTsgIGN0eC5zY2FsZShzY2wsLXNjbCk7XHJcbiAgICBjbnYuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJib3JkZXI6MXB4IHNvbGlkOyB3aWR0aDpcIisoY252LndpZHRoL2RwcikrXCJweDsgaGVpZ2h0OlwiKyhjbnYuaGVpZ2h0L2RwcikrXCJweFwiKTtcclxufVxyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuRmlsbCA9IGZ1bmN0aW9uKGdzdDphbnksIGV2ZW5PZGQ6YW55KSB7XHJcbiAgICBpZih0aGlzLmN1cnJQYWdlIT10aGlzLm5lZWRQYWdlKSByZXR1cm47XHJcbiAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICB0aGlzLl9zZXRTdHlsZShnc3QsIGN0eCk7XHJcbiAgICB0aGlzLl9kcmF3KGdzdC5wdGgsIGN0eCk7XHJcbiAgICBjdHguZmlsbCgpO1xyXG59XHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5TdHJva2UgPSBmdW5jdGlvbihnc3Q6YW55KSB7XHJcbiAgICBpZih0aGlzLmN1cnJQYWdlIT10aGlzLm5lZWRQYWdlKSByZXR1cm47XHJcbiAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICB0aGlzLl9zZXRTdHlsZShnc3QsIGN0eCk7XHJcbiAgICB0aGlzLl9kcmF3KGdzdC5wdGgsIGN0eCk7XHJcbiAgICBjdHguc3Ryb2tlKCk7XHJcbn1cclxuVG9Db250ZXh0MkQucHJvdG90eXBlLlB1dFRleHQgPSBmdW5jdGlvbihnc3Q6YW55LCBzdHI6YW55LCBzdHc6YW55KSB7XHJcbiAgICBpZih0aGlzLmN1cnJQYWdlIT10aGlzLm5lZWRQYWdlKSByZXR1cm47XHJcbiAgICB2YXIgc2NsID0gdGhpcy5fc2NhbGUoZ3N0LmN0bSk7XHJcbiAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XHJcbiAgICB0aGlzLl9zZXRTdHlsZShnc3QsIGN0eCk7XHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgdmFyIG0gPSBbMSwwLDAsLTEsMCwwXTsgIHRoaXMuX2NvbmNhdChtLCBnc3QuZm9udC5UbSk7ICB0aGlzLl9jb25jYXQobSwgZ3N0LmN0bSk7XHJcbiAgICAvL2NvbnNvbGUubG9nKHN0ciwgbSwgZ3N0KTsgIHRocm93IFwiZVwiO1xyXG4gICAgY3R4LnRyYW5zZm9ybShtWzBdLG1bMV0sbVsyXSxtWzNdLG1bNF0sbVs1XSk7XHJcbiAgICBjdHguZmlsbFRleHQoc3RyLDAsMCk7XHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG59XHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5QdXRJbWFnZSA9IGZ1bmN0aW9uKGdzdDphbnksIGJ1ZmY6YW55LCB3OmFueSwgaDphbnksIG1zazphbnkpIHtcclxuICAgIGlmKHRoaXMuY3VyclBhZ2UhPXRoaXMubmVlZFBhZ2UpIHJldHVybjtcclxuICAgIHZhciBjdHggPSB0aGlzLmN0eDtcclxuICAgIFxyXG4gICAgaWYoYnVmZi5sZW5ndGg9PXcqaCo0KSB7XHJcbiAgICAgICAgYnVmZiA9IGJ1ZmYuc2xpY2UoMCk7XHJcbiAgICAgICAgaWYobXNrICYmIG1zay5sZW5ndGg9PXcqaCo0KSBmb3IodmFyIGk9MDsgaTxidWZmLmxlbmd0aDsgaSs9NCkgYnVmZltpKzNdID0gbXNrW2krMV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNudiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksIGNjdHggPSBjbnYuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICAgIGNudi53aWR0aCA9IHc7ICBjbnYuaGVpZ2h0ID0gaDtcclxuICAgICAgICB2YXIgaW1nZCA9IGNjdHguY3JlYXRlSW1hZ2VEYXRhKHcsaCk7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8YnVmZi5sZW5ndGg7IGkrKykgaW1nZC5kYXRhW2ldPWJ1ZmZbaV07XHJcbiAgICAgICAgY2N0eC5wdXRJbWFnZURhdGEoaW1nZCwwLDApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgdmFyIG0gPSBbMSwwLDAsMSwwLDBdOyAgdGhpcy5fY29uY2F0KG0sIFsxL3csMCwwLC0xL2gsMCwxXSk7ICB0aGlzLl9jb25jYXQobSwgZ3N0LmN0bSk7XHJcbiAgICAgICAgY3R4LnRyYW5zZm9ybShtWzBdLG1bMV0sbVsyXSxtWzNdLG1bNF0sbVs1XSk7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShjbnYsMCwwKTtcclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG59XHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5TaG93UGFnZSA9IGZ1bmN0aW9uKCkgeyAgdGhpcy5jdXJyUGFnZSsrOyAgfVxyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuRG9uZSA9IGZ1bmN0aW9uKCkge31cclxuXHJcblxyXG5mdW5jdGlvbiBfZmx0KG46YW55KSAgeyAgcmV0dXJuIFwiXCIrcGFyc2VGbG9hdChuLnRvRml4ZWQoMikpOyAgfVxyXG5cclxuVG9Db250ZXh0MkQucHJvdG90eXBlLl9zZXRTdHlsZSA9IGZ1bmN0aW9uKGdzdDphbnksIGN0eDphbnkpIHtcclxuICAgIHZhciBzY2wgPSB0aGlzLl9zY2FsZShnc3QuY3RtKTtcclxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9nZXRGaWxsKGdzdC5jb2xyLCBnc3QuY2EsIGN0eCk7XHJcbiAgICBjdHguc3Ryb2tlU3R5bGU9dGhpcy5fZ2V0RmlsbChnc3QuQ09MUiwgZ3N0LkNBLCBjdHgpO1xyXG4gICAgXHJcbiAgICBjdHgubGluZUNhcCA9IFtcImJ1dHRcIixcInJvdW5kXCIsXCJzcXVhcmVcIl1bZ3N0LmxjYXBdO1xyXG4gICAgY3R4LmxpbmVKb2luPSBbXCJtaXRlclwiLFwicm91bmRcIixcImJldmVsXCJdW2dzdC5sam9pbl07XHJcbiAgICBjdHgubGluZVdpZHRoPWdzdC5sd2lkdGgqc2NsO1xyXG4gICAgdmFyIGRzaCA9IGdzdC5kYXNoLnNsaWNlKDApOyAgZm9yKHZhciBpPTA7IGk8ZHNoLmxlbmd0aDsgaSsrKSBkc2hbaV0gPSBfZmx0KGRzaFtpXSpzY2wpO1xyXG4gICAgY3R4LnNldExpbmVEYXNoKGRzaCk7IFxyXG4gICAgY3R4Lm1pdGVyTGltaXQgPSBnc3QubWxpbWl0KnNjbDtcclxuICAgIFxyXG4gICAgdmFyIGZuID0gZ3N0LmZvbnQuVGYsIGxuID0gZm4udG9Mb3dlckNhc2UoKTtcclxuICAgIHZhciBwMCA9IGxuLmluZGV4T2YoXCJib2xkXCIpIT0tMSA/IFwiYm9sZCBcIiA6IFwiXCI7XHJcbiAgICB2YXIgcDEgPSAobG4uaW5kZXhPZihcIml0YWxpY1wiKSE9LTEgfHwgbG4uaW5kZXhPZihcIm9ibGlxdWVcIikhPS0xKSA/IFwiaXRhbGljIFwiIDogXCJcIjtcclxuICAgIGN0eC5mb250ID0gcDArcDEgKyBnc3QuZm9udC5UZnMrXCJweCBcXFwiXCIrZm4rXCJcXFwiXCI7XHJcbn1cclxuVG9Db250ZXh0MkQucHJvdG90eXBlLl9nZXRGaWxsID0gZnVuY3Rpb24oY29scjphbnksIGNhOmFueSwgY3R4OmFueSlcclxue1xyXG4gICAgaWYoY29sci50eXA9PW51bGwpIHJldHVybiB0aGlzLl9jb2xyKGNvbHIsY2EpO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGdyZCA9IGNvbHIsIGNyZCA9IGdyZC5jcmRzLCBtYXQgPSBncmQubWF0LCBzY2w9dGhpcy5fc2NhbGUobWF0KSwgZ2Y7XHJcbiAgICAgICAgaWYgICAgIChncmQudHlwPT1cImxpblwiKSB7XHJcbiAgICAgICAgICAgIHZhciBwMCA9IHRoaXMuX211bHRQb2ludChtYXQsY3JkLnNsaWNlKDAsMikpLCBwMSA9IHRoaXMuX211bHRQb2ludChtYXQsY3JkLnNsaWNlKDIpKTtcclxuICAgICAgICAgICAgZ2Y9Y3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHAwWzBdLHAwWzFdLHAxWzBdLHAxWzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihncmQudHlwPT1cInJhZFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBwMCA9IHRoaXMuX211bHRQb2ludChtYXQsY3JkLnNsaWNlKDAsMikpLCBwMSA9IHRoaXMuX211bHRQb2ludChtYXQsY3JkLnNsaWNlKDMpKTtcclxuICAgICAgICAgICAgZ2Y9Y3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHAwWzBdLHAwWzFdLGNyZFsyXSpzY2wscDFbMF0scDFbMV0sY3JkWzVdKnNjbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGdyZC5ncmFkLmxlbmd0aDsgaSsrKSAgZ2YuYWRkQ29sb3JTdG9wKGdyZC5ncmFkW2ldWzBdLHRoaXMuX2NvbHIoZ3JkLmdyYWRbaV1bMV0sIGNhKSk7XHJcbiAgICAgICAgcmV0dXJuIGdmO1xyXG4gICAgfVxyXG59XHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5fY29sciAgPSBmdW5jdGlvbihjOmFueSxhOmFueSkgeyAgcmV0dXJuIFwicmdiYShcIitNYXRoLnJvdW5kKGNbMF0qMjU1KStcIixcIitNYXRoLnJvdW5kKGNbMV0qMjU1KStcIixcIitNYXRoLnJvdW5kKGNbMl0qMjU1KStcIixcIithK1wiKVwiOyAgfTtcclxuVG9Db250ZXh0MkQucHJvdG90eXBlLl9zY2FsZSA9IGZ1bmN0aW9uKG06YW55KSAgeyAgcmV0dXJuIE1hdGguc3FydChNYXRoLmFicyhtWzBdKm1bM10tbVsxXSptWzJdKSk7ICB9O1xyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuX2NvbmNhdD0gZnVuY3Rpb24obTphbnksdzphbnkgICkgeyAgXHJcbiAgICAgICAgdmFyIGE9bVswXSxiPW1bMV0sYz1tWzJdLGQ9bVszXSx0eD1tWzRdLHR5PW1bNV07XHJcbiAgICAgICAgbVswXSA9IChhICp3WzBdKSsoYiAqd1syXSk7ICAgICAgIG1bMV0gPSAoYSAqd1sxXSkrKGIgKndbM10pO1xyXG4gICAgICAgIG1bMl0gPSAoYyAqd1swXSkrKGQgKndbMl0pOyAgICAgICBtWzNdID0gKGMgKndbMV0pKyhkICp3WzNdKTtcclxuICAgICAgICBtWzRdID0gKHR4KndbMF0pKyh0eSp3WzJdKSt3WzRdOyAgbVs1XSA9ICh0eCp3WzFdKSsodHkqd1szXSkrd1s1XTsgXHJcbn1cclxuVG9Db250ZXh0MkQucHJvdG90eXBlLl9tdWx0UG9pbnQ9IGZ1bmN0aW9uKG06YW55LCBwOmFueSkgeyAgdmFyIHg9cFswXSx5PXBbMV07ICByZXR1cm4gW3gqbVswXSt5Km1bMl0rbVs0XSwgICB4Km1bMV0reSptWzNdK21bNV1dOyAgfSxcclxuVG9Db250ZXh0MkQucHJvdG90eXBlLl9kcmF3ICA9IGZ1bmN0aW9uKHBhdGg6YW55LCBjdHg6YW55KVxyXG57XHJcbiAgICB2YXIgYyA9IDAsIGNyZHMgPSBwYXRoLmNyZHM7XHJcbiAgICBmb3IodmFyIGo9MDsgajxwYXRoLmNtZHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICB2YXIgY21kID0gcGF0aC5jbWRzW2pdO1xyXG4gICAgICAgIGlmICAgICAoY21kPT1cIk1cIikgeyAgY3R4Lm1vdmVUbyhjcmRzW2NdLCBjcmRzW2MrMV0pOyAgYys9MjsgIH1cclxuICAgICAgICBlbHNlIGlmKGNtZD09XCJMXCIpIHsgIGN0eC5saW5lVG8oY3Jkc1tjXSwgY3Jkc1tjKzFdKTsgIGMrPTI7ICB9XHJcbiAgICAgICAgZWxzZSBpZihjbWQ9PVwiQ1wiKSB7ICBjdHguYmV6aWVyQ3VydmVUbyhjcmRzW2NdLCBjcmRzW2MrMV0sIGNyZHNbYysyXSwgY3Jkc1tjKzNdLCBjcmRzW2MrNF0sIGNyZHNbYys1XSk7ICBjKz02OyAgfVxyXG4gICAgICAgIGVsc2UgaWYoY21kPT1cIlFcIikgeyAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY3Jkc1tjXSwgY3Jkc1tjKzFdLCBjcmRzW2MrMl0sIGNyZHNbYyszXSk7ICBjKz00OyAgfVxyXG4gICAgICAgIGVsc2UgaWYoY21kPT1cIlpcIikgeyAgY3R4LmNsb3NlUGF0aCgpOyAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGNvbHVtZUhlYWRlcl93b3JkLCBjb2x1bWVIZWFkZXJfd29yZF9pbmRleCB9IGZyb20gXCIuL2NvbnN0YW50XCI7XHJcbmltcG9ydCB7IElsdWNreVNoZWV0U2VsZWN0aW9uIH0gZnJvbSBcIi4uL1RvTHVja3lTaGVldC9JTHVja1wiO1xyXG5pbXBvcnQgeyBJYXR0cmlidXRlTGlzdCwgc3RyaW5nVG9OdW19IGZyb20gXCIuLi9JQ29tbW9uXCI7XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmdldHh0KHJhbmdlOklsdWNreVNoZWV0U2VsZWN0aW9uLCBzaGVldHR4dDpzdHJpbmcpIHtcclxuXHJcbiAgICBsZXQgcm93MCA9IHJhbmdlW1wicm93XCJdWzBdLCByb3cxID0gcmFuZ2VbXCJyb3dcIl1bMV07XHJcbiAgICBsZXQgY29sdW1uMCA9IHJhbmdlW1wiY29sdW1uXCJdWzBdLCBjb2x1bW4xID0gcmFuZ2VbXCJjb2x1bW5cIl1bMV07XHJcblxyXG4gICAgaWYgKHJvdzAgPT0gbnVsbCAmJiByb3cxID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gc2hlZXR0eHQgKyBjaGF0YXRBQkMoY29sdW1uMCkgKyBcIjpcIiArIGNoYXRhdEFCQyhjb2x1bW4xKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbHVtbjAgPT0gbnVsbCAmJiBjb2x1bW4xID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gc2hlZXR0eHQgKyAocm93MCArIDEpICsgXCI6XCIgKyAocm93MSArIDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGNvbHVtbjAgPT0gY29sdW1uMSAmJiByb3cwID09IHJvdzEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNoZWV0dHh0ICsgY2hhdGF0QUJDKGNvbHVtbjApICsgKHJvdzAgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaGVldHR4dCArIGNoYXRhdEFCQyhjb2x1bW4wKSArIChyb3cwICsgMSkgKyBcIjpcIiArIGNoYXRhdEFCQyhjb2x1bW4xKSArIChyb3cxICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldGNlbGxyYW5nZSAodHh0OnN0cmluZywgc2hlZXRzOklhdHRyaWJ1dGVMaXN0PXt9LCBzaGVldElkOnN0cmluZz1cIjFcIikge1xyXG4gICAgbGV0IHZhbCA9IHR4dC5zcGxpdChcIiFcIik7XHJcblxyXG4gICAgbGV0IHNoZWV0dHh0ID0gXCJcIixcclxuICAgICAgICByYW5nZXR4dCA9IFwiXCIsXHJcbiAgICAgICAgc2hlZXRJbmRleCA9IC0xO1xyXG5cclxuICAgIGlmICh2YWwubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHNoZWV0dHh0ID0gdmFsWzBdO1xyXG4gICAgICAgIHJhbmdldHh0ID0gdmFsWzFdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBzaSA9IHNoZWV0c1tzaGVldHR4dF07XHJcbiAgICAgICAgaWYoc2k9PW51bGwpe1xyXG4gICAgICAgICAgICBzaGVldEluZGV4ID0gcGFyc2VJbnQoc2hlZXRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHNoZWV0SW5kZXggPSBwYXJzZUludChzaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNoZWV0SW5kZXggPSBwYXJzZUludChzaGVldElkKTtcclxuICAgICAgICByYW5nZXR4dCA9IHZhbFswXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHJhbmdldHh0LmluZGV4T2YoXCI6XCIpID09IC0xKSB7XHJcbiAgICAgICAgbGV0IHJvdyA9IHBhcnNlSW50KHJhbmdldHh0LnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSkgLSAxO1xyXG4gICAgICAgIGxldCBjb2wgPSBBQkNhdE51bShyYW5nZXR4dC5yZXBsYWNlKC9bXkEtWmEtel0vZywgXCJcIikpO1xyXG5cclxuICAgICAgICBpZiAoIWlzTmFOKHJvdykgJiYgIWlzTmFOKGNvbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIFwicm93XCI6IFtyb3csIHJvd10sXHJcbiAgICAgICAgICAgICAgICBcImNvbHVtblwiOiBbY29sLCBjb2xdLFxyXG4gICAgICAgICAgICAgICAgXCJzaGVldEluZGV4XCI6IHNoZWV0SW5kZXhcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0gXHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgcmFuZ2V0eHRBcnJheTpzdHJpbmdbXSA9IHJhbmdldHh0LnNwbGl0KFwiOlwiKTtcclxuICAgICAgICBsZXQgcm93ID0gW10sY29sID0gW107XHJcbiAgICAgICAgcm93WzBdID0gcGFyc2VJbnQocmFuZ2V0eHRBcnJheVswXS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikpIC0gMTtcclxuICAgICAgICByb3dbMV0gPSBwYXJzZUludChyYW5nZXR4dEFycmF5WzFdLnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSkgLSAxO1xyXG4gICAgICAgIC8vIGlmIChpc05hTihyb3dbMF0pKSB7XHJcbiAgICAgICAgLy8gICAgIHJvd1swXSA9IDA7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIGlmIChpc05hTihyb3dbMV0pKSB7XHJcbiAgICAgICAgLy8gICAgIHJvd1sxXSA9IHNoZWV0ZGF0YS5sZW5ndGggLSAxO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBpZiAocm93WzBdID4gcm93WzFdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb2xbMF0gPSBBQkNhdE51bShyYW5nZXR4dEFycmF5WzBdLnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKSk7XHJcbiAgICAgICAgY29sWzFdID0gQUJDYXROdW0ocmFuZ2V0eHRBcnJheVsxXS5yZXBsYWNlKC9bXkEtWmEtel0vZywgXCJcIikpO1xyXG4gICAgICAgIC8vIGlmIChpc05hTihjb2xbMF0pKSB7XHJcbiAgICAgICAgLy8gICAgIGNvbFswXSA9IDA7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIGlmIChpc05hTihjb2xbMV0pKSB7XHJcbiAgICAgICAgLy8gICAgIGNvbFsxXSA9IHNoZWV0ZGF0YVswXS5sZW5ndGggLSAxO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBpZiAoY29sWzBdID4gY29sWzFdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgXCJyb3dcIjogcm93LFxyXG4gICAgICAgICAgICBcImNvbHVtblwiOiBjb2wsXHJcbiAgICAgICAgICAgIFwic2hlZXRJbmRleFwiOiBzaGVldEluZGV4XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuLy/liJfkuIvmoIcgIOWtl+avjei9rOaVsOWtl1xyXG5mdW5jdGlvbiBBQkNhdE51bShhYmM6c3RyaW5nKSB7XHJcbiAgICBhYmMgPSBhYmMudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICBsZXQgYWJjX2xlbiA9IGFiYy5sZW5ndGg7XHJcbiAgICBpZiAoYWJjX2xlbiA9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgYWJjX2FycmF5ID0gYWJjLnNwbGl0KFwiXCIpO1xyXG4gICAgbGV0IHdvcmRsZW4gPSBjb2x1bWVIZWFkZXJfd29yZC5sZW5ndGg7XHJcbiAgICBsZXQgcmV0ID0gMDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gYWJjX2xlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgaWYgKGkgPT0gYWJjX2xlbiAtIDEpIHtcclxuICAgICAgICAgICAgcmV0ICs9IGNvbHVtZUhlYWRlcl93b3JkX2luZGV4W2FiY19hcnJheVtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXQgKz0gTWF0aC5wb3cod29yZGxlbiwgYWJjX2xlbiAtIGkgLSAxKSAqIChjb2x1bWVIZWFkZXJfd29yZF9pbmRleFthYmNfYXJyYXlbaV1dICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8v5YiX5LiL5qCHICDmlbDlrZfovazlrZfmr41cclxuZnVuY3Rpb24gY2hhdGF0QUJDKGluZGV4Om51bWJlcikge1xyXG4gICAgbGV0IHdvcmRsZW4gPSBjb2x1bWVIZWFkZXJfd29yZC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGluZGV4IDwgd29yZGxlbikge1xyXG4gICAgICAgIHJldHVybiBjb2x1bWVIZWFkZXJfd29yZFtpbmRleF07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgbGFzdCA9IDAsIHByZSA9IDAsIHJldCA9IFwiXCI7XHJcbiAgICAgICAgbGV0IGkgPSAxLCBuID0gMDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGluZGV4ID49ICh3b3JkbGVuIC8gKHdvcmRsZW4gLSAxKSkgKiAoTWF0aC5wb3cod29yZGxlbiwgaSsrKSAtIDEpKSB7XHJcbiAgICAgICAgICAgIG4gPSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGluZGV4X2FiID0gaW5kZXggLSAod29yZGxlbiAvICh3b3JkbGVuIC0gMSkpICogKE1hdGgucG93KHdvcmRsZW4sIG4gLSAxKSAtIDEpOy8vOTcwXHJcbiAgICAgICAgbGFzdCA9IGluZGV4X2FiICsgMTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgeCA9IG47IHggPiAwOyB4LS0pIHtcclxuICAgICAgICAgICAgbGV0IGxhc3QxID0gbGFzdCwgeDEgPSB4Oy8vLTcwMj0yNjgsIDNcclxuXHJcbiAgICAgICAgICAgIGlmICh4ID09IDEpIHtcclxuICAgICAgICAgICAgICAgIGxhc3QxID0gbGFzdDEgJSB3b3JkbGVuO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsYXN0MSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdDEgPSAyNjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0ICsgY29sdW1lSGVhZGVyX3dvcmRbbGFzdDEgLSAxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGFzdDEgPSBNYXRoLmNlaWwobGFzdDEgLyBNYXRoLnBvdyh3b3JkbGVuLCB4IC0gMSkpO1xyXG4gICAgICAgICAgICAvL2xhc3QxID0gbGFzdDEgJSB3b3JkbGVuO1xyXG4gICAgICAgICAgICByZXQgKz0gY29sdW1lSGVhZGVyX3dvcmRbbGFzdDEgLSAxXTtcclxuXHJcbiAgICAgICAgICAgIGlmICh4ID4gMSkge1xyXG4gICAgICAgICAgICAgICAgbGFzdCA9IGxhc3QgLSAobGFzdDEgLSAxKSAqIHdvcmRsZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKiBcclxuICogQHJldHVybiByYXRpbywgZGVmYXVsdCAwLjc1IDFpbiA9IDIuNTRjbSA9IDI1LjRtbSA9IDcycHQgPSA2cGMsICBwdCA9IDEvNzIgSW4sIHB4ID0gMS9kcGkgSW5cclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldHB0VG9QeFJhdGlvQnlEUEkoKTpudW1iZXJ7XHJcbiAgICByZXR1cm4gNzIvOTY7XHJcbn1cclxuXHJcbi8qKiBcclxuICogQGVtdXMgRU1VcywgRXhjZWwgZHJhd2luZyB1bml0XHJcbiAqIEByZXR1cm4gcGl4ZWxcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFB4QnlFTVVzKGVtdXM6bnVtYmVyKXtcclxuICAgIGlmKGVtdXM9PW51bGwpe1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgbGV0IGluY2ggPSBlbXVzLzkxNDQwMDtcclxuICAgIGxldCBwdCA9IGluY2gqNzI7XHJcbiAgICBsZXQgcHggPSBwdCAvIGdldHB0VG9QeFJhdGlvQnlEUEkoKTtcclxuICAgIHJldHVybiBweDtcclxufVxyXG5cclxuLyoqIFxyXG4gKiBAZG9tIHhtbCBhdHRyaWJ1dGUgb2JqZWN0XHJcbiAqIEBhdHRyIGF0dHJpYnV0ZSBuYW1lXHJcbiAqIEBkIGlmIGF0dHJpYnV0ZSBpcyBudWxsLCByZXR1cm4gZGVmYXVsdCB2YWx1ZSBcclxuICogQHJldHVybiBhdHRyaWJ1dGUgdmFsdWVcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFhtbEF0dGlidXRlKGRvbTpJYXR0cmlidXRlTGlzdCwgYXR0cjpzdHJpbmcsIGQ6c3RyaW5nKXtcclxuICAgIGxldCB2YWx1ZSA9IGRvbVthdHRyXTtcclxuICAgIHZhbHVlID0gdmFsdWU9PW51bGw/ZDp2YWx1ZTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5cclxuLyoqIFxyXG4gKiBAY29sdW1uV2lkdGggRXhjZWwgY29sdW1uIHdpZHRoXHJcbiAqIEByZXR1cm4gcGl4ZWwgY29sdW1uIHdpZHRoXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2x1bW5XaWR0aFBpeGVsKGNvbHVtbldpZHRoOm51bWJlcil7XHJcbiAgICBsZXQgcGl4ID0gTWF0aC5yb3VuZCgoY29sdW1uV2lkdGgtMC44MykgKiA4ICsgNSk7XHJcbiAgICByZXR1cm4gcGl4O1xyXG59XHJcblxyXG4vKiogXHJcbiAqIEByb3dIZWlnaHQgRXhjZWwgcm93IGhlaWdodFxyXG4gKiBAcmV0dXJuIHBpeGVsIHJvdyBoZWlnaHRcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvd0hlaWdodFBpeGVsKHJvd0hlaWdodDpudW1iZXIpe1xyXG4gICAgbGV0IHBpeCA9IE1hdGgucm91bmQocm93SGVpZ2h0L2dldHB0VG9QeFJhdGlvQnlEUEkoKSk7XHJcbiAgICByZXR1cm4gcGl4O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGlnaHRlbkRhcmtlbkNvbG9yKHNpeENvbG9yOnN0cmluZywgdGludDpudW1iZXIpe1xyXG4gICAgbGV0IGhleDpzdHJpbmcgPSBzaXhDb2xvci5zdWJzdHJpbmcoc2l4Q29sb3IubGVuZ3RoLTYsc2l4Q29sb3IubGVuZ3RoKTtcclxuICAgIGxldCByZ2JBcnJheTpudW1iZXJbXSA9IGhleFRvUmdiQXJyYXkoXCIjXCIraGV4KTtcclxuICAgIGxldCBoc2xBcnJheSA9IHJnYlRvSHNsKHJnYkFycmF5WzBdLCByZ2JBcnJheVsxXSxyZ2JBcnJheVsyXSk7XHJcbiAgICBpZih0aW50PjApe1xyXG4gICAgICAgIGhzbEFycmF5WzJdID0gaHNsQXJyYXlbMl0gKiAoMS4wLXRpbnQpICsgdGludDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYodGludDwwKXtcclxuICAgICAgICBoc2xBcnJheVsyXSA9IGhzbEFycmF5WzJdICogKDEuMCArIHRpbnQpXHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIHJldHVybiBcIiNcIitoZXg7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG5ld1JnYkFycmF5ID0gaHNsVG9SZ2IoaHNsQXJyYXlbMF0saHNsQXJyYXlbMV0saHNsQXJyYXlbMl0pO1xyXG5cclxuICAgIHJldHVybiByZ2JUb0hleChcIlJHQihcIiArIG5ld1JnYkFycmF5LmpvaW4oXCIsXCIpICsgXCIpXCIpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmdiVG9IZXgocmdiOnN0cmluZyl7XHJcbiAgICAvL+WNgeWFrei/m+WItuminOiJsuWAvOeahOato+WImeihqOi+vuW8j1xyXG4gICAgdmFyIHJlZyA9IC9eIyhbMC05YS1mQS1mXXszfXxbMC05YS1mQS1mXXs2fSkkLztcclxuICAgIC8vIOWmguaenOaYr3JnYuminOiJsuihqOekulxyXG4gICAgaWYgKC9eKHJnYnxSR0IpLy50ZXN0KHJnYikpIHtcclxuICAgICAgICB2YXIgYUNvbG9yID0gcmdiLnJlcGxhY2UoLyg/OlxcKHxcXCl8cmdifFJHQikqL2csIFwiXCIpLnNwbGl0KFwiLFwiKTtcclxuICAgICAgICB2YXIgc3RySGV4ID0gXCIjXCI7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGFDb2xvci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaGV4ID0gTnVtYmVyKGFDb2xvcltpXSkudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgICAgIGhleCA9ICcwJyArIGhleDsgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RySGV4ICs9IGhleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0ckhleC5sZW5ndGggIT09IDcpIHtcclxuICAgICAgICAgICAgc3RySGV4ID0gcmdiOyAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0ckhleDtcclxuICAgIH0gZWxzZSBpZiAocmVnLnRlc3QocmdiKSkge1xyXG4gICAgICAgIHZhciBhTnVtID0gcmdiLnJlcGxhY2UoLyMvLFwiXCIpLnNwbGl0KFwiXCIpO1xyXG4gICAgICAgIGlmIChhTnVtLmxlbmd0aCA9PT0gNikge1xyXG4gICAgICAgICAgICByZXR1cm4gcmdiOyAgICBcclxuICAgICAgICB9IGVsc2UgaWYoYU51bS5sZW5ndGggPT09IDMpIHtcclxuICAgICAgICAgICAgdmFyIG51bUhleCA9IFwiI1wiO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YU51bS5sZW5ndGg7IGkrPTEpIHtcclxuICAgICAgICAgICAgICAgIG51bUhleCArPSAoYU51bVtpXSArIGFOdW1baV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudW1IZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJnYjtcclxufVxyXG5cclxuZnVuY3Rpb24gaGV4VG9SZ2IoaGV4OnN0cmluZyl7XHJcbiAgICB2YXIgc0NvbG9yID0gaGV4LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAvL+WNgeWFrei/m+WItuminOiJsuWAvOeahOato+WImeihqOi+vuW8j1xyXG4gICAgdmFyIHJlZyA9IC9eIyhbMC05YS1mQS1mXXszfXxbMC05YS1mQS1mXXs2fSkkLztcclxuICAgIC8vIOWmguaenOaYrzE26L+b5Yi26aKc6ImyXHJcbiAgICBpZiAoc0NvbG9yICYmIHJlZy50ZXN0KHNDb2xvcikpIHtcclxuICAgICAgICBpZiAoc0NvbG9yLmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICAgICAgICB2YXIgc0NvbG9yTmV3ID0gXCIjXCI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MTsgaTw0OyBpKz0xKSB7XHJcbiAgICAgICAgICAgICAgICBzQ29sb3JOZXcgKz0gc0NvbG9yLnNsaWNlKGksIGkrMSkuY29uY2F0KHNDb2xvci5zbGljZShpLCBpKzEpKTsgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc0NvbG9yID0gc0NvbG9yTmV3O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WkhOeQhuWFreS9jeeahOminOiJsuWAvFxyXG4gICAgICAgIHZhciBzQ29sb3JDaGFuZ2UgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpPTE7IGk8NzsgaSs9Mikge1xyXG4gICAgICAgICAgICBzQ29sb3JDaGFuZ2UucHVzaChwYXJzZUludChcIjB4XCIrc0NvbG9yLnNsaWNlKGksIGkrMikpKTsgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIlJHQihcIiArIHNDb2xvckNoYW5nZS5qb2luKFwiLFwiKSArIFwiKVwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNDb2xvcjtcclxufVxyXG5cclxuZnVuY3Rpb24gaGV4VG9SZ2JBcnJheShoZXg6c3RyaW5nKXtcclxuICAgIHZhciBzQ29sb3IgPSBoZXgudG9Mb3dlckNhc2UoKTtcclxuICAgIC8v5Y2B5YWt6L+b5Yi26aKc6Imy5YC855qE5q2j5YiZ6KGo6L6+5byPXHJcbiAgICB2YXIgcmVnID0gL14jKFswLTlhLWZBLWZdezN9fFswLTlhLWZBLWZdezZ9KSQvO1xyXG4gICAgLy8g5aaC5p6c5pivMTbov5vliLbpopzoibJcclxuICAgIGlmIChzQ29sb3IgJiYgcmVnLnRlc3Qoc0NvbG9yKSkge1xyXG4gICAgICAgIGlmIChzQ29sb3IubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgICAgICAgIHZhciBzQ29sb3JOZXcgPSBcIiNcIjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0xOyBpPDQ7IGkrPTEpIHtcclxuICAgICAgICAgICAgICAgIHNDb2xvck5ldyArPSBzQ29sb3Iuc2xpY2UoaSwgaSsxKS5jb25jYXQoc0NvbG9yLnNsaWNlKGksIGkrMSkpOyAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzQ29sb3IgPSBzQ29sb3JOZXc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5aSE55CG5YWt5L2N55qE6aKc6Imy5YC8XHJcbiAgICAgICAgdmFyIHNDb2xvckNoYW5nZTpudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGk9MTsgaTw3OyBpKz0yKSB7XHJcbiAgICAgICAgICAgIHNDb2xvckNoYW5nZS5wdXNoKHBhcnNlSW50KFwiMHhcIitzQ29sb3Iuc2xpY2UoaSwgaSsyKSkpOyAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICBzQ29sb3JDaGFuZ2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhTTOminOiJsuWAvOi9rOaNouS4ulJHQi4gXHJcbiAqIOaNoueul+WFrOW8j+aUuee8luiHqiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9jb2xvcl9zcGFjZS5cclxuICogaCwgcywg5ZKMIGwg6K6+5a6a5ZyoIFswLCAxXSDkuYvpl7RcclxuICog6L+U5Zue55qEIHIsIGcsIOWSjCBiIOWcqCBbMCwgMjU1XeS5i+mXtFxyXG4gKlxyXG4gKiBAcGFyYW0gICBOdW1iZXIgIGggICAgICAg6Imy55u4XHJcbiAqIEBwYXJhbSAgIE51bWJlciAgcyAgICAgICDppbHlkozluqZcclxuICogQHBhcmFtICAgTnVtYmVyICBsICAgICAgIOS6ruW6plxyXG4gKiBAcmV0dXJuICBBcnJheSAgICAgICAgICAgUkdC6Imy5YC85pWw5YC8XHJcbiAqL1xyXG5mdW5jdGlvbiBoc2xUb1JnYihoOm51bWJlciwgczpudW1iZXIsIGw6bnVtYmVyKSB7XHJcbiAgICB2YXIgciwgZywgYjtcclxuXHJcbiAgICBpZihzID09IDApIHtcclxuICAgICAgICByID0gZyA9IGIgPSBsOyAvLyBhY2hyb21hdGljXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBodWUycmdiID0gZnVuY3Rpb24gaHVlMnJnYihwOm51bWJlciwgcTpudW1iZXIsIHQ6bnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGlmKHQgPCAwKSB0ICs9IDE7XHJcbiAgICAgICAgICAgIGlmKHQgPiAxKSB0IC09IDE7XHJcbiAgICAgICAgICAgIGlmKHQgPCAxLzYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xyXG4gICAgICAgICAgICBpZih0IDwgMS8yKSByZXR1cm4gcTtcclxuICAgICAgICAgICAgaWYodCA8IDIvMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XHJcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XHJcbiAgICAgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEvMyk7XHJcbiAgICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XHJcbiAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtNYXRoLnJvdW5kKHIgKiAyNTUpLCBNYXRoLnJvdW5kKGcgKiAyNTUpLCBNYXRoLnJvdW5kKGIgKiAyNTUpXTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBSR0Ig6aKc6Imy5YC86L2s5o2i5Li6IEhTTC5cclxuICog6L2s5o2i5YWs5byP5Y+C6ICD6IeqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2NvbG9yX3NwYWNlLlxyXG4gKiByLCBnLCDlkowgYiDpnIDopoHlnKggWzAsIDI1NV0g6IyD5Zu05YaFXHJcbiAqIOi/lOWbnueahCBoLCBzLCDlkowgbCDlnKggWzAsIDFdIOS5i+mXtFxyXG4gKlxyXG4gKiBAcGFyYW0gICBOdW1iZXIgIHIgICAgICAg57qi6Imy6Imy5YC8XHJcbiAqIEBwYXJhbSAgIE51bWJlciAgZyAgICAgICDnu7/oibLoibLlgLxcclxuICogQHBhcmFtICAgTnVtYmVyICBiICAgICAgIOiTneiJsuiJsuWAvFxyXG4gKiBAcmV0dXJuICBBcnJheSAgICAgICAgICAgSFNM5ZCE5YC85pWw57uEXHJcbiAqL1xyXG5mdW5jdGlvbiByZ2JUb0hzbChyOm51bWJlciwgZzpudW1iZXIsIGI6bnVtYmVyKSB7XHJcbiAgICByIC89IDI1NSwgZyAvPSAyNTUsIGIgLz0gMjU1O1xyXG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcclxuICAgIHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xyXG5cclxuICAgIGlmIChtYXggPT0gbWluKXsgXHJcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xyXG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcclxuICAgICAgICBzd2l0Y2gobWF4KSB7XHJcbiAgICAgICAgICAgIGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaCAvPSA2O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbaCwgcywgbF07XHJcbn1cclxuIFxyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JbmRleChwcmVmaXg6c3RyaW5nKTpzdHJpbmcge1xyXG4gICAgaWYocHJlZml4ID09IG51bGwpe1xyXG4gICAgICAgIHByZWZpeCA9IFwiU2hlZXRcIjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdXNlckFnZW50ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQucmVwbGFjZSgvW15hLXpBLVowLTldL2csIFwiXCIpLnNwbGl0KFwiXCIpO1xyXG5cclxuICAgIGxldCBtaWQgPSBcIlwiO1xyXG5cclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCA1OyBpKyspe1xyXG4gICAgICAgIG1pZCArPSB1c2VyQWdlbnRbTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKHVzZXJBZ2VudC5sZW5ndGggLSAxKSldO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgcmV0dXJuIHByZWZpeCArIFwiX1wiICsgbWlkICsgXCJfXCIgKyB0aW1lO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUNoYXJhY3RlcihzdHI6c3RyaW5nKXtcclxuICAgIGlmKHN0cj09bnVsbCB8fCBzdHIubGVuZ3RoPT0wKXtcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJmFtcDsvZywgXCImXCIpLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKS5yZXBsYWNlKC8mbHQ7L2csICc8JykucmVwbGFjZSgvJmd0Oy9nLCAnPicpLnJlcGxhY2UoLyZuYnNwOy9nLCAnICcpLnJlcGxhY2UoLyZhcG9zOy9nLCBcIidcIikucmVwbGFjZSgvJmlleGNsOy9nLCBcIsKhXCIpLnJlcGxhY2UoLyZjZW50Oy9nLCBcIsKiXCIpLnJlcGxhY2UoLyZwb3VuZDsvZywgXCLCo1wiKS5yZXBsYWNlKC8mY3VycmVuOy9nLCBcIsKkXCIpLnJlcGxhY2UoLyZ5ZW47L2csIFwiwqVcIikucmVwbGFjZSgvJmJydmJhcjsvZywgXCLCplwiKS5yZXBsYWNlKC8mc2VjdDsvZywgXCLCp1wiKS5yZXBsYWNlKC8mdW1sOy9nLCBcIsKoXCIpLnJlcGxhY2UoLyZjb3B5Oy9nLCBcIsKpXCIpLnJlcGxhY2UoLyZvcmRmOy9nLCBcIsKqXCIpLnJlcGxhY2UoLyZsYXF1bzsvZywgXCLCq1wiKS5yZXBsYWNlKC8mbm90Oy9nLCBcIsKsXCIpLnJlcGxhY2UoLyZzaHk7L2csIFwiwq1cIikucmVwbGFjZSgvJnJlZzsvZywgXCLCrlwiKS5yZXBsYWNlKC8mbWFjcjsvZywgXCLCr1wiKS5yZXBsYWNlKC8mZGVnOy9nLCBcIsKwXCIpLnJlcGxhY2UoLyZwbHVzbW47L2csIFwiwrFcIikucmVwbGFjZSgvJnN1cDI7L2csIFwiwrJcIikucmVwbGFjZSgvJnN1cDM7L2csIFwiwrNcIikucmVwbGFjZSgvJmFjdXRlOy9nLCBcIsK0XCIpLnJlcGxhY2UoLyZtaWNybzsvZywgXCLCtVwiKS5yZXBsYWNlKC8mcGFyYTsvZywgXCLCtlwiKS5yZXBsYWNlKC8mbWlkZG90Oy9nLCBcIsK3XCIpLnJlcGxhY2UoLyZjZWRpbDsvZywgXCLCuFwiKS5yZXBsYWNlKC8mc3VwMTsvZywgXCLCuVwiKS5yZXBsYWNlKC8mb3JkbTsvZywgXCLCulwiKS5yZXBsYWNlKC8mcmFxdW87L2csIFwiwrtcIikucmVwbGFjZSgvJmZyYWMxNDsvZywgXCLCvFwiKS5yZXBsYWNlKC8mZnJhYzEyOy9nLCBcIsK9XCIpLnJlcGxhY2UoLyZmcmFjMzQ7L2csIFwiwr5cIikucmVwbGFjZSgvJmlxdWVzdDsvZywgXCLCv1wiKS5yZXBsYWNlKC8mdGltZXM7L2csIFwiw5dcIikucmVwbGFjZSgvJmRpdmlkZTsvZywgXCLDt1wiKS5yZXBsYWNlKC8mQWdyYXZlOy9nLCBcIsOAXCIpLnJlcGxhY2UoLyZBYWN1dGU7L2csIFwiw4FcIikucmVwbGFjZSgvJkFjaXJjOy9nLCBcIsOCXCIpLnJlcGxhY2UoLyZBdGlsZGU7L2csIFwiw4NcIikucmVwbGFjZSgvJkF1bWw7L2csIFwiw4RcIikucmVwbGFjZSgvJkFyaW5nOy9nLCBcIsOFXCIpLnJlcGxhY2UoLyZBRWxpZzsvZywgXCLDhlwiKS5yZXBsYWNlKC8mQ2NlZGlsOy9nLCBcIsOHXCIpLnJlcGxhY2UoLyZFZ3JhdmU7L2csIFwiw4hcIikucmVwbGFjZSgvJkVhY3V0ZTsvZywgXCLDiVwiKS5yZXBsYWNlKC8mRWNpcmM7L2csIFwiw4pcIikucmVwbGFjZSgvJkV1bWw7L2csIFwiw4tcIikucmVwbGFjZSgvJklncmF2ZTsvZywgXCLDjFwiKS5yZXBsYWNlKC8mSWFjdXRlOy9nLCBcIsONXCIpLnJlcGxhY2UoLyZJY2lyYzsvZywgXCLDjlwiKS5yZXBsYWNlKC8mSXVtbDsvZywgXCLDj1wiKS5yZXBsYWNlKC8mRVRIOy9nLCBcIsOQXCIpLnJlcGxhY2UoLyZOdGlsZGU7L2csIFwiw5FcIikucmVwbGFjZSgvJk9ncmF2ZTsvZywgXCLDklwiKS5yZXBsYWNlKC8mT2FjdXRlOy9nLCBcIsOTXCIpLnJlcGxhY2UoLyZPY2lyYzsvZywgXCLDlFwiKS5yZXBsYWNlKC8mT3RpbGRlOy9nLCBcIsOVXCIpLnJlcGxhY2UoLyZPdW1sOy9nLCBcIsOWXCIpLnJlcGxhY2UoLyZPc2xhc2g7L2csIFwiw5hcIikucmVwbGFjZSgvJlVncmF2ZTsvZywgXCLDmVwiKS5yZXBsYWNlKC8mVWFjdXRlOy9nLCBcIsOaXCIpLnJlcGxhY2UoLyZVY2lyYzsvZywgXCLDm1wiKS5yZXBsYWNlKC8mVXVtbDsvZywgXCLDnFwiKS5yZXBsYWNlKC8mWWFjdXRlOy9nLCBcIsOdXCIpLnJlcGxhY2UoLyZUSE9STjsvZywgXCLDnlwiKS5yZXBsYWNlKC8mc3psaWc7L2csIFwiw59cIikucmVwbGFjZSgvJmFncmF2ZTsvZywgXCLDoFwiKS5yZXBsYWNlKC8mYWFjdXRlOy9nLCBcIsOhXCIpLnJlcGxhY2UoLyZhY2lyYzsvZywgXCLDolwiKS5yZXBsYWNlKC8mYXRpbGRlOy9nLCBcIsOjXCIpLnJlcGxhY2UoLyZhdW1sOy9nLCBcIsOkXCIpLnJlcGxhY2UoLyZhcmluZzsvZywgXCLDpVwiKS5yZXBsYWNlKC8mYWVsaWc7L2csIFwiw6ZcIikucmVwbGFjZSgvJmNjZWRpbDsvZywgXCLDp1wiKS5yZXBsYWNlKC8mZWdyYXZlOy9nLCBcIsOoXCIpLnJlcGxhY2UoLyZlYWN1dGU7L2csIFwiw6lcIikucmVwbGFjZSgvJmVjaXJjOy9nLCBcIsOqXCIpLnJlcGxhY2UoLyZldW1sOy9nLCBcIsOrXCIpLnJlcGxhY2UoLyZpZ3JhdmU7L2csIFwiw6xcIikucmVwbGFjZSgvJmlhY3V0ZTsvZywgXCLDrVwiKS5yZXBsYWNlKC8maWNpcmM7L2csIFwiw65cIikucmVwbGFjZSgvJml1bWw7L2csIFwiw69cIikucmVwbGFjZSgvJmV0aDsvZywgXCLDsFwiKS5yZXBsYWNlKC8mbnRpbGRlOy9nLCBcIsOxXCIpLnJlcGxhY2UoLyZvZ3JhdmU7L2csIFwiw7JcIikucmVwbGFjZSgvJm9hY3V0ZTsvZywgXCLDs1wiKS5yZXBsYWNlKC8mb2NpcmM7L2csIFwiw7RcIikucmVwbGFjZSgvJm90aWxkZTsvZywgXCLDtVwiKS5yZXBsYWNlKC8mb3VtbDsvZywgXCLDtlwiKS5yZXBsYWNlKC8mb3NsYXNoOy9nLCBcIsO4XCIpLnJlcGxhY2UoLyZ1Z3JhdmU7L2csIFwiw7lcIikucmVwbGFjZSgvJnVhY3V0ZTsvZywgXCLDulwiKS5yZXBsYWNlKC8mdWNpcmM7L2csIFwiw7tcIikucmVwbGFjZSgvJnV1bWw7L2csIFwiw7xcIikucmVwbGFjZSgvJnlhY3V0ZTsvZywgXCLDvVwiKS5yZXBsYWNlKC8mdGhvcm47L2csIFwiw75cIikucmVwbGFjZSgvJnl1bWw7L2csIFwiw79cIik7XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIGZyb211bGFSZWYge1xyXG5cclxuICAgIHN0YXRpYyBvcGVyYXRvciA9ICc9PXwhPXw8Pnw8PXw+PXw9fCt8LXw+fDx8L3wqfCV8JnxeJ1xyXG4gICAgc3RhdGljIGVycm9yID0ge1xyXG4gICAgICAgIHY6IFwiI1ZBTFVFIVwiLCAgICAvL+mUmeivr+eahOWPguaVsOaIlui/kOeul+esplxyXG4gICAgICAgIG46IFwiI05BTUU/XCIsICAgICAvL+WFrOW8j+WQjeensOmUmeivr1xyXG4gICAgICAgIG5hOiBcIiNOL0FcIiwgICAgICAvL+WHveaVsOaIluWFrOW8j+S4reayoeacieWPr+eUqOaVsOWAvFxyXG4gICAgICAgIHI6IFwiI1JFRiFcIiwgICAgICAvL+WIoOmZpOS6hueUseWFtuS7luWFrOW8j+W8leeUqOeahOWNleWFg+agvFxyXG4gICAgICAgIGQ6IFwiI0RJVi8wIVwiLCAgICAvL+mZpOaVsOaYrzDmiJbnqbrljZXlhYPmoLxcclxuICAgICAgICBubTogXCIjTlVNIVwiLCAgICAgLy/lvZPlhazlvI/miJblh73mlbDkuK3mn5DkuKrmlbDlrZfmnInpl67popjml7ZcclxuICAgICAgICBubDogXCIjTlVMTCFcIiwgICAgLy/kuqTlj4nov5DnrpfnrKbvvIjnqbrmoLzvvInkvb/nlKjkuI3mraPnoa5cclxuICAgICAgICBzcDogXCIjU1BJTEwhXCIgICAgLy/mlbDnu4TojIPlm7TmnInlhbblroPlgLxcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgb3BlcmF0b3Jqc29uOnN0cmluZ1RvTnVtID0gbnVsbFxyXG5cclxuICAgIHN0YXRpYyB0cmltKHN0cjpzdHJpbmcpIHsgIFxyXG4gICAgICAgIGlmKHN0ciA9PSBudWxsKXsgIFxyXG4gICAgICAgICAgICBzdHIgPSBcIlwiOyAgXHJcbiAgICAgICAgfSAgXHJcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oXlxccyopfChcXHMqJCkvZywgXCJcIik7ICBcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZnVuY3Rpb25Db3B5KHR4dDpzdHJpbmcsIG1vZGU6c3RyaW5nLCBzdGVwOm51bWJlcikge1xyXG4gICAgICAgIGxldCBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmIChfdGhpcy5vcGVyYXRvcmpzb24gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsZXQgYXJyID0gX3RoaXMub3BlcmF0b3Iuc3BsaXQoXCJ8XCIpLFxyXG4gICAgICAgICAgICAgICAgb3A6c3RyaW5nVG9OdW0gPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBvcFthcnJbaV0udG9TdHJpbmcoKV0gPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfdGhpcy5vcGVyYXRvcmpzb24gPSBvcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtb2RlID09IG51bGwpIHtcclxuICAgICAgICAgICAgbW9kZSA9IFwiZG93blwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0ZXAgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGVwID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eHQuc3Vic3RyKDAsIDEpID09IFwiPVwiKSB7XHJcbiAgICAgICAgICAgIHR4dCA9IHR4dC5zdWJzdHIoMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZnVuY3N0YWNrID0gdHh0LnNwbGl0KFwiXCIpO1xyXG4gICAgICAgIGxldCBpID0gMCxcclxuICAgICAgICAgICAgc3RyID0gXCJcIixcclxuICAgICAgICAgICAgZnVuY3Rpb25fc3RyID0gXCJcIixcclxuICAgICAgICAgICAgaXNwYXNzYnkgPSB0cnVlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBtYXRjaENvbmZpZyA9IHtcclxuICAgICAgICAgICAgXCJicmFja2V0XCI6IDAsXHJcbiAgICAgICAgICAgIFwiY29tbWFcIjogMCxcclxuICAgICAgICAgICAgXCJzcXVvdGVcIjogMCxcclxuICAgICAgICAgICAgXCJkcXVvdGVcIjogMFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHdoaWxlIChpIDwgZnVuY3N0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgcyA9IGZ1bmNzdGFja1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzID09IFwiKFwiICYmIG1hdGNoQ29uZmlnLmRxdW90ZSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaENvbmZpZy5icmFja2V0ICs9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IHN0ciArIFwiKFwiO1xyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBcIihcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzdHIgPSBcIlwiO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmIChzID09IFwiKVwiICYmIG1hdGNoQ29uZmlnLmRxdW90ZSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaENvbmZpZy5icmFja2V0IC09IDE7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMuZnVuY3Rpb25Db3B5KHN0ciwgbW9kZSwgc3RlcCkgKyBcIilcIjtcclxuICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAnXCInICYmIG1hdGNoQ29uZmlnLnNxdW90ZSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hDb25maWcuZHF1b3RlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBzdHIgKyAnXCInO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoQ29uZmlnLmRxdW90ZSAtPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hDb25maWcuZHF1b3RlICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcIic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gJywnICYmIG1hdGNoQ29uZmlnLmRxdW90ZSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMuZnVuY3Rpb25Db3B5KHN0ciwgbW9kZSwgc3RlcCkgKyAnLCc7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBcIlwiO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmIChzID09ICcmJyAmJiBtYXRjaENvbmZpZy5kcXVvdGUgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLmZ1bmN0aW9uQ29weShzdHIsIG1vZGUsIHN0ZXApICsgXCImXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gXCImXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHMgaW4gX3RoaXMub3BlcmF0b3Jqc29uICYmIG1hdGNoQ29uZmlnLmRxdW90ZSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc19uZXh0ID0gXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKGkgKyAxKSA8IGZ1bmNzdGFjay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzX25leHQgPSBmdW5jc3RhY2tbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBwID0gaSAtIDEsIFxyXG4gICAgICAgICAgICAgICAgICAgIHNfcHJlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihwID49IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc19wcmUgPSBmdW5jc3RhY2tbcC0tXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHA+PTAgJiYgc19wcmUgPT1cIiBcIilcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKHMgKyBzX25leHQpIGluIF90aGlzLm9wZXJhdG9yanNvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gX3RoaXMuZnVuY3Rpb25Db3B5KHN0ciwgbW9kZSwgc3RlcCkgKyBzICsgc19uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBzICsgc19uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZighKC9bXjAtOV0vLnRlc3Qoc19uZXh0KSkgJiYgcz09XCItXCIgJiYgKHNfcHJlPT1cIihcIiB8fCBzX3ByZSA9PSBudWxsIHx8IHNfcHJlID09IFwiLFwiIHx8IHNfcHJlID09IFwiIFwiIHx8IHNfcHJlIGluIF90aGlzLm9wZXJhdG9yanNvbiApICl7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IHM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLmZ1bmN0aW9uQ29weShzdHIsIG1vZGUsIHN0ZXApICsgcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IHM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpID09IGZ1bmNzdGFjay5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNjZWxsZGF0YShfdGhpcy50cmltKHN0cikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT0gXCJkb3duXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLmRvd25wYXJhbShfdGhpcy50cmltKHN0ciksIHN0ZXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PSBcInVwXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLnVwcGFyYW0oX3RoaXMudHJpbShzdHIpLCBzdGVwKTtcclxuICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT0gXCJsZWZ0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLmxlZnRwYXJhbShfdGhpcy50cmltKHN0ciksIHN0ZXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PSBcInJpZ2h0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLnJpZ2h0cGFyYW0oX3RoaXMudHJpbShzdHIpLCBzdGVwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLnRyaW0oc3RyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uX3N0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIGRvd25wYXJhbSh0eHQ6c3RyaW5nLCBzdGVwOm51bWJlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZXBhcmFtKFwiZFwiLCB0eHQsIHN0ZXApO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyB1cHBhcmFtKHR4dDpzdHJpbmcsIHN0ZXA6bnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlcGFyYW0oXCJ1XCIsIHR4dCwgc3RlcCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGxlZnRwYXJhbSh0eHQ6c3RyaW5nLCBzdGVwOm51bWJlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZXBhcmFtKFwibFwiLCB0eHQsIHN0ZXApO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyByaWdodHBhcmFtICh0eHQ6c3RyaW5nLCBzdGVwOm51bWJlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZXBhcmFtKFwiclwiLCB0eHQsIHN0ZXApO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBzdGF0aWMgdXBkYXRlcGFyYW0gKG9yaWVudDpzdHJpbmcsIHR4dDpzdHJpbmcsIHN0ZXA6bnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IF90aGlzID0gdGhpcztcclxuICAgICAgICBsZXQgdmFsID0gdHh0LnNwbGl0KFwiIVwiKSxcclxuICAgICAgICAgICAgcmFuZ2V0eHQsIHByZWZpeCA9IFwiXCI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJhbmdldHh0ID0gdmFsWzFdO1xyXG4gICAgICAgICAgICBwcmVmaXggPSB2YWxbMF0gKyBcIiFcIjtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByYW5nZXR4dCA9IHZhbFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyYW5nZXR4dC5pbmRleE9mKFwiOlwiKSA9PSAtMSkge1xyXG4gICAgICAgICAgICBsZXQgcm93ID0gcGFyc2VJbnQocmFuZ2V0eHQucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKTtcclxuICAgICAgICAgICAgbGV0IGNvbCA9IEFCQ2F0TnVtKHJhbmdldHh0LnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKSk7XHJcbiAgICAgICAgICAgIGxldCBmcmVlem9uRnVjID0gX3RoaXMuaXNmcmVlem9uRnVjKHJhbmdldHh0KTtcclxuICAgICAgICAgICAgbGV0ICRyb3cgPSBmcmVlem9uRnVjWzBdID8gXCIkXCIgOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgJGNvbCA9IGZyZWV6b25GdWNbMV0gPyBcIiRcIiA6IFwiXCI7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAob3JpZW50ID09IFwidVwiICYmICFmcmVlem9uRnVjWzBdKSB7XHJcbiAgICAgICAgICAgICAgICByb3cgLT0gc3RlcDtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50ID09IFwiclwiICYmICFmcmVlem9uRnVjWzFdKSB7XHJcbiAgICAgICAgICAgICAgICBjb2wgKz0gc3RlcDtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50ID09IFwibFwiICYmICFmcmVlem9uRnVjWzFdKSB7XHJcbiAgICAgICAgICAgICAgICBjb2wgLT0gc3RlcDtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAoIWZyZWV6b25GdWNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHJvdyArPSBzdGVwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihyb3cgPCAwIHx8IGNvbCA8IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVycm9yLnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICghaXNOYU4ocm93KSAmJiAhaXNOYU4oY29sKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICRjb2wgKyBjaGF0YXRBQkMoY29sKSArICRyb3cgKyAocm93KTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTmFOKHJvdykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAkcm93ICsgKHJvdyk7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc05hTihjb2wpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJGNvbCArIGNoYXRhdEFCQyhjb2wpO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByYW5nZXR4dCA9IHJhbmdldHh0LnNwbGl0KFwiOlwiKTtcclxuICAgICAgICAgICAgbGV0IHJvdyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgY29sID0gW107XHJcblxyXG4gICAgICAgICAgICByb3dbMF0gPSBwYXJzZUludChyYW5nZXR4dFswXS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikpO1xyXG4gICAgICAgICAgICByb3dbMV0gPSBwYXJzZUludChyYW5nZXR4dFsxXS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikpO1xyXG4gICAgICAgICAgICBpZiAocm93WzBdID4gcm93WzFdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb2xbMF0gPSBBQkNhdE51bShyYW5nZXR4dFswXS5yZXBsYWNlKC9bXkEtWmEtel0vZywgXCJcIikpO1xyXG4gICAgICAgICAgICBjb2xbMV0gPSBBQkNhdE51bShyYW5nZXR4dFsxXS5yZXBsYWNlKC9bXkEtWmEtel0vZywgXCJcIikpO1xyXG4gICAgICAgICAgICBpZiAoY29sWzBdID4gY29sWzFdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgZnJlZXpvbkZ1YzAgPSBfdGhpcy5pc2ZyZWV6b25GdWMocmFuZ2V0eHRbMF0pO1xyXG4gICAgICAgICAgICBsZXQgZnJlZXpvbkZ1YzEgPSBfdGhpcy5pc2ZyZWV6b25GdWMocmFuZ2V0eHRbMV0pO1xyXG4gICAgICAgICAgICBsZXQgJHJvdzAgPSBmcmVlem9uRnVjMFswXSA/IFwiJFwiIDogXCJcIixcclxuICAgICAgICAgICAgICAgICRjb2wwID0gZnJlZXpvbkZ1YzBbMV0gPyBcIiRcIiA6IFwiXCI7XHJcbiAgICAgICAgICAgIGxldCAkcm93MSA9IGZyZWV6b25GdWMxWzBdID8gXCIkXCIgOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgJGNvbDEgPSBmcmVlem9uRnVjMVsxXSA/IFwiJFwiIDogXCJcIjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChvcmllbnQgPT0gXCJ1XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZnJlZXpvbkZ1YzBbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICByb3dbMF0gLT0gc3RlcDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWZyZWV6b25GdWMxWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93WzFdIC09IHN0ZXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWVudCA9PSBcInJcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmcmVlem9uRnVjMFsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbFswXSArPSBzdGVwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZnJlZXpvbkZ1YzFbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xbMV0gKz0gc3RlcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50ID09IFwibFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZyZWV6b25GdWMwWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sWzBdIC09IHN0ZXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFmcmVlem9uRnVjMVsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbFsxXSAtPSBzdGVwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghZnJlZXpvbkZ1YzBbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICByb3dbMF0gKz0gc3RlcDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWZyZWV6b25GdWMxWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93WzFdICs9IHN0ZXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHJvd1swXSA8IDAgfHwgY29sWzBdIDwgMCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXJyb3IucjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbFswXSkgJiYgaXNOYU4oY29sWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICRyb3cwICsgKHJvd1swXSkgKyBcIjpcIiArICRyb3cxICsgKHJvd1sxXSk7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHJvd1swXSkgJiYgaXNOYU4ocm93WzFdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICRjb2wwICsgY2hhdGF0QUJDKGNvbFswXSkgKyBcIjpcIiArICRjb2wxICsgY2hhdGF0QUJDKGNvbFsxXSk7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICRjb2wwICsgY2hhdGF0QUJDKGNvbFswXSkgKyAkcm93MCArIChyb3dbMF0pICsgXCI6XCIgKyAkY29sMSArIGNoYXRhdEFCQyhjb2xbMV0pICsgJHJvdzEgKyAocm93WzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIGlzY2VsbGRhdGEodHh0OnN0cmluZykgeyAvL+WIpOaWreaYr+WQpuS4uuWNleWFg+agvOagvOW8j1xyXG4gICAgICAgIGxldCB2YWwgPSB0eHQuc3BsaXQoXCIhXCIpLFxyXG4gICAgICAgICAgICByYW5nZXR4dDtcclxuXHJcbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJhbmdldHh0ID0gdmFsWzFdO1xyXG4gICAgICAgIH0gXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJhbmdldHh0ID0gdmFsWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJlZ19jZWxsID0gL14oKFthLXpBLVpdKyl8KFskXVthLXpBLVpdKykpKChbMC05XSspfChbJF1bMC05XSspKSQvZzsgLy/lop7liqDmraPliJnliKTmlq3ljZXlhYPmoLzkuLrlrZfmr40r5pWw5a2X55qE5qC85byP77ya5aaCIEExOkIzXHJcbiAgICAgICAgbGV0IHJlZ19jZWxsUmFuZ2UgPSAvXigoKChbYS16QS1aXSspfChbJF1bYS16QS1aXSspKSgoWzAtOV0rKXwoWyRdWzAtOV0rKSkpfCgoKFthLXpBLVpdKyl8KFskXVthLXpBLVpdKykpKSkkL2c7IC8v5aKe5Yqg5q2j5YiZ5Yik5pat5Y2V5YWD5qC85Li65a2X5q+NK+aVsOWtl+aIluWtl+avjeeahOagvOW8j++8muWmgiBBMTpCM++8jEE6QVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChyYW5nZXR4dC5pbmRleE9mKFwiOlwiKSA9PSAtMSkge1xyXG4gICAgICAgICAgICBsZXQgcm93ID0gcGFyc2VJbnQocmFuZ2V0eHQucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKSAtIDE7XHJcbiAgICAgICAgICAgIGxldCBjb2wgPSBBQkNhdE51bShyYW5nZXR4dC5yZXBsYWNlKC9bXkEtWmEtel0vZywgXCJcIikpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCFpc05hTihyb3cpICYmICFpc05hTihjb2wpICYmIHJhbmdldHh0LnRvU3RyaW5nKCkubWF0Y2gocmVnX2NlbGwpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTmFOKHJvdykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTmFOKGNvbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWdfY2VsbFJhbmdlID0gL14oKCgoW2EtekEtWl0rKXwoWyRdW2EtekEtWl0rKSkoKFswLTldKyl8KFskXVswLTldKykpKXwoKChbYS16QS1aXSspfChbJF1bYS16QS1aXSspKSl8KCgoWzAtOV0rKXwoWyRdWzAtOV0rcykpKSkkL2c7XHJcblxyXG4gICAgICAgICAgICByYW5nZXR4dCA9IHJhbmdldHh0LnNwbGl0KFwiOlwiKTtcclxuXHJcbiAgICAgICAgICAgIGxldCByb3cgPSBbXSxjb2wgPSBbXTtcclxuICAgICAgICAgICAgcm93WzBdID0gcGFyc2VJbnQocmFuZ2V0eHRbMF0ucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKSAtIDE7XHJcbiAgICAgICAgICAgIHJvd1sxXSA9IHBhcnNlSW50KHJhbmdldHh0WzFdLnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSkgLSAxO1xyXG4gICAgICAgICAgICBpZiAocm93WzBdID4gcm93WzFdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbFswXSA9IEFCQ2F0TnVtKHJhbmdldHh0WzBdLnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKSk7XHJcbiAgICAgICAgICAgIGNvbFsxXSA9IEFCQ2F0TnVtKHJhbmdldHh0WzFdLnJlcGxhY2UoL1teQS1aYS16XS9nLCBcIlwiKSk7XHJcbiAgICAgICAgICAgIGlmIChjb2xbMF0gPiBjb2xbMV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYocmFuZ2V0eHRbMF0udG9TdHJpbmcoKS5tYXRjaChyZWdfY2VsbFJhbmdlKSAmJiByYW5nZXR4dFsxXS50b1N0cmluZygpLm1hdGNoKHJlZ19jZWxsUmFuZ2UpKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzZnJlZXpvbkZ1Yyh0eHQ6c3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IHJvdyA9IHR4dC5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIik7XHJcbiAgICAgICAgbGV0IGNvbCA9IHR4dC5yZXBsYWNlKC9bXkEtWmEtel0vZywgXCJcIik7XHJcbiAgICAgICAgbGV0IHJvdyQgPSB0eHQuc3Vic3RyKHR4dC5pbmRleE9mKHJvdykgLSAxLCAxKTtcclxuICAgICAgICBsZXQgY29sJCA9IHR4dC5zdWJzdHIodHh0LmluZGV4T2YoY29sKSAtIDEsIDEpO1xyXG4gICAgICAgIGxldCByZXQgPSBbZmFsc2UsIGZhbHNlXTtcclxuXHJcbiAgICAgICAgaWYgKHJvdyQgPT0gXCIkXCIpIHtcclxuICAgICAgICAgICAgcmV0WzBdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbCQgPT0gXCIkXCIpIHtcclxuICAgICAgICAgICAgcmV0WzFdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0NoaW5lc2UodGVtcDpzdHJpbmcpOmJvb2xlYW5cclxueyBcclxuICAgIHZhciByZSA9IC9bXlxcdTRlMDAtXFx1OWZhNV0vOyBcclxuICAgIHZhciByZWcgPSAvW1xcdTMwMDJ8XFx1ZmYxZnxcXHVmZjAxfFxcdWZmMGN8XFx1MzAwMXxcXHVmZjFifFxcdWZmMWF8XFx1MjAxY3xcXHUyMDFkfFxcdTIwMTh8XFx1MjAxOXxcXHVmZjA4fFxcdWZmMDl8XFx1MzAwYXxcXHUzMDBifFxcdTMwMDh8XFx1MzAwOXxcXHUzMDEwfFxcdTMwMTF8XFx1MzAwZXxcXHUzMDBmfFxcdTMwMGN8XFx1MzAwZHxcXHVmZTQzfFxcdWZlNDR8XFx1MzAxNHxcXHUzMDE1fFxcdTIwMjZ8XFx1MjAxNHxcXHVmZjVlfFxcdWZlNGZ8XFx1ZmZlNV0vO1xyXG4gICAgaWYocmVnLnRlc3QodGVtcCkpIHJldHVybiB0cnVlOyBcclxuICAgIGlmKHJlLnRlc3QodGVtcCkpIHJldHVybiBmYWxzZTsgXHJcblx0cmV0dXJuIHRydWU7IFxyXG59XHJcbiBcclxuZXhwb3J0IGZ1bmN0aW9uIGlzSmFwYW5lc2UodGVtcDpzdHJpbmcpOmJvb2xlYW5cclxueyBcclxuXHR2YXIgcmUgPSAvW15cXHUwODAwLVxcdTRlMDBdLzsgXHJcblx0aWYocmUudGVzdCh0ZW1wKSkgcmV0dXJuIGZhbHNlOyBcclxuXHRyZXR1cm4gdHJ1ZTsgXHJcbn1cclxuIFxyXG5leHBvcnQgZnVuY3Rpb24gaXNLb2VyYShjaHI6YW55KTpib29sZWFuIHtcclxuXHRcclxuXHRpZigoKGNociA+IDB4MzEzMCAmJiBjaHIgPCAweDMxOEYpIHx8IFxyXG5cdCAgICAoY2hyID49IDB4QUMwMCAmJiBjaHIgPD0gMHhEN0EzKSkpIFxyXG5cdHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0NvbnRhaW5NdWx0aVR5cGUoc3RyOnN0cmluZyk6Ym9vbGVhbiB7XHJcblx0XHJcbiAgICBsZXQgaXNVbmljb2RlID0gZmFsc2U7XHJcbiAgICBpZihlc2NhcGUoc3RyKS5pbmRleE9mKFwiJXVcIik+LTEpe1xyXG4gICAgICAgIGlzVW5pY29kZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGlzTm90ID0gZmFsc2U7XHJcbiAgICBsZXQgcmVnID0gL1swLTlhLXpdL2dpOyBcclxuICAgIGlmKHJlZy50ZXN0KHN0cikpe1xyXG4gICAgICAgIGlzTm90ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcmVFblNpZ24gPSAvW1xceDAwLVxceGZmXSsvZztcclxuICAgIGlmKHJlRW5TaWduLnRlc3Qoc3RyKSl7XHJcbiAgICAgICAgaXNOb3QgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKGlzVW5pY29kZSAmJiBpc05vdCl7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG5cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCaW5hcnlDb250ZW50IChwYXRoOmFueSwgb3B0aW9uczphbnkpIHtcclxuICAgIGxldCBwcm9taXNlLCByZXNvbHZlOmFueSwgcmVqZWN0OmFueTtcclxuICAgIGxldCBjYWxsYmFjazphbnk7XHJcblxyXG4gICAgaWYgKCFvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRha2VuIGZyb20galF1ZXJ5XHJcbiAgICBsZXQgY3JlYXRlU3RhbmRhcmRYSFIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICB9IGNhdGNoKCBlICkge31cclxuICAgIH1cclxuXHJcbiAgICBsZXQgY3JlYXRlQWN0aXZlWEhSID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcclxuICAgICAgICB9IGNhdGNoKCBlICkge31cclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIHJlcXVlc3Qgb2JqZWN0XHJcbiAgICB2YXIgY3JlYXRlWEhSID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LkFjdGl2ZVhPYmplY3QpID9cclxuICAgICAgICAvKiBNaWNyb3NvZnQgZmFpbGVkIHRvIHByb3Blcmx5XHJcbiAgICAgICAgKiBpbXBsZW1lbnQgdGhlIFhNTEh0dHBSZXF1ZXN0IGluIElFNyAoY2FuJ3QgcmVxdWVzdCBsb2NhbCBmaWxlcyksXHJcbiAgICAgICAgKiBzbyB3ZSB1c2UgdGhlIEFjdGl2ZVhPYmplY3Qgd2hlbiBpdCBpcyBhdmFpbGFibGVcclxuICAgICAgICAqIEFkZGl0aW9uYWxseSBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgaW4gSUU3L0lFOCBzb1xyXG4gICAgICAgICogd2UgbmVlZCBhIGZhbGxiYWNrLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YW5kYXJkWEhSKCkgfHwgY3JlYXRlQWN0aXZlWEhSKCk7XHJcbiAgICB9IDpcclxuICAgICAgICAvLyBGb3IgYWxsIG90aGVyIGJyb3dzZXJzLCB1c2UgdGhlIHN0YW5kYXJkIFhNTEh0dHBSZXF1ZXN0IG9iamVjdFxyXG4gICAgICAgIGNyZWF0ZVN0YW5kYXJkWEhSO1xyXG5cclxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGlibGUgY2FsbGJhY2tcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBjYWxsYmFjayBpbnNpZGUgb3B0aW9ucyBvYmplY3RcclxuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzb2x2ZSA9IGZ1bmN0aW9uIChkYXRhOmFueSkgeyBjYWxsYmFjayhudWxsLCBkYXRhKTsgfTtcclxuICAgIHJlamVjdCA9IGZ1bmN0aW9uIChlcnI6YW55KSB7IGNhbGxiYWNrKGVyciwgbnVsbCk7IH07XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgeGhyID0gY3JlYXRlWEhSKCk7XHJcblxyXG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoLCB0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gcmVjZW50IGJyb3dzZXJzXHJcbiAgICAgICAgaWYgKFwicmVzcG9uc2VUeXBlXCIgaW4geGhyKSB7XHJcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBvbGRlciBicm93c2VyXHJcbiAgICAgICAgaWYoeGhyLm92ZXJyaWRlTWltZVR5cGUpIHtcclxuICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIChldmVudDpFdmVudCkge1xyXG4gICAgICAgICAgICAvLyB1c2UgYHhocmAgYW5kIG5vdCBgdGhpc2AuLi4gdGhhbmtzIElFXHJcbiAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCB8fCB4aHIuc3RhdHVzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmdW5jdGlvbiAoeGhyOlhNTEh0dHBSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgeGhyLnJlc3BvbnNlVGV4dCwgdGhlIDB4RkYgbWFzayBpcyBhcHBsaWVkIGJ5IEpTWmlwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlIHx8IHhoci5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oeGhyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBamF4IGVycm9yIGZvciBcIiArIHBhdGggKyBcIiA6IFwiICsgdGhpcy5zdGF0dXMgKyBcIiBcIiArIHRoaXMuc3RhdHVzVGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYob3B0aW9ucy5wcm9ncmVzcykge1xyXG4gICAgICAgICAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGU6YW55KSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnByb2dyZXNzKHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudDogZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZDogZS5sb2FkZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWw6IGUudG90YWxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGhyLnNlbmQoKTtcclxuXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlKSwgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmV0dXJucyBhIHByb21pc2Ugb3IgdW5kZWZpbmVkIGRlcGVuZGluZyBvbiB3aGV0aGVyIGEgY2FsbGJhY2sgd2FzXHJcbiAgICAvLyBwcm92aWRlZFxyXG4gICAgcmV0dXJuIHByb21pc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBtdWx0aSBzZXF1ZW5jZSBjb252ZXJzaW9uXHJcbiAqIGV4YW1wbGU6XHJcbiAqICAx44CBRTE0IC0+IDEzXzRcclxuICogIDLjgIFFMTQgSjE0IE8xNCBUMTQgWTE0IEFEMTQgQUkxNCBBTjE0IEFTMTQgQVgxNCAtPlxyXG4gKiAgICAgWycxM180JywgJzEzXzknLCcxM18xNCcsICcxM18xOScsICcxM18yNCcsICcxM18zJywgJzEzXzgnLCAgJzEzXzEzJywgJzEzXzE4JywgJzEzXzIzJ11cclxuICogIDPjgIFFNDY6RTQ3IC0+IFsnNDVfNCcsICAnNDZfNCddXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcXJlZiAtIGJlZm9yZSBzZXF1ZW5jZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TXVsdGlTZXF1ZW5jZVRvTnVtKHNxcmVmOiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcbiAgaWYgKCFzcXJlZiB8fCBzcXJlZj8ubGVuZ3RoIDw9IDApIHJldHVybiBbXTtcclxuICBzcXJlZiA9IHNxcmVmLnRvVXBwZXJDYXNlKCk7XHJcbiAgbGV0IHNxcmVmUmF3QXJyID0gc3FyZWYuc3BsaXQoXCIgXCIpO1xyXG4gIGxldCBzcXJlZkFyciA9IHNxcmVmUmF3QXJyLmZpbHRlcigoZSkgPT4gZSAmJiBlLnRyaW0oKSk7XHJcbiAgbGV0IHNxcmVmTGFzdEFyciA9IGdldFNxcmVmUmF3QXJyRm9ybWF0KHNxcmVmQXJyKTtcclxuXHJcbiAgbGV0IHJlc0Fycjogc3RyaW5nW10gPSBbXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNxcmVmTGFzdEFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgbGV0IF9yZXMgPSBnZXRTaW5nbGVTZXF1ZW5jZVRvTnVtKHNxcmVmTGFzdEFycltpXSk7XHJcbiAgICBpZiAoX3JlcykgcmVzQXJyLnB1c2goX3Jlcyk7XHJcbiAgfVxyXG4gIHJldHVybiByZXNBcnI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBnZXQgcmVnaW9uIHNlcXVlbmNlXHJcbiAqIGV4YW1wbGU6XHJcbiAqICAx44CBW0ExOkMyJ10gLT4gWydBMScsICdBMicsICdCMScsICdCMicsICdDMScsICdDMiddXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFyciAtIGZvcm1hdHMgYXJyXHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSBhZnRlciBhcnJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWdpb25TZXF1ZW5jZShhcnI6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xyXG4gIGxldCBmb3JtYXRBcnI6IHN0cmluZ1tdID0gW107XHJcbiAgXHJcbiAgY29uc3QgcmVnRW4gPSBuZXcgUmVnRXhwKC9bQS1aXSt8WzAtOV0rL2cpO1xyXG4gIGNvbnN0IHN0YXJ0QXJyID0gYXJyWzBdPy5tYXRjaChyZWdFbik7XHJcbiAgY29uc3QgbGFzdEFyciA9IGFyclsxXT8ubWF0Y2gocmVnRW4pO1xyXG4gIGNvbnN0IGNvbHVtbk1heCA9IE1hdGgubWF4KC4uLltBQkNhdE51bShzdGFydEFyclswXSksIEFCQ2F0TnVtKGxhc3RBcnJbMF0pXSk7XHJcbiAgY29uc3QgY29sdW1uTWluID0gTWF0aC5taW4oLi4uW0FCQ2F0TnVtKHN0YXJ0QXJyWzBdKSwgQUJDYXROdW0obGFzdEFyclswXSldKTtcclxuICBjb25zdCByb3dNYXggPSBNYXRoLm1heCguLi5bcGFyc2VJbnQoc3RhcnRBcnJbMV0pLCBwYXJzZUludChsYXN0QXJyWzFdKV0pO1xyXG4gIGNvbnN0IHJvd01pbiA9IE1hdGgubWluKC4uLltwYXJzZUludChzdGFydEFyclsxXSksIHBhcnNlSW50KGxhc3RBcnJbMV0pXSk7XHJcbiAgXHJcbiAgZm9yIChsZXQgaSA9IGNvbHVtbk1pbjsgaSA8PSBjb2x1bW5NYXg7IGkrKykge1xyXG4gICAgZm9yIChsZXQgaiA9IHJvd01pbjsgaiA8PSByb3dNYXg7IGorKykge1xyXG4gICAgICBmb3JtYXRBcnIucHVzaChgJHtjaGF0YXRBQkMoaSl9JHtqfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZvcm1hdEFycjtcclxufVxyXG5cclxuLyoqXHJcbiAqIHVuaWZpZWQgcHJvY2Vzc2luZyBvZiBjb252ZXJzaW9uIGZvcm1hdHNcclxuICogZXhhbXBsZTpcclxuICogIDHjgIFbJ0UzOCcsICdBMTpDMiddIC0+IFsnRTM4JywgJ0ExJywgJ0EyJywgJ0IxJywgJ0IyJywgJ0MxJywgJ0MyJ11cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmdbXX0gYXJyIC0gZm9ybWF0cyBhcnJcclxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIGFmdGVyIGFyclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNxcmVmUmF3QXJyRm9ybWF0KGFycjogc3RyaW5nW10pOiBzdHJpbmdbXSB7XHJcbiAgYXJyPy5tYXAoKGVsKSA9PiB7XHJcbiAgICBpZiAoZWwuaW5jbHVkZXMoXCI6XCIpKSB7XHJcbiAgICAgIGxldCB0ZW1wQXJyOiBzdHJpbmdbXSA9IGVsLnNwbGl0KFwiOlwiKTtcclxuICAgICAgaWYgKHRlbXBBcnI/Lmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIGFyciA9IGFyci5jb25jYXQoZ2V0UmVnaW9uU2VxdWVuY2UodGVtcEFycikpO1xyXG4gICAgICAgIGFyci5zcGxpY2UoYXJyLmluZGV4T2YoZWwpLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBjb25zdCByZXN1bHRBcnIgPSBhcnIuZmlsdGVyKFxyXG4gICAgKHZhbHVlLCBpbmRleCwgYXJyYXkpID0+IGFycmF5LmluZGV4T2YodmFsdWUpID09PSBpbmRleFxyXG4gICk7XHJcblxyXG4gIHJldHVybiByZXN1bHRBcnI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzaW5nbGUgc2VxdWVuY2UgdG8gbnVtYmVyXHJcbiAqIGV4YW1wbGU6XHJcbiAqICAx44CBQTEgLT4gMF8wXHJcbiAqICAy44CBRVMxNCAtPiAxM180XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcXJlZiAtIGJlZm9yZSBzZXF1ZW5jZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIGFmdGVyIHNlcXVlbmNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2luZ2xlU2VxdWVuY2VUb051bShzcXJlZjogc3RyaW5nKTogc3RyaW5nIHtcclxuICBsZXQgc3FyZWZBcnJheSA9IHNxcmVmLm1hdGNoKC9bQS1aXSt8WzAtOV0rL2cpO1xyXG4gIGxldCBzcXJlZkxlbiA9IHNxcmVmQXJyYXkubGVuZ3RoO1xyXG4gIGxldCByZWdFbiA9IG5ldyBSZWdFeHAoXCJeW0EtWl0rJFwiKTtcclxuICBsZXQgcmV0ID0gXCJcIjtcclxuICBmb3IgKGxldCBpID0gc3FyZWZMZW4gLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgbGV0IGN1ciA9IHNxcmVmQXJyYXlbaV07XHJcbiAgICBpZiAocmVnRW4udGVzdChjdXIpKSB7XHJcbiAgICAgIHJldCArPSBBQkNhdE51bShjdXIpICsgXCJfXCI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXQgKz0gcGFyc2VJbnQoY3VyKSAtIDEgKyBcIl9cIjtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJldC5zdWJzdHJpbmcoMCwgcmV0Lmxlbmd0aCAtIDEpO1xyXG59XHJcblxyXG4vKipcclxuICogUjFDMSB0byBTZXF1ZW5jZVxyXG4gKiBleGFtcGxlOiBzaGVldDIhUjFDMSA9PiBzaGVldCFBMVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBSMUMxIHZhbHVlXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNSMUMxVG9TZXF1ZW5jZSh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICBpZiAoIXZhbHVlICYmIHZhbHVlPy5sZW5ndGggPD0gMCkgcmV0dXJuIFwiXCI7XHJcblxyXG4gIGNvbnN0IGxlbiA9IHZhbHVlLmxlbmd0aDtcclxuICBjb25zdCBpbmRleCA9IHZhbHVlLmxhc3RJbmRleE9mKFwiIVwiKTtcclxuICBjb25zdCB2YWx1ZUFyciA9IFt2YWx1ZS5zbGljZSgwLCBpbmRleCksIHZhbHVlLnNsaWNlKGluZGV4ICsgMSwgbGVuKV07XHJcbiAgY29uc3QgcmVwU3RyID0gdmFsdWVBcnJbMV0gfHwgXCJcIjtcclxuICBjb25zdCBpbmRleFIgPSByZXBTdHIuaW5kZXhPZihcIlJcIik7XHJcbiAgY29uc3QgaW5kZXhDID0gcmVwU3RyLmluZGV4T2YoXCJDXCIpO1xyXG4gIFxyXG4gIGNvbnN0IHJvdyA9IE51bWJlcihyZXBTdHIuc2xpY2UoaW5kZXhSICsgMSwgaW5kZXhDKSk7XHJcbiAgY29uc3QgY29sdW1uID0gY2hhdGF0QUJDKE51bWJlcihyZXBTdHIuc2xpY2UoaW5kZXhDICsgMSwgcmVwU3RyPy5sZW5ndGgpKSAtIDEpO1xyXG5cclxuICByZXR1cm4gYCR7dmFsdWVBcnJbMF19ISR7Y29sdW1ufSR7cm93fWA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzdHJpcCB4MTQgZm9ybWF0IGRhdGFcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0geyBmb3JtdWxhLCBzcXJlZiB9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGVlbE9mZlgxNCh2YWx1ZTogc3RyaW5nKTogeyAgW2tleTogc3RyaW5nXTogYW55fSB7XHJcbiAgaWYgKCF2YWx1ZSB8fCB2YWx1ZT8ubGVuZ3RoIDw9IDApIHJldHVybiB7fTtcclxuXHJcbiAgLy8gZm9ybXVsYVxyXG4gIGNvbnN0IGZvcm11bGFSZWcgPSBuZXcgUmVnRXhwKFwiPC94MTQ6Zm9ybXVsYVteXT5cIiwgXCJnXCIpO1xyXG4gIGNvbnN0IGxhc3RJbmRleCA9IHZhbHVlLm1hdGNoKGZvcm11bGFSZWcpPy5sZW5ndGg7XHJcbiAgY29uc3QgbGFzdFZhbHVlID0gYDwveDE0OmZvcm11bGEke2xhc3RJbmRleH0+YDtcclxuICBjb25zdCBsYXN0VmFsdWVFbmQgPSB2YWx1ZS5pbmRleE9mKGxhc3RWYWx1ZSk7XHJcbiAgbGV0IGZvcm11bGFWYWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBsYXN0VmFsdWVFbmQgKyBsYXN0VmFsdWUubGVuZ3RoKTtcclxuICBmb3JtdWxhVmFsdWUgPSBmb3JtdWxhVmFsdWVcclxuICAgIC5yZXBsYWNlKC88eG06Zj4vZywgXCJcIilcclxuICAgIC5yZXBsYWNlKC88XFwveG06Zj4vZywgXCJcIilcclxuICAgIC5yZXBsYWNlKC94MTQ6L2csIFwiXCIpXHJcbiAgICAucmVwbGFjZSgvXFwveDE0Oi9nLCBcIlwiKTtcclxuICBjb25zdCBmb3JtdWxhID0gZm9ybXVsYVZhbHVlO1xyXG4gIFxyXG4gIC8vIHNxcmVmXHJcbiAgY29uc3QgeG1TcXJlZkxlbiA9IFwiPHhtOnNxcmVmPlwiLmxlbmd0aDtcclxuICBjb25zdCBzcXJlZlN0YXJ0ID0gdmFsdWUuaW5kZXhPZihcIjx4bTpzcXJlZj5cIik7XHJcbiAgY29uc3Qgc3FyZWZFbmQgPSB2YWx1ZS5pbmRleE9mKFwiPC94bTpzcXJlZj5cIik7XHJcbiAgY29uc3Qgc3FyZWYgPSB2YWx1ZS5zdWJzdHJpbmcoc3FyZWZTdGFydCArIHhtU3FyZWZMZW4sIHNxcmVmRW5kKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGZvcm11bGEsXHJcbiAgICBzcXJlZixcclxuICB9O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIGdldCB0aGUgdmFsdWUgaW4gdGhlIGZvcm11bGFcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gZXh0cmFjdGVkIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNdWx0aUZvcm11bGFWYWx1ZSh2YWx1ZTogc3RyaW5nKTogc3RyaW5nW10ge1xyXG4gIGlmICghdmFsdWUgfHwgdmFsdWU/Lmxlbmd0aCA8PSAwKSByZXR1cm4gW107XHJcbiAgXHJcbiAgY29uc3QgbGVuUmVnID0gbmV3IFJlZ0V4cChcImZvcm11bGFcIiwgXCJnXCIpO1xyXG4gIGNvbnN0IGxlbiA9ICh2YWx1ZS5tYXRjaChsZW5SZWcpPy5sZW5ndGggfHwgMCkgLyAyO1xyXG4gIFxyXG4gIGlmIChsZW4gPT09IDApIHJldHVybiBbXTtcclxuICBcclxuICBsZXQgcmV0QXJyOiBhbnkgPSBbXTtcclxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBsZW47IGkrKykge1xyXG4gICAgY29uc3Qgc3RhcnRMZW4gPSBgPGZvcm11bGEke2l9PmA/Lmxlbmd0aDtcclxuICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWUuaW5kZXhPZihgPGZvcm11bGEke2l9PmApO1xyXG4gICAgY29uc3QgZW5kID0gdmFsdWUuaW5kZXhPZihgPC9mb3JtdWxhJHtpfT5gKTtcclxuICAgIGNvbnN0IF92YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyhzdGFydCArIHN0YXJ0TGVuLCBlbmQpO1xyXG4gICAgcmV0QXJyLnB1c2goZXNjYXBlQ2hhcmFjdGVyKF92YWx1ZS5yZXBsYWNlKC8mcXVvdDt8XlxcXCJ8XFxcIiQvZywgXCJcIikpKTtcclxuICB9XHJcbiAgcmV0dXJuIHJldEFycjtcclxufSIsImltcG9ydCB7IEx1Y2t5RmlsZSB9IGZyb20gXCIuL1RvTHVja3lTaGVldC9MdWNreUZpbGVcIjtcclxuLy8gaW1wb3J0IHtTZWN1cml0eURvb3IsQ2FyfSBmcm9tICcuL2NvbnRlbnQnO1xyXG5cclxuaW1wb3J0IHtIYW5kbGVaaXB9IGZyb20gJy4vSGFuZGxlWmlwJztcclxuXHJcbmltcG9ydCB7SXVwbG9hZGZpbGVMaXN0fSBmcm9tIFwiLi9JQ29tbW9uXCI7XHJcbmltcG9ydCB7IGZzdGF0IH0gZnJvbSBcImZzXCI7XHJcblxyXG4vLyAvL2RlbW9cclxuLy8gZnVuY3Rpb24gZGVtb0hhbmRsZXIoKXtcclxuLy8gICAgIGxldCB1cGxvYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIkx1Y2t5ZXhjZWwtZGVtby1maWxlXCIpO1xyXG4vLyAgICAgbGV0IHNlbGVjdEFEZW1vID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJMdWNreWV4Y2VsLXNlbGVjdC1kZW1vXCIpO1xyXG4vLyAgICAgbGV0IGRvd25sb2REZW1vID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJMdWNreWV4Y2VsLWRvd25sb2QtZmlsZVwiKTtcclxuLy8gICAgIGxldCBtYXNrID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsdWNreS1tYXNrLWRlbW9cIik7XHJcbi8vICAgICBpZih1cGxvYWQpe1xyXG4gICAgICAgIFxyXG4vLyAgICAgICAgIHdpbmRvdy5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIFxyXG4vLyAgICAgICAgICAgICB1cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbihldnQpe1xyXG4vLyAgICAgICAgICAgICAgICAgdmFyIGZpbGVzOkZpbGVMaXN0ID0gKGV2dC50YXJnZXQgYXMgYW55KS5maWxlcztcclxuLy8gICAgICAgICAgICAgICAgIGlmKGZpbGVzPT1udWxsIHx8IGZpbGVzLmxlbmd0aD09MCl7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJObyBmaWxlcyB3YWl0IGZvciBpbXBvcnRcIik7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZmlsZXNbMF0ubmFtZTtcclxuLy8gICAgICAgICAgICAgICAgIGxldCBzdWZmaXhBcnIgPSBuYW1lLnNwbGl0KFwiLlwiKSwgc3VmZml4ID0gc3VmZml4QXJyW3N1ZmZpeEFyci5sZW5ndGgtMV07XHJcbi8vICAgICAgICAgICAgICAgICBpZihzdWZmaXghPVwieGxzeFwiKXtcclxuLy8gICAgICAgICAgICAgICAgICAgICBhbGVydChcIkN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHRoZSBpbXBvcnQgb2YgeGxzeCBmaWxlc1wiKTtcclxuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgICBMdWNreUV4Y2VsLnRyYW5zZm9ybUV4Y2VsVG9MdWNreShmaWxlc1swXSwgZnVuY3Rpb24oZXhwb3J0SnNvbjphbnksIGx1Y2t5c2hlZXRmaWxlOnN0cmluZyl7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbi8vICAgICAgICAgICAgICAgICAgICAgaWYoZXhwb3J0SnNvbi5zaGVldHM9PW51bGwgfHwgZXhwb3J0SnNvbi5zaGVldHMubGVuZ3RoPT0wKXtcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJGYWlsZWQgdG8gcmVhZCB0aGUgY29udGVudCBvZiB0aGUgZXhjZWwgZmlsZSwgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgeGxzIGZpbGVzIVwiKTtcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhleHBvcnRKc29uLCBsdWNreXNoZWV0ZmlsZSk7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgd2luZG93Lmx1Y2t5c2hlZXQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4vLyAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sdWNreXNoZWV0LmNyZWF0ZSh7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogJ2x1Y2t5c2hlZXQnLCAvL2x1Y2t5c2hlZXQgaXMgdGhlIGNvbnRhaW5lciBpZFxyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzaG93aW5mb2JhcjpmYWxzZSxcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTpleHBvcnRKc29uLnNoZWV0cyxcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ZXhwb3J0SnNvbi5pbmZvLm5hbWUsXHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJbmZvOmV4cG9ydEpzb24uaW5mby5uYW1lLmNyZWF0b3JcclxuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcclxuLy8gICAgICAgICAgICAgICAgIH0pO1xyXG4vLyAgICAgICAgICAgICB9KTtcclxuXHJcbi8vICAgICAgICAgICAgIHNlbGVjdEFEZW1vLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZnVuY3Rpb24oZXZ0KXtcclxuLy8gICAgICAgICAgICAgICAgIHZhciBvYmo6YW55ID0gc2VsZWN0QURlbW87XHJcbi8vICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBvYmouc2VsZWN0ZWRJbmRleDtcclxuLy8gICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iai5vcHRpb25zW2luZGV4XS52YWx1ZTtcclxuLy8gICAgICAgICAgICAgICAgIHZhciBuYW1lID0gb2JqLm9wdGlvbnNbaW5kZXhdLmlubmVySFRNTDtcclxuLy8gICAgICAgICAgICAgICAgIGlmKHZhbHVlPT1cIlwiKXtcclxuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgICBtYXNrLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcclxuLy8gICAgICAgICAgICAgICAgIEx1Y2t5RXhjZWwudHJhbnNmb3JtRXhjZWxUb0x1Y2t5QnlVcmwodmFsdWUsIG5hbWUsIGZ1bmN0aW9uKGV4cG9ydEpzb246YW55LCBsdWNreXNoZWV0ZmlsZTpzdHJpbmcpe1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4vLyAgICAgICAgICAgICAgICAgICAgIGlmKGV4cG9ydEpzb24uc2hlZXRzPT1udWxsIHx8IGV4cG9ydEpzb24uc2hlZXRzLmxlbmd0aD09MCl7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHJlYWQgdGhlIGNvbnRlbnQgb2YgdGhlIGV4Y2VsIGZpbGUsIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHhscyBmaWxlcyFcIik7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuLy8gICAgICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXhwb3J0SnNvbiwgbHVja3lzaGVldGZpbGUpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIG1hc2suc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sdWNreXNoZWV0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuLy8gICAgICAgICAgICAgICAgICAgICB3aW5kb3cubHVja3lzaGVldC5jcmVhdGUoe1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6ICdsdWNreXNoZWV0JywgLy9sdWNreXNoZWV0IGlzIHRoZSBjb250YWluZXIgaWRcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc2hvd2luZm9iYXI6ZmFsc2UsXHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6ZXhwb3J0SnNvbi5zaGVldHMsXHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOmV4cG9ydEpzb24uaW5mby5uYW1lLFxyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB1c2VySW5mbzpleHBvcnRKc29uLmluZm8ubmFtZS5jcmVhdG9yXHJcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbi8vICAgICAgICAgICAgICAgICB9KTtcclxuLy8gICAgICAgICAgICAgfSk7XHJcblxyXG4vLyAgICAgICAgICAgICBkb3dubG9kRGVtby5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZ0KXtcclxuLy8gICAgICAgICAgICAgICAgIHZhciBvYmo6YW55ID0gc2VsZWN0QURlbW87XHJcbi8vICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBvYmouc2VsZWN0ZWRJbmRleDtcclxuLy8gICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iai5vcHRpb25zW2luZGV4XS52YWx1ZTtcclxuXHJcbi8vICAgICAgICAgICAgICAgICBpZih2YWx1ZS5sZW5ndGg9PTApe1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiUGxlYXNlIHNlbGVjdCBhIGRlbW8gZmlsZVwiKTtcclxuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgICAgICAgICAgdmFyIGVsZW1JRjphbnkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIkx1Y2t5LWRvd25sb2FkLWZyYW1lXCIpO1xyXG4vLyAgICAgICAgICAgICAgICAgaWYoZWxlbUlGPT1udWxsKXtcclxuLy8gICAgICAgICAgICAgICAgICAgICBlbGVtSUYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIGVsZW1JRi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgZWxlbUlGLmlkID0gXCJMdWNreS1kb3dubG9hZC1mcmFtZVwiO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbUlGKTtcclxuLy8gICAgICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgICAgIGVsZW1JRi5zcmMgPSB2YWx1ZTtcclxuXHJcbi8vICAgICAgICAgICAgICAgICAvLyBlbGVtSUYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtSUYpO1xyXG4vLyAgICAgICAgICAgICB9KTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICB9XHJcbi8vIH1cclxuLy8gZGVtb0hhbmRsZXIoKTtcclxuXHJcbi8vIGFwaVxyXG5leHBvcnQgY2xhc3MgTHVja3lFeGNlbHtcclxuICAgIHN0YXRpYyB0cmFuc2Zvcm1FeGNlbFRvTHVja3koZXhjZWxGaWxlOiBGaWxlLFxyXG4gICAgICAgIGNhbGxiYWNrPzogKGZpbGVzOiBJdXBsb2FkZmlsZUxpc3QsIGZzPzogc3RyaW5nKSA9PiB2b2lkLFxyXG4gICAgICAgIGVycm9ySGFuZGxlcj86IChlcnI6IEVycm9yKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgbGV0IGhhbmRsZVppcDpIYW5kbGVaaXAgPSBuZXcgSGFuZGxlWmlwKGV4Y2VsRmlsZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaGFuZGxlWmlwLnVuemlwRmlsZShmdW5jdGlvbiAoZmlsZXM6IEl1cGxvYWRmaWxlTGlzdCkge1xyXG4gICAgICAgICAgICBsZXQgbHVja3lGaWxlID0gbmV3IEx1Y2t5RmlsZShmaWxlcywgZXhjZWxGaWxlLm5hbWUpO1xyXG4gICAgICAgICAgICBsZXQgbHVja3lzaGVldGZpbGUgPSBsdWNreUZpbGUuUGFyc2UoKTtcclxuICAgICAgICAgICAgbGV0IGV4cG9ydEpzb24gPSBKU09OLnBhcnNlKGx1Y2t5c2hlZXRmaWxlKTtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXhwb3J0SnNvbiwgbHVja3lzaGVldGZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmdW5jdGlvbihlcnI6RXJyb3Ipe1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgdHJhbnNmb3JtRXhjZWxUb0x1Y2t5QnlVcmwoXHJcbiAgICAgICAgdXJsOiBzdHJpbmcsXHJcbiAgICAgICAgbmFtZTogc3RyaW5nLFxyXG4gICAgICAgIGNhbGxCYWNrPzogKGZpbGVzOiBJdXBsb2FkZmlsZUxpc3QsIGZzPzogc3RyaW5nKSA9PiB2b2lkLFxyXG4gICAgICAgIGVycm9ySGFuZGxlcj86IChlcnI6IEVycm9yKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgbGV0IGhhbmRsZVppcDpIYW5kbGVaaXAgPSBuZXcgSGFuZGxlWmlwKCk7XHJcbiAgICAgICAgaGFuZGxlWmlwLnVuemlwRmlsZUJ5VXJsKHVybCwgZnVuY3Rpb24oZmlsZXM6SXVwbG9hZGZpbGVMaXN0KXtcclxuICAgICAgICAgICAgbGV0IGx1Y2t5RmlsZSA9IG5ldyBMdWNreUZpbGUoZmlsZXMsIG5hbWUpO1xyXG4gICAgICAgICAgICBsZXQgbHVja3lzaGVldGZpbGUgPSBsdWNreUZpbGUuUGFyc2UoKTtcclxuICAgICAgICAgICAgbGV0IGV4cG9ydEpzb24gPSBKU09OLnBhcnNlKGx1Y2t5c2hlZXRmaWxlKTtcclxuICAgICAgICAgICAgaWYoY2FsbEJhY2sgIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIGNhbGxCYWNrKGV4cG9ydEpzb24sIGx1Y2t5c2hlZXRmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnVuY3Rpb24oZXJyOkVycm9yKXtcclxuICAgICAgICAgICAgaWYgKGVycm9ySGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGVycik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHRyYW5zZm9ybUx1Y2t5VG9FeGNlbChcclxuICAgICAgICBMdWNreUZpbGU6IGFueSxcclxuICAgICAgICBjYWxsQmFjaz86IChmaWxlczogc3RyaW5nKSA9PiB2b2lkICxcclxuICAgICAgICBlcnJvckhhbmRsZXI/OiAoZXJyOiBFcnJvcikgPT4gdm9pZCl7IH1cclxufSIsImltcG9ydCB7THVja3lFeGNlbH0gZnJvbSBcIi4vbWFpblwiXHJcbi8vIGV4cG9ydCBOb2RlIG1vZHVsZVxyXG5leHBvcnQgPSBMdWNreUV4Y2VsOyJdfQ=="}